"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/merkletreejs";
exports.ids = ["vendor-chunks/merkletreejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/merkletreejs/dist/Base.js":
/*!************************************************!*\
  !*** ./node_modules/merkletreejs/dist/Base.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Base = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst crypto_js_1 = __importDefault(__webpack_require__(/*! crypto-js */ \"(ssr)/./node_modules/crypto-js/index.js\"));\nclass Base {\n    /**\n     * print\n     * @desc Prints out a visual representation of the merkle tree.\n     * @example\n     *```js\n     *tree.print()\n     *```\n     */\n    print() {\n        Base.print(this);\n    }\n    /**\n     * bufferIndexOf\n     * @desc Returns the first index of which given buffer is found in array.\n     * @param {Buffer[]} haystack - Array of buffers.\n     * @param {Buffer} needle - Buffer to find.\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.bufferIndexOf(haystack, needle)\n     *```\n     */\n    bufferIndexOf(array, element, isSorted = false) {\n        if (isSorted) {\n            return this.binarySearch(array, element, buffer_1.Buffer.compare);\n        }\n        const eqChecker = (buffer1, buffer2) => buffer1.equals(buffer2);\n        return this.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n     *```\n     */\n    static binarySearch(array, element, compareFunction) {\n        let start = 0;\n        let end = array.length - 1;\n        // Iterate while start not meets end\n        while (start <= end) {\n            // Find the mid index\n            const mid = Math.floor((start + end) / 2);\n            // Check if the mid value is greater than, equal to, or less than search element.\n            const ordering = compareFunction(array[mid], element);\n            // If element is present at mid, start iterating for searching first appearance.\n            if (ordering === 0) {\n                // Linear reverse iteration until the first matching item index is found.\n                for (let i = mid - 1; i >= 0; i--) {\n                    if (compareFunction(array[i], element) === 0)\n                        continue;\n                    return i + 1;\n                }\n                return 0;\n            } /* Else look in left or right half accordingly */\n            else if (ordering < 0) {\n                start = mid + 1;\n            }\n            else {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.binarySearch(array, element, Buffer.compare)\n     *```\n     */\n    binarySearch(array, element, compareFunction) {\n        return Base.binarySearch(array, element, compareFunction);\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */\n    static linearSearch(array, element, eqChecker) {\n        for (let i = 0; i < array.length; i++) {\n            if (eqChecker(array[i], element)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */\n    linearSearch(array, element, eqChecker) {\n        return Base.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer|ArrayBuffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = MerkleTree.bufferify('0x1234')\n     *```\n     */\n    static bufferify(value) {\n        if (!buffer_1.Buffer.isBuffer(value)) {\n            // crypto-js support\n            if (typeof value === 'object' && value.words) {\n                return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n            }\n            else if (Base.isHexString(value)) {\n                return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');\n            }\n            else if (typeof value === 'string') {\n                return buffer_1.Buffer.from(value);\n            }\n            else if (typeof value === 'bigint') {\n                return buffer_1.Buffer.from(value.toString(16), 'hex');\n            }\n            else if (value instanceof Uint8Array) {\n                return buffer_1.Buffer.from(value.buffer);\n            }\n            else if (typeof value === 'number') {\n                let s = value.toString();\n                if (s.length % 2) {\n                    s = `0${s}`;\n                }\n                return buffer_1.Buffer.from(s, 'hex');\n            }\n            else if (ArrayBuffer.isView(value)) {\n                return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n            }\n        }\n        return value;\n    }\n    bigNumberify(value) {\n        return Base.bigNumberify(value);\n    }\n    static bigNumberify(value) {\n        if (typeof value === 'bigint') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            if (value.startsWith('0x') && Base.isHexString(value)) {\n                return BigInt('0x' + value.replace('0x', '').toString());\n            }\n            return BigInt(value);\n        }\n        if (buffer_1.Buffer.isBuffer(value)) {\n            return BigInt('0x' + value.toString('hex'));\n        }\n        if (value instanceof Uint8Array) {\n            return BigInt(value);\n        }\n        if (typeof value === 'number') {\n            return BigInt(value);\n        }\n        throw new Error('cannot bigNumberify');\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    static isHexString(v) {\n        return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n    }\n    /**\n     * print\n     * @desc Prints out a visual representation of the given merkle tree.\n     * @param {Object} tree - Merkle tree instance.\n     * @return {String}\n     * @example\n     *```js\n     *MerkleTree.print(tree)\n     *```\n     */\n    static print(tree) {\n        console.log(tree.toString());\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = tree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    bufferToHex(value, withPrefix = true) {\n        return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    static bufferToHex(value, withPrefix = true) {\n        return `${withPrefix ? '0x' : ''}${(value || buffer_1.Buffer.alloc(0)).toString('hex')}`;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = tree.bufferify('0x1234')\n     *```\n     */\n    bufferify(value) {\n        return Base.bufferify(value);\n    }\n    /**\n     * bufferifyFn\n     * @desc Returns a function that will bufferify the return value.\n     * @param {Function}\n     * @return {Function}\n     *\n     * @example\n     * ```js\n     *const fn = tree.bufferifyFn((value) => sha256(value))\n     *```\n     */\n    bufferifyFn(f) {\n        return (value) => {\n            const v = f(value);\n            if (buffer_1.Buffer.isBuffer(v)) {\n                return v;\n            }\n            if (this.isHexString(v)) {\n                return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');\n            }\n            if (typeof v === 'string') {\n                return buffer_1.Buffer.from(v);\n            }\n            if (typeof v === 'bigint') {\n                return buffer_1.Buffer.from(value.toString(16), 'hex');\n            }\n            if (ArrayBuffer.isView(v)) {\n                return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n            }\n            // crypto-js support\n            return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n        };\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    isHexString(value) {\n        return Base.isHexString(value);\n    }\n    /**\n     * log2\n     * @desc Returns the log2 of number.\n     * @param {Number} value\n     * @return {Number}\n     */\n    log2(n) {\n        return n === 1 ? 0 : 1 + this.log2((n / 2) | 0);\n    }\n    /**\n     * zip\n     * @desc Returns true if value is a hex string.\n     * @param {String[]|Number[]|Buffer[]} a - first array\n     * @param {String[]|Number[]|Buffer[]} b -  second array\n     * @return {String[][]|Number[][]|Buffer[][]}\n     *\n     * @example\n     * ```js\n     *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n     *```\n     */\n    zip(a, b) {\n        return a.map((e, i) => [e, b[i]]);\n    }\n    static hexZeroPad(hexStr, length) {\n        return '0x' + hexStr.replace('0x', '').padStart(length, '0');\n    }\n}\nexports.Base = Base;\nexports[\"default\"] = Base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvQmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxvQ0FBb0MsbUJBQU8sQ0FBQywwREFBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBeUM7QUFDeEQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLEVBQUUsb0RBQW9EO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLDRCQUE0QjtBQUMzQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tZXJrbGV0cmVlanMvZGlzdC9CYXNlLmpzPzhjYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2UgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5jb25zdCBjcnlwdG9fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvLWpzXCIpKTtcbmNsYXNzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIHByaW50XG4gICAgICogQGRlc2MgUHJpbnRzIG91dCBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVya2xlIHRyZWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICp0cmVlLnByaW50KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHByaW50KCkge1xuICAgICAgICBCYXNlLnByaW50KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBidWZmZXJJbmRleE9mXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gYnVmZmVyIGlzIGZvdW5kIGluIGFycmF5LlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGhheXN0YWNrIC0gQXJyYXkgb2YgYnVmZmVycy5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gbmVlZGxlIC0gQnVmZmVyIHRvIGZpbmQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kZXggPSB0cmVlLmJ1ZmZlckluZGV4T2YoaGF5c3RhY2ssIG5lZWRsZSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGJ1ZmZlckluZGV4T2YoYXJyYXksIGVsZW1lbnQsIGlzU29ydGVkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTZWFyY2goYXJyYXksIGVsZW1lbnQsIGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcUNoZWNrZXIgPSAoYnVmZmVyMSwgYnVmZmVyMikgPT4gYnVmZmVyMS5lcXVhbHMoYnVmZmVyMik7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgZXFDaGVja2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYmluYXJ5U2VhcmNoXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gaXRlbSBpcyBmb3VuZCBpbiBhcnJheSB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGFycmF5IC0gQXJyYXkgb2YgaXRlbXMuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGVsZW1lbnQgLSBJdGVtIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZUZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kZXggPSBNZXJrbGVUcmVlLmJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgQnVmZmVyLmNvbXBhcmUpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIC8vIEl0ZXJhdGUgd2hpbGUgc3RhcnQgbm90IG1lZXRzIGVuZFxuICAgICAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBtaWQgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1pZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4sIGVxdWFsIHRvLCBvciBsZXNzIHRoYW4gc2VhcmNoIGVsZW1lbnQuXG4gICAgICAgICAgICBjb25zdCBvcmRlcmluZyA9IGNvbXBhcmVGdW5jdGlvbihhcnJheVttaWRdLCBlbGVtZW50KTtcbiAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaXMgcHJlc2VudCBhdCBtaWQsIHN0YXJ0IGl0ZXJhdGluZyBmb3Igc2VhcmNoaW5nIGZpcnN0IGFwcGVhcmFuY2UuXG4gICAgICAgICAgICBpZiAob3JkZXJpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5lYXIgcmV2ZXJzZSBpdGVyYXRpb24gdW50aWwgdGhlIGZpcnN0IG1hdGNoaW5nIGl0ZW0gaW5kZXggaXMgZm91bmQuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1pZCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24oYXJyYXlbaV0sIGVsZW1lbnQpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IC8qIEVsc2UgbG9vayBpbiBsZWZ0IG9yIHJpZ2h0IGhhbGYgYWNjb3JkaW5nbHkgKi9cbiAgICAgICAgICAgIGVsc2UgaWYgKG9yZGVyaW5nIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBiaW5hcnlTZWFyY2hcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvZiB3aGljaCBnaXZlbiBpdGVtIGlzIGZvdW5kIGluIGFycmF5IHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gYXJyYXkgLSBBcnJheSBvZiBpdGVtcy5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gZWxlbWVudCAtIEl0ZW0gdG8gZmluZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlRnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gSW5kZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBpbmRleCA9IHRyZWUuYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBCdWZmZXIuY29tcGFyZSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgY29tcGFyZUZ1bmN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbGluZWFyU2VhcmNoXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gaXRlbSBpcyBmb3VuZCBpbiBhcnJheSB1c2luZyBsaW5lYXIgc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGFycmF5IC0gQXJyYXkgb2YgaXRlbXMuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGVsZW1lbnQgLSBJdGVtIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXFDaGVja2VyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kZXggPSBNZXJrbGVUcmVlLmxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgKGEsIGIpID0+IGEgPT09IGIpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgbGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCBlcUNoZWNrZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVxQ2hlY2tlcihhcnJheVtpXSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGxpbmVhclNlYXJjaFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9mIHdoaWNoIGdpdmVuIGl0ZW0gaXMgZm91bmQgaW4gYXJyYXkgdXNpbmcgbGluZWFyIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBhcnJheSAtIEFycmF5IG9mIGl0ZW1zLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBlbGVtZW50IC0gSXRlbSB0byBmaW5kLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxQ2hlY2tlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSBJbmRleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGluZGV4ID0gdHJlZS5saW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIChhLCBiKSA9PiBhID09PSBiKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgbGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCBlcUNoZWNrZXIpIHtcbiAgICAgICAgcmV0dXJuIEJhc2UubGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCBlcUNoZWNrZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBidWZmZXJpZnlcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGEgYnVmZmVyIHR5cGUgZm9yIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBidWYgPSBNZXJrbGVUcmVlLmJ1ZmZlcmlmeSgnMHgxMjM0JylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBidWZmZXJpZnkodmFsdWUpIHtcbiAgICAgICAgaWYgKCFidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBjcnlwdG8tanMgc3VwcG9ydFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUud29yZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoY3J5cHRvX2pzXzEuZGVmYXVsdC5lbmMuSGV4KSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQmFzZS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUucmVwbGFjZSgvXjB4LywgJycpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoMTYpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUuYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICBzID0gYDAke3N9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHMsICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUuYnVmZmVyLCB2YWx1ZS5ieXRlT2Zmc2V0LCB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGJpZ051bWJlcmlmeSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQmFzZS5iaWdOdW1iZXJpZnkodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgYmlnTnVtYmVyaWZ5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcweCcpICYmIEJhc2UuaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgnMHgnICsgdmFsdWUucmVwbGFjZSgnMHgnLCAnJykudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgnMHgnICsgdmFsdWUudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYmlnTnVtYmVyaWZ5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGlzSGV4U3RyaW5nXG4gICAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgaGV4IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc29sZS5sb2coTWVya2xlVHJlZS5pc0hleFN0cmluZygnMHgxMjM0JykpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNIZXhTdHJpbmcodikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIC9eKDB4KT9bMC05QS1GYS1mXSokLy50ZXN0KHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwcmludFxuICAgICAqIEBkZXNjIFByaW50cyBvdXQgYSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIG1lcmtsZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmVlIC0gTWVya2xlIHRyZWUgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqTWVya2xlVHJlZS5wcmludCh0cmVlKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIHByaW50KHRyZWUpIHtcbiAgICAgICAgY29uc29sZS5sb2codHJlZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYnVmZmVyVG9IZXhcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGEgaGV4IHN0cmluZyB3aXRoIDB4IHByZWZpeCBmb3IgZ2l2ZW4gYnVmZmVyLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGhleFN0ciA9IHRyZWUuYnVmZmVyVG9IZXgoQnVmZmVyLmZyb20oJ0EnKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGJ1ZmZlclRvSGV4KHZhbHVlLCB3aXRoUHJlZml4ID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gQmFzZS5idWZmZXJUb0hleCh2YWx1ZSwgd2l0aFByZWZpeCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJ1ZmZlclRvSGV4XG4gICAgICogQGRlc2MgUmV0dXJucyBhIGhleCBzdHJpbmcgd2l0aCAweCBwcmVmaXggZm9yIGdpdmVuIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBoZXhTdHIgPSBNZXJrbGVUcmVlLmJ1ZmZlclRvSGV4KEJ1ZmZlci5mcm9tKCdBJykpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYnVmZmVyVG9IZXgodmFsdWUsIHdpdGhQcmVmaXggPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBgJHt3aXRoUHJlZml4ID8gJzB4JyA6ICcnfSR7KHZhbHVlIHx8IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygwKSkudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJ1ZmZlcmlmeVxuICAgICAqIEBkZXNjIFJldHVybnMgYSBidWZmZXIgdHlwZSBmb3IgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R8QnVmZmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGJ1ZiA9IHRyZWUuYnVmZmVyaWZ5KCcweDEyMzQnKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgYnVmZmVyaWZ5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmJ1ZmZlcmlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJ1ZmZlcmlmeUZuXG4gICAgICogQGRlc2MgUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBidWZmZXJpZnkgdGhlIHJldHVybiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgZm4gPSB0cmVlLmJ1ZmZlcmlmeUZuKCh2YWx1ZSkgPT4gc2hhMjU2KHZhbHVlKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGJ1ZmZlcmlmeUZuKGYpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdiA9IGYodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odi5yZXBsYWNlKCcweCcsICcnKSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoMTYpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHYuYnVmZmVyLCB2LmJ5dGVPZmZzZXQsIHYuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcnlwdG8tanMgc3VwcG9ydFxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGYoY3J5cHRvX2pzXzEuZGVmYXVsdC5lbmMuSGV4LnBhcnNlKHZhbHVlLnRvU3RyaW5nKCdoZXgnKSkpLnRvU3RyaW5nKGNyeXB0b19qc18xLmRlZmF1bHQuZW5jLkhleCksICdoZXgnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaXNIZXhTdHJpbmdcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBoZXggc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zb2xlLmxvZyhNZXJrbGVUcmVlLmlzSGV4U3RyaW5nKCcweDEyMzQnKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmlzSGV4U3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbG9nMlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIGxvZzIgb2YgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBsb2cyKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT09IDEgPyAwIDogMSArIHRoaXMubG9nMigobiAvIDIpIHwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHppcFxuICAgICAqIEBkZXNjIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGhleCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxOdW1iZXJbXXxCdWZmZXJbXX0gYSAtIGZpcnN0IGFycmF5XG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxOdW1iZXJbXXxCdWZmZXJbXX0gYiAtICBzZWNvbmQgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXVtdfE51bWJlcltdW118QnVmZmVyW11bXX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IHppcHBlZCA9IHRyZWUuemlwKFsnYScsICdiJ10sWydBJywgJ0InXSlcbiAgICAgKmNvbnNvbGUubG9nKHppcHBlZCkgLy8gWyBbICdhJywgJ0EnIF0sIFsgJ2InLCAnQicgXSBdXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB6aXAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5tYXAoKGUsIGkpID0+IFtlLCBiW2ldXSk7XG4gICAgfVxuICAgIHN0YXRpYyBoZXhaZXJvUGFkKGhleFN0ciwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgaGV4U3RyLnJlcGxhY2UoJzB4JywgJycpLnBhZFN0YXJ0KGxlbmd0aCwgJzAnKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2UgPSBCYXNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/Base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/IncrementalMerkleTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/merkletreejs/dist/IncrementalMerkleTree.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IncrementalMerkleTree = void 0;\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/./node_modules/merkletreejs/dist/Base.js\"));\nconst treeify_1 = __importDefault(__webpack_require__(/*! treeify */ \"(ssr)/./node_modules/treeify/treeify.js\"));\nclass IncrementalMerkleTree extends Base_1.default {\n    constructor(hashFn, options) {\n        super();\n        this.hashFn = hashFn;\n        if (options.depth) {\n            this.depth = options.depth;\n        }\n        if (options.arity) {\n            this.arity = options.arity;\n        }\n        if (this.depth < 1) {\n            throw new Error('depth must be greater than 0');\n        }\n        if (this.arity < 1) {\n            throw new Error('arity must be greater than 0');\n        }\n        const nodes = [];\n        let zeroValue = options.zeroValue;\n        this.zeroValue = zeroValue;\n        this.zeroes = [];\n        if (this.depth) {\n            for (let i = 0; i < this.depth; i++) {\n                this.zeroes.push(zeroValue);\n                nodes[i] = [];\n                zeroValue = this.hashFn(Array(this.arity).fill(zeroValue));\n            }\n        }\n        this.nodes = nodes;\n        this.root = zeroValue;\n    }\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.bufferify(this.getRoot()));\n    }\n    insert(leaf) {\n        if (this.depth && this.arity) {\n            if (this.nodes[0].length >= this.getMaxLeaves()) {\n                throw new Error('tree is full');\n            }\n        }\n        let node = leaf;\n        let index = this.nodes[0].length;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this.nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        this.root = node;\n    }\n    delete(index) {\n        this.update(index, this.zeroValue);\n    }\n    update(index, newLeaf) {\n        if (index < 0 || index >= this.nodes[0].length) {\n            throw new Error('out of bounds');\n        }\n        let node = newLeaf;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this.nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        this.root = node;\n    }\n    getDepth() {\n        return this.depth;\n    }\n    getArity() {\n        return this.arity;\n    }\n    getMaxLeaves() {\n        return Math.pow(this.depth, this.arity);\n    }\n    indexOf(leaf) {\n        return this.nodes[0].indexOf(leaf);\n    }\n    getLeaves() {\n        const leaves = this.copyList(this.nodes[0]);\n        const index = this.nodes[0].length;\n        for (let i = index; i < this.getMaxLeaves(); i++) {\n            leaves[i] = this.zeroValue;\n        }\n        return leaves;\n    }\n    copyList(list) {\n        return list.map((x) => BigInt(x));\n    }\n    getLayers() {\n        const layers = [];\n        for (const list of this.nodes) {\n            layers.push(this.copyList(list));\n        }\n        if (layers[0].length < this.getMaxLeaves()) {\n            let index = layers[0].length;\n            for (let i = index; i < this.getMaxLeaves(); i++) {\n                layers[0][i] = this.zeroValue;\n            }\n            for (let level = 0; level < this.depth; level++) {\n                const position = index % this.arity;\n                const levelStartIndex = index - position;\n                const levelEndIndex = levelStartIndex + this.arity;\n                for (let i = levelStartIndex; i < levelEndIndex; i++) {\n                    if (i >= layers[level].length) {\n                        layers[level][i] = this.zeroes[level];\n                    }\n                }\n                index = Math.floor(index / this.arity);\n            }\n        }\n        layers.push([this.root]);\n        return layers;\n    }\n    getHexLayers() {\n        return this.getLayers().reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(layer => this.bufferToHex(this.bufferify(layer))));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(this.bufferify(value), false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    computeRoot() {\n        let node;\n        let index = this.nodes[0].length;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        return node;\n    }\n    getProof(index) {\n        if (index < 0 || index >= this.nodes[0].length) {\n            throw new Error('The leaf does not exist in this tree');\n        }\n        const siblings = [];\n        const pathIndices = [];\n        const leafIndex = index;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            pathIndices[level] = position;\n            siblings[level] = [];\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i !== index) {\n                    if (i < this.nodes[level].length) {\n                        siblings[level].push(this.nodes[level][i]);\n                    }\n                    else {\n                        siblings[level].push(this.zeroes[level]);\n                    }\n                }\n            }\n            index = Math.floor(index / this.arity);\n        }\n        return { root: this.root, leaf: this.nodes[0][leafIndex], pathIndices, siblings };\n    }\n    verify(proof) {\n        let node = proof.leaf;\n        for (let i = 0; i < proof.siblings.length; i += 1) {\n            const children = proof.siblings[i].slice();\n            children.splice(proof.pathIndices[i], 0, node);\n            node = this.hashFn(children);\n        }\n        return proof.root === node;\n    }\n    toString() {\n        return this.toTreeString();\n    }\n    toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n}\nexports.IncrementalMerkleTree = IncrementalMerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.IncrementalMerkleTree = IncrementalMerkleTree;\n}\nexports[\"default\"] = IncrementalMerkleTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvSW5jcmVtZW50YWxNZXJrbGVUcmVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLCtCQUErQixtQkFBTyxDQUFDLDhEQUFRO0FBQy9DLGtDQUFrQyxtQkFBTyxDQUFDLHdEQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvSW5jcmVtZW50YWxNZXJrbGVUcmVlLmpzPzNiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluY3JlbWVudGFsTWVya2xlVHJlZSA9IHZvaWQgMDtcbmNvbnN0IEJhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9CYXNlXCIpKTtcbmNvbnN0IHRyZWVpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidHJlZWlmeVwiKSk7XG5jbGFzcyBJbmNyZW1lbnRhbE1lcmtsZVRyZWUgZXh0ZW5kcyBCYXNlXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoaGFzaEZuLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFzaEZuID0gaGFzaEZuO1xuICAgICAgICBpZiAob3B0aW9ucy5kZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5kZXB0aCA9IG9wdGlvbnMuZGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXJpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuYXJpdHkgPSBvcHRpb25zLmFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlcHRoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXB0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXJpdHkgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICBsZXQgemVyb1ZhbHVlID0gb3B0aW9ucy56ZXJvVmFsdWU7XG4gICAgICAgIHRoaXMuemVyb1ZhbHVlID0gemVyb1ZhbHVlO1xuICAgICAgICB0aGlzLnplcm9lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnplcm9lcy5wdXNoKHplcm9WYWx1ZSk7XG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICB6ZXJvVmFsdWUgPSB0aGlzLmhhc2hGbihBcnJheSh0aGlzLmFyaXR5KS5maWxsKHplcm9WYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5yb290ID0gemVyb1ZhbHVlO1xuICAgIH1cbiAgICBnZXRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH1cbiAgICBnZXRIZXhSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJUb0hleCh0aGlzLmJ1ZmZlcmlmeSh0aGlzLmdldFJvb3QoKSkpO1xuICAgIH1cbiAgICBpbnNlcnQobGVhZikge1xuICAgICAgICBpZiAodGhpcy5kZXB0aCAmJiB0aGlzLmFyaXR5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1swXS5sZW5ndGggPj0gdGhpcy5nZXRNYXhMZWF2ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJlZSBpcyBmdWxsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBsZWFmO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm5vZGVzWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbbGV2ZWxdW2luZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxTdGFydEluZGV4OyBpIDwgbGV2ZWxFbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLm5vZGVzW2xldmVsXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLm5vZGVzW2xldmVsXVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuemVyb2VzW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuaGFzaEZuKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgfVxuICAgIGRlbGV0ZShpbmRleCkge1xuICAgICAgICB0aGlzLnVwZGF0ZShpbmRleCwgdGhpcy56ZXJvVmFsdWUpO1xuICAgIH1cbiAgICB1cGRhdGUoaW5kZXgsIG5ld0xlYWYpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm5vZGVzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBuZXdMZWFmO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAlIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBsZXZlbFN0YXJ0SW5kZXggPSBpbmRleCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxFbmRJbmRleCA9IGxldmVsU3RhcnRJbmRleCArIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1tsZXZlbF1baW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbFN0YXJ0SW5kZXg7IGkgPCBsZXZlbEVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMubm9kZXNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMubm9kZXNbbGV2ZWxdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy56ZXJvZXNbbGV2ZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoRm4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0RGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xuICAgIH1cbiAgICBnZXRBcml0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJpdHk7XG4gICAgfVxuICAgIGdldE1heExlYXZlcygpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMuZGVwdGgsIHRoaXMuYXJpdHkpO1xuICAgIH1cbiAgICBpbmRleE9mKGxlYWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uaW5kZXhPZihsZWFmKTtcbiAgICB9XG4gICAgZ2V0TGVhdmVzKCkge1xuICAgICAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLmNvcHlMaXN0KHRoaXMubm9kZXNbMF0pO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubm9kZXNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCB0aGlzLmdldE1heExlYXZlcygpOyBpKyspIHtcbiAgICAgICAgICAgIGxlYXZlc1tpXSA9IHRoaXMuemVyb1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWF2ZXM7XG4gICAgfVxuICAgIGNvcHlMaXN0KGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QubWFwKCh4KSA9PiBCaWdJbnQoeCkpO1xuICAgIH1cbiAgICBnZXRMYXllcnMoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3Qgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgbGF5ZXJzLnB1c2godGhpcy5jb3B5TGlzdChsaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheWVyc1swXS5sZW5ndGggPCB0aGlzLmdldE1heExlYXZlcygpKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBsYXllcnNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy5nZXRNYXhMZWF2ZXMoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzWzBdW2ldID0gdGhpcy56ZXJvVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsU3RhcnRJbmRleCA9IGluZGV4IC0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgbGV2ZWxFbmRJbmRleCA9IGxldmVsU3RhcnRJbmRleCArIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsU3RhcnRJbmRleDsgaSA8IGxldmVsRW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBsYXllcnNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzW2xldmVsXVtpXSA9IHRoaXMuemVyb2VzW2xldmVsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLmFyaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXllcnMucHVzaChbdGhpcy5yb290XSk7XG4gICAgICAgIHJldHVybiBsYXllcnM7XG4gICAgfVxuICAgIGdldEhleExheWVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJzKCkucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goaXRlbS5tYXAobGF5ZXIgPT4gdGhpcy5idWZmZXJUb0hleCh0aGlzLmJ1ZmZlcmlmeShsYXllcikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgZ2V0TGF5ZXJzQXNPYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKCkubWFwKChsYXllcikgPT4gbGF5ZXIubWFwKCh2YWx1ZSkgPT4gdGhpcy5idWZmZXJUb0hleCh0aGlzLmJ1ZmZlcmlmeSh2YWx1ZSksIGZhbHNlKSkpO1xuICAgICAgICBjb25zdCBvYmpzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGF5ZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0geyBbbGF5ZXJzW2ldW2pdXTogbnVsbCB9O1xuICAgICAgICAgICAgICAgIGlmIChvYmpzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbbGF5ZXJzW2ldW2pdXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gb2Jqcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBha2V5ID0gT2JqZWN0LmtleXMoYSlbMF07XG4gICAgICAgICAgICAgICAgICAgIG9ialtsYXllcnNbaV1bal1dW2FrZXldID0gYVtha2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gb2Jqcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmtleSA9IE9iamVjdC5rZXlzKGIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2xheWVyc1tpXVtqXV1bYmtleV0gPSBiW2JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyci5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmpzLnB1c2goLi4uYXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Jqc1swXTtcbiAgICB9XG4gICAgY29tcHV0ZVJvb3QoKSB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm5vZGVzWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbFN0YXJ0SW5kZXg7IGkgPCBsZXZlbEVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMubm9kZXNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMubm9kZXNbbGV2ZWxdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy56ZXJvZXNbbGV2ZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoRm4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGdldFByb29mKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5ub2Rlc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxlYWYgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyB0cmVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgcGF0aEluZGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGVhZkluZGV4ID0gaW5kZXg7XG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCB0aGlzLmRlcHRoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGluZGV4ICUgdGhpcy5hcml0eTtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsU3RhcnRJbmRleCA9IGluZGV4IC0gcG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBsZXZlbEVuZEluZGV4ID0gbGV2ZWxTdGFydEluZGV4ICsgdGhpcy5hcml0eTtcbiAgICAgICAgICAgIHBhdGhJbmRpY2VzW2xldmVsXSA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgc2libGluZ3NbbGV2ZWxdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxTdGFydEluZGV4OyBpIDwgbGV2ZWxFbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5ub2Rlc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0ucHVzaCh0aGlzLm5vZGVzW2xldmVsXVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0ucHVzaCh0aGlzLnplcm9lc1tsZXZlbF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcm9vdDogdGhpcy5yb290LCBsZWFmOiB0aGlzLm5vZGVzWzBdW2xlYWZJbmRleF0sIHBhdGhJbmRpY2VzLCBzaWJsaW5ncyB9O1xuICAgIH1cbiAgICB2ZXJpZnkocHJvb2YpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBwcm9vZi5sZWFmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb29mLnNpYmxpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHByb29mLnNpYmxpbmdzW2ldLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UocHJvb2YucGF0aEluZGljZXNbaV0sIDAsIG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuaGFzaEZuKGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvb2Yucm9vdCA9PT0gbm9kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVHJlZVN0cmluZygpO1xuICAgIH1cbiAgICB0b1RyZWVTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuZ2V0TGF5ZXJzQXNPYmplY3QoKTtcbiAgICAgICAgcmV0dXJuIHRyZWVpZnlfMS5kZWZhdWx0LmFzVHJlZShvYmosIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5jcmVtZW50YWxNZXJrbGVUcmVlID0gSW5jcmVtZW50YWxNZXJrbGVUcmVlO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgO1xuICAgIHdpbmRvdy5JbmNyZW1lbnRhbE1lcmtsZVRyZWUgPSBJbmNyZW1lbnRhbE1lcmtsZVRyZWU7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBJbmNyZW1lbnRhbE1lcmtsZVRyZWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/IncrementalMerkleTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/MerkleMountainRange.js":
/*!***************************************************************!*\
  !*** ./node_modules/merkletreejs/dist/MerkleMountainRange.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MerkleMountainRange = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst sha256_1 = __importDefault(__webpack_require__(/*! crypto-js/sha256 */ \"(ssr)/./node_modules/crypto-js/sha256.js\"));\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/./node_modules/merkletreejs/dist/Base.js\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n        super();\n        this.root = buffer_1.Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves) {\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */\n    append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n    hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n    hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n    getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for (let i = 255; i > 0; i--) {\n            if ((width & (1 << (i - 1))) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error('invalid bit calculation');\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while (bits > 0) {\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error('received invalid number of peaks');\n        }\n        if (width === 0 && !peaks.length) {\n            return buffer_1.Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n    getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n    getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n    mountainHeight(size) {\n        let height = 1;\n        while (1 << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n    heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n    isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n    getChildren(index) {\n        const left = index - (1 << (this.heightAt(index) - 1));\n        const right = index - 1;\n        if (left === right) {\n            throw new Error('not a parent');\n        }\n        return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n    getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error('not a leaf');\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for (let i = 0; i < peaks.length; i++) {\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while (cursor !== index) {\n            height--;\n            ([left, right] = this.getChildren(cursor));\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error('index is out of range');\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for (let i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error('target not found');\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while (height > 0) {\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                // on the leaf node. Stop climbing down\n                break;\n            }\n            else {\n                // on the parent node. Go left or right\n                ([left, right] = this.getChildren(cursor));\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while (height < path.length) {\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            }\n            else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            }\n            else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error('hashed peak is invalid');\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            }\n            else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error('invalid number of peaks');\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for (let i = 0; i < 32; i++) {\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error('invalid number of peaks');\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            }\n            else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    }\n                    else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                }\n                else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for (let i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n    _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleMountainRange = MerkleMountainRange;\n}\nexports[\"default\"] = MerkleMountainRange;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvTWVya2xlTW91bnRhaW5SYW5nZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxpQ0FBaUMsbUJBQU8sQ0FBQyxrRUFBa0I7QUFDM0QsK0JBQStCLG1CQUFPLENBQUMsOERBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvTWVya2xlTW91bnRhaW5SYW5nZS5qcz82ZDgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXJrbGVNb3VudGFpblJhbmdlID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuY29uc3Qgc2hhMjU2XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNyeXB0by1qcy9zaGEyNTZcIikpO1xuY29uc3QgQmFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0Jhc2VcIikpO1xuLy8gQGNyZWRpdDogaHR0cHM6Ly9naXRodWIuY29tL3dhbnNlb2Ivc29saWRpdHktbW1yXG4vKipcbiAqIEBkZXNjIFRoZSBpbmRleCBvZiB0aGlzIE1NUiBpbXBsZW1lbnRhdGlvbiBzdGFydHMgZnJvbSAxIG5vdCAwLlxuICovXG5jbGFzcyBNZXJrbGVNb3VudGFpblJhbmdlIGV4dGVuZHMgQmFzZV8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hGbiA9IHNoYTI1Nl8xLmRlZmF1bHQsIGxlYXZlcyA9IFtdLCBoYXNoTGVhZkZuLCBwZWFrQmFnZ2luZ0ZuLCBoYXNoQnJhbmNoRm4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yb290ID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgdGhpcy5oYXNoZXMgPSB7fTtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIGxlYXZlcyA9IGxlYXZlcy5tYXAodGhpcy5idWZmZXJpZnkpO1xuICAgICAgICB0aGlzLmhhc2hGbiA9IHRoaXMuYnVmZmVyaWZ5Rm4oaGFzaEZuKTtcbiAgICAgICAgdGhpcy5oYXNoTGVhZkZuID0gaGFzaExlYWZGbjtcbiAgICAgICAgdGhpcy5wZWFrQmFnZ2luZ0ZuID0gcGVha0JhZ2dpbmdGbjtcbiAgICAgICAgdGhpcy5oYXNoQnJhbmNoRm4gPSBoYXNoQnJhbmNoRm47XG4gICAgICAgIGZvciAoY29uc3QgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKGxlYWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIFRoaXMgb25seSBzdG9yZXMgdGhlIGhhc2hlZCB2YWx1ZSBvZiB0aGUgbGVhZi5cbiAgICAgKiBJZiB5b3UgbmVlZCB0byByZXRyaWV2ZSB0aGUgZGV0YWlsIGRhdGEgbGF0ZXIsIHVzZSBhIG1hcCB0byBzdG9yZSB0aGVtLlxuICAgICAqL1xuICAgIGFwcGVuZChkYXRhKSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLmJ1ZmZlcmlmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZGF0YUhhc2ggPSB0aGlzLmhhc2hGbihkYXRhKTtcbiAgICAgICAgY29uc3QgZGF0YUhhc2hIZXggPSB0aGlzLmJ1ZmZlclRvSGV4KGRhdGFIYXNoKTtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFbZGF0YUhhc2hIZXhdIHx8IHRoaXMuYnVmZmVyVG9IZXgodGhpcy5oYXNoRm4odGhpcy5kYXRhW2RhdGFIYXNoSGV4XSkpICE9PSBkYXRhSGFzaEhleCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2RhdGFIYXNoSGV4XSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVhZiA9IHRoaXMuaGFzaExlYWYodGhpcy5zaXplICsgMSwgZGF0YUhhc2gpO1xuICAgICAgICB0aGlzLmhhc2hlc1t0aGlzLnNpemUgKyAxXSA9IGxlYWY7XG4gICAgICAgIHRoaXMud2lkdGggKz0gMTtcbiAgICAgICAgLy8gZmluZCBwZWFrcyBmb3IgZW5sYXJnZWQgdHJlZVxuICAgICAgICBjb25zdCBwZWFrSW5kZXhlcyA9IHRoaXMuZ2V0UGVha0luZGV4ZXModGhpcy53aWR0aCk7XG4gICAgICAgIC8vIHRoZSByaWdodCBtb3N0IHBlYWsncyB2YWx1ZSBpcyB0aGUgbmV3IHNpemUgb2YgdGhlIHVwZGF0ZWQgdHJlZVxuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmdldFNpemUodGhpcy53aWR0aCk7XG4gICAgICAgIC8vIHN0YXJ0aW5nIGZyb20gdGhlIGxlZnQtbW9zdCBwZWFrLCBnZXQgYWxsIHBlYWsgaGFzaGVzXG4gICAgICAgIGNvbnN0IHBlYWtzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVha0luZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBlYWtzW2ldID0gdGhpcy5fZ2V0T3JDcmVhdGVOb2RlKHBlYWtJbmRleGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRyZWUgcm9vdCBoYXNoXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucGVha0JhZ2dpbmcodGhpcy53aWR0aCwgcGVha3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRoZSBoYXNoIG9mIGEgbGVhZiBub2RlIHdpdGggaGFzaChNIHwgREFUQSApXG4gICAgICogICAgICAgTSBpcyB0aGUgaW5kZXggb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgaGFzaExlYWYoaW5kZXgsIGRhdGFIYXNoKSB7XG4gICAgICAgIGRhdGFIYXNoID0gdGhpcy5idWZmZXJpZnkoZGF0YUhhc2gpO1xuICAgICAgICBpZiAodGhpcy5oYXNoTGVhZkZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJpZnkodGhpcy5oYXNoTGVhZkZuKGluZGV4LCBkYXRhSGFzaCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hGbihidWZmZXJfMS5CdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlcmlmeShpbmRleCksIGRhdGFIYXNoXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRoZSBoYXNoIGEgcGFyZW50IG5vZGUgd2l0aCBoYXNoKE0gfCBMZWZ0IGNoaWxkIHwgUmlnaHQgY2hpbGQpXG4gICAgICogICAgICAgTSBpcyB0aGUgaW5kZXggb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgaGFzaEJyYW5jaChpbmRleCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzaEJyYW5jaEZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJpZnkodGhpcy5oYXNoQnJhbmNoRm4oaW5kZXgsIGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaEZuKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmZmVyaWZ5KGluZGV4KSwgdGhpcy5idWZmZXJpZnkobGVmdCksIHRoaXMuYnVmZmVyaWZ5KHJpZ2h0KV0pKTtcbiAgICB9XG4gICAgZ2V0UGVha3MoKSB7XG4gICAgICAgIGNvbnN0IHBlYWtJbmRleGVzID0gdGhpcy5nZXRQZWFrSW5kZXhlcyh0aGlzLndpZHRoKTtcbiAgICAgICAgY29uc3QgcGVha3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZWFrSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGVha3NbaV0gPSB0aGlzLmhhc2hlc1twZWFrSW5kZXhlc1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlYWtzO1xuICAgIH1cbiAgICBnZXRMZWFmSW5kZXgod2lkdGgpIHtcbiAgICAgICAgaWYgKHdpZHRoICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2l6ZSh3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2l6ZSh3aWR0aCAtIDEpICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyBhbGwgcGVha3Mgb2YgdGhlIHNtYWxsZXN0IG1lcmtsZSBtb3VudGFpbiByYW5nZSB0cmVlIHdoaWNoIGluY2x1ZGVzXG4gICAgICogICAgICAgdGhlIGdpdmVuIGluZGV4KHNpemUpLlxuICAgICAqL1xuICAgIGdldFBlYWtJbmRleGVzKHdpZHRoKSB7XG4gICAgICAgIGNvbnN0IG51bVBlYWtzID0gdGhpcy5udW1PZlBlYWtzKHdpZHRoKTtcbiAgICAgICAgY29uc3QgcGVha0luZGV4ZXMgPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMjU1OyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoKHdpZHRoICYgKDEgPDwgKGkgLSAxKSkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVhayBleGlzdHNcbiAgICAgICAgICAgICAgICBzaXplID0gc2l6ZSArICgxIDw8IGkpIC0gMTtcbiAgICAgICAgICAgICAgICBwZWFrSW5kZXhlc1tjb3VudCsrXSA9IHNpemU7XG4gICAgICAgICAgICAgICAgaWYgKHBlYWtJbmRleGVzLmxlbmd0aCA+PSBudW1QZWFrcykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ICE9PSBwZWFrSW5kZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaXQgY2FsY3VsYXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVha0luZGV4ZXM7XG4gICAgfVxuICAgIG51bU9mUGVha3Mod2lkdGgpIHtcbiAgICAgICAgbGV0IGJpdHMgPSB3aWR0aDtcbiAgICAgICAgbGV0IG51bSA9IDA7XG4gICAgICAgIHdoaWxlIChiaXRzID4gMCkge1xuICAgICAgICAgICAgaWYgKGJpdHMgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzID0gYml0cyA+PiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIHBlYWtCYWdnaW5nKHdpZHRoLCBwZWFrcykge1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKHdpZHRoKTtcbiAgICAgICAgaWYgKHRoaXMubnVtT2ZQZWFrcyh3aWR0aCkgIT09IHBlYWtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNlaXZlZCBpbnZhbGlkIG51bWJlciBvZiBwZWFrcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCAmJiAhcGVha3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlYWtCYWdnaW5nRm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmlmeSh0aGlzLnBlYWtCYWdnaW5nRm4oc2l6ZSwgcGVha3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYXNoRm4oYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXJpZnkoc2l6ZSksIC4uLnBlYWtzLm1hcCh0aGlzLmJ1ZmZlcmlmeSldKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdGhlIHNpemUgb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZ2V0U2l6ZSh3aWR0aCkge1xuICAgICAgICByZXR1cm4gKHdpZHRoIDw8IDEpIC0gdGhpcy5udW1PZlBlYWtzKHdpZHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0aGUgcm9vdCB2YWx1ZSBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBnZXRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH1cbiAgICBnZXRIZXhSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJUb0hleCh0aGlzLmdldFJvb3QoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXYgSXQgcmV0dXJucyB0aGUgaGFzaCB2YWx1ZSBvZiBhIG5vZGUgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbi4gTm90ZSB0aGF0IHRoZSBpbmRleCBzdGFydHMgZnJvbSAxLlxuICAgICAqL1xuICAgIGdldE5vZGUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaGVzW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBoaWdoZXN0IHBlYWsuXG4gICAgICovXG4gICAgbW91bnRhaW5IZWlnaHQoc2l6ZSkge1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMTtcbiAgICAgICAgd2hpbGUgKDEgPDwgaGVpZ2h0IDw9IHNpemUgKyBoZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWlnaHQgLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGluZGV4LlxuICAgICAqL1xuICAgIGhlaWdodEF0KGluZGV4KSB7XG4gICAgICAgIGxldCByZWR1Y2VkSW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHBlYWtJbmRleCA9IDA7XG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xuICAgICAgICAvLyBpZiBhbiBpbmRleCBoYXMgYSBsZWZ0IG1vdW50YWluIHRoZW4gc3VidHJhY3QgdGhlIG1vdW50YWluXG4gICAgICAgIHdoaWxlIChyZWR1Y2VkSW5kZXggPiBwZWFrSW5kZXgpIHtcbiAgICAgICAgICAgIHJlZHVjZWRJbmRleCAtPSAoMSA8PCBoZWlnaHQpIC0gMTtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMubW91bnRhaW5IZWlnaHQocmVkdWNlZEluZGV4KTtcbiAgICAgICAgICAgIHBlYWtJbmRleCA9ICgxIDw8IGhlaWdodCkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluZGV4IGlzIG9uIHRoZSByaWdodCBzbG9wZVxuICAgICAgICByZXR1cm4gaGVpZ2h0IC0gKHBlYWtJbmRleCAtIHJlZHVjZWRJbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgd2hldGhlciB0aGUgaW5kZXggaXMgdGhlIGxlYWYgbm9kZSBvciBub3RcbiAgICAgKi9cbiAgICBpc0xlYWYoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0QXQoaW5kZXgpID09PSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRoZSBjaGlsZHJlbiB3aGVuIGl0IGlzIGEgcGFyZW50IG5vZGUuXG4gICAgICovXG4gICAgZ2V0Q2hpbGRyZW4oaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IGluZGV4IC0gKDEgPDwgKHRoaXMuaGVpZ2h0QXQoaW5kZXgpIC0gMSkpO1xuICAgICAgICBjb25zdCByaWdodCA9IGluZGV4IC0gMTtcbiAgICAgICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHBhcmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIGEgbWVya2xlIHByb29mIGZvciBhIGxlYWYuIE5vdGUgdGhhdCB0aGUgaW5kZXggc3RhcnRzIGZyb20gMS5cbiAgICAgKi9cbiAgICBnZXRNZXJrbGVQcm9vZihpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzTGVhZihpbmRleCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgbGVhZicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgLy8gZmluZCBhbGwgcGVha3MgZm9yIGJhZ2dpbmdcbiAgICAgICAgY29uc3QgcGVha3MgPSB0aGlzLmdldFBlYWtJbmRleGVzKHRoaXMud2lkdGgpO1xuICAgICAgICBjb25zdCBwZWFrQmFnZ2luZyA9IFtdO1xuICAgICAgICBsZXQgY3Vyc29yID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZWFrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgaGFzaCBvZiBhbGwgcGVha3NcbiAgICAgICAgICAgIHBlYWtCYWdnaW5nW2ldID0gdGhpcy5oYXNoZXNbcGVha3NbaV1dO1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgcGVhayB3aGljaCBpbmNsdWRlcyB0aGUgdGFyZ2V0IGluZGV4XG4gICAgICAgICAgICBpZiAocGVha3NbaV0gPj0gaW5kZXggJiYgY3Vyc29yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gcGVha3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICBsZXQgcmlnaHQgPSAwO1xuICAgICAgICAvLyBnZXQgaGFzaGVzIG9mIHRoZSBzaWJsaW5ncyBpbiB0aGUgbW91bnRhaW4gd2hpY2ggdGhlIGluZGV4IGJlbGdvbnMgdG8uXG4gICAgICAgIC8vIGl0IG1vdmVzIHRoZSBjdXJzb3IgZnJvbSB0aGUgc3VtbWl0IG9mIHRoZSBtb3VudGFpbiBkb3duIHRvIHRoZSB0YXJnZXQgaW5kZXhcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaGVpZ2h0QXQoY3Vyc29yKTtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKGN1cnNvciAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGhlaWdodC0tO1xuICAgICAgICAgICAgKFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldENoaWxkcmVuKGN1cnNvcikpO1xuICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIGRvd24gdG8gdGhlIGxlZnQgc2l6ZSBvciByaWdodCBzaXplXG4gICAgICAgICAgICBjdXJzb3IgPSBpbmRleCA8PSBsZWZ0ID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICAgICAgLy8gcmVtYWluaW5nIG5vZGUgaXMgdGhlIHNpYmxpbmdcbiAgICAgICAgICAgIHNpYmxpbmdzW2hlaWdodCAtIDFdID0gdGhpcy5oYXNoZXNbaW5kZXggPD0gbGVmdCA/IHJpZ2h0IDogbGVmdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIHBlYWtCYWdnaW5nLFxuICAgICAgICAgICAgc2libGluZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0cnVlIHdoZW4gdGhlIGdpdmVuIHBhcmFtcyB2ZXJpZmllcyB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBleGlzdHMgaW4gdGhlIHRyZWUgb3IgcmV2ZXJ0cyB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdmVyaWZ5KHJvb3QsIHdpZHRoLCBpbmRleCwgdmFsdWUsIHBlYWtzLCBzaWJsaW5ncykge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuYnVmZmVyaWZ5KHZhbHVlKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSh3aWR0aCk7XG4gICAgICAgIGlmIChzaXplIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5kZXggaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgdGhlIHJvb3QgZXF1YWxzIHRoZSBwZWFrIGJhZ2dpbmcgaGFzaFxuICAgICAgICBpZiAoIXJvb3QuZXF1YWxzKHRoaXMucGVha0JhZ2dpbmcod2lkdGgsIHBlYWtzKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByb290IGhhc2ggZnJvbSB0aGUgcGVha3MnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHRoZSBtb3VudGFpbiB3aGVyZSB0aGUgdGFyZ2V0IGluZGV4IGJlbG9uZ3MgdG9cbiAgICAgICAgbGV0IGN1cnNvciA9IDA7XG4gICAgICAgIGxldCB0YXJnZXRQZWFrO1xuICAgICAgICBjb25zdCBwZWFrSW5kZXhlcyA9IHRoaXMuZ2V0UGVha0luZGV4ZXMod2lkdGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlYWtJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGVha0luZGV4ZXNbaV0gPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRQZWFrID0gcGVha3NbaV07XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gcGVha0luZGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXJnZXRQZWFrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHRoZSBwYXRoIGNsaW1iaW5nIGRvd25cbiAgICAgICAgbGV0IGhlaWdodCA9IHNpYmxpbmdzLmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IHBhdGggPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICBsZXQgcmlnaHQgPSAwO1xuICAgICAgICB3aGlsZSAoaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgLy8gcmVjb3JkIHRoZSBjdXJyZW50IGN1cnNvciBhbmQgY2xpbWIgZG93blxuICAgICAgICAgICAgcGF0aFstLWhlaWdodF0gPSBjdXJzb3I7XG4gICAgICAgICAgICBpZiAoY3Vyc29yID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBsZWFmIG5vZGUuIFN0b3AgY2xpbWJpbmcgZG93blxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb24gdGhlIHBhcmVudCBub2RlLiBHbyBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgICAgICAgICAgKFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldENoaWxkcmVuKGN1cnNvcikpO1xuICAgICAgICAgICAgICAgIGN1cnNvciA9IGluZGV4ID4gbGVmdCA/IHJpZ2h0IDogbGVmdDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHN1bW1pdCBoYXNoIGNsaW1iaW5nIHVwIGFnYWluXG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICB3aGlsZSAoaGVpZ2h0IDwgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgY3Vyc29yXG4gICAgICAgICAgICBjdXJzb3IgPSBwYXRoW2hlaWdodF07XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY3Vzb3IgaXMgb24gdGhlIGxlYWZcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoTGVhZihjdXJzb3IsIHRoaXMuaGFzaEZuKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJzb3IgLSAxID09PSBwYXRoW2hlaWdodCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgLy8gY3Vyc29yIGlzIG9uIGEgcGFyZW50IGFuZCBhIHNpYmxpbmdzIGlzIG9uIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuaGFzaEJyYW5jaChjdXJzb3IsIHNpYmxpbmdzW2hlaWdodCAtIDFdLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGN1cnNvciBpcyBvbiBhIHBhcmVudCBhbmQgYSBzaWJsaW5ncyBpcyBvbiB0aGUgcmlnaHRcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoQnJhbmNoKGN1cnNvciwgbm9kZSwgc2libGluZ3NbaGVpZ2h0IC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xpbWIgdXBcbiAgICAgICAgICAgIGhlaWdodCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGVkIGhhc2ggdmFsdWUgb2YgdGhlIHN1bW1pdCBzaG91bGQgZXF1YWwgdG8gdGhlIHRhcmdldCBwZWFrIGhhc2hcbiAgICAgICAgaWYgKCFub2RlLmVxdWFscyh0YXJnZXRQZWFrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoZWQgcGVhayBpcyBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHBlYWtzVG9QZWFrTWFwKHdpZHRoLCBwZWFrcykge1xuICAgICAgICBjb25zdCBwZWFrTWFwID0ge307XG4gICAgICAgIGxldCBiaXRJbmRleCA9IDA7XG4gICAgICAgIGxldCBwZWFrUmVmID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gcGVha3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBoZWlnaHQgPSAxOyBoZWlnaHQgPD0gMzI7IGhlaWdodCsrKSB7XG4gICAgICAgICAgICAvLyBpbmRleCBzdGFydHMgZnJvbSB0aGUgcmlnaHQgbW9zdCBiaXRcbiAgICAgICAgICAgIGJpdEluZGV4ID0gMzIgLSBoZWlnaHQ7XG4gICAgICAgICAgICBwZWFrUmVmID0gMSA8PCAoaGVpZ2h0IC0gMSk7XG4gICAgICAgICAgICBpZiAoKHdpZHRoICYgcGVha1JlZikgIT09IDApIHtcbiAgICAgICAgICAgICAgICBwZWFrTWFwW2JpdEluZGV4XSA9IHBlYWtzWy0tY291bnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVha01hcFtiaXRJbmRleF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG51bWJlciBvZiBwZWFrcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZWFrTWFwO1xuICAgIH1cbiAgICBwZWFrTWFwVG9QZWFrcyh3aWR0aCwgcGVha01hcCkge1xuICAgICAgICBjb25zdCBhcnJMZW5ndGggPSB0aGlzLm51bU9mUGVha3Mod2lkdGgpO1xuICAgICAgICBjb25zdCBwZWFrcyA9IG5ldyBBcnJheShhcnJMZW5ndGgpO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwZWFrTWFwW2ldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVha3NbY291bnQrK10gPSBwZWFrTWFwW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCAhPT0gYXJyTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbnVtYmVyIG9mIHBlYWtzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlYWtzO1xuICAgIH1cbiAgICBwZWFrVXBkYXRlKHdpZHRoLCBwcmV2UGVha01hcCwgaXRlbUhhc2gpIHtcbiAgICAgICAgY29uc3QgbmV4dFBlYWtNYXAgPSB7fTtcbiAgICAgICAgY29uc3QgbmV3V2lkdGggPSB3aWR0aCArIDE7XG4gICAgICAgIGxldCBjdXJzb3JJbmRleCA9IHRoaXMuZ2V0TGVhZkluZGV4KG5ld1dpZHRoKTtcbiAgICAgICAgbGV0IGN1cnNvck5vZGUgPSB0aGlzLmhhc2hMZWFmKGN1cnNvckluZGV4LCBpdGVtSGFzaCk7XG4gICAgICAgIGxldCBiaXRJbmRleCA9IDA7XG4gICAgICAgIGxldCBwZWFrUmVmID0gMDtcbiAgICAgICAgbGV0IHByZXZQZWFrRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5leHRQZWFrRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IG9idGFpbmVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGhlaWdodCA9IDE7IGhlaWdodCA8PSAzMjsgaGVpZ2h0KyspIHtcbiAgICAgICAgICAgIC8vIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSByaWdodCBtb3N0IGJpdFxuICAgICAgICAgICAgYml0SW5kZXggPSAzMiAtIGhlaWdodDtcbiAgICAgICAgICAgIGlmIChvYnRhaW5lZCkge1xuICAgICAgICAgICAgICAgIG5leHRQZWFrTWFwW2JpdEluZGV4XSA9IHByZXZQZWFrTWFwW2JpdEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlYWtSZWYgPSAxIDw8IChoZWlnaHQgLSAxKTtcbiAgICAgICAgICAgICAgICBwcmV2UGVha0V4aXN0ID0gKHdpZHRoICYgcGVha1JlZikgIT09IDA7XG4gICAgICAgICAgICAgICAgbmV4dFBlYWtFeGlzdCA9IChuZXdXaWR0aCAmIHBlYWtSZWYpICE9PSAwO1xuICAgICAgICAgICAgICAgIC8vIGdldCBuZXcgY3Vyc29yIG5vZGUgd2l0aCBoYXNoaW5nIHRoZSBwZWFrIGFuZCB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgICAgICAgICAgICBjdXJzb3JJbmRleCsrO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2UGVha0V4aXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvck5vZGUgPSB0aGlzLmhhc2hCcmFuY2goY3Vyc29ySW5kZXgsIHByZXZQZWFrTWFwW2JpdEluZGV4XSwgY3Vyc29yTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIG5ldyBwZWFrIGV4aXN0cyBmb3IgdGhlIGJpdCBpbmRleFxuICAgICAgICAgICAgICAgIGlmIChuZXh0UGVha0V4aXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHByZXYgcGVhayBleGlzdHMgZm9yIHRoZSBiaXQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZQZWFrRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQZWFrTWFwW2JpdEluZGV4XSA9IHByZXZQZWFrTWFwW2JpdEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQZWFrTWFwW2JpdEluZGV4XSA9IGN1cnNvck5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2J0YWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBlYWtNYXBbYml0SW5kZXhdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHRQZWFrTWFwO1xuICAgIH1cbiAgICByb2xsVXAocm9vdCwgd2lkdGgsIHBlYWtzLCBpdGVtSGFzaGVzKSB7XG4gICAgICAgIC8vIGNoZWNrIHRoZSByb290IGVxdWFscyB0aGUgcGVhayBiYWdnaW5nIGhhc2hcbiAgICAgICAgaWYgKCFyb290LmVxdWFscyh0aGlzLnBlYWtCYWdnaW5nKHdpZHRoLCBwZWFrcykpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcm9vdCBoYXNoIGZyb20gdGhlIHBlYWtzJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRtcFdpZHRoID0gd2lkdGg7XG4gICAgICAgIGxldCB0bXBQZWFrTWFwID0gdGhpcy5wZWFrc1RvUGVha01hcCh3aWR0aCwgcGVha3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1IYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRtcFBlYWtNYXAgPSB0aGlzLnBlYWtVcGRhdGUodG1wV2lkdGgsIHRtcFBlYWtNYXAsIGl0ZW1IYXNoZXNbaV0pO1xuICAgICAgICAgICAgdG1wV2lkdGgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wZWFrQmFnZ2luZyh0bXBXaWR0aCwgdGhpcy5wZWFrTWFwVG9QZWFrcyh0bXBXaWR0aCwgdG1wUGVha01hcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRoZSBoYXNoIHZhbHVlIG9mIHRoZSBub2RlIGZvciB0aGUgaW5kZXguXG4gICAgICogICAgICBJZiB0aGUgaGFzaCBhbHJlYWR5IGV4aXN0cyBpdCBzaW1wbHkgcmV0dXJucyB0aGUgc3RvcmVkIHZhbHVlLiBPbiB0aGUgb3RoZXIgaGFuZCxcbiAgICAgKiAgICAgIGl0IGNvbXB1dGVzIGhhc2hlcyByZWN1cnNpdmVseSBkb3dud2FyZC5cbiAgICAgKiAgICAgIE9ubHkgYXBwZW5kaW5nIGFuIGl0ZW0gY2FsbHMgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0T3JDcmVhdGVOb2RlKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFzaGVzW2luZGV4XSkge1xuICAgICAgICAgICAgY29uc3QgW2xlZnRJbmRleCwgcmlnaHRJbmRleF0gPSB0aGlzLmdldENoaWxkcmVuKGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRIYXNoID0gdGhpcy5fZ2V0T3JDcmVhdGVOb2RlKGxlZnRJbmRleCk7XG4gICAgICAgICAgICBjb25zdCByaWdodEhhc2ggPSB0aGlzLl9nZXRPckNyZWF0ZU5vZGUocmlnaHRJbmRleCk7XG4gICAgICAgICAgICB0aGlzLmhhc2hlc1tpbmRleF0gPSB0aGlzLmhhc2hCcmFuY2goaW5kZXgsIGxlZnRIYXNoLCByaWdodEhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hlc1tpbmRleF07XG4gICAgfVxufVxuZXhwb3J0cy5NZXJrbGVNb3VudGFpblJhbmdlID0gTWVya2xlTW91bnRhaW5SYW5nZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIDtcbiAgICB3aW5kb3cuTWVya2xlTW91bnRhaW5SYW5nZSA9IE1lcmtsZU1vdW50YWluUmFuZ2U7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNZXJrbGVNb3VudGFpblJhbmdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/MerkleMountainRange.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/MerkleSumTree.js":
/*!*********************************************************!*\
  !*** ./node_modules/merkletreejs/dist/MerkleSumTree.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MerkleSumTree = exports.ProofStep = exports.Leaf = exports.Bucket = void 0;\nconst Base_1 = __webpack_require__(/*! ./Base */ \"(ssr)/./node_modules/merkletreejs/dist/Base.js\");\nclass Bucket {\n    constructor(size, hashed) {\n        this.size = BigInt(size);\n        this.hashed = hashed;\n        // each node in the tree can have a parent, and a left or right sibling\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexports.Bucket = Bucket;\nclass Leaf {\n    constructor(hashFn, rng, data) {\n        this.hashFn = hashFn;\n        this.rng = rng.map(x => BigInt(x));\n        this.data = data;\n    }\n    getBucket() {\n        let hashed;\n        if (this.data) {\n            hashed = this.hashFn(this.data);\n        }\n        else {\n            hashed = Buffer.alloc(32);\n        }\n        return new Bucket(BigInt(this.rng[1]) - BigInt(this.rng[0]), hashed);\n    }\n}\nexports.Leaf = Leaf;\nclass ProofStep {\n    constructor(bucket, right) {\n        this.bucket = bucket;\n        this.right = right; // whether the bucket hash should be appeded on the right side in this step (default is left\n    }\n}\nexports.ProofStep = ProofStep;\nclass MerkleSumTree extends Base_1.Base {\n    constructor(leaves, hashFn) {\n        super();\n        this.leaves = leaves;\n        this.hashFn = hashFn;\n        MerkleSumTree.checkConsecutive(leaves);\n        this.buckets = [];\n        for (const l of leaves) {\n            this.buckets.push(l.getBucket());\n        }\n        let buckets = [];\n        for (const bucket of this.buckets) {\n            buckets.push(bucket);\n        }\n        while (buckets.length !== 1) {\n            const newBuckets = [];\n            while (buckets.length) {\n                if (buckets.length >= 2) {\n                    const b1 = buckets.shift();\n                    const b2 = buckets.shift();\n                    const size = b1.size + b2.size;\n                    const hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(b1.size), this.bufferify(b1.hashed), this.sizeToBuffer(b2.size), this.bufferify(b2.hashed)]));\n                    const b = new Bucket(size, hashed);\n                    b2.parent = b;\n                    b1.parent = b2.parent;\n                    b1.right = b2;\n                    b2.left = b1;\n                    newBuckets.push(b);\n                }\n                else {\n                    newBuckets.push(buckets.shift());\n                }\n            }\n            buckets = newBuckets;\n        }\n        this.root = buckets[0];\n    }\n    sizeToBuffer(size) {\n        const buf = Buffer.alloc(8);\n        const view = new DataView(buf.buffer);\n        view.setBigInt64(0, BigInt(size), false); // true when little endian\n        return buf;\n    }\n    static checkConsecutive(leaves) {\n        let curr = BigInt(0);\n        for (const leaf of leaves) {\n            if (leaf.rng[0] !== curr) {\n                throw new Error('leaf ranges are invalid');\n            }\n            curr = BigInt(leaf.rng[1]);\n        }\n    }\n    // gets inclusion/exclusion proof of a bucket in the specified index\n    getProof(index) {\n        let curr = this.buckets[Number(index)];\n        const proof = [];\n        while (curr && curr.parent) {\n            const right = !!curr.right;\n            const bucket = curr.right ? curr.right : curr.left;\n            curr = curr.parent;\n            proof.push(new ProofStep(bucket, right));\n        }\n        return proof;\n    }\n    sum(arr) {\n        let total = BigInt(0);\n        for (const value of arr) {\n            total += BigInt(value);\n        }\n        return total;\n    }\n    // validates the suppplied proof for a specified leaf according to the root bucket\n    verifyProof(root, leaf, proof) {\n        const rng = [this.sum(proof.filter(x => !x.right).map(x => x.bucket.size)), BigInt(root.size) - this.sum(proof.filter(x => x.right).map(x => x.bucket.size))];\n        if (!(rng[0] === leaf.rng[0] && rng[1] === leaf.rng[1])) {\n            // supplied steps are not routing to the range specified\n            return false;\n        }\n        let curr = leaf.getBucket();\n        let hashed;\n        for (const step of proof) {\n            if (step.right) {\n                hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(curr.size), this.bufferify(curr.hashed), this.sizeToBuffer(step.bucket.size), this.bufferify(step.bucket.hashed)]));\n            }\n            else {\n                hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(step.bucket.size), this.bufferify(step.bucket.hashed), this.sizeToBuffer(curr.size), this.bufferify(curr.hashed)]));\n            }\n            curr = new Bucket(BigInt(curr.size) + BigInt(step.bucket.size), hashed);\n        }\n        return curr.size === root.size && curr.hashed.toString('hex') === root.hashed.toString('hex');\n    }\n}\nexports.MerkleSumTree = MerkleSumTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleSumTree = MerkleSumTree;\n}\nexports[\"default\"] = MerkleSumTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvTWVya2xlU3VtVHJlZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsY0FBYztBQUN6RSxlQUFlLG1CQUFPLENBQUMsOERBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tZXJrbGV0cmVlanMvZGlzdC9NZXJrbGVTdW1UcmVlLmpzPzk4ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lcmtsZVN1bVRyZWUgPSBleHBvcnRzLlByb29mU3RlcCA9IGV4cG9ydHMuTGVhZiA9IGV4cG9ydHMuQnVja2V0ID0gdm9pZCAwO1xuY29uc3QgQmFzZV8xID0gcmVxdWlyZShcIi4vQmFzZVwiKTtcbmNsYXNzIEJ1Y2tldCB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgaGFzaGVkKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IEJpZ0ludChzaXplKTtcbiAgICAgICAgdGhpcy5oYXNoZWQgPSBoYXNoZWQ7XG4gICAgICAgIC8vIGVhY2ggbm9kZSBpbiB0aGUgdHJlZSBjYW4gaGF2ZSBhIHBhcmVudCwgYW5kIGEgbGVmdCBvciByaWdodCBzaWJsaW5nXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5CdWNrZXQgPSBCdWNrZXQ7XG5jbGFzcyBMZWFmIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoRm4sIHJuZywgZGF0YSkge1xuICAgICAgICB0aGlzLmhhc2hGbiA9IGhhc2hGbjtcbiAgICAgICAgdGhpcy5ybmcgPSBybmcubWFwKHggPT4gQmlnSW50KHgpKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgZ2V0QnVja2V0KCkge1xuICAgICAgICBsZXQgaGFzaGVkO1xuICAgICAgICBpZiAodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBoYXNoZWQgPSB0aGlzLmhhc2hGbih0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzaGVkID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJ1Y2tldChCaWdJbnQodGhpcy5ybmdbMV0pIC0gQmlnSW50KHRoaXMucm5nWzBdKSwgaGFzaGVkKTtcbiAgICB9XG59XG5leHBvcnRzLkxlYWYgPSBMZWFmO1xuY2xhc3MgUHJvb2ZTdGVwIHtcbiAgICBjb25zdHJ1Y3RvcihidWNrZXQsIHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuYnVja2V0ID0gYnVja2V0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7IC8vIHdoZXRoZXIgdGhlIGJ1Y2tldCBoYXNoIHNob3VsZCBiZSBhcHBlZGVkIG9uIHRoZSByaWdodCBzaWRlIGluIHRoaXMgc3RlcCAoZGVmYXVsdCBpcyBsZWZ0XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9vZlN0ZXAgPSBQcm9vZlN0ZXA7XG5jbGFzcyBNZXJrbGVTdW1UcmVlIGV4dGVuZHMgQmFzZV8xLkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxlYXZlcywgaGFzaEZuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGVhdmVzID0gbGVhdmVzO1xuICAgICAgICB0aGlzLmhhc2hGbiA9IGhhc2hGbjtcbiAgICAgICAgTWVya2xlU3VtVHJlZS5jaGVja0NvbnNlY3V0aXZlKGxlYXZlcyk7XG4gICAgICAgIHRoaXMuYnVja2V0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGwgb2YgbGVhdmVzKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHMucHVzaChsLmdldEJ1Y2tldCgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVja2V0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGJ1Y2tldCBvZiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICAgIGJ1Y2tldHMucHVzaChidWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChidWNrZXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgY29uc3QgbmV3QnVja2V0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKGJ1Y2tldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYjEgPSBidWNrZXRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIyID0gYnVja2V0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gYjEuc2l6ZSArIGIyLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2hlZCA9IHRoaXMuaGFzaEZuKEJ1ZmZlci5jb25jYXQoW3RoaXMuc2l6ZVRvQnVmZmVyKGIxLnNpemUpLCB0aGlzLmJ1ZmZlcmlmeShiMS5oYXNoZWQpLCB0aGlzLnNpemVUb0J1ZmZlcihiMi5zaXplKSwgdGhpcy5idWZmZXJpZnkoYjIuaGFzaGVkKV0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IG5ldyBCdWNrZXQoc2l6ZSwgaGFzaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgYjIucGFyZW50ID0gYjtcbiAgICAgICAgICAgICAgICAgICAgYjEucGFyZW50ID0gYjIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBiMS5yaWdodCA9IGIyO1xuICAgICAgICAgICAgICAgICAgICBiMi5sZWZ0ID0gYjE7XG4gICAgICAgICAgICAgICAgICAgIG5ld0J1Y2tldHMucHVzaChiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0J1Y2tldHMucHVzaChidWNrZXRzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldHMgPSBuZXdCdWNrZXRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdCA9IGJ1Y2tldHNbMF07XG4gICAgfVxuICAgIHNpemVUb0J1ZmZlcihzaXplKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRCaWdJbnQ2NCgwLCBCaWdJbnQoc2l6ZSksIGZhbHNlKTsgLy8gdHJ1ZSB3aGVuIGxpdHRsZSBlbmRpYW5cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgc3RhdGljIGNoZWNrQ29uc2VjdXRpdmUobGVhdmVzKSB7XG4gICAgICAgIGxldCBjdXJyID0gQmlnSW50KDApO1xuICAgICAgICBmb3IgKGNvbnN0IGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgICAgICAgICBpZiAobGVhZi5ybmdbMF0gIT09IGN1cnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlYWYgcmFuZ2VzIGFyZSBpbnZhbGlkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyID0gQmlnSW50KGxlYWYucm5nWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBnZXRzIGluY2x1c2lvbi9leGNsdXNpb24gcHJvb2Ygb2YgYSBidWNrZXQgaW4gdGhlIHNwZWNpZmllZCBpbmRleFxuICAgIGdldFByb29mKGluZGV4KSB7XG4gICAgICAgIGxldCBjdXJyID0gdGhpcy5idWNrZXRzW051bWJlcihpbmRleCldO1xuICAgICAgICBjb25zdCBwcm9vZiA9IFtdO1xuICAgICAgICB3aGlsZSAoY3VyciAmJiBjdXJyLnBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSAhIWN1cnIucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCBidWNrZXQgPSBjdXJyLnJpZ2h0ID8gY3Vyci5yaWdodCA6IGN1cnIubGVmdDtcbiAgICAgICAgICAgIGN1cnIgPSBjdXJyLnBhcmVudDtcbiAgICAgICAgICAgIHByb29mLnB1c2gobmV3IFByb29mU3RlcChidWNrZXQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb29mO1xuICAgIH1cbiAgICBzdW0oYXJyKSB7XG4gICAgICAgIGxldCB0b3RhbCA9IEJpZ0ludCgwKTtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnIpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZXMgdGhlIHN1cHBwbGllZCBwcm9vZiBmb3IgYSBzcGVjaWZpZWQgbGVhZiBhY2NvcmRpbmcgdG8gdGhlIHJvb3QgYnVja2V0XG4gICAgdmVyaWZ5UHJvb2Yocm9vdCwgbGVhZiwgcHJvb2YpIHtcbiAgICAgICAgY29uc3Qgcm5nID0gW3RoaXMuc3VtKHByb29mLmZpbHRlcih4ID0+ICF4LnJpZ2h0KS5tYXAoeCA9PiB4LmJ1Y2tldC5zaXplKSksIEJpZ0ludChyb290LnNpemUpIC0gdGhpcy5zdW0ocHJvb2YuZmlsdGVyKHggPT4geC5yaWdodCkubWFwKHggPT4geC5idWNrZXQuc2l6ZSkpXTtcbiAgICAgICAgaWYgKCEocm5nWzBdID09PSBsZWFmLnJuZ1swXSAmJiBybmdbMV0gPT09IGxlYWYucm5nWzFdKSkge1xuICAgICAgICAgICAgLy8gc3VwcGxpZWQgc3RlcHMgYXJlIG5vdCByb3V0aW5nIHRvIHRoZSByYW5nZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyciA9IGxlYWYuZ2V0QnVja2V0KCk7XG4gICAgICAgIGxldCBoYXNoZWQ7XG4gICAgICAgIGZvciAoY29uc3Qgc3RlcCBvZiBwcm9vZikge1xuICAgICAgICAgICAgaWYgKHN0ZXAucmlnaHQpIHtcbiAgICAgICAgICAgICAgICBoYXNoZWQgPSB0aGlzLmhhc2hGbihCdWZmZXIuY29uY2F0KFt0aGlzLnNpemVUb0J1ZmZlcihjdXJyLnNpemUpLCB0aGlzLmJ1ZmZlcmlmeShjdXJyLmhhc2hlZCksIHRoaXMuc2l6ZVRvQnVmZmVyKHN0ZXAuYnVja2V0LnNpemUpLCB0aGlzLmJ1ZmZlcmlmeShzdGVwLmJ1Y2tldC5oYXNoZWQpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFzaGVkID0gdGhpcy5oYXNoRm4oQnVmZmVyLmNvbmNhdChbdGhpcy5zaXplVG9CdWZmZXIoc3RlcC5idWNrZXQuc2l6ZSksIHRoaXMuYnVmZmVyaWZ5KHN0ZXAuYnVja2V0Lmhhc2hlZCksIHRoaXMuc2l6ZVRvQnVmZmVyKGN1cnIuc2l6ZSksIHRoaXMuYnVmZmVyaWZ5KGN1cnIuaGFzaGVkKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnIgPSBuZXcgQnVja2V0KEJpZ0ludChjdXJyLnNpemUpICsgQmlnSW50KHN0ZXAuYnVja2V0LnNpemUpLCBoYXNoZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyLnNpemUgPT09IHJvb3Quc2l6ZSAmJiBjdXJyLmhhc2hlZC50b1N0cmluZygnaGV4JykgPT09IHJvb3QuaGFzaGVkLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG59XG5leHBvcnRzLk1lcmtsZVN1bVRyZWUgPSBNZXJrbGVTdW1UcmVlO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgO1xuICAgIHdpbmRvdy5NZXJrbGVTdW1UcmVlID0gTWVya2xlU3VtVHJlZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1lcmtsZVN1bVRyZWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/MerkleSumTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/MerkleTree.js":
/*!******************************************************!*\
  !*** ./node_modules/merkletreejs/dist/MerkleTree.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MerkleTree = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst buffer_reverse_1 = __importDefault(__webpack_require__(/*! buffer-reverse */ \"(ssr)/./node_modules/buffer-reverse/index.js\"));\nconst sha256_1 = __importDefault(__webpack_require__(/*! crypto-js/sha256 */ \"(ssr)/./node_modules/crypto-js/sha256.js\"));\nconst treeify_1 = __importDefault(__webpack_require__(/*! treeify */ \"(ssr)/./node_modules/treeify/treeify.js\"));\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/./node_modules/merkletreejs/dist/Base.js\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base_1.default {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    constructor(leaves, hashFn = sha256_1.default, options = {}) {\n        super();\n        this.duplicateOdd = false;\n        this.concatenator = buffer_1.Buffer.concat;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.complete = false;\n        if (options.complete) {\n            if (options.isBitcoinTree) {\n                throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n            }\n            if (options.duplicateOdd) {\n                throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n            }\n        }\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        this.complete = !!options.complete;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === 'function') {\n                this.fillDefaultHash = options.fillDefaultHash;\n            }\n            else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n                this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n            }\n            else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        if (options.concatenator) {\n            this.concatenator = options.concatenator;\n        }\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.processLeaves(leaves);\n    }\n    getOptions() {\n        var _a, _b;\n        return {\n            complete: this.complete,\n            isBitcoinTree: this.isBitcoinTree,\n            hashLeaves: this.hashLeaves,\n            sortLeaves: this.sortLeaves,\n            sortPairs: this.sortPairs,\n            sort: this.sort,\n            fillDefaultHash: (_b = (_a = this.fillDefaultHash) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null,\n            duplicateOdd: this.duplicateOdd\n        };\n    }\n    processLeaves(leaves) {\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.leaves = leaves.map(this.bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for (let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n                this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n            }\n        }\n        this.createHashes(this.leaves);\n    }\n    createHashes(nodes) {\n        this.layers = [nodes];\n        while (nodes.length > 1) {\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length))\n                ? (2 * nodes.length) - (Math.pow(2, Math.ceil(Math.log2(nodes.length))))\n                : nodes.length;\n            for (let i = 0; i < nodes.length; i += 2) {\n                if (i >= layerLimit) {\n                    this.layers[layerIndex].push(...nodes.slice(layerLimit));\n                    break;\n                }\n                else if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        const data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            hash = this.hashFn(this.concatenator([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]));\n                            hash = buffer_reverse_1.default(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        }\n                        else {\n                            if (this.duplicateOdd) {\n                                // continue with creating layer\n                            }\n                            else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(buffer_1.Buffer.compare);\n                }\n                let hash = this.hashFn(this.concatenator(combined));\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse_1.default(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n    addLeaf(leaf, shouldHash = false) {\n        if (shouldHash) {\n            leaf = this.hashFn(leaf);\n        }\n        this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n    addLeaves(leaves, shouldHash = false) {\n        if (shouldHash) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(this.hashFn);\n                if (this.sortLeaves) {\n                    values = values.sort(buffer_1.Buffer.compare);\n                }\n            }\n            return this.leaves.filter(leaf => this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n    getLeaf(index) {\n        if (index < 0 || index > this.leaves.length - 1) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n    getLeafIndex(target) {\n        target = this.bufferify(target);\n        const leaves = this.getLeaves();\n        for (let i = 0; i < leaves.length; i++) {\n            const leaf = leaves[i];\n            if (leaf.equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n    getLeafCount() {\n        return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n    getHexLeaves() {\n        return this.leaves.map(leaf => this.bufferToHex(leaf));\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n    static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n    static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(MerkleTree.bufferify);\n    }\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[][]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    getLayers() {\n        return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[][]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n    getHexLayers() {\n        return this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(layer => this.bufferToHex(layer)));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n    getLayersFlat() {\n        const layers = this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            }\n            else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(buffer_1.Buffer.from([0]));\n        return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n    getHexLayersFlat() {\n        return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n    getLayerCount() {\n        return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    getRoot() {\n        if (this.layers.length === 0) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    getProof(leaf, index) {\n        if (typeof leaf === 'undefined') {\n            throw new Error('leaf is required');\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for (let i = 0; i < this.leaves.length; i++) {\n                if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        for (let i = 0; i < this.layers.length; i++) {\n            const layer = this.layers[i];\n            const isRightNode = index % 2;\n            const pairIndex = (isRightNode ? index - 1\n                : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1\n                    // Proof Generation for Bitcoin Trees\n                    ? index\n                    // Proof Generation for Non-Bitcoin Trees\n                    : index + 1);\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? 'left' : 'right',\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            index = (index / 2) | 0;\n        }\n        return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n    getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n    }\n    /**\n     * getProofs\n     * @desc Returns the proofs for all leaves.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n     * @example\n     * ```js\n     *const proofs = tree.getProofs()\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proofs = tree.getProofs()\n     *```\n     */\n    getProofs() {\n        const proof = [];\n        const proofs = [];\n        this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n        return proofs;\n    }\n    /**\n     * getProofsDFS\n     * @desc Get all proofs through single traverse\n     * @param {Number} currentLayer - Current layer index in traverse.\n     * @param {Number} index - Current tarvese node index in traverse.\n     * @param {Object[]} proof - Proof chain for single leaf.\n     * @param {Object[]} proofs - Proofs for all leaves\n     * @example\n     * ```js\n     *const layers = tree.getLayers()\n     *const index = 0;\n     *let proof = [];\n     *let proofs = [];\n     *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n     *```\n     */\n    getProofsDFS(currentLayer, index, proof, proofs) {\n        const isRightNode = index % 2;\n        if (currentLayer === -1) {\n            if (!isRightNode)\n                proofs.push([...proof].reverse());\n            return;\n        }\n        if (index >= this.layers[currentLayer].length)\n            return;\n        const layer = this.layers[currentLayer];\n        const pairIndex = isRightNode ? index - 1 : index + 1;\n        let pushed = false;\n        if (pairIndex < layer.length) {\n            pushed = true;\n            proof.push({\n                position: isRightNode ? 'left' : 'right',\n                data: layer[pairIndex]\n            });\n        }\n        const leftchildIndex = index * 2;\n        const rightchildIndex = index * 2 + 1;\n        this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n        this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n        if (pushed)\n            proof.splice(proof.length - 1, 1);\n    }\n    /**\n     * getHexProofs\n     * @desc Returns the proofs for all leaves as hex strings.\n     * @return {String[]} - Proofs array as hex strings.\n     * @example\n     * ```js\n     *const proofs = tree.getHexProofs()\n     *```\n     */\n    getHexProofs() {\n        return this.getProofs().map(item => this.bufferToHex(item.data));\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n    getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => {\n            return [\n                item.position === 'left' ? 0 : 1,\n                this.bufferToHex(item.data)\n            ];\n        });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n    static marshalProof(proof) {\n        const json = proof.map(item => {\n            if (typeof item === 'string') {\n                return item;\n            }\n            if (buffer_1.Buffer.isBuffer(item)) {\n                return MerkleTree.bufferToHex(item);\n            }\n            return {\n                position: item.position,\n                data: MerkleTree.bufferToHex(item.data)\n            };\n        });\n        return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n    static unmarshalProof(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(item => {\n            if (typeof item === 'string') {\n                return MerkleTree.bufferify(item);\n            }\n            else if (item instanceof Object) {\n                return {\n                    position: item.position,\n                    data: MerkleTree.bufferify(item.data)\n                };\n            }\n            else {\n                throw new Error('Expected item to be of type string or object');\n            }\n        });\n    }\n    static marshalTree(tree) {\n        const root = tree.getHexRoot();\n        const leaves = tree.leaves.map(leaf => MerkleTree.bufferToHex(leaf));\n        const layers = tree.getHexLayers();\n        const options = tree.getOptions();\n        return JSON.stringify({\n            options,\n            root,\n            layers,\n            leaves\n        }, null, 2);\n    }\n    static unmarshalTree(jsonStr, hashFn = sha256_1.default, options = {}) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            throw new Error('could not parse json');\n        }\n        options = Object.assign({}, parsed.options || {}, options);\n        return new MerkleTree(parsed.leaves, hashFn, options);\n    }\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    getProofIndices(treeIndices, depth) {\n        const leafCount = Math.pow(2, depth);\n        let maximalIndices = new Set();\n        for (const index of treeIndices) {\n            let x = leafCount + index;\n            while (x > 1) {\n                maximalIndices.add(x ^ 1);\n                x = (x / 2) | 0;\n            }\n        }\n        const a = treeIndices.map(index => leafCount + index);\n        const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices) {\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while (index > 1) {\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1))\n                        break;\n                    index = (index / 2) | 0;\n                }\n            }\n        }\n        return proof.filter(index => {\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n        const depth = Math.ceil(Math.log2(leavesCount));\n        const unevenLayers = [];\n        for (let index = 0; index < depth; index++) {\n            const unevenLayer = leavesCount % 2 !== 0;\n            if (unevenLayer) {\n                unevenLayers.push({ index, leavesCount });\n            }\n            leavesCount = Math.ceil(leavesCount / 2);\n        }\n        const proofIndices = [];\n        let layerNodes = sortedLeafIndices;\n        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n            const siblingIndices = layerNodes.map((index) => {\n                if (index % 2 === 0) {\n                    return index + 1;\n                }\n                return index - 1;\n            });\n            let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));\n            const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);\n            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n                proofNodeIndices = proofNodeIndices.slice(0, -1);\n            }\n            proofIndices.push(proofNodeIndices);\n            layerNodes = [...new Set(layerNodes.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n        }\n        return proofIndices;\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n    getMultiProof(tree, indices) {\n        if (!this.complete) {\n            console.warn('Warning: For correct multiProofs it\\'s strongly recommended to set complete: true');\n        }\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n        }\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            if (indices.every(Number.isInteger)) {\n                return this.getMultiProofForUnevenTree(indices);\n            }\n        }\n        if (!indices.every(Number.isInteger)) {\n            let els = indices;\n            if (this.sortPairs) {\n                els = els.sort(buffer_1.Buffer.compare);\n            }\n            let ids = els.map((el) => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n            if (!ids.every((idx) => idx !== -1)) {\n                throw new Error('Element does not exist in Merkle tree');\n            }\n            const hashes = [];\n            const proof = [];\n            let nextIds = [];\n            for (let i = 0; i < this.layers.length; i++) {\n                const layer = this.layers[i];\n                for (let j = 0; j < ids.length; j++) {\n                    const idx = ids[j];\n                    const pairElement = this.getPairNode(layer, idx);\n                    hashes.push(layer[idx]);\n                    if (pairElement) {\n                        proof.push(pairElement);\n                    }\n                    nextIds.push((idx / 2) | 0);\n                }\n                ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n                nextIds = [];\n            }\n            return proof.filter((value) => !hashes.includes(value));\n        }\n        return this.getProofIndices(indices, Math.log2((tree.length / 2) | 0)).map(index => tree[index]);\n    }\n    getMultiProofForUnevenTree(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayers();\n        }\n        let proofHashes = [];\n        let currentLayerIndices = indices;\n        for (const treeLayer of tree) {\n            const siblings = [];\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    const idx = index + 1;\n                    if (!currentLayerIndices.includes(idx)) {\n                        if (treeLayer[idx]) {\n                            siblings.push(treeLayer[idx]);\n                            continue;\n                        }\n                    }\n                }\n                const idx = index - 1;\n                if (!currentLayerIndices.includes(idx)) {\n                    if (treeLayer[idx]) {\n                        siblings.push(treeLayer[idx]);\n                        continue;\n                    }\n                }\n            }\n            proofHashes = proofHashes.concat(siblings);\n            const uniqueIndices = new Set();\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    uniqueIndices.add(index / 2);\n                    continue;\n                }\n                if (index % 2 === 0) {\n                    uniqueIndices.add((index + 1) / 2);\n                    continue;\n                }\n                uniqueIndices.add((index - 1) / 2);\n            }\n            currentLayerIndices = Array.from(uniqueIndices);\n        }\n        return proofHashes;\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n    getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n    getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error('Invalid Inputs!');\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = [...leaves].sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        }\n        else {\n            ids = leaves.map((el) => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx) => idx !== -1)) {\n            throw new Error('Element does not exist in Merkle tree');\n        }\n        const _proofs = proofs.map(item => this.bufferify(item));\n        const tested = [];\n        const flags = [];\n        for (let index = 0; index < this.layers.length; index++) {\n            const layer = this.layers[index];\n            ids = ids.reduce((ids, idx) => {\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this.getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                ids.push((idx / 2) | 0);\n                return ids;\n            }, []);\n        }\n        return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            }\n            else if (Array.isArray(node)) {\n                isLeftNode = (node[0] === 0);\n                data = this.bufferify(node[1]);\n            }\n            else if (buffer_1.Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            }\n            else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = (node.position === 'left');\n            }\n            else {\n                throw new Error('Expected node to be of type string or object');\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse_1.default(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n                hash = this.hashFn(this.concatenator(buffers));\n                hash = buffer_reverse_1.default(this.hashFn(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (buffer_1.Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashFn(this.concatenator(buffers));\n                }\n            }\n        }\n        return buffer_1.Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} proofIndices - Leave indices for proof\n     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n     * @param {Number} leavesCount - Count of original leaves\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const leavesCount = leaves.length\n     *const proofIndices = [2, 5, 6]\n     *const proofLeaves = proofIndices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n     *```\n     */\n    verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            // TODO: combine these functions and simplify\n            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n        }\n        const depth = Math.ceil(Math.log2(leavesCount));\n        root = this.bufferify(root);\n        proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const tree = {};\n        for (const [index, leaf] of this.zip(proofIndices, proofLeaves)) {\n            tree[(Math.pow(2, depth)) + index] = leaf;\n        }\n        for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)) {\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while (i < indexqueue.length) {\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                let pair = [tree[index - (index % 2)], tree[index - (index % 2) + 1]];\n                if (this.sortPairs) {\n                    pair = pair.sort(buffer_1.Buffer.compare);\n                }\n                const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n                tree[(index / 2) | 0] = hash;\n                indexqueue.push((index / 2) | 0);\n            }\n            i += 1;\n        }\n        return !proofIndices.length || (({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root));\n    }\n    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n        root = this.bufferify(root);\n        leaves = leaves.map(this.bufferify);\n        proofs = proofs.map(this.bufferify);\n        const leavesLen = leaves.length;\n        const totalHashes = proofFlag.length;\n        const hashes = [];\n        let leafPos = 0;\n        let hashPos = 0;\n        let proofPos = 0;\n        for (let i = 0; i < totalHashes; i++) {\n            const bufA = proofFlag[i] ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++]) : proofs[proofPos++];\n            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n            hashes[i] = this.hashFn(this.concatenator(buffers));\n        }\n        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n        return root.equals(computedRoot);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n    getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n    static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n        const tree = new MerkleTree([], hashFn, options);\n        return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n    static getMultiProof(tree, indices) {\n        const t = new MerkleTree([]);\n        return t.getMultiProof(tree, indices);\n    }\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    resetTree() {\n        this.leaves = [];\n        this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n    getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n    toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n    toString() {\n        return this.toTreeString();\n    }\n    isUnevenTree(treeLayers) {\n        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n        return !this.isPowOf2(depth);\n    }\n    isPowOf2(v) {\n        return v && !(v & (v - 1));\n    }\n    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n        const leafTuples = this.zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);\n        const leafTupleIndices = leafTuples.map(([index]) => index);\n        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n        let nextSliceStart = 0;\n        const proofTuplesByLayers = [];\n        for (let i = 0; i < proofIndices.length; i++) {\n            const indices = proofIndices[i];\n            const sliceStart = nextSliceStart;\n            nextSliceStart += indices.length;\n            proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n        }\n        const tree = [leafTuples];\n        for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB)\n                .map(([, hash]) => hash);\n            const s = tree[layerIndex].map(([layerIndex]) => layerIndex);\n            const parentIndices = [...new Set(s.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n            const parentLayer = [];\n            for (let i = 0; i < parentIndices.length; i++) {\n                const parentNodeTreeIndex = parentIndices[i];\n                const bufA = currentLayer[i * 2];\n                const bufB = currentLayer[i * 2 + 1];\n                const hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;\n                parentLayer.push([parentNodeTreeIndex, hash]);\n            }\n            tree.push(parentLayer);\n        }\n        return tree[tree.length - 1][0][1];\n    }\n}\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleTree = MerkleTree;\n}\nexports[\"default\"] = MerkleTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvTWVya2xlVHJlZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyx5Q0FBeUMsbUJBQU8sQ0FBQyxvRUFBZ0I7QUFDakUsaUNBQWlDLG1CQUFPLENBQUMsa0VBQWtCO0FBQzNELGtDQUFrQyxtQkFBTyxDQUFDLHdEQUFTO0FBQ25ELCtCQUErQixtQkFBTyxDQUFDLDhEQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyREFBMkQ7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVEsb0JBQW9CO0FBQzNDLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUNBQXlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tZXJrbGV0cmVlanMvZGlzdC9NZXJrbGVUcmVlLmpzPzIwN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lcmtsZVRyZWUgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5jb25zdCBidWZmZXJfcmV2ZXJzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJidWZmZXItcmV2ZXJzZVwiKSk7XG5jb25zdCBzaGEyNTZfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvLWpzL3NoYTI1NlwiKSk7XG5jb25zdCB0cmVlaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRyZWVpZnlcIikpO1xuY29uc3QgQmFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0Jhc2VcIikpO1xuLyoqXG4gKiBDbGFzcyByZXByZW5zZW50aW5nIGEgTWVya2xlIFRyZWVcbiAqIEBuYW1lc3BhY2UgTWVya2xlVHJlZVxuICovXG5jbGFzcyBNZXJrbGVUcmVlIGV4dGVuZHMgQmFzZV8xLmRlZmF1bHQge1xuICAgIC8qKlxuICAgICAqIEBkZXNjIENvbnN0cnVjdHMgYSBNZXJrbGUgVHJlZS5cbiAgICAgKiBBbGwgbm9kZXMgYW5kIGxlYXZlcyBhcmUgc3RvcmVkIGFzIEJ1ZmZlcnMuXG4gICAgICogTG9uZWx5IGxlYWYgbm9kZXMgYXJlIHByb21vdGVkIHRvIHRoZSBuZXh0IGxldmVsIHVwIHdpdGhvdXQgYmVpbmcgaGFzaGVkIGFnYWluLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGxlYXZlcyAtIEFycmF5IG9mIGhhc2hlZCBsZWF2ZXMuIEVhY2ggbGVhZiBtdXN0IGJlIGEgQnVmZmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc2hGdW5jdGlvbiAtIEhhc2ggZnVuY3Rpb24gdG8gdXNlIGZvciBoYXNoaW5nIGxlYXZlcyBhbmQgbm9kZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgTWVya2xlVHJlZSA9IHJlcXVpcmUoJ21lcmtsZXRyZWVqcycpXG4gICAgICpjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuICAgICAqXG4gICAgICpmdW5jdGlvbiBzaGEyNTYoZGF0YSkge1xuICAgICAqICAvLyByZXR1cm5zIEJ1ZmZlclxuICAgICAqICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICAgICAqfVxuICAgICAqXG4gICAgICpjb25zdCBsZWF2ZXMgPSBbJ2EnLCAnYicsICdjJ10ubWFwKHZhbHVlID0+IGtlY2Nhayh2YWx1ZSkpXG4gICAgICpcbiAgICAgKmNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShsZWF2ZXMsIHNoYTI1NilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlYXZlcywgaGFzaEZuID0gc2hhMjU2XzEuZGVmYXVsdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZHVwbGljYXRlT2RkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29uY2F0ZW5hdG9yID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdDtcbiAgICAgICAgdGhpcy5oYXNoTGVhdmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNCaXRjb2luVHJlZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlYXZlcyA9IFtdO1xuICAgICAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgICAgICB0aGlzLnNvcnRMZWF2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zb3J0UGFpcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zb3J0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmlsbERlZmF1bHRIYXNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNCaXRjb2luVHJlZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9uIFwiY29tcGxldGVcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBcImlzQml0Y29pblRyZWVcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZHVwbGljYXRlT2RkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb24gXCJjb21wbGV0ZVwiIGlzIGluY29tcGF0aWJsZSB3aXRoIFwiZHVwbGljYXRlT2RkXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQml0Y29pblRyZWUgPSAhIW9wdGlvbnMuaXNCaXRjb2luVHJlZTtcbiAgICAgICAgdGhpcy5oYXNoTGVhdmVzID0gISFvcHRpb25zLmhhc2hMZWF2ZXM7XG4gICAgICAgIHRoaXMuc29ydExlYXZlcyA9ICEhb3B0aW9ucy5zb3J0TGVhdmVzO1xuICAgICAgICB0aGlzLnNvcnRQYWlycyA9ICEhb3B0aW9ucy5zb3J0UGFpcnM7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSAhIW9wdGlvbnMuY29tcGxldGU7XG4gICAgICAgIGlmIChvcHRpb25zLmZpbGxEZWZhdWx0SGFzaCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbGxEZWZhdWx0SGFzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbERlZmF1bHRIYXNoID0gb3B0aW9ucy5maWxsRGVmYXVsdEhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5maWxsRGVmYXVsdEhhc2gpIHx8IHR5cGVvZiBvcHRpb25zLmZpbGxEZWZhdWx0SGFzaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxEZWZhdWx0SGFzaCA9IChpZHgsIGhhc2hGbikgPT4gb3B0aW9ucy5maWxsRGVmYXVsdEhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBcImZpbGxEZWZhdWx0SGFzaFwiIG11c3QgYmUgYSBmdW5jdGlvbiwgQnVmZmVyLCBvciBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvcnQgPSAhIW9wdGlvbnMuc29ydDtcbiAgICAgICAgaWYgKHRoaXMuc29ydCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TGVhdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc29ydFBhaXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR1cGxpY2F0ZU9kZCA9ICEhb3B0aW9ucy5kdXBsaWNhdGVPZGQ7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbmNhdGVuYXRvcikge1xuICAgICAgICAgICAgdGhpcy5jb25jYXRlbmF0b3IgPSBvcHRpb25zLmNvbmNhdGVuYXRvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc2hGbiA9IHRoaXMuYnVmZmVyaWZ5Rm4oaGFzaEZuKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzTGVhdmVzKGxlYXZlcyk7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wbGV0ZTogdGhpcy5jb21wbGV0ZSxcbiAgICAgICAgICAgIGlzQml0Y29pblRyZWU6IHRoaXMuaXNCaXRjb2luVHJlZSxcbiAgICAgICAgICAgIGhhc2hMZWF2ZXM6IHRoaXMuaGFzaExlYXZlcyxcbiAgICAgICAgICAgIHNvcnRMZWF2ZXM6IHRoaXMuc29ydExlYXZlcyxcbiAgICAgICAgICAgIHNvcnRQYWlyczogdGhpcy5zb3J0UGFpcnMsXG4gICAgICAgICAgICBzb3J0OiB0aGlzLnNvcnQsXG4gICAgICAgICAgICBmaWxsRGVmYXVsdEhhc2g6IChfYiA9IChfYSA9IHRoaXMuZmlsbERlZmF1bHRIYXNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCxcbiAgICAgICAgICAgIGR1cGxpY2F0ZU9kZDogdGhpcy5kdXBsaWNhdGVPZGRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvY2Vzc0xlYXZlcyhsZWF2ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzaExlYXZlcykge1xuICAgICAgICAgICAgbGVhdmVzID0gbGVhdmVzLm1hcCh0aGlzLmhhc2hGbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWF2ZXMgPSBsZWF2ZXMubWFwKHRoaXMuYnVmZmVyaWZ5KTtcbiAgICAgICAgaWYgKHRoaXMuc29ydExlYXZlcykge1xuICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSB0aGlzLmxlYXZlcy5zb3J0KGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWxsRGVmYXVsdEhhc2gpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlYXZlcy5sZW5ndGg7IGkgPCBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHRoaXMubGVhdmVzLmxlbmd0aCkpKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMucHVzaCh0aGlzLmJ1ZmZlcmlmeSh0aGlzLmZpbGxEZWZhdWx0SGFzaChpLCB0aGlzLmhhc2hGbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0ZUhhc2hlcyh0aGlzLmxlYXZlcyk7XG4gICAgfVxuICAgIGNyZWF0ZUhhc2hlcyhub2Rlcykge1xuICAgICAgICB0aGlzLmxheWVycyA9IFtub2Rlc107XG4gICAgICAgIHdoaWxlIChub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsYXllckluZGV4ID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5sYXllcnMucHVzaChbXSk7XG4gICAgICAgICAgICBjb25zdCBsYXllckxpbWl0ID0gdGhpcy5jb21wbGV0ZSAmJiBsYXllckluZGV4ID09PSAxICYmICFOdW1iZXIuaXNJbnRlZ2VyKE1hdGgubG9nMihub2Rlcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgID8gKDIgKiBub2Rlcy5sZW5ndGgpIC0gKE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobm9kZXMubGVuZ3RoKSkpKVxuICAgICAgICAgICAgICAgIDogbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChpID49IGxheWVyTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJJbmRleF0ucHVzaCguLi5ub2Rlcy5zbGljZShsYXllckxpbWl0KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpICsgMSA9PT0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGFzaCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBiaXRjb2luIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQml0Y29pblRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXRjb2luIG1ldGhvZCBvZiBkdXBsaWNhdGluZyB0aGUgb2RkIGVuZGluZyBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihbYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KGRhdGEpLCBidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQoZGF0YSldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGJ1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdCh0aGlzLmhhc2hGbihoYXNoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJJbmRleF0ucHVzaChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmR1cGxpY2F0ZU9kZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSB3aXRoIGNyZWF0aW5nIGxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGNvcHkgb2YgaGFzaCBhbmQgY29udGludWUgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLnB1c2gobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaSArIDEgPT09IG5vZGVzLmxlbmd0aCA/IGxlZnQgOiBub2Rlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgbGV0IGNvbWJpbmVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0JpdGNvaW5UcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkID0gW2J1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdChsZWZ0KSwgYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KHJpZ2h0KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21iaW5lZCA9IFtsZWZ0LCByaWdodF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvcnRQYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb21iaW5lZC5zb3J0KGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihjb21iaW5lZCkpO1xuICAgICAgICAgICAgICAgIC8vIGRvdWJsZSBoYXNoIGlmIGJpdGNvaW4gdHJlZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQml0Y29pblRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGJ1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdCh0aGlzLmhhc2hGbihoYXNoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLnB1c2goaGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlcyA9IHRoaXMubGF5ZXJzW2xheWVySW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFkZExlYWZcbiAgICAgKiBAZGVzYyBBZGRzIGEgbGVhZiB0byB0aGUgdHJlZSBhbmQgcmUtY2FsY3VsYXRlcyBsYXllcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSAtIExlYWZcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IC0gU2V0IHRvIHRydWUgaWYgdGhlIGxlYWYgc2hvdWxkIGJlIGhhc2hlZCBiZWZvcmUgYmVpbmcgYWRkZWQgdG8gdHJlZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKnRyZWUuYWRkTGVhZihuZXdMZWFmKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgYWRkTGVhZihsZWFmLCBzaG91bGRIYXNoID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHNob3VsZEhhc2gpIHtcbiAgICAgICAgICAgIGxlYWYgPSB0aGlzLmhhc2hGbihsZWFmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NMZWF2ZXModGhpcy5sZWF2ZXMuY29uY2F0KGxlYWYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWRkTGVhdmVzXG4gICAgICogQGRlc2MgQWRkcyBtdWx0aXBsZSBsZWF2ZXMgdG8gdGhlIHRyZWUgYW5kIHJlLWNhbGN1bGF0ZXMgbGF5ZXJzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118QnVmZmVyW119IC0gQXJyYXkgb2YgbGVhdmVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAtIFNldCB0byB0cnVlIGlmIHRoZSBsZWF2ZXMgc2hvdWxkIGJlIGhhc2hlZCBiZWZvcmUgYmVpbmcgYWRkZWQgdG8gdHJlZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKnRyZWUuYWRkTGVhdmVzKG5ld0xlYXZlcylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGFkZExlYXZlcyhsZWF2ZXMsIHNob3VsZEhhc2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAoc2hvdWxkSGFzaCkge1xuICAgICAgICAgICAgbGVhdmVzID0gbGVhdmVzLm1hcCh0aGlzLmhhc2hGbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzTGVhdmVzKHRoaXMubGVhdmVzLmNvbmNhdChsZWF2ZXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TGVhdmVzXG4gICAgICogQGRlc2MgUmV0dXJucyBhcnJheSBvZiBsZWF2ZXMgb2YgTWVya2xlIFRyZWUuXG4gICAgICogQHJldHVybiB7QnVmZmVyW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsZWF2ZXMgPSB0cmVlLmdldExlYXZlcygpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRMZWF2ZXModmFsdWVzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc2hMZWF2ZXMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKHRoaXMuaGFzaEZuKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3J0TGVhdmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5zb3J0KGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWF2ZXMuZmlsdGVyKGxlYWYgPT4gdGhpcy5idWZmZXJJbmRleE9mKHZhbHVlcywgbGVhZiwgdGhpcy5zb3J0TGVhdmVzKSAhPT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxlYXZlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TGVhZlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIGxlYWYgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxlYWYgPSB0cmVlLmdldExlYWYoMSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldExlYWYoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMubGVhdmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVhdmVzW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TGVhZkluZGV4XG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGxlYWYsIG9yIC0xIGlmIHRoZSBsZWFmIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IC0gVGFyZ2V0IGxlYWZcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsZWFmID0gQnVmZmVyLmZyb20oJ2FiYycpXG4gICAgICpjb25zdCBpbmRleCA9IHRyZWUuZ2V0TGVhZkluZGV4KGxlYWYpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRMZWFmSW5kZXgodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuYnVmZmVyaWZ5KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHRoaXMuZ2V0TGVhdmVzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsZWFmID0gbGVhdmVzW2ldO1xuICAgICAgICAgICAgaWYgKGxlYWYuZXF1YWxzKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExlYWZDb3VudFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBsZWF2ZXMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgY291bnQgPSB0cmVlLmdldExlYWZDb3VudCgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRMZWFmQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlYXZlcy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldEhleExlYXZlc1xuICAgICAqIEBkZXNjIFJldHVybnMgYXJyYXkgb2YgbGVhdmVzIG9mIE1lcmtsZSBUcmVlIGFzIGhleCBzdHJpbmdzLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGVhdmVzID0gdHJlZS5nZXRIZXhMZWF2ZXMoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0SGV4TGVhdmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWF2ZXMubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJUb0hleChsZWFmKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1hcnNoYWxMZWF2ZXNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGFycmF5IG9mIGxlYXZlcyBvZiBNZXJrbGUgVHJlZSBhcyBhIEpTT04gc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118QnVmZmVyW119IC0gTWVya2xlIHRyZWUgbGVhdmVzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAtIExpc3Qgb2YgbGVhdmVzIGFzIEpTT04gc3RyaW5nXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBqc29uU3RyID0gTWVya2xlVHJlZS5tYXJzaGFsTGVhdmVzKGxlYXZlcylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBtYXJzaGFsTGVhdmVzKGxlYXZlcykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobGVhdmVzLm1hcChsZWFmID0+IE1lcmtsZVRyZWUuYnVmZmVyVG9IZXgobGVhZikpLCBudWxsLCAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdW5tYXJzaGFsTGVhdmVzXG4gICAgICogQGRlc2MgUmV0dXJucyBhcnJheSBvZiBsZWF2ZXMgb2YgTWVya2xlIFRyZWUgYXMgYSBCdWZmZXJzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gLSBKU09OIHN0cmluZ2lmaWVkIGxlYXZlc1xuICAgICAqIEByZXR1cm4ge0J1ZmZlcltdfSAtIFVubWFyc2hhbGxlZCBsaXN0IG9mIGxlYXZlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGVhdmVzID0gTWVya2xlVHJlZS51bm1hcnNoYWxMZWF2ZXMoanNvblN0cilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyB1bm1hcnNoYWxMZWF2ZXMoanNvblN0cikge1xuICAgICAgICBsZXQgcGFyc2VkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uU3RyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uU3RyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uU3RyIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBqc29uU3RyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0eXBlIG9mIHN0cmluZyBvciBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEpTT04gc3RyaW5nIHRvIGJlIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZC5tYXAoTWVya2xlVHJlZS5idWZmZXJpZnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRMYXllcnNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IG9mIGFsbCBsYXllcnMgb2YgTWVya2xlIFRyZWUsIGluY2x1ZGluZyBsZWF2ZXMgYW5kIHJvb3QuXG4gICAgICogQHJldHVybiB7QnVmZmVyW11bXX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0TGF5ZXJzKClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldExheWVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRIZXhMYXllcnNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IG9mIGFsbCBsYXllcnMgb2YgTWVya2xlIFRyZWUsIGluY2x1ZGluZyBsZWF2ZXMgYW5kIHJvb3QgYXMgaGV4IHN0cmluZ3MuXG4gICAgICogQHJldHVybiB7U3RyaW5nW11bXX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0SGV4TGF5ZXJzKClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldEhleExheWVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKGl0ZW0ubWFwKGxheWVyID0+IHRoaXMuYnVmZmVyVG9IZXgobGF5ZXIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TGF5ZXJzRmxhdFxuICAgICAqIEBkZXNjIFJldHVybnMgc2luZ2xlIGZsYXQgYXJyYXkgb2YgYWxsIGxheWVycyBvZiBNZXJrbGUgVHJlZSwgaW5jbHVkaW5nIGxlYXZlcyBhbmQgcm9vdC5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJbXX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0TGF5ZXJzRmxhdCgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRMYXllcnNGbGF0KCkge1xuICAgICAgICBjb25zdCBsYXllcnMgPSB0aGlzLmxheWVycy5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhY2MudW5zaGlmdCguLi5pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjYy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBsYXllcnMudW5zaGlmdChidWZmZXJfMS5CdWZmZXIuZnJvbShbMF0pKTtcbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0SGV4TGF5ZXJzRmxhdFxuICAgICAqIEBkZXNjIFJldHVybnMgc2luZ2xlIGZsYXQgYXJyYXkgb2YgYWxsIGxheWVycyBvZiBNZXJrbGUgVHJlZSwgaW5jbHVkaW5nIGxlYXZlcyBhbmQgcm9vdCBhcyBoZXggc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGF5ZXJzID0gdHJlZS5nZXRIZXhMYXllcnNGbGF0KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldEhleExheWVyc0ZsYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyc0ZsYXQoKS5tYXAobGF5ZXIgPT4gdGhpcy5idWZmZXJUb0hleChsYXllcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRMYXllckNvdW50XG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGxheWVycy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBjb3VudCA9IHRyZWUuZ2V0TGF5ZXJDb3VudCgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRMYXllckNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcnMoKS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFJvb3RcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBNZXJrbGUgcm9vdCBoYXNoIGFzIGEgQnVmZmVyLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IHJvb3QgPSB0cmVlLmdldFJvb3QoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0Um9vdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXllcnNbdGhpcy5sYXllcnMubGVuZ3RoIC0gMV1bMF0gfHwgYnVmZmVyXzEuQnVmZmVyLmZyb20oW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRIZXhSb290XG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgTWVya2xlIHJvb3QgaGFzaCBhcyBhIGhleCBzdHJpbmcuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3Qgcm9vdCA9IHRyZWUuZ2V0SGV4Um9vdCgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRIZXhSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJUb0hleCh0aGlzLmdldFJvb3QoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFByb29mXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2YgZm9yIGEgdGFyZ2V0IGxlYWYuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGxlYWYgLSBUYXJnZXQgbGVhZlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIC0gVGFyZ2V0IGxlYWYgaW5kZXggaW4gbGVhdmVzIGFycmF5LlxuICAgICAqIFVzZSBpZiB0aGVyZSBhcmUgbGVhdmVzIGNvbnRhaW5pbmcgZHVwbGljYXRlIGRhdGEgaW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggaXQuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119IC0gQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGEgcG9zaXRpb24gcHJvcGVydHkgb2YgdHlwZSBzdHJpbmdcbiAgICAgKiB3aXRoIHZhbHVlcyBvZiAnbGVmdCcgb3IgJ3JpZ2h0JyBhbmQgYSBkYXRhIHByb3BlcnR5IG9mIHR5cGUgQnVmZmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZihsZWF2ZXNbMl0pXG4gICAgICpgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGVhdmVzID0gWydhJywgJ2InLCAnYSddLm1hcCh2YWx1ZSA9PiBrZWNjYWsodmFsdWUpKVxuICAgICAqY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKGxlYXZlcywga2VjY2FrKVxuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldFByb29mKGxlYXZlc1syXSwgMilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldFByb29mKGxlYWYsIGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGVhZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGVhZiBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGxlYWYgPSB0aGlzLmJ1ZmZlcmlmeShsZWFmKTtcbiAgICAgICAgY29uc3QgcHJvb2YgPSBbXTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUobGVhZiwgdGhpcy5sZWF2ZXNbaV0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4IDw9IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGlzUmlnaHROb2RlID0gaW5kZXggJSAyO1xuICAgICAgICAgICAgY29uc3QgcGFpckluZGV4ID0gKGlzUmlnaHROb2RlID8gaW5kZXggLSAxXG4gICAgICAgICAgICAgICAgOiB0aGlzLmlzQml0Y29pblRyZWUgJiYgaW5kZXggPT09IGxheWVyLmxlbmd0aCAtIDEgJiYgaSA8IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvb2YgR2VuZXJhdGlvbiBmb3IgQml0Y29pbiBUcmVlc1xuICAgICAgICAgICAgICAgICAgICA/IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb29mIEdlbmVyYXRpb24gZm9yIE5vbi1CaXRjb2luIFRyZWVzXG4gICAgICAgICAgICAgICAgICAgIDogaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGlmIChwYWlySW5kZXggPCBsYXllci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwcm9vZi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlzUmlnaHROb2RlID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGF5ZXJbcGFpckluZGV4XVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGluZGV4IHRvIHBhcmVudCBpbmRleFxuICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggLyAyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb29mO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRIZXhQcm9vZlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mIGZvciBhIHRhcmdldCBsZWFmIGFzIGhleCBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBsZWFmIC0gVGFyZ2V0IGxlYWZcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSAtIFRhcmdldCBsZWFmIGluZGV4IGluIGxlYXZlcyBhcnJheS5cbiAgICAgKiBVc2UgaWYgdGhlcmUgYXJlIGxlYXZlcyBjb250YWluaW5nIGR1cGxpY2F0ZSBkYXRhIGluIG9yZGVyIHRvIGRpc3Rpbmd1aXNoIGl0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfSAtIFByb29mIGFycmF5IGFzIGhleCBzdHJpbmdzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRIZXhQcm9vZihsZWF2ZXNbMl0pXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRIZXhQcm9vZihsZWFmLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9vZihsZWFmLCBpbmRleCkubWFwKGl0ZW0gPT4gdGhpcy5idWZmZXJUb0hleChpdGVtLmRhdGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0UHJvb2ZzXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2ZzIGZvciBhbGwgbGVhdmVzLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAtIEFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBhIHBvc2l0aW9uIHByb3BlcnR5IG9mIHR5cGUgc3RyaW5nXG4gICAgICogd2l0aCB2YWx1ZXMgb2YgJ2xlZnQnIG9yICdyaWdodCcgYW5kIGEgZGF0YSBwcm9wZXJ0eSBvZiB0eXBlIEJ1ZmZlciBmb3IgYWxsIGxlYXZlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBwcm9vZnMgPSB0cmVlLmdldFByb29mcygpXG4gICAgICpgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGVhdmVzID0gWydhJywgJ2InLCAnYSddLm1hcCh2YWx1ZSA9PiBrZWNjYWsodmFsdWUpKVxuICAgICAqY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKGxlYXZlcywga2VjY2FrKVxuICAgICAqY29uc3QgcHJvb2ZzID0gdHJlZS5nZXRQcm9vZnMoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0UHJvb2ZzKCkge1xuICAgICAgICBjb25zdCBwcm9vZiA9IFtdO1xuICAgICAgICBjb25zdCBwcm9vZnMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRQcm9vZnNERlModGhpcy5sYXllcnMubGVuZ3RoIC0gMSwgMCwgcHJvb2YsIHByb29mcyk7XG4gICAgICAgIHJldHVybiBwcm9vZnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFByb29mc0RGU1xuICAgICAqIEBkZXNjIEdldCBhbGwgcHJvb2ZzIHRocm91Z2ggc2luZ2xlIHRyYXZlcnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGN1cnJlbnRMYXllciAtIEN1cnJlbnQgbGF5ZXIgaW5kZXggaW4gdHJhdmVyc2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gQ3VycmVudCB0YXJ2ZXNlIG5vZGUgaW5kZXggaW4gdHJhdmVyc2UuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcHJvb2YgLSBQcm9vZiBjaGFpbiBmb3Igc2luZ2xlIGxlYWYuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcHJvb2ZzIC0gUHJvb2ZzIGZvciBhbGwgbGVhdmVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgbGF5ZXJzID0gdHJlZS5nZXRMYXllcnMoKVxuICAgICAqY29uc3QgaW5kZXggPSAwO1xuICAgICAqbGV0IHByb29mID0gW107XG4gICAgICpsZXQgcHJvb2ZzID0gW107XG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UHJvb2ZzREZTKGxheWVycywgaW5kZXgsIHByb29mLCBwcm9vZnMpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRQcm9vZnNERlMoY3VycmVudExheWVyLCBpbmRleCwgcHJvb2YsIHByb29mcykge1xuICAgICAgICBjb25zdCBpc1JpZ2h0Tm9kZSA9IGluZGV4ICUgMjtcbiAgICAgICAgaWYgKGN1cnJlbnRMYXllciA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghaXNSaWdodE5vZGUpXG4gICAgICAgICAgICAgICAgcHJvb2ZzLnB1c2goWy4uLnByb29mXS5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmxheWVyc1tjdXJyZW50TGF5ZXJdLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1tjdXJyZW50TGF5ZXJdO1xuICAgICAgICBjb25zdCBwYWlySW5kZXggPSBpc1JpZ2h0Tm9kZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICAgICAgbGV0IHB1c2hlZCA9IGZhbHNlO1xuICAgICAgICBpZiAocGFpckluZGV4IDwgbGF5ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBwdXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgcHJvb2YucHVzaCh7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGlzUmlnaHROb2RlID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICBkYXRhOiBsYXllcltwYWlySW5kZXhdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0Y2hpbGRJbmRleCA9IGluZGV4ICogMjtcbiAgICAgICAgY29uc3QgcmlnaHRjaGlsZEluZGV4ID0gaW5kZXggKiAyICsgMTtcbiAgICAgICAgdGhpcy5nZXRQcm9vZnNERlMoY3VycmVudExheWVyIC0gMSwgbGVmdGNoaWxkSW5kZXgsIHByb29mLCBwcm9vZnMpO1xuICAgICAgICB0aGlzLmdldFByb29mc0RGUyhjdXJyZW50TGF5ZXIgLSAxLCByaWdodGNoaWxkSW5kZXgsIHByb29mLCBwcm9vZnMpO1xuICAgICAgICBpZiAocHVzaGVkKVxuICAgICAgICAgICAgcHJvb2Yuc3BsaWNlKHByb29mLmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRIZXhQcm9vZnNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwcm9vZnMgZm9yIGFsbCBsZWF2ZXMgYXMgaGV4IHN0cmluZ3MuXG4gICAgICogQHJldHVybiB7U3RyaW5nW119IC0gUHJvb2ZzIGFycmF5IGFzIGhleCBzdHJpbmdzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IHByb29mcyA9IHRyZWUuZ2V0SGV4UHJvb2ZzKClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldEhleFByb29mcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2ZzKCkubWFwKGl0ZW0gPT4gdGhpcy5idWZmZXJUb0hleChpdGVtLmRhdGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBnZXRQb3NpdGlvbmFsSGV4UHJvb2ZcbiAgICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mIGZvciBhIHRhcmdldCBsZWFmIGFzIGhleCBzdHJpbmdzIGFuZCB0aGUgcG9zaXRpb24gaW4gYmluYXJ5IChsZWZ0ID09IDApLlxuICAgICogQHBhcmFtIHtCdWZmZXJ9IGxlYWYgLSBUYXJnZXQgbGVhZlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gLSBUYXJnZXQgbGVhZiBpbmRleCBpbiBsZWF2ZXMgYXJyYXkuXG4gICAgKiBVc2UgaWYgdGhlcmUgYXJlIGxlYXZlcyBjb250YWluaW5nIGR1cGxpY2F0ZSBkYXRhIGluIG9yZGVyIHRvIGRpc3Rpbmd1aXNoIGl0LlxuICAgICogQHJldHVybiB7KHN0cmluZyB8IG51bWJlcilbXVtdfSAtIFByb29mIGFycmF5IGFzIGhleCBzdHJpbmdzLiBwb3NpdGlvbiBhdCBpbmRleCAwXG4gICAgKiBAZXhhbXBsZVxuICAgICogYGBganNcbiAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldFBvc2l0aW9uYWxIZXhQcm9vZihsZWF2ZXNbMl0pXG4gICAgKmBgYFxuICAgICovXG4gICAgZ2V0UG9zaXRpb25hbEhleFByb29mKGxlYWYsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByb29mKGxlYWYsIGluZGV4KS5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGl0ZW0ucG9zaXRpb24gPT09ICdsZWZ0JyA/IDAgOiAxLFxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyVG9IZXgoaXRlbS5kYXRhKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1hcnNoYWxQcm9vZlxuICAgICAqIEBkZXNjIFJldHVybnMgcHJvb2YgYXJyYXkgYXMgSlNPTiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxPYmplY3RbXX0gcHJvb2YgLSBNZXJrbGUgdHJlZSBwcm9vZiBhcnJheVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gLSBQcm9vZiBhcnJheSBhcyBKU09OIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBqc29uU3RyID0gTWVya2xlVHJlZS5tYXJzaGFsUHJvb2YocHJvb2YpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgbWFyc2hhbFByb29mKHByb29mKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBwcm9vZi5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1lcmtsZVRyZWUuYnVmZmVyVG9IZXgoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IE1lcmtsZVRyZWUuYnVmZmVyVG9IZXgoaXRlbS5kYXRhKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdW5tYXJzaGFsUHJvb2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwcm9vZiBmb3IgYSB0YXJnZXQgbGVhZiBhcyBhIGxpc3Qgb2YgQnVmZmVycy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IC0gTWVya2xlIHRyZWUgbGVhdmVzXG4gICAgICogQHJldHVybiB7U3RyaW5nfE9iamVjdH0gLSBNYXJzaGFsbGVkIHByb29mXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgcHJvb2YgPSBNZXJrbGVUcmVlLnVubWFyc2hhbFByb29mKGpzb25TdHIpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgdW5tYXJzaGFsUHJvb2YoanNvblN0cikge1xuICAgICAgICBsZXQgcGFyc2VkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uU3RyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uU3RyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uU3RyIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBqc29uU3RyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0eXBlIG9mIHN0cmluZyBvciBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEpTT04gc3RyaW5nIHRvIGJlIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1lcmtsZVRyZWUuYnVmZmVyaWZ5KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBNZXJrbGVUcmVlLmJ1ZmZlcmlmeShpdGVtLmRhdGEpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaXRlbSB0byBiZSBvZiB0eXBlIHN0cmluZyBvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBtYXJzaGFsVHJlZSh0cmVlKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0cmVlLmdldEhleFJvb3QoKTtcbiAgICAgICAgY29uc3QgbGVhdmVzID0gdHJlZS5sZWF2ZXMubWFwKGxlYWYgPT4gTWVya2xlVHJlZS5idWZmZXJUb0hleChsZWFmKSk7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRyZWUuZ2V0SGV4TGF5ZXJzKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0cmVlLmdldE9wdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGF5ZXJzLFxuICAgICAgICAgICAgbGVhdmVzXG4gICAgICAgIH0sIG51bGwsIDIpO1xuICAgIH1cbiAgICBzdGF0aWMgdW5tYXJzaGFsVHJlZShqc29uU3RyLCBoYXNoRm4gPSBzaGEyNTZfMS5kZWZhdWx0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YganNvblN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoanNvblN0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvblN0ciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgcGFyc2VkID0ganNvblN0cjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdHlwZSBvZiBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHBhcnNlIGpzb24nKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkLm9wdGlvbnMgfHwge30sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IE1lcmtsZVRyZWUocGFyc2VkLmxlYXZlcywgaGFzaEZuLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0UHJvb2ZJbmRpY2VzXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2YgaW5kaWNlcyBmb3IgZ2l2ZW4gdHJlZSBpbmRpY2VzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHRyZWVJbmRpY2VzIC0gVHJlZSBpbmRpY2VzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIC0gVHJlZSBkZXB0aDsgbnVtYmVyIG9mIGxheWVycy5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gLSBQcm9vZiBpbmRpY2VzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgcHJvb2ZJbmRpY2VzID0gdHJlZS5nZXRQcm9vZkluZGljZXMoWzIsNSw2XSwgNClcbiAgICAgKmNvbnNvbGUubG9nKHByb29mSW5kaWNlcykgLy8gWyAyMywgMjAsIDE5LCA4LCAzIF1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldFByb29mSW5kaWNlcyh0cmVlSW5kaWNlcywgZGVwdGgpIHtcbiAgICAgICAgY29uc3QgbGVhZkNvdW50ID0gTWF0aC5wb3coMiwgZGVwdGgpO1xuICAgICAgICBsZXQgbWF4aW1hbEluZGljZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdHJlZUluZGljZXMpIHtcbiAgICAgICAgICAgIGxldCB4ID0gbGVhZkNvdW50ICsgaW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoeCA+IDEpIHtcbiAgICAgICAgICAgICAgICBtYXhpbWFsSW5kaWNlcy5hZGQoeCBeIDEpO1xuICAgICAgICAgICAgICAgIHggPSAoeCAvIDIpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhID0gdHJlZUluZGljZXMubWFwKGluZGV4ID0+IGxlYWZDb3VudCArIGluZGV4KTtcbiAgICAgICAgY29uc3QgYiA9IEFycmF5LmZyb20obWF4aW1hbEluZGljZXMpLnNvcnQoKGEsIGIpID0+IGEgLSBiKS5yZXZlcnNlKCk7XG4gICAgICAgIG1heGltYWxJbmRpY2VzID0gYS5jb25jYXQoYik7XG4gICAgICAgIGNvbnN0IHJlZHVuZGFudEluZGljZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHByb29mID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4IG9mIG1heGltYWxJbmRpY2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJlZHVuZGFudEluZGljZXMuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHByb29mLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkdW5kYW50SW5kaWNlcy5hZGQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZHVuZGFudEluZGljZXMuaGFzKGluZGV4IF4gMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggLyAyKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9vZi5maWx0ZXIoaW5kZXggPT4ge1xuICAgICAgICAgICAgcmV0dXJuICF0cmVlSW5kaWNlcy5pbmNsdWRlcyhpbmRleCAtIGxlYWZDb3VudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQcm9vZkluZGljZXNGb3JVbmV2ZW5UcmVlKHNvcnRlZExlYWZJbmRpY2VzLCBsZWF2ZXNDb3VudCkge1xuICAgICAgICBjb25zdCBkZXB0aCA9IE1hdGguY2VpbChNYXRoLmxvZzIobGVhdmVzQ291bnQpKTtcbiAgICAgICAgY29uc3QgdW5ldmVuTGF5ZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkZXB0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgdW5ldmVuTGF5ZXIgPSBsZWF2ZXNDb3VudCAlIDIgIT09IDA7XG4gICAgICAgICAgICBpZiAodW5ldmVuTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB1bmV2ZW5MYXllcnMucHVzaCh7IGluZGV4LCBsZWF2ZXNDb3VudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlYXZlc0NvdW50ID0gTWF0aC5jZWlsKGxlYXZlc0NvdW50IC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvb2ZJbmRpY2VzID0gW107XG4gICAgICAgIGxldCBsYXllck5vZGVzID0gc29ydGVkTGVhZkluZGljZXM7XG4gICAgICAgIGZvciAobGV0IGxheWVySW5kZXggPSAwOyBsYXllckluZGV4IDwgZGVwdGg7IGxheWVySW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3Qgc2libGluZ0luZGljZXMgPSBsYXllck5vZGVzLm1hcCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCAtIDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBwcm9vZk5vZGVJbmRpY2VzID0gc2libGluZ0luZGljZXMuZmlsdGVyKChpbmRleCkgPT4gIWxheWVyTm9kZXMuaW5jbHVkZXMoaW5kZXgpKTtcbiAgICAgICAgICAgIGNvbnN0IHVuZXZlbkxheWVyID0gdW5ldmVuTGF5ZXJzLmZpbmQoKHsgaW5kZXggfSkgPT4gaW5kZXggPT09IGxheWVySW5kZXgpO1xuICAgICAgICAgICAgaWYgKHVuZXZlbkxheWVyICYmIGxheWVyTm9kZXMuaW5jbHVkZXModW5ldmVuTGF5ZXIubGVhdmVzQ291bnQgLSAxKSkge1xuICAgICAgICAgICAgICAgIHByb29mTm9kZUluZGljZXMgPSBwcm9vZk5vZGVJbmRpY2VzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb29mSW5kaWNlcy5wdXNoKHByb29mTm9kZUluZGljZXMpO1xuICAgICAgICAgICAgbGF5ZXJOb2RlcyA9IFsuLi5uZXcgU2V0KGxheWVyTm9kZXMubWFwKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggKyAxKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCAtIDEpIC8gMjtcbiAgICAgICAgICAgICAgICB9KSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9vZkluZGljZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldE11bHRpUHJvb2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBtdWx0aXByb29mIGZvciBnaXZlbiB0cmVlIGluZGljZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gaW5kaWNlcyAtIFRyZWUgaW5kaWNlcy5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJbXX0gLSBNdWx0aXByb29mc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGluZGljZXMgPSBbMiwgNSwgNl1cbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRNdWx0aVByb29mKGluZGljZXMpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRNdWx0aVByb29mKHRyZWUsIGluZGljZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEZvciBjb3JyZWN0IG11bHRpUHJvb2ZzIGl0XFwncyBzdHJvbmdseSByZWNvbW1lbmRlZCB0byBzZXQgY29tcGxldGU6IHRydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluZGljZXMpIHtcbiAgICAgICAgICAgIGluZGljZXMgPSB0cmVlO1xuICAgICAgICAgICAgdHJlZSA9IHRoaXMuZ2V0TGF5ZXJzRmxhdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzVW5ldmVuID0gdGhpcy5pc1VuZXZlblRyZWUoKTtcbiAgICAgICAgaWYgKGlzVW5ldmVuKSB7XG4gICAgICAgICAgICBpZiAoaW5kaWNlcy5ldmVyeShOdW1iZXIuaXNJbnRlZ2VyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE11bHRpUHJvb2ZGb3JVbmV2ZW5UcmVlKGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW5kaWNlcy5ldmVyeShOdW1iZXIuaXNJbnRlZ2VyKSkge1xuICAgICAgICAgICAgbGV0IGVscyA9IGluZGljZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3J0UGFpcnMpIHtcbiAgICAgICAgICAgICAgICBlbHMgPSBlbHMuc29ydChidWZmZXJfMS5CdWZmZXIuY29tcGFyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaWRzID0gZWxzLm1hcCgoZWwpID0+IHRoaXMuYnVmZmVySW5kZXhPZih0aGlzLmxlYXZlcywgZWwsIHRoaXMuc29ydExlYXZlcykpLnNvcnQoKGEsIGIpID0+IGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTEpO1xuICAgICAgICAgICAgaWYgKCFpZHMuZXZlcnkoKGlkeCkgPT4gaWR4ICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gTWVya2xlIHRyZWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc2hlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJvb2YgPSBbXTtcbiAgICAgICAgICAgIGxldCBuZXh0SWRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGlkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBpZHNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhaXJFbGVtZW50ID0gdGhpcy5nZXRQYWlyTm9kZShsYXllciwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVzLnB1c2gobGF5ZXJbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2YucHVzaChwYWlyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dElkcy5wdXNoKChpZHggLyAyKSB8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHMgPSBuZXh0SWRzLmZpbHRlcigodmFsdWUsIGksIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGkpO1xuICAgICAgICAgICAgICAgIG5leHRJZHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9vZi5maWx0ZXIoKHZhbHVlKSA9PiAhaGFzaGVzLmluY2x1ZGVzKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2ZJbmRpY2VzKGluZGljZXMsIE1hdGgubG9nMigodHJlZS5sZW5ndGggLyAyKSB8IDApKS5tYXAoaW5kZXggPT4gdHJlZVtpbmRleF0pO1xuICAgIH1cbiAgICBnZXRNdWx0aVByb29mRm9yVW5ldmVuVHJlZSh0cmVlLCBpbmRpY2VzKSB7XG4gICAgICAgIGlmICghaW5kaWNlcykge1xuICAgICAgICAgICAgaW5kaWNlcyA9IHRyZWU7XG4gICAgICAgICAgICB0cmVlID0gdGhpcy5nZXRMYXllcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvb2ZIYXNoZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRMYXllckluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgICBmb3IgKGNvbnN0IHRyZWVMYXllciBvZiB0cmVlKSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjdXJyZW50TGF5ZXJJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudExheWVySW5kaWNlcy5pbmNsdWRlcyhpZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZUxheWVyW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5wdXNoKHRyZWVMYXllcltpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBpbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXJJbmRpY2VzLmluY2x1ZGVzKGlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVMYXllcltpZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5wdXNoKHRyZWVMYXllcltpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvb2ZIYXNoZXMgPSBwcm9vZkhhc2hlcy5jb25jYXQoc2libGluZ3MpO1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlSW5kaWNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgY3VycmVudExheWVySW5kaWNlcykge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlSW5kaWNlcy5hZGQoaW5kZXggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlSW5kaWNlcy5hZGQoKGluZGV4ICsgMSkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZUluZGljZXMuYWRkKChpbmRleCAtIDEpIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGF5ZXJJbmRpY2VzID0gQXJyYXkuZnJvbSh1bmlxdWVJbmRpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvb2ZIYXNoZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldEhleE11bHRpUHJvb2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBtdWx0aXByb29mIGZvciBnaXZlbiB0cmVlIGluZGljZXMgYXMgaGV4IHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gaW5kaWNlcyAtIFRyZWUgaW5kaWNlcy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBNdWx0aXByb29mcyBhcyBoZXggc3RyaW5ncy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBpbmRpY2VzID0gWzIsIDUsIDZdXG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0SGV4TXVsdGlQcm9vZihpbmRpY2VzKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0SGV4TXVsdGlQcm9vZih0cmVlLCBpbmRpY2VzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE11bHRpUHJvb2YodHJlZSwgaW5kaWNlcykubWFwKCh4KSA9PiB0aGlzLmJ1ZmZlclRvSGV4KHgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0UHJvb2ZGbGFnc1xuICAgICAqIEBkZXNjIFJldHVybnMgbGlzdCBvZiBib29sZWFucyB3aGVyZSBwcm9vZnMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBoYXNoaW5nLlxuICAgICAqIFByb29mIGZsYWdzIGFyZSB1c2VkIGluIHRoZSBTb2xpZGl0eSBtdWx0aXByb29mIHZlcmlmaWVycy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfEJ1ZmZlcltdfSBsZWF2ZXNcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBwcm9vZnNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFuW119IC0gQm9vbGVhbiBmbGFnc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGluZGljZXMgPSBbMiwgNSwgNl1cbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRNdWx0aVByb29mKGluZGljZXMpXG4gICAgICpjb25zdCBwcm9vZkZsYWdzID0gdHJlZS5nZXRQcm9vZkZsYWdzKGxlYXZlcywgcHJvb2YpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRQcm9vZkZsYWdzKGxlYXZlcywgcHJvb2ZzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsZWF2ZXMpIHx8IGxlYXZlcy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElucHV0cyEnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWRzO1xuICAgICAgICBpZiAobGVhdmVzLmV2ZXJ5KE51bWJlci5pc0ludGVnZXIpKSB7XG4gICAgICAgICAgICBpZHMgPSBbLi4ubGVhdmVzXS5zb3J0KChhLCBiKSA9PiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xKTsgLy8gSW5kaWNlcyB3aGVyZSBwYXNzZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkcyA9IGxlYXZlcy5tYXAoKGVsKSA9PiB0aGlzLmJ1ZmZlckluZGV4T2YodGhpcy5sZWF2ZXMsIGVsLCB0aGlzLnNvcnRMZWF2ZXMpKS5zb3J0KChhLCBiKSA9PiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlkcy5ldmVyeSgoaWR4KSA9PiBpZHggIT09IC0xKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIE1lcmtsZSB0cmVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX3Byb29mcyA9IHByb29mcy5tYXAoaXRlbSA9PiB0aGlzLmJ1ZmZlcmlmeShpdGVtKSk7XG4gICAgICAgIGNvbnN0IHRlc3RlZCA9IFtdO1xuICAgICAgICBjb25zdCBmbGFncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5sYXllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzW2luZGV4XTtcbiAgICAgICAgICAgIGlkcyA9IGlkcy5yZWR1Y2UoKGlkcywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcHBlZCA9IHRlc3RlZC5pbmNsdWRlcyhsYXllcltpZHhdKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpckVsZW1lbnQgPSB0aGlzLmdldFBhaXJOb2RlKGxheWVyLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9vZlVzZWQgPSBfcHJvb2ZzLmluY2x1ZGVzKGxheWVyW2lkeF0pIHx8IF9wcm9vZnMuaW5jbHVkZXMocGFpckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBwYWlyRWxlbWVudCAmJiBmbGFncy5wdXNoKCFwcm9vZlVzZWQpO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0ZWQucHVzaChsYXllcltpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgdGVzdGVkLnB1c2gocGFpckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHMucHVzaCgoaWR4IC8gMikgfCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9vZiBwYXRoIChhcnJheSBvZiBoYXNoZXMpIGNhbiBjb25uZWN0IHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIHRvIHRoZSBNZXJrbGUgcm9vdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwcm9vZiAtIEFycmF5IG9mIHByb29mIG9iamVjdHMgdGhhdCBzaG91bGQgY29ubmVjdFxuICAgICAqIHRhcmdldCBub2RlIHRvIE1lcmtsZSByb290LlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSB0YXJnZXROb2RlIC0gVGFyZ2V0IG5vZGUgQnVmZmVyXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHJvb3QgLSBNZXJrbGUgcm9vdCBCdWZmZXJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3Qgcm9vdCA9IHRyZWUuZ2V0Um9vdCgpXG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UHJvb2YobGVhdmVzWzJdKVxuICAgICAqY29uc3QgdmVyaWZpZWQgPSB0cmVlLnZlcmlmeShwcm9vZiwgbGVhdmVzWzJdLCByb290KVxuICAgICAqYGBgXG4gICAgICovXG4gICAgdmVyaWZ5KHByb29mLCB0YXJnZXROb2RlLCByb290KSB7XG4gICAgICAgIGxldCBoYXNoID0gdGhpcy5idWZmZXJpZnkodGFyZ2V0Tm9kZSk7XG4gICAgICAgIHJvb3QgPSB0aGlzLmJ1ZmZlcmlmeShyb290KTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb29mKSB8fFxuICAgICAgICAgICAgIXRhcmdldE5vZGUgfHxcbiAgICAgICAgICAgICFyb290KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9vZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHByb29mW2ldO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGlzTGVmdE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgLy8gY2FzZSBmb3Igd2hlbiBwcm9vZiBpcyBoZXggdmFsdWVzIG9ubHlcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5idWZmZXJpZnkobm9kZSk7XG4gICAgICAgICAgICAgICAgaXNMZWZ0Tm9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0Tm9kZSA9IChub2RlWzBdID09PSAwKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5idWZmZXJpZnkobm9kZVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpc0xlZnROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5idWZmZXJpZnkobm9kZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBpc0xlZnROb2RlID0gKG5vZGUucG9zaXRpb24gPT09ICdsZWZ0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vZGUgdG8gYmUgb2YgdHlwZSBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5pc0JpdGNvaW5UcmVlKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKGJ1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdChoYXNoKSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyc1tpc0xlZnROb2RlID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQoZGF0YSkpO1xuICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihidWZmZXJzKSk7XG4gICAgICAgICAgICAgICAgaGFzaCA9IGJ1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdCh0aGlzLmhhc2hGbihoYXNoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3J0UGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKGhhc2gsIGRhdGEpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKGhhc2gsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGJ1ZmZlcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhLCBoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihidWZmZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyc1tpc0xlZnROb2RlID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGJ1ZmZlcnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKGhhc2gsIHJvb3QpID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB2ZXJpZnlNdWx0aVByb29mXG4gICAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIHRoZSBtdWx0aXByb29mcyBjYW4gY29ubmVjdCB0aGUgbGVhdmVzIHRvIHRoZSBNZXJrbGUgcm9vdC5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gcm9vdCAtIE1lcmtsZSB0cmVlIHJvb3RcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBwcm9vZkluZGljZXMgLSBMZWF2ZSBpbmRpY2VzIGZvciBwcm9vZlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IHByb29mTGVhdmVzIC0gTGVhZiB2YWx1ZXMgYXQgaW5kaWNlcyBmb3IgcHJvb2ZcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVhdmVzQ291bnQgLSBDb3VudCBvZiBvcmlnaW5hbCBsZWF2ZXNcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBwcm9vZiAtIE11bHRpcHJvb2ZzIGdpdmVuIGluZGljZXNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGVhdmVzID0gdHJlZS5nZXRMZWF2ZXMoKVxuICAgICAqY29uc3Qgcm9vdCA9IHRyZWUuZ2V0Um9vdCgpXG4gICAgICpjb25zdCB0cmVlRmxhdCA9IHRyZWUuZ2V0TGF5ZXJzRmxhdCgpXG4gICAgICpjb25zdCBsZWF2ZXNDb3VudCA9IGxlYXZlcy5sZW5ndGhcbiAgICAgKmNvbnN0IHByb29mSW5kaWNlcyA9IFsyLCA1LCA2XVxuICAgICAqY29uc3QgcHJvb2ZMZWF2ZXMgPSBwcm9vZkluZGljZXMubWFwKGkgPT4gbGVhdmVzW2ldKVxuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldE11bHRpUHJvb2YodHJlZUZsYXQsIGluZGljZXMpXG4gICAgICpjb25zdCB2ZXJpZmllZCA9IHRyZWUudmVyaWZ5TXVsdGlQcm9vZihyb290LCBwcm9vZkluZGljZXMsIHByb29mTGVhdmVzLCBsZWF2ZXNDb3VudCwgcHJvb2YpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB2ZXJpZnlNdWx0aVByb29mKHJvb3QsIHByb29mSW5kaWNlcywgcHJvb2ZMZWF2ZXMsIGxlYXZlc0NvdW50LCBwcm9vZikge1xuICAgICAgICBjb25zdCBpc1VuZXZlbiA9IHRoaXMuaXNVbmV2ZW5UcmVlKCk7XG4gICAgICAgIGlmIChpc1VuZXZlbikge1xuICAgICAgICAgICAgLy8gVE9ETzogY29tYmluZSB0aGVzZSBmdW5jdGlvbnMgYW5kIHNpbXBsaWZ5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlNdWx0aVByb29mRm9yVW5ldmVuVHJlZShyb290LCBwcm9vZkluZGljZXMsIHByb29mTGVhdmVzLCBsZWF2ZXNDb3VudCwgcHJvb2YpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlcHRoID0gTWF0aC5jZWlsKE1hdGgubG9nMihsZWF2ZXNDb3VudCkpO1xuICAgICAgICByb290ID0gdGhpcy5idWZmZXJpZnkocm9vdCk7XG4gICAgICAgIHByb29mTGVhdmVzID0gcHJvb2ZMZWF2ZXMubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJpZnkobGVhZikpO1xuICAgICAgICBwcm9vZiA9IHByb29mLm1hcChsZWFmID0+IHRoaXMuYnVmZmVyaWZ5KGxlYWYpKTtcbiAgICAgICAgY29uc3QgdHJlZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgbGVhZl0gb2YgdGhpcy56aXAocHJvb2ZJbmRpY2VzLCBwcm9vZkxlYXZlcykpIHtcbiAgICAgICAgICAgIHRyZWVbKE1hdGgucG93KDIsIGRlcHRoKSkgKyBpbmRleF0gPSBsZWFmO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBwcm9vZml0ZW1dIG9mIHRoaXMuemlwKHRoaXMuZ2V0UHJvb2ZJbmRpY2VzKHByb29mSW5kaWNlcywgZGVwdGgpLCBwcm9vZikpIHtcbiAgICAgICAgICAgIHRyZWVbaW5kZXhdID0gcHJvb2ZpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleHF1ZXVlID0gT2JqZWN0LmtleXModHJlZSkubWFwKHZhbHVlID0+ICt2YWx1ZSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBpbmRleHF1ZXVlID0gaW5kZXhxdWV1ZS5zbGljZSgwLCBpbmRleHF1ZXVlLmxlbmd0aCAtIDEpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXhxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhxdWV1ZVtpXTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAyICYmICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0cmVlLCBpbmRleCBeIDEpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhaXIgPSBbdHJlZVtpbmRleCAtIChpbmRleCAlIDIpXSwgdHJlZVtpbmRleCAtIChpbmRleCAlIDIpICsgMV1dO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvcnRQYWlycykge1xuICAgICAgICAgICAgICAgICAgICBwYWlyID0gcGFpci5zb3J0KGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHBhaXJbMV0gPyB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihwYWlyKSkgOiBwYWlyWzBdO1xuICAgICAgICAgICAgICAgIHRyZWVbKGluZGV4IC8gMikgfCAwXSA9IGhhc2g7XG4gICAgICAgICAgICAgICAgaW5kZXhxdWV1ZS5wdXNoKChpbmRleCAvIDIpIHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcm9vZkluZGljZXMubGVuZ3RoIHx8ICgoe30pLmhhc093blByb3BlcnR5LmNhbGwodHJlZSwgMSkgJiYgdHJlZVsxXS5lcXVhbHMocm9vdCkpO1xuICAgIH1cbiAgICB2ZXJpZnlNdWx0aVByb29mV2l0aEZsYWdzKHJvb3QsIGxlYXZlcywgcHJvb2ZzLCBwcm9vZkZsYWcpIHtcbiAgICAgICAgcm9vdCA9IHRoaXMuYnVmZmVyaWZ5KHJvb3QpO1xuICAgICAgICBsZWF2ZXMgPSBsZWF2ZXMubWFwKHRoaXMuYnVmZmVyaWZ5KTtcbiAgICAgICAgcHJvb2ZzID0gcHJvb2ZzLm1hcCh0aGlzLmJ1ZmZlcmlmeSk7XG4gICAgICAgIGNvbnN0IGxlYXZlc0xlbiA9IGxlYXZlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHRvdGFsSGFzaGVzID0gcHJvb2ZGbGFnLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaGFzaGVzID0gW107XG4gICAgICAgIGxldCBsZWFmUG9zID0gMDtcbiAgICAgICAgbGV0IGhhc2hQb3MgPSAwO1xuICAgICAgICBsZXQgcHJvb2ZQb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsSGFzaGVzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZkEgPSBwcm9vZkZsYWdbaV0gPyAobGVhZlBvcyA8IGxlYXZlc0xlbiA/IGxlYXZlc1tsZWFmUG9zKytdIDogaGFzaGVzW2hhc2hQb3MrK10pIDogcHJvb2ZzW3Byb29mUG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYnVmQiA9IGxlYWZQb3MgPCBsZWF2ZXNMZW4gPyBsZWF2ZXNbbGVhZlBvcysrXSA6IGhhc2hlc1toYXNoUG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVycyA9IFtidWZBLCBidWZCXS5zb3J0KGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgICAgIGhhc2hlc1tpXSA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGJ1ZmZlcnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUoaGFzaGVzW3RvdGFsSGFzaGVzIC0gMV0sIHJvb3QpID09PSAwO1xuICAgIH1cbiAgICB2ZXJpZnlNdWx0aVByb29mRm9yVW5ldmVuVHJlZShyb290LCBpbmRpY2VzLCBsZWF2ZXMsIGxlYXZlc0NvdW50LCBwcm9vZikge1xuICAgICAgICByb290ID0gdGhpcy5idWZmZXJpZnkocm9vdCk7XG4gICAgICAgIGxlYXZlcyA9IGxlYXZlcy5tYXAobGVhZiA9PiB0aGlzLmJ1ZmZlcmlmeShsZWFmKSk7XG4gICAgICAgIHByb29mID0gcHJvb2YubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJpZnkobGVhZikpO1xuICAgICAgICBjb25zdCBjb21wdXRlZFJvb3QgPSB0aGlzLmNhbGN1bGF0ZVJvb3RGb3JVbmV2ZW5UcmVlKGluZGljZXMsIGxlYXZlcywgbGVhdmVzQ291bnQsIHByb29mKTtcbiAgICAgICAgcmV0dXJuIHJvb3QuZXF1YWxzKGNvbXB1dGVkUm9vdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldERlcHRoXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgdHJlZSBkZXB0aCAobnVtYmVyIG9mIGxheWVycylcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBkZXB0aCA9IHRyZWUuZ2V0RGVwdGgoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0RGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVycygpLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExheWVyc0FzT2JqZWN0XG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgbGF5ZXJzIGFzIG5lc3RlZCBvYmplY3RzIGluc3RlYWQgb2YgYW4gYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsYXllcnNPYmogPSB0cmVlLmdldExheWVyc0FzT2JqZWN0KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldExheWVyc0FzT2JqZWN0KCkge1xuICAgICAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVycygpLm1hcCgobGF5ZXIpID0+IGxheWVyLm1hcCgodmFsdWUpID0+IHRoaXMuYnVmZmVyVG9IZXgodmFsdWUsIGZhbHNlKSkpO1xuICAgICAgICBjb25zdCBvYmpzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGF5ZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0geyBbbGF5ZXJzW2ldW2pdXTogbnVsbCB9O1xuICAgICAgICAgICAgICAgIGlmIChvYmpzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbbGF5ZXJzW2ldW2pdXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gb2Jqcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBha2V5ID0gT2JqZWN0LmtleXMoYSlbMF07XG4gICAgICAgICAgICAgICAgICAgIG9ialtsYXllcnNbaV1bal1dW2FrZXldID0gYVtha2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gb2Jqcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmtleSA9IE9iamVjdC5rZXlzKGIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2xheWVyc1tpXVtqXV1bYmtleV0gPSBiW2JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyci5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmpzLnB1c2goLi4uYXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Jqc1swXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9vZiBwYXRoIChhcnJheSBvZiBoYXNoZXMpIGNhbiBjb25uZWN0IHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIHRvIHRoZSBNZXJrbGUgcm9vdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwcm9vZiAtIEFycmF5IG9mIHByb29mIG9iamVjdHMgdGhhdCBzaG91bGQgY29ubmVjdFxuICAgICAqIHRhcmdldCBub2RlIHRvIE1lcmtsZSByb290LlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSB0YXJnZXROb2RlIC0gVGFyZ2V0IG5vZGUgQnVmZmVyXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHJvb3QgLSBNZXJrbGUgcm9vdCBCdWZmZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNoRnVuY3Rpb24gLSBIYXNoIGZ1bmN0aW9uIGZvciBoYXNoaW5nIGxlYXZlcyBhbmQgbm9kZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCB2ZXJpZmllZCA9IE1lcmtsZVRyZWUudmVyaWZ5KHByb29mLCBsZWFmLCByb290LCBzaGEyNTYsIG9wdGlvbnMpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgdmVyaWZ5KHByb29mLCB0YXJnZXROb2RlLCByb290LCBoYXNoRm4gPSBzaGEyNTZfMS5kZWZhdWx0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKFtdLCBoYXNoRm4sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdHJlZS52ZXJpZnkocHJvb2YsIHRhcmdldE5vZGUsIHJvb3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRNdWx0aVByb29mXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgbXVsdGlwcm9vZiBmb3IgZ2l2ZW4gdHJlZSBpbmRpY2VzLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IHRyZWUgLSBUcmVlIGFzIGEgZmxhdCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBpbmRpY2VzIC0gVHJlZSBpbmRpY2VzLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcltdfSAtIE11bHRpcHJvb2ZzXG4gICAgICpcbiAgICAgKkBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGZsYXRUcmVlID0gdHJlZS5nZXRMYXllcnNGbGF0KClcbiAgICAgKmNvbnN0IGluZGljZXMgPSBbMiwgNSwgNl1cbiAgICAgKmNvbnN0IHByb29mID0gTWVya2xlVHJlZS5nZXRNdWx0aVByb29mKGZsYXRUcmVlLCBpbmRpY2VzKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIGdldE11bHRpUHJvb2YodHJlZSwgaW5kaWNlcykge1xuICAgICAgICBjb25zdCB0ID0gbmV3IE1lcmtsZVRyZWUoW10pO1xuICAgICAgICByZXR1cm4gdC5nZXRNdWx0aVByb29mKHRyZWUsIGluZGljZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXNldFRyZWVcbiAgICAgKiBAZGVzYyBSZXNldHMgdGhlIHRyZWUgYnkgY2xlYXJpbmcgdGhlIGxlYXZlcyBhbmQgbGF5ZXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqdHJlZS5yZXNldFRyZWUoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcmVzZXRUcmVlKCkge1xuICAgICAgICB0aGlzLmxlYXZlcyA9IFtdO1xuICAgICAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQYWlyTm9kZVxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIG5vZGUgYXQgdGhlIGluZGV4IGZvciBnaXZlbiBsYXllci5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsYXllciAtIFRyZWUgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBhdCBsYXllci5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IC0gTm9kZVxuICAgICAqXG4gICAgICpAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBub2RlID0gdHJlZS5nZXRQYWlyTm9kZShsYXllciwgaW5kZXgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRQYWlyTm9kZShsYXllciwgaWR4KSB7XG4gICAgICAgIGNvbnN0IHBhaXJJZHggPSBpZHggJSAyID09PSAwID8gaWR4ICsgMSA6IGlkeCAtIDE7XG4gICAgICAgIGlmIChwYWlySWR4IDwgbGF5ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXJbcGFpcklkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0b1RyZWVTdHJpbmdcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXJrbGUgdHJlZSBhcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zb2xlLmxvZyh0cmVlLnRvVHJlZVN0cmluZygpKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgdG9UcmVlU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmdldExheWVyc0FzT2JqZWN0KCk7XG4gICAgICAgIHJldHVybiB0cmVlaWZ5XzEuZGVmYXVsdC5hc1RyZWUob2JqLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdG9TdHJpbmdcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXJrbGUgdHJlZSBhcyBhIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnNvbGUubG9nKHRyZWUudG9TdHJpbmcoKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1RyZWVTdHJpbmcoKTtcbiAgICB9XG4gICAgaXNVbmV2ZW5UcmVlKHRyZWVMYXllcnMpIHtcbiAgICAgICAgY29uc3QgZGVwdGggPSAodHJlZUxheWVycyA9PT0gbnVsbCB8fCB0cmVlTGF5ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmVlTGF5ZXJzLmxlbmd0aCkgfHwgdGhpcy5nZXREZXB0aCgpO1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNQb3dPZjIoZGVwdGgpO1xuICAgIH1cbiAgICBpc1Bvd09mMih2KSB7XG4gICAgICAgIHJldHVybiB2ICYmICEodiAmICh2IC0gMSkpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVSb290Rm9yVW5ldmVuVHJlZShsZWFmSW5kaWNlcywgbGVhZkhhc2hlcywgdG90YWxMZWF2ZXNDb3VudCwgcHJvb2ZIYXNoZXMpIHtcbiAgICAgICAgY29uc3QgbGVhZlR1cGxlcyA9IHRoaXMuemlwKGxlYWZJbmRpY2VzLCBsZWFmSGFzaGVzKS5zb3J0KChbaW5kZXhBXSwgW2luZGV4Ql0pID0+IGluZGV4QSAtIGluZGV4Qik7XG4gICAgICAgIGNvbnN0IGxlYWZUdXBsZUluZGljZXMgPSBsZWFmVHVwbGVzLm1hcCgoW2luZGV4XSkgPT4gaW5kZXgpO1xuICAgICAgICBjb25zdCBwcm9vZkluZGljZXMgPSB0aGlzLmdldFByb29mSW5kaWNlc0ZvclVuZXZlblRyZWUobGVhZlR1cGxlSW5kaWNlcywgdG90YWxMZWF2ZXNDb3VudCk7XG4gICAgICAgIGxldCBuZXh0U2xpY2VTdGFydCA9IDA7XG4gICAgICAgIGNvbnN0IHByb29mVHVwbGVzQnlMYXllcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9vZkluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBwcm9vZkluZGljZXNbaV07XG4gICAgICAgICAgICBjb25zdCBzbGljZVN0YXJ0ID0gbmV4dFNsaWNlU3RhcnQ7XG4gICAgICAgICAgICBuZXh0U2xpY2VTdGFydCArPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHByb29mVHVwbGVzQnlMYXllcnNbaV0gPSB0aGlzLnppcChpbmRpY2VzLCBwcm9vZkhhc2hlcy5zbGljZShzbGljZVN0YXJ0LCBuZXh0U2xpY2VTdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyZWUgPSBbbGVhZlR1cGxlc107XG4gICAgICAgIGZvciAobGV0IGxheWVySW5kZXggPSAwOyBsYXllckluZGV4IDwgcHJvb2ZUdXBsZXNCeUxheWVycy5sZW5ndGg7IGxheWVySW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudExheWVyID0gcHJvb2ZUdXBsZXNCeUxheWVyc1tsYXllckluZGV4XS5jb25jYXQodHJlZVtsYXllckluZGV4XSkuc29ydCgoW2luZGV4QV0sIFtpbmRleEJdKSA9PiBpbmRleEEgLSBpbmRleEIpXG4gICAgICAgICAgICAgICAgLm1hcCgoWywgaGFzaF0pID0+IGhhc2gpO1xuICAgICAgICAgICAgY29uc3QgcyA9IHRyZWVbbGF5ZXJJbmRleF0ubWFwKChbbGF5ZXJJbmRleF0pID0+IGxheWVySW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SW5kaWNlcyA9IFsuLi5uZXcgU2V0KHMubWFwKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggKyAxKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCAtIDEpIC8gMjtcbiAgICAgICAgICAgICAgICB9KSldO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TGF5ZXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50SW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGVUcmVlSW5kZXggPSBwYXJlbnRJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZkEgPSBjdXJyZW50TGF5ZXJbaSAqIDJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZkIgPSBjdXJyZW50TGF5ZXJbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gYnVmQiA/IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKFtidWZBLCBidWZCXSkpIDogYnVmQTtcbiAgICAgICAgICAgICAgICBwYXJlbnRMYXllci5wdXNoKFtwYXJlbnROb2RlVHJlZUluZGV4LCBoYXNoXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlLnB1c2gocGFyZW50TGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlW3RyZWUubGVuZ3RoIC0gMV1bMF1bMV07XG4gICAgfVxufVxuZXhwb3J0cy5NZXJrbGVUcmVlID0gTWVya2xlVHJlZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIDtcbiAgICB3aW5kb3cuTWVya2xlVHJlZSA9IE1lcmtsZVRyZWU7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNZXJrbGVUcmVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/MerkleTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/merkletreejs/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MerkleTree = void 0;\nconst MerkleTree_1 = __importDefault(__webpack_require__(/*! ./MerkleTree */ \"(ssr)/./node_modules/merkletreejs/dist/MerkleTree.js\"));\nexports.MerkleTree = MerkleTree_1.default;\nvar MerkleMountainRange_1 = __webpack_require__(/*! ./MerkleMountainRange */ \"(ssr)/./node_modules/merkletreejs/dist/MerkleMountainRange.js\");\nObject.defineProperty(exports, \"MerkleMountainRange\", ({ enumerable: true, get: function () { return MerkleMountainRange_1.MerkleMountainRange; } }));\nvar IncrementalMerkleTree_1 = __webpack_require__(/*! ./IncrementalMerkleTree */ \"(ssr)/./node_modules/merkletreejs/dist/IncrementalMerkleTree.js\");\nObject.defineProperty(exports, \"IncrementalMerkleTree\", ({ enumerable: true, get: function () { return IncrementalMerkleTree_1.IncrementalMerkleTree; } }));\nvar MerkleSumTree_1 = __webpack_require__(/*! ./MerkleSumTree */ \"(ssr)/./node_modules/merkletreejs/dist/MerkleSumTree.js\");\nObject.defineProperty(exports, \"MerkleSumTree\", ({ enumerable: true, get: function () { return MerkleSumTree_1.MerkleSumTree; } }));\nexports[\"default\"] = MerkleTree_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIscUNBQXFDLG1CQUFPLENBQUMsMEVBQWM7QUFDM0Qsa0JBQWtCO0FBQ2xCLDRCQUE0QixtQkFBTyxDQUFDLDRGQUF1QjtBQUMzRCx1REFBc0QsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDbkosOEJBQThCLG1CQUFPLENBQUMsZ0dBQXlCO0FBQy9ELHlEQUF3RCxFQUFFLHFDQUFxQyx5REFBeUQsRUFBQztBQUN6SixzQkFBc0IsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDL0MsaURBQWdELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2pJLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L2luZGV4LmpzPzE2NjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lcmtsZVRyZWUgPSB2b2lkIDA7XG5jb25zdCBNZXJrbGVUcmVlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTWVya2xlVHJlZVwiKSk7XG5leHBvcnRzLk1lcmtsZVRyZWUgPSBNZXJrbGVUcmVlXzEuZGVmYXVsdDtcbnZhciBNZXJrbGVNb3VudGFpblJhbmdlXzEgPSByZXF1aXJlKFwiLi9NZXJrbGVNb3VudGFpblJhbmdlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVya2xlTW91bnRhaW5SYW5nZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWVya2xlTW91bnRhaW5SYW5nZV8xLk1lcmtsZU1vdW50YWluUmFuZ2U7IH0gfSk7XG52YXIgSW5jcmVtZW50YWxNZXJrbGVUcmVlXzEgPSByZXF1aXJlKFwiLi9JbmNyZW1lbnRhbE1lcmtsZVRyZWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmNyZW1lbnRhbE1lcmtsZVRyZWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEluY3JlbWVudGFsTWVya2xlVHJlZV8xLkluY3JlbWVudGFsTWVya2xlVHJlZTsgfSB9KTtcbnZhciBNZXJrbGVTdW1UcmVlXzEgPSByZXF1aXJlKFwiLi9NZXJrbGVTdW1UcmVlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVya2xlU3VtVHJlZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWVya2xlU3VtVHJlZV8xLk1lcmtsZVN1bVRyZWU7IH0gfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBNZXJrbGVUcmVlXzEuZGVmYXVsdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/index.js\n");

/***/ })

};
;