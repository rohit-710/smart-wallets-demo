"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/multiaddr";
exports.ids = ["vendor-chunks/multiaddr"];
exports.modules = {

/***/ "(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/alloc.js":
/*!**************************************************************************!*\
  !*** ./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/alloc.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar asUint8array = __webpack_require__(/*! ./util/as-uint8array.js */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/as-uint8array.js\");\n\nfunction alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return asUint8array.asUint8Array(globalThis.Buffer.alloc(size));\n  }\n  return new Uint8Array(size);\n}\nfunction allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return asUint8array.asUint8Array(globalThis.Buffer.allocUnsafe(size));\n  }\n  return new Uint8Array(size);\n}\n\nexports.alloc = alloc;\nexports.allocUnsafe = allocUnsafe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL2FsbG9jLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsbUJBQW1CLG1CQUFPLENBQUMsc0hBQXlCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Nqcy9zcmMvYWxsb2MuanM/Yjk5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBhc1VpbnQ4YXJyYXkgPSByZXF1aXJlKCcuL3V0aWwvYXMtdWludDhhcnJheS5qcycpO1xuXG5mdW5jdGlvbiBhbGxvYyhzaXplID0gMCkge1xuICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvYyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFzVWludDhhcnJheS5hc1VpbnQ4QXJyYXkoZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2Moc2l6ZSkpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn1cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUgPSAwKSB7XG4gIGlmIChnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYXNVaW50OGFycmF5LmFzVWludDhBcnJheShnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xufVxuXG5leHBvcnRzLmFsbG9jID0gYWxsb2M7XG5leHBvcnRzLmFsbG9jVW5zYWZlID0gYWxsb2NVbnNhZmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/alloc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/concat.js":
/*!***************************************************************************!*\
  !*** ./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/concat.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar alloc = __webpack_require__(/*! ./alloc.js */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/alloc.js\");\nvar asUint8array = __webpack_require__(/*! ./util/as-uint8array.js */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/as-uint8array.js\");\n\nfunction concat(arrays, length) {\n  if (!length) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n  }\n  const output = alloc.allocUnsafe(length);\n  let offset = 0;\n  for (const arr of arrays) {\n    output.set(arr, offset);\n    offset += arr.length;\n  }\n  return asUint8array.asUint8Array(output);\n}\n\nexports.concat = concat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL2NvbmNhdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFlBQVksbUJBQU8sQ0FBQyw0RkFBWTtBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyxzSEFBeUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL211bHRpYWRkci9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvY2pzL3NyYy9jb25jYXQuanM/NmViZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBhbGxvYyA9IHJlcXVpcmUoJy4vYWxsb2MuanMnKTtcbnZhciBhc1VpbnQ4YXJyYXkgPSByZXF1aXJlKCcuL3V0aWwvYXMtdWludDhhcnJheS5qcycpO1xuXG5mdW5jdGlvbiBjb25jYXQoYXJyYXlzLCBsZW5ndGgpIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIubGVuZ3RoLCAwKTtcbiAgfVxuICBjb25zdCBvdXRwdXQgPSBhbGxvYy5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGFzVWludDhhcnJheS5hc1VpbnQ4QXJyYXkob3V0cHV0KTtcbn1cblxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/concat.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/equals.js":
/*!***************************************************************************!*\
  !*** ./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/equals.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.equals = equals;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL2VxdWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Nqcy9zcmMvZXF1YWxzLmpzPzAzZWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/equals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/from-string.js":
/*!********************************************************************************!*\
  !*** ./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/from-string.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar bases = __webpack_require__(/*! ./util/bases.js */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/bases.js\");\nvar asUint8array = __webpack_require__(/*! ./util/as-uint8array.js */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/as-uint8array.js\");\n\nfunction fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return asUint8array.asUint8Array(globalThis.Buffer.from(string, 'utf-8'));\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}\n\nexports.fromString = fromString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL2Zyb20tc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsWUFBWSxtQkFBTyxDQUFDLHNHQUFpQjtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyxzSEFBeUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsR0FBRyxRQUFRO0FBQ3pEOztBQUVBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Nqcy9zcmMvZnJvbS1zdHJpbmcuanM/NDQyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlcyA9IHJlcXVpcmUoJy4vdXRpbC9iYXNlcy5qcycpO1xudmFyIGFzVWludDhhcnJheSA9IHJlcXVpcmUoJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJyk7XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBjb25zdCBiYXNlID0gYmFzZXNbZW5jb2RpbmddO1xuICBpZiAoIWJhc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHsgZW5jb2RpbmcgfVwiYCk7XG4gIH1cbiAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20gIT0gbnVsbCkge1xuICAgIHJldHVybiBhc1VpbnQ4YXJyYXkuYXNVaW50OEFycmF5KGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oc3RyaW5nLCAndXRmLTgnKSk7XG4gIH1cbiAgcmV0dXJuIGJhc2UuZGVjb2Rlci5kZWNvZGUoYCR7IGJhc2UucHJlZml4IH0keyBzdHJpbmcgfWApO1xufVxuXG5leHBvcnRzLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/to-string.js":
/*!******************************************************************************!*\
  !*** ./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/to-string.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar bases = __webpack_require__(/*! ./util/bases.js */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/bases.js\");\n\nfunction toString(array, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');\n  }\n  return base.encoder.encode(array).substring(1);\n}\n\nexports.toString = toString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL3RvLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFlBQVksbUJBQU8sQ0FBQyxzR0FBaUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL3RvLXN0cmluZy5qcz9jOTM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJhc2VzID0gcmVxdWlyZSgnLi91dGlsL2Jhc2VzLmpzJyk7XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKGFycmF5LCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBjb25zdCBiYXNlID0gYmFzZXNbZW5jb2RpbmddO1xuICBpZiAoIWJhc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHsgZW5jb2RpbmcgfVwiYCk7XG4gIH1cbiAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20gIT0gbnVsbCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gYmFzZS5lbmNvZGVyLmVuY29kZShhcnJheSkuc3Vic3RyaW5nKDEpO1xufVxuXG5leHBvcnRzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/to-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/as-uint8array.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/as-uint8array.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction asUint8Array(buf) {\n  if (globalThis.Buffer != null) {\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n  return buf;\n}\n\nexports.asUint8Array = asUint8Array;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL3V0aWwvYXMtdWludDhhcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL3V0aWwvYXMtdWludDhhcnJheS5qcz80ZmJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gYXNVaW50OEFycmF5KGJ1Zikge1xuICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmV4cG9ydHMuYXNVaW50OEFycmF5ID0gYXNVaW50OEFycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/as-uint8array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/bases.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/bases.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar basics = __webpack_require__(/*! multiformats/basics */ \"(ssr)/./node_modules/multiformats/cjs/src/basics.js\");\nvar alloc = __webpack_require__(/*! ../alloc.js */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/alloc.js\");\n\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = alloc.allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: basics.bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...basics.bases\n};\n\nmodule.exports = BASES;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL3V0aWwvYmFzZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGdGQUFxQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsNkZBQWE7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Nqcy9zcmMvdXRpbC9iYXNlcy5qcz9kMTc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJhc2ljcyA9IHJlcXVpcmUoJ211bHRpZm9ybWF0cy9iYXNpY3MnKTtcbnZhciBhbGxvYyA9IHJlcXVpcmUoJy4uL2FsbG9jLmpzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjKG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHByZWZpeCxcbiAgICBlbmNvZGVyOiB7XG4gICAgICBuYW1lLFxuICAgICAgcHJlZml4LFxuICAgICAgZW5jb2RlXG4gICAgfSxcbiAgICBkZWNvZGVyOiB7IGRlY29kZSB9XG4gIH07XG59XG5jb25zdCBzdHJpbmcgPSBjcmVhdGVDb2RlYygndXRmOCcsICd1JywgYnVmID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICByZXR1cm4gJ3UnICsgZGVjb2Rlci5kZWNvZGUoYnVmKTtcbn0sIHN0ciA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0ci5zdWJzdHJpbmcoMSkpO1xufSk7XG5jb25zdCBhc2NpaSA9IGNyZWF0ZUNvZGVjKCdhc2NpaScsICdhJywgYnVmID0+IHtcbiAgbGV0IHN0cmluZyA9ICdhJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59LCBzdHIgPT4ge1xuICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICBjb25zdCBidWYgPSBhbGxvYy5hbGxvY1Vuc2FmZShzdHIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufSk7XG5jb25zdCBCQVNFUyA9IHtcbiAgdXRmODogc3RyaW5nLFxuICAndXRmLTgnOiBzdHJpbmcsXG4gIGhleDogYmFzaWNzLmJhc2VzLmJhc2UxNixcbiAgbGF0aW4xOiBhc2NpaSxcbiAgYXNjaWk6IGFzY2lpLFxuICBiaW5hcnk6IGFzY2lpLFxuICAuLi5iYXNpY3MuYmFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQkFTRVM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/util/bases.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/src/codec.js":
/*!*********************************************!*\
  !*** ./node_modules/multiaddr/src/codec.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst convert = __webpack_require__(/*! ./convert */ \"(ssr)/./node_modules/multiaddr/src/convert.js\")\nconst protocols = __webpack_require__(/*! ./protocols-table */ \"(ssr)/./node_modules/multiaddr/src/protocols-table.js\")\nconst varint = __webpack_require__(/*! varint */ \"(ssr)/./node_modules/varint/index.js\")\nconst { concat: uint8ArrayConcat } = __webpack_require__(/*! uint8arrays/concat */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/concat.js\")\nconst { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/to-string.js\")\n\n// export codec\nmodule.exports = {\n  stringToStringTuples,\n  stringTuplesToString,\n\n  tuplesToStringTuples,\n  stringTuplesToTuples,\n\n  bytesToTuples,\n  tuplesToBytes,\n\n  bytesToString,\n  stringToBytes,\n\n  fromString,\n  fromBytes,\n  validateBytes,\n  isValidBytes,\n  cleanPath,\n\n  ParseError,\n  protoFromTuple,\n\n  sizeForAddr\n}\n\n// string -> [[str name, str addr]... ]\n/**\n * @param {string} str\n */\nfunction stringToStringTuples (str) {\n  const tuples = []\n  const parts = str.split('/').slice(1) // skip first empty elem\n  if (parts.length === 1 && parts[0] === '') {\n    return []\n  }\n\n  for (let p = 0; p < parts.length; p++) {\n    const part = parts[p]\n    const proto = protocols(part)\n\n    if (proto.size === 0) {\n      tuples.push([part])\n      continue\n    }\n\n    p++ // advance addr part\n    if (p >= parts.length) {\n      throw ParseError('invalid address: ' + str)\n    }\n\n    // if it's a path proto, take the rest\n    if (proto.path) {\n      tuples.push([\n        part,\n        // TODO: should we need to check each path part to see if it's a proto?\n        // This would allow for other protocols to be added after a unix path,\n        // however it would have issues if the path had a protocol name in the path\n        cleanPath(parts.slice(p).join('/'))\n      ])\n      break\n    }\n\n    tuples.push([part, parts[p]])\n  }\n\n  return tuples\n}\n\n// [[str name, str addr]... ] -> string\n/**\n * @param {[number, string?][]} tuples\n */\nfunction stringTuplesToString (tuples) {\n  /** @type {Array<string | undefined>} */\n  const parts = []\n  tuples.map((tup) => {\n    const proto = protoFromTuple(tup)\n    parts.push(proto.name)\n    if (tup.length > 1) {\n      parts.push(tup[1])\n    }\n    return null\n  })\n\n  return cleanPath(parts.join('/'))\n}\n\n// [[str name, str addr]... ] -> [[int code, Uint8Array]... ]\n/**\n * @param {Array<string[] | string >} tuples\n * @returns {[number , Uint8Array?][]}\n */\nfunction stringTuplesToTuples (tuples) {\n  return tuples.map((tup) => {\n    if (!Array.isArray(tup)) {\n      tup = [tup]\n    }\n    const proto = protoFromTuple(tup)\n    if (tup.length > 1) {\n      return [proto.code, convert.toBytes(proto.code, tup[1])]\n    }\n    return [proto.code]\n  })\n}\n\n/**\n * Convert tuples to string tuples\n *\n * [[int code, Uint8Array]... ] -> [[int code, str addr]... ]\n *\n * @param {Array<[number, Uint8Array?]>} tuples\n * @returns {Array<[number, string?]>}\n */\n\nfunction tuplesToStringTuples (tuples) {\n  return tuples.map(tup => {\n    const proto = protoFromTuple(tup)\n    if (tup[1]) {\n      return [proto.code, convert.toString(proto.code, tup[1])]\n    }\n    return [proto.code]\n  })\n}\n\n// [[int code, Uint8Array ]... ] -> Uint8Array\n/**\n * @param {[number, Uint8Array?][]} tuples\n */\nfunction tuplesToBytes (tuples) {\n  return fromBytes(uint8ArrayConcat(tuples.map((/** @type {any[]} */ tup) => {\n    const proto = protoFromTuple(tup)\n    let buf = Uint8Array.from(varint.encode(proto.code))\n\n    if (tup.length > 1) {\n      buf = uint8ArrayConcat([buf, tup[1]]) // add address buffer\n    }\n\n    return buf\n  })))\n}\n\n/**\n * @param {import(\"./types\").Protocol} p\n * @param {Uint8Array | number[]} addr\n */\nfunction sizeForAddr (p, addr) {\n  if (p.size > 0) {\n    return p.size / 8\n  } else if (p.size === 0) {\n    return 0\n  } else {\n    const size = varint.decode(addr)\n    return size + varint.decode.bytes\n  }\n}\n\n/**\n *\n * @param {Uint8Array} buf\n * @returns {Array<[number, Uint8Array?]>}\n */\nfunction bytesToTuples (buf) {\n  /** @type {Array<[number, Uint8Array?]>} */\n  const tuples = []\n  let i = 0\n  while (i < buf.length) {\n    const code = varint.decode(buf, i)\n    const n = varint.decode.bytes\n\n    const p = protocols(code)\n\n    const size = sizeForAddr(p, buf.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      i += n\n      continue\n    }\n\n    const addr = buf.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > buf.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n  }\n\n  return tuples\n}\n\n// Uint8Array -> String\n/**\n * @param {Uint8Array} buf\n */\nfunction bytesToString (buf) {\n  const a = bytesToTuples(buf)\n  const b = tuplesToStringTuples(a)\n  return stringTuplesToString(b)\n}\n\n// String -> Uint8Array\n/**\n * @param {string} str\n */\nfunction stringToBytes (str) {\n  str = cleanPath(str)\n  const a = stringToStringTuples(str)\n  const b = stringTuplesToTuples(a)\n\n  return tuplesToBytes(b)\n}\n\n// String -> Uint8Array\n/**\n * @param {string} str\n */\nfunction fromString (str) {\n  return stringToBytes(str)\n}\n\n// Uint8Array -> Uint8Array\n/**\n * @param {Uint8Array} buf\n */\nfunction fromBytes (buf) {\n  const err = validateBytes(buf)\n  if (err) throw err\n  return Uint8Array.from(buf) // copy\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction validateBytes (buf) {\n  try {\n    bytesToTuples(buf) // try to parse. will throw if breaks\n  } catch (err) {\n    return err\n  }\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction isValidBytes (buf) {\n  return validateBytes(buf) === undefined\n}\n\n/**\n * @param {string} str\n */\nfunction cleanPath (str) {\n  return '/' + str.trim().split('/').filter((/** @type {any} */ a) => a).join('/')\n}\n\n/**\n * @param {string} str\n */\nfunction ParseError (str) {\n  return new Error('Error parsing address: ' + str)\n}\n\n/**\n * @param {any[]} tup\n */\nfunction protoFromTuple (tup) {\n  const proto = protocols(tup[0])\n  return proto\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL3NyYy9jb2RlYy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBVztBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxxR0FBb0I7QUFDakUsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLDJHQUF1Qjs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0EsMkRBQTJELE9BQU87QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL211bHRpYWRkci9zcmMvY29kZWMuanM/YTdjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29udmVydCA9IHJlcXVpcmUoJy4vY29udmVydCcpXG5jb25zdCBwcm90b2NvbHMgPSByZXF1aXJlKCcuL3Byb3RvY29scy10YWJsZScpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgeyBjb25jYXQ6IHVpbnQ4QXJyYXlDb25jYXQgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5jb25zdCB7IHRvU3RyaW5nOiB1aW50OEFycmF5VG9TdHJpbmcgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZycpXG5cbi8vIGV4cG9ydCBjb2RlY1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZ1RvU3RyaW5nVHVwbGVzLFxuICBzdHJpbmdUdXBsZXNUb1N0cmluZyxcblxuICB0dXBsZXNUb1N0cmluZ1R1cGxlcyxcbiAgc3RyaW5nVHVwbGVzVG9UdXBsZXMsXG5cbiAgYnl0ZXNUb1R1cGxlcyxcbiAgdHVwbGVzVG9CeXRlcyxcblxuICBieXRlc1RvU3RyaW5nLFxuICBzdHJpbmdUb0J5dGVzLFxuXG4gIGZyb21TdHJpbmcsXG4gIGZyb21CeXRlcyxcbiAgdmFsaWRhdGVCeXRlcyxcbiAgaXNWYWxpZEJ5dGVzLFxuICBjbGVhblBhdGgsXG5cbiAgUGFyc2VFcnJvcixcbiAgcHJvdG9Gcm9tVHVwbGUsXG5cbiAgc2l6ZUZvckFkZHJcbn1cblxuLy8gc3RyaW5nIC0+IFtbc3RyIG5hbWUsIHN0ciBhZGRyXS4uLiBdXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9TdHJpbmdUdXBsZXMgKHN0cikge1xuICBjb25zdCB0dXBsZXMgPSBbXVxuICBjb25zdCBwYXJ0cyA9IHN0ci5zcGxpdCgnLycpLnNsaWNlKDEpIC8vIHNraXAgZmlyc3QgZW1wdHkgZWxlbVxuICBpZiAocGFydHMubGVuZ3RoID09PSAxICYmIHBhcnRzWzBdID09PSAnJykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXJ0cy5sZW5ndGg7IHArKykge1xuICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1twXVxuICAgIGNvbnN0IHByb3RvID0gcHJvdG9jb2xzKHBhcnQpXG5cbiAgICBpZiAocHJvdG8uc2l6ZSA9PT0gMCkge1xuICAgICAgdHVwbGVzLnB1c2goW3BhcnRdKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBwKysgLy8gYWR2YW5jZSBhZGRyIHBhcnRcbiAgICBpZiAocCA+PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IFBhcnNlRXJyb3IoJ2ludmFsaWQgYWRkcmVzczogJyArIHN0cilcbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIGEgcGF0aCBwcm90bywgdGFrZSB0aGUgcmVzdFxuICAgIGlmIChwcm90by5wYXRoKSB7XG4gICAgICB0dXBsZXMucHVzaChbXG4gICAgICAgIHBhcnQsXG4gICAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBuZWVkIHRvIGNoZWNrIGVhY2ggcGF0aCBwYXJ0IHRvIHNlZSBpZiBpdCdzIGEgcHJvdG8/XG4gICAgICAgIC8vIFRoaXMgd291bGQgYWxsb3cgZm9yIG90aGVyIHByb3RvY29scyB0byBiZSBhZGRlZCBhZnRlciBhIHVuaXggcGF0aCxcbiAgICAgICAgLy8gaG93ZXZlciBpdCB3b3VsZCBoYXZlIGlzc3VlcyBpZiB0aGUgcGF0aCBoYWQgYSBwcm90b2NvbCBuYW1lIGluIHRoZSBwYXRoXG4gICAgICAgIGNsZWFuUGF0aChwYXJ0cy5zbGljZShwKS5qb2luKCcvJykpXG4gICAgICBdKVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0dXBsZXMucHVzaChbcGFydCwgcGFydHNbcF1dKVxuICB9XG5cbiAgcmV0dXJuIHR1cGxlc1xufVxuXG4vLyBbW3N0ciBuYW1lLCBzdHIgYWRkcl0uLi4gXSAtPiBzdHJpbmdcbi8qKlxuICogQHBhcmFtIHtbbnVtYmVyLCBzdHJpbmc/XVtdfSB0dXBsZXNcbiAqL1xuZnVuY3Rpb24gc3RyaW5nVHVwbGVzVG9TdHJpbmcgKHR1cGxlcykge1xuICAvKiogQHR5cGUge0FycmF5PHN0cmluZyB8IHVuZGVmaW5lZD59ICovXG4gIGNvbnN0IHBhcnRzID0gW11cbiAgdHVwbGVzLm1hcCgodHVwKSA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBwcm90b0Zyb21UdXBsZSh0dXApXG4gICAgcGFydHMucHVzaChwcm90by5uYW1lKVxuICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xuICAgICAgcGFydHMucHVzaCh0dXBbMV0pXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0pXG5cbiAgcmV0dXJuIGNsZWFuUGF0aChwYXJ0cy5qb2luKCcvJykpXG59XG5cbi8vIFtbc3RyIG5hbWUsIHN0ciBhZGRyXS4uLiBdIC0+IFtbaW50IGNvZGUsIFVpbnQ4QXJyYXldLi4uIF1cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmdbXSB8IHN0cmluZyA+fSB0dXBsZXNcbiAqIEByZXR1cm5zIHtbbnVtYmVyICwgVWludDhBcnJheT9dW119XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1R1cGxlc1RvVHVwbGVzICh0dXBsZXMpIHtcbiAgcmV0dXJuIHR1cGxlcy5tYXAoKHR1cCkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0dXApKSB7XG4gICAgICB0dXAgPSBbdHVwXVxuICAgIH1cbiAgICBjb25zdCBwcm90byA9IHByb3RvRnJvbVR1cGxlKHR1cClcbiAgICBpZiAodHVwLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBbcHJvdG8uY29kZSwgY29udmVydC50b0J5dGVzKHByb3RvLmNvZGUsIHR1cFsxXSldXG4gICAgfVxuICAgIHJldHVybiBbcHJvdG8uY29kZV1cbiAgfSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHR1cGxlcyB0byBzdHJpbmcgdHVwbGVzXG4gKlxuICogW1tpbnQgY29kZSwgVWludDhBcnJheV0uLi4gXSAtPiBbW2ludCBjb2RlLCBzdHIgYWRkcl0uLi4gXVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8W251bWJlciwgVWludDhBcnJheT9dPn0gdHVwbGVzXG4gKiBAcmV0dXJucyB7QXJyYXk8W251bWJlciwgc3RyaW5nP10+fVxuICovXG5cbmZ1bmN0aW9uIHR1cGxlc1RvU3RyaW5nVHVwbGVzICh0dXBsZXMpIHtcbiAgcmV0dXJuIHR1cGxlcy5tYXAodHVwID0+IHtcbiAgICBjb25zdCBwcm90byA9IHByb3RvRnJvbVR1cGxlKHR1cClcbiAgICBpZiAodHVwWzFdKSB7XG4gICAgICByZXR1cm4gW3Byb3RvLmNvZGUsIGNvbnZlcnQudG9TdHJpbmcocHJvdG8uY29kZSwgdHVwWzFdKV1cbiAgICB9XG4gICAgcmV0dXJuIFtwcm90by5jb2RlXVxuICB9KVxufVxuXG4vLyBbW2ludCBjb2RlLCBVaW50OEFycmF5IF0uLi4gXSAtPiBVaW50OEFycmF5XG4vKipcbiAqIEBwYXJhbSB7W251bWJlciwgVWludDhBcnJheT9dW119IHR1cGxlc1xuICovXG5mdW5jdGlvbiB0dXBsZXNUb0J5dGVzICh0dXBsZXMpIHtcbiAgcmV0dXJuIGZyb21CeXRlcyh1aW50OEFycmF5Q29uY2F0KHR1cGxlcy5tYXAoKC8qKiBAdHlwZSB7YW55W119ICovIHR1cCkgPT4ge1xuICAgIGNvbnN0IHByb3RvID0gcHJvdG9Gcm9tVHVwbGUodHVwKVxuICAgIGxldCBidWYgPSBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZShwcm90by5jb2RlKSlcblxuICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xuICAgICAgYnVmID0gdWludDhBcnJheUNvbmNhdChbYnVmLCB0dXBbMV1dKSAvLyBhZGQgYWRkcmVzcyBidWZmZXJcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmXG4gIH0pKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdHlwZXNcIikuUHJvdG9jb2x9IHBcbiAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bWJlcltdfSBhZGRyXG4gKi9cbmZ1bmN0aW9uIHNpemVGb3JBZGRyIChwLCBhZGRyKSB7XG4gIGlmIChwLnNpemUgPiAwKSB7XG4gICAgcmV0dXJuIHAuc2l6ZSAvIDhcbiAgfSBlbHNlIGlmIChwLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gMFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpemUgPSB2YXJpbnQuZGVjb2RlKGFkZHIpXG4gICAgcmV0dXJuIHNpemUgKyB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm5zIHtBcnJheTxbbnVtYmVyLCBVaW50OEFycmF5P10+fVxuICovXG5mdW5jdGlvbiBieXRlc1RvVHVwbGVzIChidWYpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxbbnVtYmVyLCBVaW50OEFycmF5P10+fSAqL1xuICBjb25zdCB0dXBsZXMgPSBbXVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBidWYubGVuZ3RoKSB7XG4gICAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoYnVmLCBpKVxuICAgIGNvbnN0IG4gPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICBjb25zdCBwID0gcHJvdG9jb2xzKGNvZGUpXG5cbiAgICBjb25zdCBzaXplID0gc2l6ZUZvckFkZHIocCwgYnVmLnNsaWNlKGkgKyBuKSlcblxuICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICB0dXBsZXMucHVzaChbY29kZV0pXG4gICAgICBpICs9IG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgYWRkciA9IGJ1Zi5zbGljZShpICsgbiwgaSArIG4gKyBzaXplKVxuXG4gICAgaSArPSAoc2l6ZSArIG4pXG5cbiAgICBpZiAoaSA+IGJ1Zi5sZW5ndGgpIHsgLy8gZGlkIG5vdCBlbmQgX2V4YWN0bHlfIGF0IGJ1ZmZlci5sZW5ndGhcbiAgICAgIHRocm93IFBhcnNlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyBVaW50OEFycmF5OiAnICsgdWludDhBcnJheVRvU3RyaW5nKGJ1ZiwgJ2Jhc2UxNicpKVxuICAgIH1cblxuICAgIC8vIG9rLCB0dXBsZSBzZWVtcyBnb29kLlxuICAgIHR1cGxlcy5wdXNoKFtjb2RlLCBhZGRyXSlcbiAgfVxuXG4gIHJldHVybiB0dXBsZXNcbn1cblxuLy8gVWludDhBcnJheSAtPiBTdHJpbmdcbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyAoYnVmKSB7XG4gIGNvbnN0IGEgPSBieXRlc1RvVHVwbGVzKGJ1ZilcbiAgY29uc3QgYiA9IHR1cGxlc1RvU3RyaW5nVHVwbGVzKGEpXG4gIHJldHVybiBzdHJpbmdUdXBsZXNUb1N0cmluZyhiKVxufVxuXG4vLyBTdHJpbmcgLT4gVWludDhBcnJheVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMgKHN0cikge1xuICBzdHIgPSBjbGVhblBhdGgoc3RyKVxuICBjb25zdCBhID0gc3RyaW5nVG9TdHJpbmdUdXBsZXMoc3RyKVxuICBjb25zdCBiID0gc3RyaW5nVHVwbGVzVG9UdXBsZXMoYSlcblxuICByZXR1cm4gdHVwbGVzVG9CeXRlcyhiKVxufVxuXG4vLyBTdHJpbmcgLT4gVWludDhBcnJheVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyaW5nVG9CeXRlcyhzdHIpXG59XG5cbi8vIFVpbnQ4QXJyYXkgLT4gVWludDhBcnJheVxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICovXG5mdW5jdGlvbiBmcm9tQnl0ZXMgKGJ1Zikge1xuICBjb25zdCBlcnIgPSB2YWxpZGF0ZUJ5dGVzKGJ1ZilcbiAgaWYgKGVycikgdGhyb3cgZXJyXG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmKSAvLyBjb3B5XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCeXRlcyAoYnVmKSB7XG4gIHRyeSB7XG4gICAgYnl0ZXNUb1R1cGxlcyhidWYpIC8vIHRyeSB0byBwYXJzZS4gd2lsbCB0aHJvdyBpZiBicmVha3NcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGVyclxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEJ5dGVzIChidWYpIHtcbiAgcmV0dXJuIHZhbGlkYXRlQnl0ZXMoYnVmKSA9PT0gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiBjbGVhblBhdGggKHN0cikge1xuICByZXR1cm4gJy8nICsgc3RyLnRyaW0oKS5zcGxpdCgnLycpLmZpbHRlcigoLyoqIEB0eXBlIHthbnl9ICovIGEpID0+IGEpLmpvaW4oJy8nKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gUGFyc2VFcnJvciAoc3RyKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0Vycm9yIHBhcnNpbmcgYWRkcmVzczogJyArIHN0cilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSB0dXBcbiAqL1xuZnVuY3Rpb24gcHJvdG9Gcm9tVHVwbGUgKHR1cCkge1xuICBjb25zdCBwcm90byA9IHByb3RvY29scyh0dXBbMF0pXG4gIHJldHVybiBwcm90b1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/src/codec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/src/convert.js":
/*!***********************************************!*\
  !*** ./node_modules/multiaddr/src/convert.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst ip = __webpack_require__(/*! ./ip */ \"(ssr)/./node_modules/multiaddr/src/ip.js\")\nconst protocols = __webpack_require__(/*! ./protocols-table */ \"(ssr)/./node_modules/multiaddr/src/protocols-table.js\")\nconst { CID } = __webpack_require__(/*! multiformats/cid */ \"(ssr)/./node_modules/multiformats/cjs/src/cid.js\")\nconst { base32 } = __webpack_require__(/*! multiformats/bases/base32 */ \"(ssr)/./node_modules/multiformats/cjs/src/bases/base32.js\")\nconst { base58btc } = __webpack_require__(/*! multiformats/bases/base58 */ \"(ssr)/./node_modules/multiformats/cjs/src/bases/base58.js\")\nconst Digest = __webpack_require__(/*! multiformats/hashes/digest */ \"(ssr)/./node_modules/multiformats/cjs/src/hashes/digest.js\")\nconst varint = __webpack_require__(/*! varint */ \"(ssr)/./node_modules/varint/index.js\")\nconst { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/to-string.js\")\nconst { fromString: uint8ArrayFromString } = __webpack_require__(/*! uint8arrays/from-string */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/from-string.js\")\nconst { concat: uint8ArrayConcat } = __webpack_require__(/*! uint8arrays/concat */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/concat.js\")\n\nmodule.exports = Convert\n\n// converts (serializes) addresses\n/**\n * @param {string} proto\n * @param {string | Uint8Array} a\n */\nfunction Convert (proto, a) {\n  if (a instanceof Uint8Array) {\n    return Convert.toString(proto, a)\n  } else {\n    return Convert.toBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n *\n * @param {number|string} proto\n * @param {Uint8Array} buf\n * @returns {string}\n */\nConvert.toString = function convertToString (proto, buf) {\n  const protocol = protocols(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\nConvert.toBytes = function convertToBytes (/** @type {string | number } */ proto, /** @type {string} */ str) {\n  const protocol = protocols(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\n/**\n * @param {string} ipString\n */\nfunction ip2bytes (ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\n/**\n * @param {Uint8Array} ipBuff\n */\nfunction bytes2ip (ipBuff) {\n  const ipString = ip.toString(ipBuff)\n  if (!ipString || !ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\n/**\n * @param {number} port\n */\nfunction port2bytes (port) {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction bytes2port (buf) {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\n/**\n * @param {string} str\n */\nfunction str2bytes (str) {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction bytes2str (buf) {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\n/**\n * @param {string} hash - base58btc string\n */\nfunction mh2bytes (hash) {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\n/**\n * Converts bytes to bas58btc string\n *\n * @param {Uint8Array} buf\n * @returns {string} base58btc string\n */\nfunction bytes2mh (buf) {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.decode.bytes)\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\n/**\n * @param {string} str\n */\nfunction onion2bytes (str) {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')\n  }\n  if (addr[0].length !== 16) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion address.')\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\n/**\n * @param {string} str\n */\nfunction onion32bytes (str) {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')\n  }\n  if (addr[0].length !== 56) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion3 address.')\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction bytes2onion (buf) {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return addr + ':' + port\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL3NyYy9jb252ZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyxzREFBTTtBQUN6QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDN0MsUUFBUSxNQUFNLEVBQUUsbUJBQU8sQ0FBQywwRUFBa0I7QUFDMUMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw0RkFBMkI7QUFDdEQsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyw0RkFBMkI7QUFDekQsZUFBZSxtQkFBTyxDQUFDLDhGQUE0QjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLDJHQUF1QjtBQUN4RSxRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMsK0dBQXlCO0FBQzlFLFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxxR0FBb0I7O0FBRWpFOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGtCQUFrQixxQkFBcUIsUUFBUTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL3NyYy9jb252ZXJ0LmpzP2U5M2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlwID0gcmVxdWlyZSgnLi9pcCcpXG5jb25zdCBwcm90b2NvbHMgPSByZXF1aXJlKCcuL3Byb3RvY29scy10YWJsZScpXG5jb25zdCB7IENJRCB9ID0gcmVxdWlyZSgnbXVsdGlmb3JtYXRzL2NpZCcpXG5jb25zdCB7IGJhc2UzMiB9ID0gcmVxdWlyZSgnbXVsdGlmb3JtYXRzL2Jhc2VzL2Jhc2UzMicpXG5jb25zdCB7IGJhc2U1OGJ0YyB9ID0gcmVxdWlyZSgnbXVsdGlmb3JtYXRzL2Jhc2VzL2Jhc2U1OCcpXG5jb25zdCBEaWdlc3QgPSByZXF1aXJlKCdtdWx0aWZvcm1hdHMvaGFzaGVzL2RpZ2VzdCcpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgeyB0b1N0cmluZzogdWludDhBcnJheVRvU3RyaW5nIH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy90by1zdHJpbmcnKVxuY29uc3QgeyBmcm9tU3RyaW5nOiB1aW50OEFycmF5RnJvbVN0cmluZyB9ID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuY29uc3QgeyBjb25jYXQ6IHVpbnQ4QXJyYXlDb25jYXQgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFxuXG4vLyBjb252ZXJ0cyAoc2VyaWFsaXplcykgYWRkcmVzc2VzXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b1xuICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBhXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnQgKHByb3RvLCBhKSB7XG4gIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBDb252ZXJ0LnRvU3RyaW5nKHByb3RvLCBhKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBDb252ZXJ0LnRvQnl0ZXMocHJvdG8sIGEpXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IFtjb2RlLFVpbnQ4QXJyYXldIHRvIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gcHJvdG9cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5Db252ZXJ0LnRvU3RyaW5nID0gZnVuY3Rpb24gY29udmVydFRvU3RyaW5nIChwcm90bywgYnVmKSB7XG4gIGNvbnN0IHByb3RvY29sID0gcHJvdG9jb2xzKHByb3RvKVxuICBzd2l0Y2ggKHByb3RvY29sLmNvZGUpIHtcbiAgICBjYXNlIDQ6IC8vIGlwdjRcbiAgICBjYXNlIDQxOiAvLyBpcHY2XG4gICAgICByZXR1cm4gYnl0ZXMyaXAoYnVmKVxuXG4gICAgY2FzZSA2OiAvLyB0Y3BcbiAgICBjYXNlIDI3MzogLy8gdWRwXG4gICAgY2FzZSAzMzogLy8gZGNjcFxuICAgIGNhc2UgMTMyOiAvLyBzY3RwXG4gICAgICByZXR1cm4gYnl0ZXMycG9ydChidWYpLnRvU3RyaW5nKClcblxuICAgIGNhc2UgNTM6IC8vIGRuc1xuICAgIGNhc2UgNTQ6IC8vIGRuczRcbiAgICBjYXNlIDU1OiAvLyBkbnM2XG4gICAgY2FzZSA1NjogLy8gZG5zYWRkclxuICAgIGNhc2UgNDAwOiAvLyB1bml4XG4gICAgY2FzZSA3Nzc6IC8vIG1lbW9yeVxuICAgICAgcmV0dXJuIGJ5dGVzMnN0cihidWYpXG5cbiAgICBjYXNlIDQyMTogLy8gaXBmc1xuICAgICAgcmV0dXJuIGJ5dGVzMm1oKGJ1ZilcbiAgICBjYXNlIDQ0NDogLy8gb25pb25cbiAgICAgIHJldHVybiBieXRlczJvbmlvbihidWYpXG4gICAgY2FzZSA0NDU6IC8vIG9uaW9uM1xuICAgICAgcmV0dXJuIGJ5dGVzMm9uaW9uKGJ1ZilcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyhidWYsICdiYXNlMTYnKSAvLyBubyBjbHVlLiBjb252ZXJ0IHRvIGhleFxuICB9XG59XG5cbkNvbnZlcnQudG9CeXRlcyA9IGZ1bmN0aW9uIGNvbnZlcnRUb0J5dGVzICgvKiogQHR5cGUge3N0cmluZyB8IG51bWJlciB9ICovIHByb3RvLCAvKiogQHR5cGUge3N0cmluZ30gKi8gc3RyKSB7XG4gIGNvbnN0IHByb3RvY29sID0gcHJvdG9jb2xzKHByb3RvKVxuICBzd2l0Y2ggKHByb3RvY29sLmNvZGUpIHtcbiAgICBjYXNlIDQ6IC8vIGlwdjRcbiAgICAgIHJldHVybiBpcDJieXRlcyhzdHIpXG4gICAgY2FzZSA0MTogLy8gaXB2NlxuICAgICAgcmV0dXJuIGlwMmJ5dGVzKHN0cilcblxuICAgIGNhc2UgNjogLy8gdGNwXG4gICAgY2FzZSAyNzM6IC8vIHVkcFxuICAgIGNhc2UgMzM6IC8vIGRjY3BcbiAgICBjYXNlIDEzMjogLy8gc2N0cFxuICAgICAgcmV0dXJuIHBvcnQyYnl0ZXMocGFyc2VJbnQoc3RyLCAxMCkpXG5cbiAgICBjYXNlIDUzOiAvLyBkbnNcbiAgICBjYXNlIDU0OiAvLyBkbnM0XG4gICAgY2FzZSA1NTogLy8gZG5zNlxuICAgIGNhc2UgNTY6IC8vIGRuc2FkZHJcbiAgICBjYXNlIDQwMDogLy8gdW5peFxuICAgIGNhc2UgNzc3OiAvLyBtZW1vcnlcbiAgICAgIHJldHVybiBzdHIyYnl0ZXMoc3RyKVxuXG4gICAgY2FzZSA0MjE6IC8vIGlwZnNcbiAgICAgIHJldHVybiBtaDJieXRlcyhzdHIpXG4gICAgY2FzZSA0NDQ6IC8vIG9uaW9uXG4gICAgICByZXR1cm4gb25pb24yYnl0ZXMoc3RyKVxuICAgIGNhc2UgNDQ1OiAvLyBvbmlvbjNcbiAgICAgIHJldHVybiBvbmlvbjMyYnl0ZXMoc3RyKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdWludDhBcnJheUZyb21TdHJpbmcoc3RyLCAnYmFzZTE2JykgLy8gbm8gY2x1ZS4gY29udmVydCBmcm9tIGhleFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlwU3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlwMmJ5dGVzIChpcFN0cmluZykge1xuICBpZiAoIWlwLmlzSVAoaXBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlwIGFkZHJlc3MnKVxuICB9XG4gIHJldHVybiBpcC50b0J5dGVzKGlwU3RyaW5nKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaXBCdWZmXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzMmlwIChpcEJ1ZmYpIHtcbiAgY29uc3QgaXBTdHJpbmcgPSBpcC50b1N0cmluZyhpcEJ1ZmYpXG4gIGlmICghaXBTdHJpbmcgfHwgIWlwLmlzSVAoaXBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlwIGFkZHJlc3MnKVxuICB9XG4gIHJldHVybiBpcFN0cmluZ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0XG4gKi9cbmZ1bmN0aW9uIHBvcnQyYnl0ZXMgKHBvcnQpIHtcbiAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKDIpXG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmKVxuICB2aWV3LnNldFVpbnQxNigwLCBwb3J0KVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWYpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZnVuY3Rpb24gYnl0ZXMycG9ydCAoYnVmKSB7XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlcilcbiAgcmV0dXJuIHZpZXcuZ2V0VWludDE2KGJ1Zi5ieXRlT2Zmc2V0KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gc3RyMmJ5dGVzIChzdHIpIHtcbiAgY29uc3QgYnVmID0gdWludDhBcnJheUZyb21TdHJpbmcoc3RyKVxuICBjb25zdCBzaXplID0gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUoYnVmLmxlbmd0aCkpXG4gIHJldHVybiB1aW50OEFycmF5Q29uY2F0KFtzaXplLCBidWZdLCBzaXplLmxlbmd0aCArIGJ1Zi5sZW5ndGgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZnVuY3Rpb24gYnl0ZXMyc3RyIChidWYpIHtcbiAgY29uc3Qgc2l6ZSA9IHZhcmludC5kZWNvZGUoYnVmKVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBpZiAoYnVmLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IGxlbmd0aHMnKVxuICB9XG5cbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyhidWYpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggLSBiYXNlNThidGMgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIG1oMmJ5dGVzIChoYXNoKSB7XG4gIGxldCBtaFxuXG4gIGlmIChoYXNoWzBdID09PSAnUScgfHwgaGFzaFswXSA9PT0gJzEnKSB7XG4gICAgbWggPSBEaWdlc3QuZGVjb2RlKGJhc2U1OGJ0Yy5kZWNvZGUoYHoke2hhc2h9YCkpLmJ5dGVzXG4gIH0gZWxzZSB7XG4gICAgbWggPSBDSUQucGFyc2UoaGFzaCkubXVsdGloYXNoLmJ5dGVzXG4gIH1cblxuICAvLyB0aGUgYWRkcmVzcyBpcyBhIHZhcmludCBwcmVmaXhlZCBtdWx0aWhhc2ggc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gIGNvbnN0IHNpemUgPSBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZShtaC5sZW5ndGgpKVxuICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbc2l6ZSwgbWhdLCBzaXplLmxlbmd0aCArIG1oLmxlbmd0aClcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBiYXM1OGJ0YyBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybnMge3N0cmluZ30gYmFzZTU4YnRjIHN0cmluZ1xuICovXG5mdW5jdGlvbiBieXRlczJtaCAoYnVmKSB7XG4gIGNvbnN0IHNpemUgPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgY29uc3QgYWRkcmVzcyA9IGJ1Zi5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxuXG4gIGlmIChhZGRyZXNzLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IGxlbmd0aHMnKVxuICB9XG5cbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyhhZGRyZXNzLCAnYmFzZTU4YnRjJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIG9uaW9uMmJ5dGVzIChzdHIpIHtcbiAgY29uc3QgYWRkciA9IHN0ci5zcGxpdCgnOicpXG4gIGlmIChhZGRyLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHBhcnNlIG9uaW9uIGFkZHI6ICcgKyBhZGRyICsgJyBkb2VzIG5vdCBjb250YWluIGEgcG9ydCBudW1iZXInKVxuICB9XG4gIGlmIChhZGRyWzBdLmxlbmd0aCAhPT0gMTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBvbmlvbiBhZGRyOiAnICsgYWRkclswXSArICcgbm90IGEgVG9yIG9uaW9uIGFkZHJlc3MuJylcbiAgfVxuXG4gIC8vIG9uaW9uIGFkZHJlc3NlcyBkbyBub3QgaW5jbHVkZSB0aGUgbXVsdGliYXNlIHByZWZpeCwgYWRkIGl0IGJlZm9yZSBkZWNvZGluZ1xuICBjb25zdCBidWYgPSBiYXNlMzIuZGVjb2RlKCdiJyArIGFkZHJbMF0pXG5cbiAgLy8gb25pb24gcG9ydCBudW1iZXJcbiAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGFkZHJbMV0sIDEwKVxuICBpZiAocG9ydCA8IDEgfHwgcG9ydCA+IDY1NTM2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IG51bWJlciBpcyBub3QgaW4gcmFuZ2UoMSwgNjU1MzYpJylcbiAgfVxuICBjb25zdCBwb3J0QnVmID0gcG9ydDJieXRlcyhwb3J0KVxuICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbYnVmLCBwb3J0QnVmXSwgYnVmLmxlbmd0aCArIHBvcnRCdWYubGVuZ3RoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gb25pb24zMmJ5dGVzIChzdHIpIHtcbiAgY29uc3QgYWRkciA9IHN0ci5zcGxpdCgnOicpXG4gIGlmIChhZGRyLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHBhcnNlIG9uaW9uIGFkZHI6ICcgKyBhZGRyICsgJyBkb2VzIG5vdCBjb250YWluIGEgcG9ydCBudW1iZXInKVxuICB9XG4gIGlmIChhZGRyWzBdLmxlbmd0aCAhPT0gNTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBvbmlvbiBhZGRyOiAnICsgYWRkclswXSArICcgbm90IGEgVG9yIG9uaW9uMyBhZGRyZXNzLicpXG4gIH1cbiAgLy8gb25pb24gYWRkcmVzc2VzIGRvIG5vdCBpbmNsdWRlIHRoZSBtdWx0aWJhc2UgcHJlZml4LCBhZGQgaXQgYmVmb3JlIGRlY29kaW5nXG4gIGNvbnN0IGJ1ZiA9IGJhc2UzMi5kZWNvZGUoJ2InICsgYWRkclswXSlcblxuICAvLyBvbmlvbiBwb3J0IG51bWJlclxuICBjb25zdCBwb3J0ID0gcGFyc2VJbnQoYWRkclsxXSwgMTApXG4gIGlmIChwb3J0IDwgMSB8fCBwb3J0ID4gNjU1MzYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgbnVtYmVyIGlzIG5vdCBpbiByYW5nZSgxLCA2NTUzNiknKVxuICB9XG4gIGNvbnN0IHBvcnRCdWYgPSBwb3J0MmJ5dGVzKHBvcnQpXG4gIHJldHVybiB1aW50OEFycmF5Q29uY2F0KFtidWYsIHBvcnRCdWZdLCBidWYubGVuZ3RoICsgcG9ydEJ1Zi5sZW5ndGgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZnVuY3Rpb24gYnl0ZXMyb25pb24gKGJ1Zikge1xuICBjb25zdCBhZGRyQnl0ZXMgPSBidWYuc2xpY2UoMCwgYnVmLmxlbmd0aCAtIDIpXG4gIGNvbnN0IHBvcnRCeXRlcyA9IGJ1Zi5zbGljZShidWYubGVuZ3RoIC0gMilcbiAgY29uc3QgYWRkciA9IHVpbnQ4QXJyYXlUb1N0cmluZyhhZGRyQnl0ZXMsICdiYXNlMzInKVxuICBjb25zdCBwb3J0ID0gYnl0ZXMycG9ydChwb3J0Qnl0ZXMpXG4gIHJldHVybiBhZGRyICsgJzonICsgcG9ydFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/src/convert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/multiaddr/src/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst codec = __webpack_require__(/*! ./codec */ \"(ssr)/./node_modules/multiaddr/src/codec.js\")\nconst protocols = __webpack_require__(/*! ./protocols-table */ \"(ssr)/./node_modules/multiaddr/src/protocols-table.js\")\nconst varint = __webpack_require__(/*! varint */ \"(ssr)/./node_modules/varint/index.js\")\nconst { CID } = __webpack_require__(/*! multiformats/cid */ \"(ssr)/./node_modules/multiformats/cjs/src/cid.js\")\nconst { base58btc } = __webpack_require__(/*! multiformats/bases/base58 */ \"(ssr)/./node_modules/multiformats/cjs/src/bases/base58.js\")\nconst errCode = __webpack_require__(/*! err-code */ \"(ssr)/./node_modules/err-code/index.js\")\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nconst { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/to-string.js\")\nconst { equals: uint8ArrayEquals } = __webpack_require__(/*! uint8arrays/equals */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/equals.js\")\n\n/**\n * @typedef {(addr: Multiaddr) => Promise<string[]>} Resolver\n * @typedef {string | Multiaddr | Uint8Array | null} MultiaddrInput\n * @typedef {import('./types').MultiaddrObject} MultiaddrObject\n * @typedef {import('./types').Protocol} Protocol\n */\n\n/** @type {Map<string, Resolver>} */\nconst resolvers = new Map()\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr')\n\n/**\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\n * a Uint8Array, String or another Multiaddr instance\n * public key.\n *\n */\nclass Multiaddr {\n  /**\n   * @example\n   * ```js\n   * new Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   * ```\n   *\n   * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n   */\n  constructor (addr) {\n    // default\n    if (addr == null) {\n      addr = ''\n    }\n\n    // Define symbol\n    Object.defineProperty(this, symbol, { value: true })\n\n    if (addr instanceof Uint8Array) {\n      /** @type {Uint8Array} - The raw bytes representing this multiaddress */\n      this.bytes = codec.fromBytes(addr)\n    } else if (typeof addr === 'string') {\n      if (addr.length > 0 && addr.charAt(0) !== '/') {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n      }\n      this.bytes = codec.fromString(addr)\n    } else if (Multiaddr.isMultiaddr(addr)) { // Multiaddr\n      this.bytes = codec.fromBytes(addr.bytes) // validate + copy buffer\n    } else {\n      throw new Error('addr must be a string, Buffer, or another Multiaddr')\n    }\n  }\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString () {\n    return codec.bytesToString(this.bytes)\n  }\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * JSON.stringify(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Returns Multiaddr as a convinient options object to be used with net.createConnection\n   *\n   * @example\n   * ```js\n   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   * ```\n   */\n  toOptions () {\n    /** @type {MultiaddrObject} */\n    const opts = {}\n    const parsed = this.toString().split('/')\n    opts.family = parsed[1] === 'ip4' ? 4 : 6\n    opts.host = parsed[2]\n    opts.transport = parsed[3]\n    opts.port = parseInt(parsed[4])\n    return opts\n  }\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   * ```\n   *\n   * @returns {Protocol[]} protocols - All the protocols the address is composed of\n   */\n  protos () {\n    return this.protoCodes().map(code => Object.assign({}, protocols(code)))\n  }\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   * ```\n   *\n   * @returns {number[]} protocol codes\n   */\n  protoCodes () {\n    const codes = []\n    const buf = this.bytes\n    let i = 0\n    while (i < buf.length) {\n      const code = varint.decode(buf, i)\n      const n = varint.decode.bytes\n\n      const p = protocols(code)\n      const size = codec.sizeForAddr(p, buf.slice(i + n))\n\n      i += (size + n)\n      codes.push(code)\n    }\n\n    return codes\n  }\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   * ```\n   *\n   * @returns {string[]} protocol names\n   */\n  protoNames () {\n    return this.protos().map(proto => proto.name)\n  }\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * ```js\n   * new Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   * ```\n   */\n  tuples () {\n    return codec.bytesToTuples(this.bytes)\n  }\n\n  /**\n   * Returns a tuple of string/number parts\n   * - tuples[][0] = code of protocol\n   * - tuples[][1] = contents of address\n   *\n   * @example\n   * ```js\n   * new Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]\n   * ```\n   */\n  stringTuples () {\n    const t = codec.bytesToTuples(this.bytes)\n    return codec.tuplesToStringTuples(t)\n  }\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate (addr) {\n    addr = new Multiaddr(addr)\n    return new Multiaddr(this.toString() + addr.toString())\n  }\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   * @returns {Multiaddr}\n   */\n  decapsulate (addr) {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n    if (i < 0) {\n      throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)\n    }\n    return new Multiaddr(s.slice(0, i))\n  }\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * const addr = new Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * new Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   *\n   * @param {number} code - The code of the protocol to decapsulate from this Multiaddr\n   * @returns {Multiaddr}\n   */\n  decapsulateCode (code) {\n    const tuples = this.tuples()\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)))\n      }\n    }\n    return this\n  }\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   * ```\n   *\n   * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma\n   */\n  getPeerId () {\n    try {\n      const tuples = this.stringTuples().filter((tuple) => {\n        if (tuple[0] === protocols.names.ipfs.code) {\n          return true\n        }\n        return false\n      })\n\n      // Get the last ipfs tuple ['ipfs', 'peerid string']\n      const tuple = tuples.pop()\n      if (tuple && tuple[1]) {\n        const peerIdStr = tuple[1]\n\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')\n        }\n\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   * ```js\n   *\n   * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present\n   */\n  getPath () {\n    let path = null\n    try {\n      path = this.stringTuples().filter((tuple) => {\n        const proto = protocols(tuple[0])\n        if (proto.path) {\n          return true\n        }\n        return false\n      })[0][1]\n\n      if (!path) {\n        path = null\n      }\n    } catch (e) {\n      path = null\n    }\n    return path\n  }\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   *\n   * @param {Multiaddr} addr\n   * @returns {boolean}\n   */\n  equals (addr) {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  /**\n   * Resolve multiaddr if containing resolvable hostname.\n   *\n   * @example\n   * ```js\n   * Multiaddr.resolvers.set('dnsaddr', resolverFunction)\n   * const mh1 = new Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n   * const resolvedMultiaddrs = await mh1.resolve()\n   * // [\n   * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\n   * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\n   * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>\n   * // ]\n   * ```\n   *\n   * @returns {Promise<Array<Multiaddr>>}\n   */\n  async resolve () {\n    const resolvableProto = this.protos().find((p) => p.resolvable)\n\n    // Multiaddr is not resolvable?\n    if (!resolvableProto) {\n      return [this]\n    }\n\n    const resolver = resolvers.get(resolvableProto.name)\n    if (!resolver) {\n      throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), 'ERR_NO_AVAILABLE_RESOLVER')\n    }\n\n    const addresses = await resolver(this)\n    return addresses.map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * ```js\n   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 4, address: '127.0.0.1', port: 4001}\n   * ```\n   *\n   * @returns {{family: 4 | 6, address: string, port: number}}\n   * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\n   */\n  nodeAddress () {\n    const codes = this.protoCodes()\n    const names = this.protoNames()\n    const parts = this.toString().split('/').slice(1)\n\n    if (parts.length < 4) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".')\n    } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\n      throw new Error(`no protocol with name: \"'${names[0]}'\". Must have a valid family name: \"{ip4, ip6, dns4, dns6}\".`)\n    } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {\n      throw new Error(`no protocol with name: \"'${names[1]}'\". Must have a valid transport protocol: \"{tcp, udp}\".`)\n    }\n\n    return {\n      family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,\n      address: parts[1],\n      port: parseInt(parts[3]) // tcp or udp port\n    }\n  }\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * ```js\n   * const mh1 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   * const mh2 = new Multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\n   * const mh4 = new Multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')\n   * // <Multiaddr 047f0000010607d0de039302a503221220d52ebb89d85b02a284948203a62ff28389c57c9f42beec4ec20db76a64835843 - /ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a>\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   * mh4.isThinWaistAddress()\n   * // false\n   * ```\n   *\n   * @param {Multiaddr} [addr] - Defaults to using `this` instance\n   */\n  isThinWaistAddress (addr) {\n    const protos = (addr || this).protos()\n\n    if (protos.length !== 2) {\n      return false\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false\n    }\n    if (protos[1].code !== 6 && protos[1].code !== 273) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Creates a Multiaddr from a node-friendly address object\n   *\n   * @example\n   * ```js\n   * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   * ```\n   *\n   * @param {{family: 4 | 6, address: string, port: number}} addr\n   * @param {string} transport\n   */\n  static fromNodeAddress (addr, transport) {\n    if (!addr) { throw new Error('requires node address object') }\n    if (!transport) { throw new Error('requires transport protocol') }\n    let ip\n    switch (addr.family) {\n      case 4:\n        ip = 'ip4'\n        break\n      case 6:\n        ip = 'ip6'\n        break\n      default:\n        throw Error(`Invalid addr family. Got '${addr.family}' instead of 4 or 6`)\n    }\n    return new Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))\n  }\n\n  /**\n   * Returns if something is a Multiaddr that is a name\n   *\n   * @param {Multiaddr} addr\n   * @returns {boolean} isName\n   */\n  static isName (addr) {\n    if (!Multiaddr.isMultiaddr(addr)) {\n      return false\n    }\n\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable)\n  }\n\n  /**\n   * Check if object is a CID instance\n   *\n   * @param {any} value\n   * @returns {value is Multiaddr}\n   */\n  static isMultiaddr (value) {\n    return value instanceof Multiaddr || Boolean(value && value[symbol])\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string.\n   * For post Node.js v10.0.0.\n   * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\n   *\n   * @example\n   * ```js\n   * console.log(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n   * ```\n   *\n   * @returns {string}\n   */\n  [inspect] () {\n    return '<Multiaddr ' +\n    uint8ArrayToString(this.bytes, 'base16') + ' - ' +\n    codec.bytesToString(this.bytes) + '>'\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string.\n   * Fallback for pre Node.js v10.0.0.\n   * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\n   *\n   * @example\n   * ```js\n   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\n   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n   * ```\n   *\n   * @returns {string}\n   */\n  inspect () {\n    return '<Multiaddr ' +\n      uint8ArrayToString(this.bytes, 'base16') + ' - ' +\n      codec.bytesToString(this.bytes) + '>'\n  }\n}\n\n/**\n * Object containing table, names and codes of all supported protocols.\n * To get the protocol values from a Multiaddr, you can use\n * [`.protos()`](#multiaddrprotos),\n * [`.protoCodes()`](#multiaddrprotocodes) or\n * [`.protoNames()`](#multiaddrprotonames)\n *\n * @returns {{table: Array, names: Object, codes: Object}}\n */\nMultiaddr.protocols = protocols\n\nMultiaddr.resolvers = resolvers\n\n/**\n * Static factory\n *\n * @param {MultiaddrInput} addr\n */\nfunction multiaddr (addr) {\n  return new Multiaddr(addr)\n}\n\nmodule.exports = { Multiaddr, multiaddr, protocols, resolvers }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLDBFQUFrQjtBQUMxQyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDRGQUEyQjtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBVTtBQUNsQztBQUNBLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQywyR0FBdUI7QUFDeEUsUUFBUSwyQkFBMkIsRUFBRSxtQkFBTyxDQUFDLHFHQUFvQjs7QUFFakU7QUFDQSxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLDRCQUE0QjtBQUN6Qzs7QUFFQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsYUFBYTs7QUFFdkQ7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBLE1BQU07QUFDTjtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQSxNQUFNLHdDQUF3QztBQUM5QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QyxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELHFCQUFxQixFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsS0FBSztBQUMvRyxNQUFNO0FBQ04sa0RBQWtELFNBQVMscUNBQXFDLHFCQUFxQjtBQUNySCxNQUFNO0FBQ04sa0RBQWtELFNBQVMsNENBQTRDLFNBQVM7QUFDaEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFdBQVcsRUFBRSxTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQ0FBbUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQ0FBK0M7QUFDN0QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL2luZGV4LmpzPzkwZmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvZGVjID0gcmVxdWlyZSgnLi9jb2RlYycpXG5jb25zdCBwcm90b2NvbHMgPSByZXF1aXJlKCcuL3Byb3RvY29scy10YWJsZScpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgeyBDSUQgfSA9IHJlcXVpcmUoJ211bHRpZm9ybWF0cy9jaWQnKVxuY29uc3QgeyBiYXNlNThidGMgfSA9IHJlcXVpcmUoJ211bHRpZm9ybWF0cy9iYXNlcy9iYXNlNTgnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IGluc3BlY3QgPSBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXG5jb25zdCB7IHRvU3RyaW5nOiB1aW50OEFycmF5VG9TdHJpbmcgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZycpXG5jb25zdCB7IGVxdWFsczogdWludDhBcnJheUVxdWFscyB9ID0gcmVxdWlyZSgndWludDhhcnJheXMvZXF1YWxzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7KGFkZHI6IE11bHRpYWRkcikgPT4gUHJvbWlzZTxzdHJpbmdbXT59IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7c3RyaW5nIHwgTXVsdGlhZGRyIHwgVWludDhBcnJheSB8IG51bGx9IE11bHRpYWRkcklucHV0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuTXVsdGlhZGRyT2JqZWN0fSBNdWx0aWFkZHJPYmplY3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMnKS5Qcm90b2NvbH0gUHJvdG9jb2xcbiAqL1xuXG4vKiogQHR5cGUge01hcDxzdHJpbmcsIFJlc29sdmVyPn0gKi9cbmNvbnN0IHJlc29sdmVycyA9IG5ldyBNYXAoKVxuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcignQG11bHRpZm9ybWF0cy9qcy1tdWx0aWFkZHIvbXVsdGlhZGRyJylcblxuLyoqXG4gKiBDcmVhdGVzIGEgW211bHRpYWRkcl0oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWFkZHIpIGZyb21cbiAqIGEgVWludDhBcnJheSwgU3RyaW5nIG9yIGFub3RoZXIgTXVsdGlhZGRyIGluc3RhbmNlXG4gKiBwdWJsaWMga2V5LlxuICpcbiAqL1xuY2xhc3MgTXVsdGlhZGRyIHtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJylcbiAgICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpYWRkcklucHV0fSBbYWRkcl0gLSBJZiBTdHJpbmcgb3IgVWludDhBcnJheSwgbmVlZHMgdG8gYWRoZXJlIHRvIHRoZSBhZGRyZXNzIGZvcm1hdCBvZiBhIFttdWx0aWFkZHJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGlhZGRyI3N0cmluZy1mb3JtYXQpXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYWRkcikge1xuICAgIC8vIGRlZmF1bHRcbiAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICBhZGRyID0gJydcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgc3ltYm9sXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHN5bWJvbCwgeyB2YWx1ZTogdHJ1ZSB9KVxuXG4gICAgaWYgKGFkZHIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAvKiogQHR5cGUge1VpbnQ4QXJyYXl9IC0gVGhlIHJhdyBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBtdWx0aWFkZHJlc3MgKi9cbiAgICAgIHRoaXMuYnl0ZXMgPSBjb2RlYy5mcm9tQnl0ZXMoYWRkcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhZGRyID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGFkZHIubGVuZ3RoID4gMCAmJiBhZGRyLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGlhZGRyIFwiJHthZGRyfVwiIG11c3Qgc3RhcnQgd2l0aCBhIFwiL1wiYClcbiAgICAgIH1cbiAgICAgIHRoaXMuYnl0ZXMgPSBjb2RlYy5mcm9tU3RyaW5nKGFkZHIpXG4gICAgfSBlbHNlIGlmIChNdWx0aWFkZHIuaXNNdWx0aWFkZHIoYWRkcikpIHsgLy8gTXVsdGlhZGRyXG4gICAgICB0aGlzLmJ5dGVzID0gY29kZWMuZnJvbUJ5dGVzKGFkZHIuYnl0ZXMpIC8vIHZhbGlkYXRlICsgY29weSBidWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRyIG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgb3IgYW5vdGhlciBNdWx0aWFkZHInKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIFN0cmluZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLnRvU3RyaW5nKClcbiAgICogLy8gJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJ1xuICAgKiBgYGBcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gY29kZWMuYnl0ZXNUb1N0cmluZyh0aGlzLmJ5dGVzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTXVsdGlhZGRyIGFzIGEgSlNPTiBlbmNvZGVkIG9iamVjdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBKU09OLnN0cmluZ2lmeShuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpKVxuICAgKiAvLyAnL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnXG4gICAqIGBgYFxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNdWx0aWFkZHIgYXMgYSBjb252aW5pZW50IG9wdGlvbnMgb2JqZWN0IHRvIGJlIHVzZWQgd2l0aCBuZXQuY3JlYXRlQ29ubmVjdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLnRvT3B0aW9ucygpXG4gICAqIC8vIHsgZmFtaWx5OiA0LCBob3N0OiAnMTI3LjAuMC4xJywgdHJhbnNwb3J0OiAndGNwJywgcG9ydDogNDAwMSB9XG4gICAqIGBgYFxuICAgKi9cbiAgdG9PcHRpb25zICgpIHtcbiAgICAvKiogQHR5cGUge011bHRpYWRkck9iamVjdH0gKi9cbiAgICBjb25zdCBvcHRzID0ge31cbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoJy8nKVxuICAgIG9wdHMuZmFtaWx5ID0gcGFyc2VkWzFdID09PSAnaXA0JyA/IDQgOiA2XG4gICAgb3B0cy5ob3N0ID0gcGFyc2VkWzJdXG4gICAgb3B0cy50cmFuc3BvcnQgPSBwYXJzZWRbM11cbiAgICBvcHRzLnBvcnQgPSBwYXJzZUludChwYXJzZWRbNF0pXG4gICAgcmV0dXJuIG9wdHNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm90b2NvbHMgdGhlIE11bHRpYWRkciBpcyBkZWZpbmVkIHdpdGgsIGFzIGFuIGFycmF5IG9mIG9iamVjdHMsIGluXG4gICAqIGxlZnQtdG8tcmlnaHQgb3JkZXIuIEVhY2ggb2JqZWN0IGNvbnRhaW5zIHRoZSBwcm90b2NvbCBjb2RlLCBwcm90b2NvbCBuYW1lLFxuICAgKiBhbmQgdGhlIHNpemUgb2YgaXRzIGFkZHJlc3Mgc3BhY2UgaW4gYml0cy5cbiAgICogW1NlZSBsaXN0IG9mIHByb3RvY29sc10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWFkZHIvYmxvYi9tYXN0ZXIvcHJvdG9jb2xzLmNzdilcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS5wcm90b3MoKVxuICAgKiAvLyBbIHsgY29kZTogNCwgc2l6ZTogMzIsIG5hbWU6ICdpcDQnIH0sXG4gICAqIC8vICAgeyBjb2RlOiA2LCBzaXplOiAxNiwgbmFtZTogJ3RjcCcgfSBdXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvdG9jb2xbXX0gcHJvdG9jb2xzIC0gQWxsIHRoZSBwcm90b2NvbHMgdGhlIGFkZHJlc3MgaXMgY29tcG9zZWQgb2ZcbiAgICovXG4gIHByb3RvcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG9Db2RlcygpLm1hcChjb2RlID0+IE9iamVjdC5hc3NpZ24oe30sIHByb3RvY29scyhjb2RlKSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29kZXMgb2YgdGhlIHByb3RvY29scyBpbiBsZWZ0LXRvLXJpZ2h0IG9yZGVyLlxuICAgKiBbU2VlIGxpc3Qgb2YgcHJvdG9jb2xzXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYWRkci9ibG9iL21hc3Rlci9wcm90b2NvbHMuY3N2KVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykucHJvdG9Db2RlcygpXG4gICAqIC8vIFsgNCwgNiBdXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IHByb3RvY29sIGNvZGVzXG4gICAqL1xuICBwcm90b0NvZGVzICgpIHtcbiAgICBjb25zdCBjb2RlcyA9IFtdXG4gICAgY29uc3QgYnVmID0gdGhpcy5ieXRlc1xuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChpIDwgYnVmLmxlbmd0aCkge1xuICAgICAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoYnVmLCBpKVxuICAgICAgY29uc3QgbiA9IHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICAgICAgY29uc3QgcCA9IHByb3RvY29scyhjb2RlKVxuICAgICAgY29uc3Qgc2l6ZSA9IGNvZGVjLnNpemVGb3JBZGRyKHAsIGJ1Zi5zbGljZShpICsgbikpXG5cbiAgICAgIGkgKz0gKHNpemUgKyBuKVxuICAgICAgY29kZXMucHVzaChjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBjb2Rlc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBwcm90b2NvbHMgaW4gbGVmdC10by1yaWdodCBvcmRlci5cbiAgICogW1NlZSBsaXN0IG9mIHByb3RvY29sc10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWFkZHIvYmxvYi9tYXN0ZXIvcHJvdG9jb2xzLmNzdilcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS5wcm90b05hbWVzKClcbiAgICogLy8gWyAnaXA0JywgJ3RjcCcgXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ1tdfSBwcm90b2NvbCBuYW1lc1xuICAgKi9cbiAgcHJvdG9OYW1lcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG9zKCkubWFwKHByb3RvID0+IHByb3RvLm5hbWUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHR1cGxlIG9mIHBhcnRzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIG5ldyBNdWx0aWFkZHIoXCIvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMVwiKS50dXBsZXMoKVxuICAgKiAvLyBbIFsgNCwgPEJ1ZmZlciA3ZiAwMCAwMCAwMT4gXSwgWyA2LCA8QnVmZmVyIDBmIGExPiBdIF1cbiAgICogYGBgXG4gICAqL1xuICB0dXBsZXMgKCkge1xuICAgIHJldHVybiBjb2RlYy5ieXRlc1RvVHVwbGVzKHRoaXMuYnl0ZXMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHR1cGxlIG9mIHN0cmluZy9udW1iZXIgcGFydHNcbiAgICogLSB0dXBsZXNbXVswXSA9IGNvZGUgb2YgcHJvdG9jb2xcbiAgICogLSB0dXBsZXNbXVsxXSA9IGNvbnRlbnRzIG9mIGFkZHJlc3NcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogbmV3IE11bHRpYWRkcihcIi9pcDQvMTI3LjAuMC4xL3RjcC80MDAxXCIpLnN0cmluZ1R1cGxlcygpXG4gICAqIC8vIFsgWyA0LCAnMTI3LjAuMC4xJyBdLCBbIDYsICc0MDAxJyBdIF1cbiAgICogYGBgXG4gICAqL1xuICBzdHJpbmdUdXBsZXMgKCkge1xuICAgIGNvbnN0IHQgPSBjb2RlYy5ieXRlc1RvVHVwbGVzKHRoaXMuYnl0ZXMpXG4gICAgcmV0dXJuIGNvZGVjLnR1cGxlc1RvU3RyaW5nVHVwbGVzKHQpXG4gIH1cblxuICAvKipcbiAgICogRW5jYXBzdWxhdGVzIGEgTXVsdGlhZGRyIGluIGFub3RoZXIgTXVsdGlhZGRyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1oMSA9IG5ldyBNdWx0aWFkZHIoJy9pcDQvOC44LjguOC90Y3AvMTA4MCcpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzOCAtIC9pcDQvOC44LjguOC90Y3AvMTA4MD5cbiAgICpcbiAgICogY29uc3QgbWgyID0gbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAgICpcbiAgICogY29uc3QgbWgzID0gbWgxLmVuY2Fwc3VsYXRlKG1oMilcbiAgICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4MDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvOC44LjguOC90Y3AvMTA4MC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICAgKlxuICAgKiBtaDMudG9TdHJpbmcoKVxuICAgKiAvLyAnL2lwNC84LjguOC44L3RjcC8xMDgwL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpYWRkcklucHV0fSBhZGRyIC0gTXVsdGlhZGRyIHRvIGFkZCBpbnRvIHRoaXMgTXVsdGlhZGRyXG4gICAqL1xuICBlbmNhcHN1bGF0ZSAoYWRkcikge1xuICAgIGFkZHIgPSBuZXcgTXVsdGlhZGRyKGFkZHIpXG4gICAgcmV0dXJuIG5ldyBNdWx0aWFkZHIodGhpcy50b1N0cmluZygpICsgYWRkci50b1N0cmluZygpKVxuICB9XG5cbiAgLyoqXG4gICAqIERlY2Fwc3VsYXRlcyBhIE11bHRpYWRkciBmcm9tIGFub3RoZXIgTXVsdGlhZGRyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1oMSA9IG5ldyBNdWx0aWFkZHIoJy9pcDQvOC44LjguOC90Y3AvMTA4MCcpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzOCAtIC9pcDQvOC44LjguOC90Y3AvMTA4MD5cbiAgICpcbiAgICogY29uc3QgbWgyID0gbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAgICpcbiAgICogY29uc3QgbWgzID0gbWgxLmVuY2Fwc3VsYXRlKG1oMilcbiAgICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4MDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvOC44LjguOC90Y3AvMTA4MC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICAgKlxuICAgKiBtaDMuZGVjYXBzdWxhdGUobWgyKS50b1N0cmluZygpXG4gICAqIC8vICcvaXA0LzguOC44LjgvdGNwLzEwODAnXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpYWRkciB8IHN0cmluZ30gYWRkciAtIE11bHRpYWRkciB0byByZW1vdmUgZnJvbSB0aGlzIE11bHRpYWRkclxuICAgKiBAcmV0dXJucyB7TXVsdGlhZGRyfVxuICAgKi9cbiAgZGVjYXBzdWxhdGUgKGFkZHIpIHtcbiAgICBjb25zdCBhZGRyU3RyaW5nID0gYWRkci50b1N0cmluZygpXG4gICAgY29uc3QgcyA9IHRoaXMudG9TdHJpbmcoKVxuICAgIGNvbnN0IGkgPSBzLmxhc3RJbmRleE9mKGFkZHJTdHJpbmcpXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3MgJyArIHRoaXMgKyAnIGRvZXMgbm90IGNvbnRhaW4gc3ViYWRkcmVzczogJyArIGFkZHIpXG4gICAgfVxuICAgIHJldHVybiBuZXcgTXVsdGlhZGRyKHMuc2xpY2UoMCwgaSkpXG4gIH1cblxuICAvKipcbiAgICogQSBtb3JlIHJlbGlhYmxlIHZlcnNpb24gb2YgYGRlY2Fwc3VsYXRlYCBpZiB5b3UgYXJlIHRhcmdldGluZyBhXG4gICAqIHNwZWNpZmljIGNvZGUsIHN1Y2ggYXMgNDIxICh0aGUgYHAycGAgcHJvdG9jb2wgY29kZSkuIFRoZSBsYXN0IGluZGV4IG9mIHRoZSBjb2RlXG4gICAqIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBgTXVsdGlhZGRyYCwgYW5kIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIElmIHRoZSBjb2RlIGlzIG5vdCBwcmVzZW50LCB0aGUgb3JpZ2luYWwgYE11bHRpYWRkcmAgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGFkZHIgPSBuZXcgTXVsdGlhZGRyKCcvaXA0LzAuMC4wLjAvdGNwLzgwODAvcDJwL1FtY2dwc3lXZ0g4WThhakp6MUN1NzJLblM1dW8yQWEyTHB6VTdraW5TdXBOS0MnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0MDAuLi4gLSAvaXA0LzAuMC4wLjAvdGNwLzgwODAvcDJwL1FtY2dwc3lXZ0g4WThhakp6MUN1NzJLblM1dW8yQWEyTHB6VTdraW5TdXBOS0M+XG4gICAqXG4gICAqIGFkZHIuZGVjYXBzdWxhdGVDb2RlKDQyMSkudG9TdHJpbmcoKVxuICAgKiAvLyAnL2lwNC8wLjAuMC4wL3RjcC84MDgwJ1xuICAgKlxuICAgKiBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvODA4MCcpLmRlY2Fwc3VsYXRlQ29kZSg0MjEpLnRvU3RyaW5nKClcbiAgICogLy8gJy9pcDQvMTI3LjAuMC4xL3RjcC84MDgwJ1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgLSBUaGUgY29kZSBvZiB0aGUgcHJvdG9jb2wgdG8gZGVjYXBzdWxhdGUgZnJvbSB0aGlzIE11bHRpYWRkclxuICAgKiBAcmV0dXJucyB7TXVsdGlhZGRyfVxuICAgKi9cbiAgZGVjYXBzdWxhdGVDb2RlIChjb2RlKSB7XG4gICAgY29uc3QgdHVwbGVzID0gdGhpcy50dXBsZXMoKVxuICAgIGZvciAobGV0IGkgPSB0dXBsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0dXBsZXNbaV1bMF0gPT09IGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWFkZHIoY29kZWMudHVwbGVzVG9CeXRlcyh0dXBsZXMuc2xpY2UoMCwgaSkpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHBlZXJJZCBpZiB0aGUgbXVsdGlhZGRyIGNvbnRhaW5zIG9uZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtaDEgPSBuZXcgTXVsdGlhZGRyKCcvaXA0LzguOC44LjgvdGNwLzEwODAvaXBmcy9RbVZhbGlkQmFzZTU4c3RyaW5nJylcbiAgICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4IC0gL2lwNC84LjguOC44L3RjcC8xMDgwL2lwZnMvUW1WYWxpZEJhc2U1OHN0cmluZz5cbiAgICpcbiAgICogLy8gc2hvdWxkIHJldHVybiBRbVZhbGlkQmFzZTU4c3RyaW5nIG9yIG51bGwgaWYgdGhlIGlkIGlzIG1pc3Npbmcgb3IgaW52YWxpZFxuICAgKiBjb25zdCBwZWVySWQgPSBtaDEuZ2V0UGVlcklkKClcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfSBwZWVySWQgLSBUaGUgaWQgb2YgdGhlIHBlZXIgb3IgbnVsbCBpZiBpbnZhbGlkIG9yIG1pc3NpbmcgZnJvbSB0aGUgbWFcbiAgICovXG4gIGdldFBlZXJJZCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHR1cGxlcyA9IHRoaXMuc3RyaW5nVHVwbGVzKCkuZmlsdGVyKCh0dXBsZSkgPT4ge1xuICAgICAgICBpZiAodHVwbGVbMF0gPT09IHByb3RvY29scy5uYW1lcy5pcGZzLmNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSlcblxuICAgICAgLy8gR2V0IHRoZSBsYXN0IGlwZnMgdHVwbGUgWydpcGZzJywgJ3BlZXJpZCBzdHJpbmcnXVxuICAgICAgY29uc3QgdHVwbGUgPSB0dXBsZXMucG9wKClcbiAgICAgIGlmICh0dXBsZSAmJiB0dXBsZVsxXSkge1xuICAgICAgICBjb25zdCBwZWVySWRTdHIgPSB0dXBsZVsxXVxuXG4gICAgICAgIC8vIHBlZXIgaWQgaXMgYmFzZTU4YnRjIGVuY29kZWQgc3RyaW5nIGJ1dCBub3QgbXVsdGliYXNlIGVuY29kZWQgc28gYWRkIHRoZSBgemBcbiAgICAgICAgLy8gcHJlZml4IHNvIHdlIGNhbiB2YWxpZGF0ZSB0aGF0IGl0IGlzIGNvcnJlY3RseSBlbmNvZGVkXG4gICAgICAgIGlmIChwZWVySWRTdHJbMF0gPT09ICdRJyB8fCBwZWVySWRTdHJbMF0gPT09ICcxJykge1xuICAgICAgICAgIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoYmFzZTU4YnRjLmRlY29kZShgeiR7cGVlcklkU3RyfWApLCAnYmFzZTU4YnRjJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byBwYXJzZSBwZWVyIGlkIGFzIENJRFxuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvU3RyaW5nKENJRC5wYXJzZShwZWVySWRTdHIpLm11bHRpaGFzaC5ieXRlcywgJ2Jhc2U1OGJ0YycpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgcGF0aCBpZiB0aGUgbXVsdGlhZGRyIGNvbnRhaW5zIG9uZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtaDEgPSBuZXcgTXVsdGlhZGRyKCcvaXA0LzguOC44LjgvdGNwLzEwODAvdW5peC90bXAvcDJwLnNvY2snKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0MDgwODA4MDgwNjA0MzggLSAvaXA0LzguOC44LjgvdGNwLzEwODAvdW5peC90bXAvcDJwLnNvY2s+XG4gICAqXG4gICAqIC8vIHNob3VsZCByZXR1cm4gdXRmOCBzdHJpbmcgb3IgbnVsbCBpZiB0aGUgaWQgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gICAqIGNvbnN0IHBhdGggPSBtaDEuZ2V0UGF0aCgpXG4gICAqIGBgYGpzXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfSBwYXRoIC0gVGhlIHBhdGggb2YgdGhlIG11bHRpYWRkciwgb3IgbnVsbCBpZiBubyBwYXRoIHByb3RvY29sIGlzIHByZXNlbnRcbiAgICovXG4gIGdldFBhdGggKCkge1xuICAgIGxldCBwYXRoID0gbnVsbFxuICAgIHRyeSB7XG4gICAgICBwYXRoID0gdGhpcy5zdHJpbmdUdXBsZXMoKS5maWx0ZXIoKHR1cGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gcHJvdG9jb2xzKHR1cGxlWzBdKVxuICAgICAgICBpZiAocHJvdG8ucGF0aCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9KVswXVsxXVxuXG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcGF0aCA9IG51bGxcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBwYXRoID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gTXVsdGlhZGRycyBhcmUgdGhlIHNhbWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgbWgxID0gbmV3IE11bHRpYWRkcignL2lwNC84LjguOC44L3RjcC8xMDgwJylcbiAgICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4IC0gL2lwNC84LjguOC44L3RjcC8xMDgwPlxuICAgKlxuICAgKiBjb25zdCBtaDIgPSBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICAgKlxuICAgKiBtaDEuZXF1YWxzKG1oMSlcbiAgICogLy8gdHJ1ZVxuICAgKlxuICAgKiBtaDEuZXF1YWxzKG1oMilcbiAgICogLy8gZmFsc2VcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlhZGRyfSBhZGRyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzIChhZGRyKSB7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlFcXVhbHModGhpcy5ieXRlcywgYWRkci5ieXRlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIG11bHRpYWRkciBpZiBjb250YWluaW5nIHJlc29sdmFibGUgaG9zdG5hbWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIE11bHRpYWRkci5yZXNvbHZlcnMuc2V0KCdkbnNhZGRyJywgcmVzb2x2ZXJGdW5jdGlvbilcbiAgICogY29uc3QgbWgxID0gbmV3IE11bHRpYWRkcignL2Ruc2FkZHIvYm9vdHN0cmFwLmxpYnAycC5pby9wMnAvUW1iTEhBbk1vSlBXU0NSNVpodHg2QkhKWDlLaUtOTjZ0cHZiVWNxYW5qNzVOYicpXG4gICAqIGNvbnN0IHJlc29sdmVkTXVsdGlhZGRycyA9IGF3YWl0IG1oMS5yZXNvbHZlKClcbiAgICogLy8gW1xuICAgKiAvLyAgIDxNdWx0aWFkZHIgMDQ5MzRiNTM1MzA2MGZhMWE1MDMyMjEyMjBjMTBmOTMxOWRhYzM1YzI3MGE2Yjc0Y2Q2NDRjYjNhY2ZjMWY2ZWZjOGM4MjFmOGViMjgyNTk5ZmQxODE0ZjY0IC0gL2lwNC8xNDcuNzUuODMuODMvdGNwLzQwMDEvcDJwL1FtYkxIQW5Nb0pQV1NDUjVaaHR4NkJISlg5S2lLTk42dHB2YlVjcWFuajc1TmI+LFxuICAgKiAvLyAgIDxNdWx0aWFkZHIgMDQ5MzRiNTM1MzA2MDFiYmRlMDNhNTAzMjIxMjIwYzEwZjkzMTlkYWMzNWMyNzBhNmI3NGNkNjQ0Y2IzYWNmYzFmNmVmYzhjODIxZjhlYjI4MjU5OWZkMTgxNGY2NCAtIC9pcDQvMTQ3Ljc1LjgzLjgzL3RjcC80NDMvd3NzL3AycC9RbWJMSEFuTW9KUFdTQ1I1Wmh0eDZCSEpYOUtpS05ONnRwdmJVY3Fhbmo3NU5iPixcbiAgICogLy8gICA8TXVsdGlhZGRyIDA0OTM0YjUzNTM5MTAyMGZhMWNjMDNhNTAzMjIxMjIwYzEwZjkzMTlkYWMzNWMyNzBhNmI3NGNkNjQ0Y2IzYWNmYzFmNmVmYzhjODIxZjhlYjI4MjU5OWZkMTgxNGY2NCAtIC9pcDQvMTQ3Ljc1LjgzLjgzL3VkcC80MDAxL3F1aWMvcDJwL1FtYkxIQW5Nb0pQV1NDUjVaaHR4NkJISlg5S2lLTk42dHB2YlVjcWFuajc1TmI+XG4gICAqIC8vIF1cbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE11bHRpYWRkcj4+fVxuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZSAoKSB7XG4gICAgY29uc3QgcmVzb2x2YWJsZVByb3RvID0gdGhpcy5wcm90b3MoKS5maW5kKChwKSA9PiBwLnJlc29sdmFibGUpXG5cbiAgICAvLyBNdWx0aWFkZHIgaXMgbm90IHJlc29sdmFibGU/XG4gICAgaWYgKCFyZXNvbHZhYmxlUHJvdG8pIHtcbiAgICAgIHJldHVybiBbdGhpc11cbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlciA9IHJlc29sdmVycy5nZXQocmVzb2x2YWJsZVByb3RvLm5hbWUpXG4gICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSByZXNvbHZlciBmb3IgJHtyZXNvbHZhYmxlUHJvdG8ubmFtZX1gKSwgJ0VSUl9OT19BVkFJTEFCTEVfUkVTT0xWRVInKVxuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IHJlc29sdmVyKHRoaXMpXG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5tYXAoKGEpID0+IG5ldyBNdWx0aWFkZHIoYSkpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIE11bHRpYWRkcnMgbm9kZS1mcmllbmRseSBhZGRyZXNzIG9iamVjdC4gTm90ZSB0aGF0IHByb3RvY29sIGluZm9ybWF0aW9uXG4gICAqIGlzIGxlZnQgb3V0OiBpbiBOb2RlIChhbmQgbW9zdCBuZXR3b3JrIHN5c3RlbXMpIHRoZSBwcm90b2NvbCBpcyB1bmtub3dhYmxlXG4gICAqIGdpdmVuIG9ubHkgdGhlIGFkZHJlc3MuXG4gICAqXG4gICAqIEhhcyB0byBiZSBhIFRoaW5XYWlzdCBBZGRyZXNzLCBvdGhlcndpc2UgdGhyb3dzIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykubm9kZUFkZHJlc3MoKVxuICAgKiAvLyB7ZmFtaWx5OiA0LCBhZGRyZXNzOiAnMTI3LjAuMC4xJywgcG9ydDogNDAwMX1cbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIHt7ZmFtaWx5OiA0IHwgNiwgYWRkcmVzczogc3RyaW5nLCBwb3J0OiBudW1iZXJ9fVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGVycm9yIGlmIE11bHRpYWRkciBpcyBub3QgYSBUaGluIFdhaXN0IGFkZHJlc3NcbiAgICovXG4gIG5vZGVBZGRyZXNzICgpIHtcbiAgICBjb25zdCBjb2RlcyA9IHRoaXMucHJvdG9Db2RlcygpXG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLnByb3RvTmFtZXMoKVxuICAgIGNvbnN0IHBhcnRzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KCcvJykuc2xpY2UoMSlcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPCA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpYWRkciBtdXN0IGhhdmUgYSB2YWxpZCBmb3JtYXQ6IFwiL3tpcDQsIGlwNiwgZG5zNCwgZG5zNn0ve2FkZHJlc3N9L3t0Y3AsIHVkcH0ve3BvcnR9XCIuJylcbiAgICB9IGVsc2UgaWYgKGNvZGVzWzBdICE9PSA0ICYmIGNvZGVzWzBdICE9PSA0MSAmJiBjb2Rlc1swXSAhPT0gNTQgJiYgY29kZXNbMF0gIT09IDU1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIHByb3RvY29sIHdpdGggbmFtZTogXCInJHtuYW1lc1swXX0nXCIuIE11c3QgaGF2ZSBhIHZhbGlkIGZhbWlseSBuYW1lOiBcIntpcDQsIGlwNiwgZG5zNCwgZG5zNn1cIi5gKVxuICAgIH0gZWxzZSBpZiAocGFydHNbMl0gIT09ICd0Y3AnICYmIHBhcnRzWzJdICE9PSAndWRwJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBwcm90b2NvbCB3aXRoIG5hbWU6IFwiJyR7bmFtZXNbMV19J1wiLiBNdXN0IGhhdmUgYSB2YWxpZCB0cmFuc3BvcnQgcHJvdG9jb2w6IFwie3RjcCwgdWRwfVwiLmApXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZhbWlseTogKGNvZGVzWzBdID09PSA0MSB8fCBjb2Rlc1swXSA9PT0gNTUpID8gNiA6IDQsXG4gICAgICBhZGRyZXNzOiBwYXJ0c1sxXSxcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzNdKSAvLyB0Y3Agb3IgdWRwIHBvcnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiBhIE11bHRpYWRkciBpcyBhIFRoaW4gV2Fpc3QgYWRkcmVzcyBvciBub3QuXG4gICAqXG4gICAqIFRoaW4gV2Fpc3QgaXMgaWYgYSBNdWx0aWFkZHIgYWRoZXJlcyB0byB0aGUgc3RhbmRhcmQgY29tYmluYXRpb24gb2Y6XG4gICAqXG4gICAqIGB7SVB2NCwgSVB2Nn0ve1RDUCwgVURQfWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgbWgxID0gbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAgICogY29uc3QgbWgyID0gbmV3IE11bHRpYWRkcignL2lwNC8xOTIuMTY4LjIuMS90Y3AvNTAwMScpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDRjMGE4MDIwMTA2MTM4OSAtIC9pcDQvMTkyLjE2OC4yLjEvdGNwLzUwMDE+XG4gICAqIGNvbnN0IG1oMyA9IG1oMS5lbmNhcHN1bGF0ZShtaDIpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMTA0YzBhODAyMDEwNjEzODkgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMS9pcDQvMTkyLjE2OC4yLjEvdGNwLzUwMDE+XG4gICAqIGNvbnN0IG1oNCA9IG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC8yMDAwL3dzcy9wMnAtd2VicnRjLXN0YXIvcDJwL1FtY2dwc3lXZ0g4WThhakp6MUN1NzJLblM1dW8yQWEyTHB6VTdraW5Tb29vMmEnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjA3ZDBkZTAzOTMwMmE1MDMyMjEyMjBkNTJlYmI4OWQ4NWIwMmEyODQ5NDgyMDNhNjJmZjI4Mzg5YzU3YzlmNDJiZWVjNGVjMjBkYjc2YTY0ODM1ODQzIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzIwMDAvd3NzL3AycC13ZWJydGMtc3Rhci9wMnAvUW1jZ3BzeVdnSDhZOGFqSnoxQ3U3MktuUzV1bzJBYTJMcHpVN2tpblNvb28yYT5cbiAgICogbWgxLmlzVGhpbldhaXN0QWRkcmVzcygpXG4gICAqIC8vIHRydWVcbiAgICogbWgyLmlzVGhpbldhaXN0QWRkcmVzcygpXG4gICAqIC8vIHRydWVcbiAgICogbWgzLmlzVGhpbldhaXN0QWRkcmVzcygpXG4gICAqIC8vIGZhbHNlXG4gICAqIG1oNC5pc1RoaW5XYWlzdEFkZHJlc3MoKVxuICAgKiAvLyBmYWxzZVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWFkZHJ9IFthZGRyXSAtIERlZmF1bHRzIHRvIHVzaW5nIGB0aGlzYCBpbnN0YW5jZVxuICAgKi9cbiAgaXNUaGluV2Fpc3RBZGRyZXNzIChhZGRyKSB7XG4gICAgY29uc3QgcHJvdG9zID0gKGFkZHIgfHwgdGhpcykucHJvdG9zKClcblxuICAgIGlmIChwcm90b3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAocHJvdG9zWzBdLmNvZGUgIT09IDQgJiYgcHJvdG9zWzBdLmNvZGUgIT09IDQxKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHByb3Rvc1sxXS5jb2RlICE9PSA2ICYmIHByb3Rvc1sxXS5jb2RlICE9PSAyNzMpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBNdWx0aWFkZHIgZnJvbSBhIG5vZGUtZnJpZW5kbHkgYWRkcmVzcyBvYmplY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogTXVsdGlhZGRyLmZyb21Ob2RlQWRkcmVzcyh7YWRkcmVzczogJzEyNy4wLjAuMScsIHBvcnQ6ICc0MDAxJ30sICd0Y3AnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7e2ZhbWlseTogNCB8IDYsIGFkZHJlc3M6IHN0cmluZywgcG9ydDogbnVtYmVyfX0gYWRkclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNwb3J0XG4gICAqL1xuICBzdGF0aWMgZnJvbU5vZGVBZGRyZXNzIChhZGRyLCB0cmFuc3BvcnQpIHtcbiAgICBpZiAoIWFkZHIpIHsgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBub2RlIGFkZHJlc3Mgb2JqZWN0JykgfVxuICAgIGlmICghdHJhbnNwb3J0KSB7IHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgdHJhbnNwb3J0IHByb3RvY29sJykgfVxuICAgIGxldCBpcFxuICAgIHN3aXRjaCAoYWRkci5mYW1pbHkpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaXAgPSAnaXA0J1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSA2OlxuICAgICAgICBpcCA9ICdpcDYnXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBhZGRyIGZhbWlseS4gR290ICcke2FkZHIuZmFtaWx5fScgaW5zdGVhZCBvZiA0IG9yIDZgKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE11bHRpYWRkcignLycgKyBbaXAsIGFkZHIuYWRkcmVzcywgdHJhbnNwb3J0LCBhZGRyLnBvcnRdLmpvaW4oJy8nKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHNvbWV0aGluZyBpcyBhIE11bHRpYWRkciB0aGF0IGlzIGEgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpYWRkcn0gYWRkclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXNOYW1lXG4gICAqL1xuICBzdGF0aWMgaXNOYW1lIChhZGRyKSB7XG4gICAgaWYgKCFNdWx0aWFkZHIuaXNNdWx0aWFkZHIoYWRkcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIGlmIGEgcGFydCBvZiB0aGUgbXVsdGlhZGRyIGlzIHJlc29sdmFibGUsIHRoZW4gcmV0dXJuIHRydWVcbiAgICByZXR1cm4gYWRkci5wcm90b3MoKS5zb21lKChwcm90bykgPT4gcHJvdG8ucmVzb2x2YWJsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBvYmplY3QgaXMgYSBDSUQgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEByZXR1cm5zIHt2YWx1ZSBpcyBNdWx0aWFkZHJ9XG4gICAqL1xuICBzdGF0aWMgaXNNdWx0aWFkZHIgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTXVsdGlhZGRyIHx8IEJvb2xlYW4odmFsdWUgJiYgdmFsdWVbc3ltYm9sXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbiAgICogRm9yIHBvc3QgTm9kZS5qcyB2MTAuMC4wLlxuICAgKiBodHRwczovL25vZGVqcy5vcmcvYXBpL2RlcHJlY2F0aW9ucy5odG1sI2RlcHJlY2F0aW9uc19kZXAwMDc5X2N1c3RvbV9pbnNwZWN0aW9uX2Z1bmN0aW9uX29uX29iamVjdHNfdmlhX2luc3BlY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc29sZS5sb2cobmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKSlcbiAgICogLy8gJzxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPidcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBbaW5zcGVjdF0gKCkge1xuICAgIHJldHVybiAnPE11bHRpYWRkciAnICtcbiAgICB1aW50OEFycmF5VG9TdHJpbmcodGhpcy5ieXRlcywgJ2Jhc2UxNicpICsgJyAtICcgK1xuICAgIGNvZGVjLmJ5dGVzVG9TdHJpbmcodGhpcy5ieXRlcykgKyAnPidcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbiAgICogRmFsbGJhY2sgZm9yIHByZSBOb2RlLmpzIHYxMC4wLjAuXG4gICAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZGVwcmVjYXRpb25zLmh0bWwjZGVwcmVjYXRpb25zX2RlcDAwNzlfY3VzdG9tX2luc3BlY3Rpb25fZnVuY3Rpb25fb25fb2JqZWN0c192aWFfaW5zcGVjdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLmluc3BlY3QoKVxuICAgKiAvLyAnPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+J1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAnPE11bHRpYWRkciAnICtcbiAgICAgIHVpbnQ4QXJyYXlUb1N0cmluZyh0aGlzLmJ5dGVzLCAnYmFzZTE2JykgKyAnIC0gJyArXG4gICAgICBjb2RlYy5ieXRlc1RvU3RyaW5nKHRoaXMuYnl0ZXMpICsgJz4nXG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyB0YWJsZSwgbmFtZXMgYW5kIGNvZGVzIG9mIGFsbCBzdXBwb3J0ZWQgcHJvdG9jb2xzLlxuICogVG8gZ2V0IHRoZSBwcm90b2NvbCB2YWx1ZXMgZnJvbSBhIE11bHRpYWRkciwgeW91IGNhbiB1c2VcbiAqIFtgLnByb3RvcygpYF0oI211bHRpYWRkcnByb3RvcyksXG4gKiBbYC5wcm90b0NvZGVzKClgXSgjbXVsdGlhZGRycHJvdG9jb2Rlcykgb3JcbiAqIFtgLnByb3RvTmFtZXMoKWBdKCNtdWx0aWFkZHJwcm90b25hbWVzKVxuICpcbiAqIEByZXR1cm5zIHt7dGFibGU6IEFycmF5LCBuYW1lczogT2JqZWN0LCBjb2RlczogT2JqZWN0fX1cbiAqL1xuTXVsdGlhZGRyLnByb3RvY29scyA9IHByb3RvY29sc1xuXG5NdWx0aWFkZHIucmVzb2x2ZXJzID0gcmVzb2x2ZXJzXG5cbi8qKlxuICogU3RhdGljIGZhY3RvcnlcbiAqXG4gKiBAcGFyYW0ge011bHRpYWRkcklucHV0fSBhZGRyXG4gKi9cbmZ1bmN0aW9uIG11bHRpYWRkciAoYWRkcikge1xuICByZXR1cm4gbmV3IE11bHRpYWRkcihhZGRyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgTXVsdGlhZGRyLCBtdWx0aWFkZHIsIHByb3RvY29scywgcmVzb2x2ZXJzIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/src/ip.js":
/*!******************************************!*\
  !*** ./node_modules/multiaddr/src/ip.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isIp = __webpack_require__(/*! is-ip */ \"(ssr)/./node_modules/is-ip/index.js\")\nconst { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ \"(ssr)/./node_modules/multiaddr/node_modules/uint8arrays/cjs/src/to-string.js\")\n\nconst isIP = isIp\nconst isV4 = isIp.v4\nconst isV6 = isIp.v6\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// @ts-ignore - this is copied from the link above better to keep it the same\nconst toBytes = function (ip, buff, offset) {\n  offset = ~~offset\n\n  let result\n\n  if (isV4(ip)) {\n    result = buff || new Uint8Array(offset + 4)\n    // @ts-ignore\n    // eslint-disable-next-line array-callback-return\n    ip.split(/\\./g).map(function (byte) {\n      result[offset++] = parseInt(byte, 10) & 0xff\n    })\n  } else if (isV6(ip)) {\n    const sections = ip.split(':', 8)\n\n    let i\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = isV4(sections[i])\n      let v4Buffer\n\n      if (isv4) {\n        v4Buffer = toBytes(sections[i])\n        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16')\n      }\n\n      if (v4Buffer && ++i < 8) {\n        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'))\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0')\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0')\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      const argv = [i, '1']\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0')\n      }\n      sections.splice.apply(sections, argv)\n    }\n\n    result = buff || new Uint8Array(offset + 16)\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16)\n      result[offset++] = (word >> 8) & 0xff\n      result[offset++] = word & 0xff\n    }\n  }\n\n  if (!result) {\n    throw Error('Invalid ip address: ' + ip)\n  }\n\n  return result\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\n// @ts-ignore - this is copied from the link above better to keep it the same\nconst toString = function (buff, offset, length) {\n  offset = ~~offset\n  length = length || (buff.length - offset)\n\n  const result = []\n  let string\n  const view = new DataView(buff.buffer)\n  if (length === 4) {\n    // IPv4\n    for (let i = 0; i < length; i++) {\n      result.push(buff[offset + i])\n    }\n    string = result.join('.')\n  } else if (length === 16) {\n    // IPv6\n    for (let i = 0; i < length; i += 2) {\n      result.push(view.getUint16(offset + i).toString(16))\n    }\n    string = result.join(':')\n    string = string.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n    string = string.replace(/:{3,4}/, '::')\n  }\n\n  return string\n}\n\nmodule.exports = {\n  isIP,\n  isV4,\n  isV6,\n  toBytes,\n  toString\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL3NyYy9pcC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsa0RBQU87QUFDNUIsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLDJHQUF1Qjs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL211bHRpYWRkci9zcmMvaXAuanM/NDE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgaXNJcCA9IHJlcXVpcmUoJ2lzLWlwJylcbmNvbnN0IHsgdG9TdHJpbmc6IHVpbnQ4QXJyYXlUb1N0cmluZyB9ID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcblxuY29uc3QgaXNJUCA9IGlzSXBcbmNvbnN0IGlzVjQgPSBpc0lwLnY0XG5jb25zdCBpc1Y2ID0gaXNJcC52NlxuXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ub2RlLWlwL2Jsb2IvbWFzdGVyL2xpYi9pcC5qcyNMN1xuLy8gQHRzLWlnbm9yZSAtIHRoaXMgaXMgY29waWVkIGZyb20gdGhlIGxpbmsgYWJvdmUgYmV0dGVyIHRvIGtlZXAgaXQgdGhlIHNhbWVcbmNvbnN0IHRvQnl0ZXMgPSBmdW5jdGlvbiAoaXAsIGJ1ZmYsIG9mZnNldCkge1xuICBvZmZzZXQgPSB+fm9mZnNldFxuXG4gIGxldCByZXN1bHRcblxuICBpZiAoaXNWNChpcCkpIHtcbiAgICByZXN1bHQgPSBidWZmIHx8IG5ldyBVaW50OEFycmF5KG9mZnNldCArIDQpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICBpcC5zcGxpdCgvXFwuL2cpLm1hcChmdW5jdGlvbiAoYnl0ZSkge1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9IHBhcnNlSW50KGJ5dGUsIDEwKSAmIDB4ZmZcbiAgICB9KVxuICB9IGVsc2UgaWYgKGlzVjYoaXApKSB7XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBpcC5zcGxpdCgnOicsIDgpXG5cbiAgICBsZXQgaVxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXN2NCA9IGlzVjQoc2VjdGlvbnNbaV0pXG4gICAgICBsZXQgdjRCdWZmZXJcblxuICAgICAgaWYgKGlzdjQpIHtcbiAgICAgICAgdjRCdWZmZXIgPSB0b0J5dGVzKHNlY3Rpb25zW2ldKVxuICAgICAgICBzZWN0aW9uc1tpXSA9IHVpbnQ4QXJyYXlUb1N0cmluZyh2NEJ1ZmZlci5zbGljZSgwLCAyKSwgJ2Jhc2UxNicpXG4gICAgICB9XG5cbiAgICAgIGlmICh2NEJ1ZmZlciAmJiArK2kgPCA4KSB7XG4gICAgICAgIHNlY3Rpb25zLnNwbGljZShpLCAwLCB1aW50OEFycmF5VG9TdHJpbmcodjRCdWZmZXIuc2xpY2UoMiwgNCksICdiYXNlMTYnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VjdGlvbnNbMF0gPT09ICcnKSB7XG4gICAgICB3aGlsZSAoc2VjdGlvbnMubGVuZ3RoIDwgOCkgc2VjdGlvbnMudW5zaGlmdCgnMCcpXG4gICAgfSBlbHNlIGlmIChzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgIHdoaWxlIChzZWN0aW9ucy5sZW5ndGggPCA4KSBzZWN0aW9ucy5wdXNoKCcwJylcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGggJiYgc2VjdGlvbnNbaV0gIT09ICcnOyBpKyspO1xuICAgICAgY29uc3QgYXJndiA9IFtpLCAnMSddXG4gICAgICBmb3IgKGkgPSA5IC0gc2VjdGlvbnMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3YucHVzaCgnMCcpXG4gICAgICB9XG4gICAgICBzZWN0aW9ucy5zcGxpY2UuYXBwbHkoc2VjdGlvbnMsIGFyZ3YpXG4gICAgfVxuXG4gICAgcmVzdWx0ID0gYnVmZiB8fCBuZXcgVWludDhBcnJheShvZmZzZXQgKyAxNilcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHdvcmQgPSBwYXJzZUludChzZWN0aW9uc1tpXSwgMTYpXG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gKHdvcmQgPj4gOCkgJiAweGZmXG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gd29yZCAmIDB4ZmZcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGlwIGFkZHJlc3M6ICcgKyBpcClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvbm9kZS1pcC9ibG9iL21hc3Rlci9saWIvaXAuanMjTDYzXG4vLyBAdHMtaWdub3JlIC0gdGhpcyBpcyBjb3BpZWQgZnJvbSB0aGUgbGluayBhYm92ZSBiZXR0ZXIgdG8ga2VlcCBpdCB0aGUgc2FtZVxuY29uc3QgdG9TdHJpbmcgPSBmdW5jdGlvbiAoYnVmZiwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gfn5vZmZzZXRcbiAgbGVuZ3RoID0gbGVuZ3RoIHx8IChidWZmLmxlbmd0aCAtIG9mZnNldClcblxuICBjb25zdCByZXN1bHQgPSBbXVxuICBsZXQgc3RyaW5nXG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpXG4gIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAvLyBJUHY0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYnVmZltvZmZzZXQgKyBpXSlcbiAgICB9XG4gICAgc3RyaW5nID0gcmVzdWx0LmpvaW4oJy4nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMTYpIHtcbiAgICAvLyBJUHY2XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgcmVzdWx0LnB1c2godmlldy5nZXRVaW50MTYob2Zmc2V0ICsgaSkudG9TdHJpbmcoMTYpKVxuICAgIH1cbiAgICBzdHJpbmcgPSByZXN1bHQuam9pbignOicpXG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLyhefDopMCg6MCkqOjAoOnwkKS8sICckMTo6JDMnKVxuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC86ezMsNH0vLCAnOjonKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNJUCxcbiAgaXNWNCxcbiAgaXNWNixcbiAgdG9CeXRlcyxcbiAgdG9TdHJpbmdcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/src/ip.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/multiaddr/src/protocols-table.js":
/*!*******************************************************!*\
  !*** ./node_modules/multiaddr/src/protocols-table.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\n/** @typedef {import(\"./types\").Protocol} Protocol */\n\n/**\n * Protocols\n *\n * @param {number | string} proto\n * @returns {Protocol}\n */\nfunction Protocols (proto) {\n  if (typeof (proto) === 'number') {\n    if (Protocols.codes[proto]) {\n      return Protocols.codes[proto]\n    }\n\n    throw new Error('no protocol with code: ' + proto)\n  } else if (typeof (proto) === 'string') {\n    if (Protocols.names[proto]) {\n      return Protocols.names[proto]\n    }\n\n    throw new Error('no protocol with name: ' + proto)\n  }\n\n  throw new Error('invalid protocol id type: ' + proto)\n}\n\nconst V = -1\nProtocols.lengthPrefixedVarSize = V\nProtocols.V = V\n\n/** @type {Array<[number, number, string, (string|boolean)?, string?]>} */\nProtocols.table = [\n  [4, 32, 'ip4'],\n  [6, 16, 'tcp'],\n  [33, 16, 'dccp'],\n  [41, 128, 'ip6'],\n  [42, V, 'ip6zone'],\n  [53, V, 'dns', 'resolvable'],\n  [54, V, 'dns4', 'resolvable'],\n  [55, V, 'dns6', 'resolvable'],\n  [56, V, 'dnsaddr', 'resolvable'],\n  [132, 16, 'sctp'],\n  [273, 16, 'udp'],\n  [275, 0, 'p2p-webrtc-star'],\n  [276, 0, 'p2p-webrtc-direct'],\n  [277, 0, 'p2p-stardust'],\n  [290, 0, 'p2p-circuit'],\n  [301, 0, 'udt'],\n  [302, 0, 'utp'],\n  [400, V, 'unix', false, 'path'],\n  // `ipfs` is added before `p2p` for legacy support.\n  // All text representations will default to `p2p`, but `ipfs` will\n  // still be supported\n  [421, V, 'ipfs'],\n  // `p2p` is the preferred name for 421, and is now the default\n  [421, V, 'p2p'],\n  [443, 0, 'https'],\n  [444, 96, 'onion'],\n  [445, 296, 'onion3'],\n  [446, V, 'garlic64'],\n  [460, 0, 'quic'],\n  [477, 0, 'ws'],\n  [478, 0, 'wss'],\n  [479, 0, 'p2p-websocket-star'],\n  [480, 0, 'http'],\n  [777, V, 'memory']\n]\n/** @type {Record<string,Protocol>} */\nProtocols.names = {}\n/** @type {Record<number,Protocol>} */\nProtocols.codes = {}\n\n// populate tables\nProtocols.table.map(row => {\n  const proto = p.apply(null, row)\n  Protocols.codes[proto.code] = proto\n  Protocols.names[proto.name] = proto\n  return null\n})\n\nProtocols.object = p\n\n/**\n *\n * Create a protocol\n *\n * @param {number} code\n * @param {number} size\n * @param {string} name\n * @param {any} [resolvable]\n * @param {any} [path]\n * @returns {Protocol}\n */\nfunction p (code, size, name, resolvable, path) {\n  return {\n    code,\n    size,\n    name,\n    resolvable: Boolean(resolvable),\n    path: Boolean(path)\n  }\n}\n\nmodule.exports = Protocols\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL3NyYy9wcm90b2NvbHMtdGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixjQUFjLDRCQUE0Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDZEQUE2RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBLFdBQVcseUJBQXlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL3Byb3RvY29scy10YWJsZS5qcz85MTBjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzXCIpLlByb3RvY29sfSBQcm90b2NvbCAqL1xuXG4vKipcbiAqIFByb3RvY29sc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSBwcm90b1xuICogQHJldHVybnMge1Byb3RvY29sfVxuICovXG5mdW5jdGlvbiBQcm90b2NvbHMgKHByb3RvKSB7XG4gIGlmICh0eXBlb2YgKHByb3RvKSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoUHJvdG9jb2xzLmNvZGVzW3Byb3RvXSkge1xuICAgICAgcmV0dXJuIFByb3RvY29scy5jb2Rlc1twcm90b11cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByb3RvY29sIHdpdGggY29kZTogJyArIHByb3RvKVxuICB9IGVsc2UgaWYgKHR5cGVvZiAocHJvdG8pID09PSAnc3RyaW5nJykge1xuICAgIGlmIChQcm90b2NvbHMubmFtZXNbcHJvdG9dKSB7XG4gICAgICByZXR1cm4gUHJvdG9jb2xzLm5hbWVzW3Byb3RvXVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJvdG9jb2wgd2l0aCBuYW1lOiAnICsgcHJvdG8pXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJvdG9jb2wgaWQgdHlwZTogJyArIHByb3RvKVxufVxuXG5jb25zdCBWID0gLTFcblByb3RvY29scy5sZW5ndGhQcmVmaXhlZFZhclNpemUgPSBWXG5Qcm90b2NvbHMuViA9IFZcblxuLyoqIEB0eXBlIHtBcnJheTxbbnVtYmVyLCBudW1iZXIsIHN0cmluZywgKHN0cmluZ3xib29sZWFuKT8sIHN0cmluZz9dPn0gKi9cblByb3RvY29scy50YWJsZSA9IFtcbiAgWzQsIDMyLCAnaXA0J10sXG4gIFs2LCAxNiwgJ3RjcCddLFxuICBbMzMsIDE2LCAnZGNjcCddLFxuICBbNDEsIDEyOCwgJ2lwNiddLFxuICBbNDIsIFYsICdpcDZ6b25lJ10sXG4gIFs1MywgViwgJ2RucycsICdyZXNvbHZhYmxlJ10sXG4gIFs1NCwgViwgJ2RuczQnLCAncmVzb2x2YWJsZSddLFxuICBbNTUsIFYsICdkbnM2JywgJ3Jlc29sdmFibGUnXSxcbiAgWzU2LCBWLCAnZG5zYWRkcicsICdyZXNvbHZhYmxlJ10sXG4gIFsxMzIsIDE2LCAnc2N0cCddLFxuICBbMjczLCAxNiwgJ3VkcCddLFxuICBbMjc1LCAwLCAncDJwLXdlYnJ0Yy1zdGFyJ10sXG4gIFsyNzYsIDAsICdwMnAtd2VicnRjLWRpcmVjdCddLFxuICBbMjc3LCAwLCAncDJwLXN0YXJkdXN0J10sXG4gIFsyOTAsIDAsICdwMnAtY2lyY3VpdCddLFxuICBbMzAxLCAwLCAndWR0J10sXG4gIFszMDIsIDAsICd1dHAnXSxcbiAgWzQwMCwgViwgJ3VuaXgnLCBmYWxzZSwgJ3BhdGgnXSxcbiAgLy8gYGlwZnNgIGlzIGFkZGVkIGJlZm9yZSBgcDJwYCBmb3IgbGVnYWN5IHN1cHBvcnQuXG4gIC8vIEFsbCB0ZXh0IHJlcHJlc2VudGF0aW9ucyB3aWxsIGRlZmF1bHQgdG8gYHAycGAsIGJ1dCBgaXBmc2Agd2lsbFxuICAvLyBzdGlsbCBiZSBzdXBwb3J0ZWRcbiAgWzQyMSwgViwgJ2lwZnMnXSxcbiAgLy8gYHAycGAgaXMgdGhlIHByZWZlcnJlZCBuYW1lIGZvciA0MjEsIGFuZCBpcyBub3cgdGhlIGRlZmF1bHRcbiAgWzQyMSwgViwgJ3AycCddLFxuICBbNDQzLCAwLCAnaHR0cHMnXSxcbiAgWzQ0NCwgOTYsICdvbmlvbiddLFxuICBbNDQ1LCAyOTYsICdvbmlvbjMnXSxcbiAgWzQ0NiwgViwgJ2dhcmxpYzY0J10sXG4gIFs0NjAsIDAsICdxdWljJ10sXG4gIFs0NzcsIDAsICd3cyddLFxuICBbNDc4LCAwLCAnd3NzJ10sXG4gIFs0NzksIDAsICdwMnAtd2Vic29ja2V0LXN0YXInXSxcbiAgWzQ4MCwgMCwgJ2h0dHAnXSxcbiAgWzc3NywgViwgJ21lbW9yeSddXG5dXG4vKiogQHR5cGUge1JlY29yZDxzdHJpbmcsUHJvdG9jb2w+fSAqL1xuUHJvdG9jb2xzLm5hbWVzID0ge31cbi8qKiBAdHlwZSB7UmVjb3JkPG51bWJlcixQcm90b2NvbD59ICovXG5Qcm90b2NvbHMuY29kZXMgPSB7fVxuXG4vLyBwb3B1bGF0ZSB0YWJsZXNcblByb3RvY29scy50YWJsZS5tYXAocm93ID0+IHtcbiAgY29uc3QgcHJvdG8gPSBwLmFwcGx5KG51bGwsIHJvdylcbiAgUHJvdG9jb2xzLmNvZGVzW3Byb3RvLmNvZGVdID0gcHJvdG9cbiAgUHJvdG9jb2xzLm5hbWVzW3Byb3RvLm5hbWVdID0gcHJvdG9cbiAgcmV0dXJuIG51bGxcbn0pXG5cblByb3RvY29scy5vYmplY3QgPSBwXG5cbi8qKlxuICpcbiAqIENyZWF0ZSBhIHByb3RvY29sXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHthbnl9IFtyZXNvbHZhYmxlXVxuICogQHBhcmFtIHthbnl9IFtwYXRoXVxuICogQHJldHVybnMge1Byb3RvY29sfVxuICovXG5mdW5jdGlvbiBwIChjb2RlLCBzaXplLCBuYW1lLCByZXNvbHZhYmxlLCBwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBzaXplLFxuICAgIG5hbWUsXG4gICAgcmVzb2x2YWJsZTogQm9vbGVhbihyZXNvbHZhYmxlKSxcbiAgICBwYXRoOiBCb29sZWFuKHBhdGgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b2NvbHNcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/multiaddr/src/protocols-table.js\n");

/***/ })

};
;