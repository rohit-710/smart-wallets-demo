"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_assert.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/_assert.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports[\"default\"] = assert;\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxjQUFjO0FBQzlGO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcz9jNWQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vdXRwdXQgPSBleHBvcnRzLmV4aXN0cyA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLmJvb2wgPSBleHBvcnRzLm51bWJlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_sha2.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/_sha2.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHA2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19zaGEyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWixxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanM/MTYwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0hBMiA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmNsYXNzIFNIQTIgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5vdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMiA9IFNIQTI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_u64.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/_u64.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexports.split = split;\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports[\"default\"] = u64;\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsZUFBZTtBQUN6VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcz9jOTFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQ1TCA9IGV4cG9ydHMuYWRkNUggPSBleHBvcnRzLmFkZDRIID0gZXhwb3J0cy5hZGQ0TCA9IGV4cG9ydHMuYWRkM0ggPSBleHBvcnRzLmFkZDNMID0gZXhwb3J0cy5hZGQgPSBleHBvcnRzLnJvdGxCTCA9IGV4cG9ydHMucm90bEJIID0gZXhwb3J0cy5yb3RsU0wgPSBleHBvcnRzLnJvdGxTSCA9IGV4cG9ydHMucm90cjMyTCA9IGV4cG9ydHMucm90cjMySCA9IGV4cG9ydHMucm90ckJMID0gZXhwb3J0cy5yb3RyQkggPSBleHBvcnRzLnJvdHJTTCA9IGV4cG9ydHMucm90clNIID0gZXhwb3J0cy5zaHJTTCA9IGV4cG9ydHMuc2hyU0ggPSBleHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zcGxpdCA9IGV4cG9ydHMuZnJvbUJpZyA9IHZvaWQgMDtcbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuZXhwb3J0cy5zaHJTSCA9IHNoclNIO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5zaHJTTCA9IHNoclNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RyU0ggPSByb3RyU0g7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5yb3RyU0wgPSByb3RyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmV4cG9ydHMucm90ckJIID0gcm90ckJIO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdHJCTCA9IHJvdHJCTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuZXhwb3J0cy5yb3RyMzJIID0gcm90cjMySDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG5leHBvcnRzLnJvdHIzMkwgPSByb3RyMzJMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTSCA9IHJvdGxTSDtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTTCA9IHJvdGxTTDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCSCA9IHJvdGxCSDtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RsQkwgPSByb3RsQkw7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG5leHBvcnRzLmFkZCA9IGFkZDtcbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmV4cG9ydHMuYWRkM0wgPSBhZGQzTDtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQzSCA9IGFkZDNIO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDRMID0gYWRkNEw7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNEggPSBhZGQ0SDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDVMID0gYWRkNUw7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNUggPSBhZGQ1SDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/cryptoNode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/cryptoNode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc ? nc.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvTm9kZS5qcz82ZWNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5jID0gcmVxdWlyZShcIm5vZGU6Y3J5cHRvXCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/hmac.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/hmac.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, _assert_js_1.hash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, _assert_js_1.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2htYWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLFlBQVk7QUFDM0IscUJBQXFCLG1CQUFPLENBQUMsdUZBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzPzA2MjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhtYWMgPSBleHBvcnRzLkhNQUMgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5jbGFzcyBITUFDIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5oYXNoKShoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLkhNQUMgPSBITUFDO1xuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmV4cG9ydHMuaG1hYyA9IGhtYWM7XG5leHBvcnRzLmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/pbkdf2.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/pbkdf2.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pbkdf2Async = exports.pbkdf2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_assert.js\");\nconst hmac_js_1 = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/hmac.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js\");\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0, _assert_js_1.hash)(hash);\n    const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0, _assert_js_1.number)(c);\n    (0, _assert_js_1.number)(dkLen);\n    (0, _assert_js_1.number)(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = (0, utils_js_1.toBytes)(_password);\n    const salt = (0, utils_js_1.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac_js_1.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_js_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexports.pbkdf2 = pbkdf2;\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_js_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexports.pbkdf2Async = pbkdf2Async;\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3Bia2RmMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxjQUFjO0FBQ3BDLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFjO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwQkFBMEI7QUFDdkUsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVksd0NBQXdDO0FBQ3BELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9wYmtkZjIuanM/YTAxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGJrZGYyQXN5bmMgPSBleHBvcnRzLnBia2RmMiA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBobWFjX2pzXzEgPSByZXF1aXJlKFwiLi9obWFjLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHBia2RmMkluaXQoaGFzaCwgX3Bhc3N3b3JkLCBfc2FsdCwgX29wdHMpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmhhc2gpKGhhc2gpO1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgdXRpbHNfanNfMS5jaGVja09wdHMpKHsgZGtMZW46IDMyLCBhc3luY1RpY2s6IDEwIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2sgfSA9IG9wdHM7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKGMpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShka0xlbik7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKGFzeW5jVGljayk7XG4gICAgaWYgKGMgPCAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BCS0RGMjogaXRlcmF0aW9ucyAoYykgc2hvdWxkIGJlID49IDEnKTtcbiAgICBjb25zdCBwYXNzd29yZCA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9wYXNzd29yZCk7XG4gICAgY29uc3Qgc2FsdCA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9zYWx0KTtcbiAgICAvLyBESyA9IFBCS0RGMihQUkYsIFBhc3N3b3JkLCBTYWx0LCBjLCBka0xlbik7XG4gICAgY29uc3QgREsgPSBuZXcgVWludDhBcnJheShka0xlbik7XG4gICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgY29uc3QgUFJGID0gaG1hY19qc18xLmhtYWMuY3JlYXRlKGhhc2gsIHBhc3N3b3JkKTtcbiAgICBjb25zdCBQUkZTYWx0ID0gUFJGLl9jbG9uZUludG8oKS51cGRhdGUoc2FsdCk7XG4gICAgcmV0dXJuIHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9O1xufVxuZnVuY3Rpb24gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpIHtcbiAgICBQUkYuZGVzdHJveSgpO1xuICAgIFBSRlNhbHQuZGVzdHJveSgpO1xuICAgIGlmIChwcmZXKVxuICAgICAgICBwcmZXLmRlc3Ryb3koKTtcbiAgICB1LmZpbGwoMCk7XG4gICAgcmV0dXJuIERLO1xufVxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3N3b3JkIGZyb20gd2hpY2ggYSBkZXJpdmVkIGtleSBpcyBnZW5lcmF0ZWRcbiAqIEBwYXJhbSBzYWx0IC0gY3J5cHRvZ3JhcGhpYyBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxuICovXG5mdW5jdGlvbiBwYmtkZjIoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgZm9yIChsZXQgdWkgPSAxOyB1aSA8IGM7IHVpKyspIHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuZXhwb3J0cy5wYmtkZjIgPSBwYmtkZjI7XG5hc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGF3YWl0ICgwLCB1dGlsc19qc18xLmFzeW5jTG9vcCkoYyAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbmV4cG9ydHMucGJrZGYyQXN5bmMgPSBwYmtkZjJBc3luYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/pbkdf2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/ripemd160.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/ripemd160.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ripemd160 = exports.RIPEMD160 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_sha2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js\");\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3JpcGVtZDE2MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxvREFBb0Q7QUFDcEQsc0RBQXNEO0FBQ3RELDREQUE0RDtBQUM1RCw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwLmpzP2Y5MjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IGV4cG9ydHMuUklQRU1EMTYwID0gdm9pZCAwO1xuY29uc3QgX3NoYTJfanNfMSA9IHJlcXVpcmUoXCIuL19zaGEyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuLy8gaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAvcGRmL0FCLTk2MDEvQUItOTYwMS5wZGZcbmNvbnN0IFJobyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheShbNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOF0pO1xuY29uc3QgSWQgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG5jb25zdCBQaSA9IC8qIEBfX1BVUkVfXyAqLyBJZC5tYXAoKGkpID0+ICg5ICogaSArIDUpICUgMTYpO1xubGV0IGlkeEwgPSBbSWRdO1xubGV0IGlkeFIgPSBbUGldO1xuZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgZm9yIChsZXQgaiBvZiBbaWR4TCwgaWR4Ul0pXG4gICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvW2tdKSk7XG5jb25zdCBzaGlmdHMgPSAvKiBAX19QVVJFX18gKi8gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IG5ldyBVaW50OEFycmF5KGkpKTtcbmNvbnN0IHNoaWZ0c0wgPSAvKiBAX19QVVJFX18gKi8gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSID0gLyogQF9fUFVSRV9fICovIGlkeFIubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0c1tpXVtqXSkpO1xuY29uc3QgS2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDAwMDAwMDAwLCAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGE5NTNmZDRlLFxuXSk7XG5jb25zdCBLciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDAsXG5dKTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICh3b3JkID4+PiAoMzIgLSBzaGlmdCkpO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XG4gICAgaWYgKGdyb3VwID09PSAwKVxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAzKVxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgQlVGID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSgxNik7XG5jbGFzcyBSSVBFTUQxNjAgZXh0ZW5kcyBfc2hhMl9qc18xLlNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5IHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IGgwLCBoMSwgaDIsIGgzLCBoNCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xuICAgIH1cbiAgICBzZXQoaDAsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSBoMiB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBCVUZbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIDAgdG8gODAsIHdlIHNwbGl0IGl0IGludG8gNSBncm91cHNcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xuICAgICAgICAgICAgY29uc3Qgckdyb3VwID0gNCAtIGdyb3VwO1xuICAgICAgICAgICAgY29uc3QgaGJsID0gS2xbZ3JvdXBdLCBoYnIgPSBLcltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzbCA9IHNoaWZ0c0xbZ3JvdXBdLCBzciA9IHNoaWZ0c1JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKHJvdGwoYWwgKyBmKGdyb3VwLCBibCwgY2wsIGRsKSArIEJVRltybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSByb3RsKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyBmKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZbcnJbaV1dICsgaGJyLCBzcltpXSkgKyBlcikgfCAwO1xuICAgICAgICAgICAgICAgIGFyID0gZXIsIGVyID0gZHIsIGRyID0gcm90bChjciwgMTApIHwgMCwgY3IgPSBiciwgYnIgPSB0cjsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgdGhpcy5zZXQoKHRoaXMuaDEgKyBjbCArIGRyKSB8IDAsICh0aGlzLmgyICsgZGwgKyBlcikgfCAwLCAodGhpcy5oMyArIGVsICsgYXIpIHwgMCwgKHRoaXMuaDQgKyBhbCArIGJyKSB8IDAsICh0aGlzLmgwICsgYmwgKyBjcikgfCAwKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgQlVGLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SSVBFTUQxNjAgPSBSSVBFTUQxNjA7XG4vKipcbiAqIFJJUEVNRC0xNjAgLSBhIGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gbXNnIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMucmlwZW1kMTYwID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgUklQRU1EMTYwKCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/ripemd160.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/scrypt.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/scrypt.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scryptAsync = exports.scrypt = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_assert.js\");\nconst sha256_js_1 = __webpack_require__(/*! ./sha256.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/sha256.js\");\nconst pbkdf2_js_1 = __webpack_require__(/*! ./pbkdf2.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/pbkdf2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js\");\n// RFC 7914 Scrypt KDF\n// Left rotate for uint32\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b));\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    // Based on https://cr.yp.to/salsa20.html\n    // Xor blocks\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    // Save state to temporary variables (salsa)\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop (salsa)\n    for (let i = 0; i < 8; i += 2) {\n        x04 ^= rotl(x00 + x12 | 0, 7);\n        x08 ^= rotl(x04 + x00 | 0, 9);\n        x12 ^= rotl(x08 + x04 | 0, 13);\n        x00 ^= rotl(x12 + x08 | 0, 18);\n        x09 ^= rotl(x05 + x01 | 0, 7);\n        x13 ^= rotl(x09 + x05 | 0, 9);\n        x01 ^= rotl(x13 + x09 | 0, 13);\n        x05 ^= rotl(x01 + x13 | 0, 18);\n        x14 ^= rotl(x10 + x06 | 0, 7);\n        x02 ^= rotl(x14 + x10 | 0, 9);\n        x06 ^= rotl(x02 + x14 | 0, 13);\n        x10 ^= rotl(x06 + x02 | 0, 18);\n        x03 ^= rotl(x15 + x11 | 0, 7);\n        x07 ^= rotl(x03 + x15 | 0, 9);\n        x11 ^= rotl(x07 + x03 | 0, 13);\n        x15 ^= rotl(x11 + x07 | 0, 18);\n        x01 ^= rotl(x00 + x03 | 0, 7);\n        x02 ^= rotl(x01 + x00 | 0, 9);\n        x03 ^= rotl(x02 + x01 | 0, 13);\n        x00 ^= rotl(x03 + x02 | 0, 18);\n        x06 ^= rotl(x05 + x04 | 0, 7);\n        x07 ^= rotl(x06 + x05 | 0, 9);\n        x04 ^= rotl(x07 + x06 | 0, 13);\n        x05 ^= rotl(x04 + x07 | 0, 18);\n        x11 ^= rotl(x10 + x09 | 0, 7);\n        x08 ^= rotl(x11 + x10 | 0, 9);\n        x09 ^= rotl(x08 + x11 | 0, 13);\n        x10 ^= rotl(x09 + x08 | 0, 18);\n        x12 ^= rotl(x15 + x14 | 0, 7);\n        x13 ^= rotl(x12 + x15 | 0, 9);\n        x14 ^= rotl(x13 + x12 | 0, 13);\n        x15 ^= rotl(x14 + x13 | 0, 18);\n    }\n    // Write output (salsa)\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for (let i = 0; i < 16; i++)\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ← B[2r−1]\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n        if (i > 0)\n            tail += 16; // First iteration overwrites tmp value in tail\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n    }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n    // Maxmem - 1GB+1KB by default\n    const opts = (0, utils_js_1.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10,\n        maxmem: 1024 ** 3 + 1024,\n    }, _opts);\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n    (0, _assert_js_1.number)(N);\n    (0, _assert_js_1.number)(r);\n    (0, _assert_js_1.number)(p);\n    (0, _assert_js_1.number)(dkLen);\n    (0, _assert_js_1.number)(asyncTick);\n    (0, _assert_js_1.number)(maxmem);\n    if (onProgress !== undefined && typeof onProgress !== 'function')\n        throw new Error('progressCb should be function');\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\n        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\n        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');\n    }\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\n        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\n    }\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\n    }\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem) {\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\n    }\n    // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n    // Since it has only one iteration there is no reason to use async variant\n    const B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, { c: 1, dkLen: blockSize * p });\n    const B32 = (0, utils_js_1.u32)(B);\n    // Re-used between parallel iterations. Array(iterations) of B\n    const V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));\n    const tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));\n    let blockMixCb = () => { };\n    if (onProgress) {\n        const totalBlockMix = 2 * N * p;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n        let blockMixCnt = 0;\n        blockMixCb = () => {\n            blockMixCnt++;\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n                onProgress(blockMixCnt / totalBlockMix);\n        };\n    }\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n    const res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, { c: 1, dkLen });\n    B.fill(0);\n    V.fill(0);\n    tmp.fill(0);\n    return res;\n}\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n */\nfunction scrypt(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        for (let i = 0, pos = 0; i < N - 1; i++) {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        for (let i = 0; i < N; i++) {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        }\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\nexports.scrypt = scrypt;\n/**\n * Scrypt KDF from RFC 7914.\n */\nasync function scryptAsync(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        let pos = 0;\n        await (0, utils_js_1.asyncLoop)(N - 1, asyncTick, () => {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        });\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        await (0, utils_js_1.asyncLoop)(N, asyncTick, () => {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        });\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\nexports.scryptAsync = scryptAsync;\n//# sourceMappingURL=scrypt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NjcnlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxjQUFjO0FBQ3BDLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFjO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLDBEQUEwRDtBQUMxRCxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHdCQUF3QjtBQUN4Qiw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUyx3QkFBd0IsUUFBUTtBQUNsRztBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsNEJBQTRCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUEwRDtBQUN0RSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsZ0NBQWdDO0FBQ2hDLGlDQUFpQyxXQUFXO0FBQzVDLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxzREFBc0Q7QUFDdEQsNEJBQTRCLGlCQUFpQjtBQUM3QywrREFBK0Q7QUFDL0QsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFFQUFxRTtBQUNqRixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxTQUFTO0FBQ1Qsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCw0QkFBNEIsaUJBQWlCO0FBQzdDLCtEQUErRDtBQUMvRCwwQ0FBMEM7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zY3J5cHQuanM/NzI1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NyeXB0QXN5bmMgPSBleHBvcnRzLnNjcnlwdCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBzaGEyNTZfanNfMSA9IHJlcXVpcmUoXCIuL3NoYTI1Ni5qc1wiKTtcbmNvbnN0IHBia2RmMl9qc18xID0gcmVxdWlyZShcIi4vcGJrZGYyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUkZDIDc5MTQgU2NyeXB0IEtERlxuLy8gTGVmdCByb3RhdGUgZm9yIHVpbnQzMlxuY29uc3Qgcm90bCA9IChhLCBiKSA9PiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XG4vLyBUaGUgbWFpbiBTY3J5cHQgbG9vcDogdXNlcyBTYWxzYSBleHRlbnNpdmVseS5cbi8vIFNpeCB2ZXJzaW9ucyBvZiB0aGUgZnVuY3Rpb24gd2VyZSB0cmllZCwgdGhpcyBpcyB0aGUgZmFzdGVzdCBvbmUuXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIFhvckFuZFNhbHNhKHByZXYsIHBpLCBpbnB1dCwgaWksIG91dCwgb2kpIHtcbiAgICAvLyBCYXNlZCBvbiBodHRwczovL2NyLnlwLnRvL3NhbHNhMjAuaHRtbFxuICAgIC8vIFhvciBibG9ja3NcbiAgICBsZXQgeTAwID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDEgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA2ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDcgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwOCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA5ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTEyID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTMgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxNCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTE1ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcyAoc2Fsc2EpXG4gICAgbGV0IHgwMCA9IHkwMCwgeDAxID0geTAxLCB4MDIgPSB5MDIsIHgwMyA9IHkwMywgeDA0ID0geTA0LCB4MDUgPSB5MDUsIHgwNiA9IHkwNiwgeDA3ID0geTA3LCB4MDggPSB5MDgsIHgwOSA9IHkwOSwgeDEwID0geTEwLCB4MTEgPSB5MTEsIHgxMiA9IHkxMiwgeDEzID0geTEzLCB4MTQgPSB5MTQsIHgxNSA9IHkxNTtcbiAgICAvLyBNYWluIGxvb3AgKHNhbHNhKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgIHgwNCBePSByb3RsKHgwMCArIHgxMiB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MDQgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDEyIF49IHJvdGwoeDA4ICsgeDA0IHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MTIgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgwOSBePSByb3RsKHgwNSArIHgwMSB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MDkgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDAxIF49IHJvdGwoeDEzICsgeDA5IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDEgKyB4MTMgfCAwLCAxOCk7XG4gICAgICAgIHgxNCBePSByb3RsKHgxMCArIHgwNiB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MTQgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA2IF49IHJvdGwoeDAyICsgeDE0IHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDYgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwMyBePSByb3RsKHgxNSArIHgxMSB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDMgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDExIF49IHJvdGwoeDA3ICsgeDAzIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTEgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgwMSBePSByb3RsKHgwMCArIHgwMyB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MDEgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDAzIF49IHJvdGwoeDAyICsgeDAxIHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MDMgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwNiBePSByb3RsKHgwNSArIHgwNCB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDYgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDA0IF49IHJvdGwoeDA3ICsgeDA2IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDQgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgxMSBePSByb3RsKHgxMCArIHgwOSB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MTEgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA5IF49IHJvdGwoeDA4ICsgeDExIHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDkgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgxMiBePSByb3RsKHgxNSArIHgxNCB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MTIgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDE0IF49IHJvdGwoeDEzICsgeDEyIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTQgKyB4MTMgfCAwLCAxOCk7XG4gICAgfVxuICAgIC8vIFdyaXRlIG91dHB1dCAoc2Fsc2EpXG4gICAgb3V0W29pKytdID0gKHkwMCArIHgwMCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDEgKyB4MDEpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAyICsgeDAyKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMyArIHgwMykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDQgKyB4MDQpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA1ICsgeDA1KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNiArIHgwNikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDcgKyB4MDcpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA4ICsgeDA4KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOSArIHgwOSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTAgKyB4MTApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTExICsgeDExKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMiArIHgxMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTMgKyB4MTMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTE0ICsgeDE0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNSArIHgxNSkgfCAwO1xufVxuZnVuY3Rpb24gQmxvY2tNaXgoaW5wdXQsIGlpLCBvdXQsIG9pLCByKSB7XG4gICAgLy8gVGhlIGJsb2NrIEIgaXMgciAxMjgtYnl0ZSBjaHVua3MgKHdoaWNoIGlzIGVxdWl2YWxlbnQgb2YgMnIgNjQtYnl0ZSBjaHVua3MpXG4gICAgbGV0IGhlYWQgPSBvaSArIDA7XG4gICAgbGV0IHRhaWwgPSBvaSArIDE2ICogcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICAgIG91dFt0YWlsICsgaV0gPSBpbnB1dFtpaSArICgyICogciAtIDEpICogMTYgKyBpXTsgLy8gWCDihpAgQlsycuKIkjFdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByOyBpKyssIGhlYWQgKz0gMTYsIGlpICs9IDE2KSB7XG4gICAgICAgIC8vIFdlIHdyaXRlIG9kZCAmIGV2ZW4gWWkgYXQgc2FtZSB0aW1lLiBFdmVuOiAwYlhYWFhYMCBPZGQ6ICAwYlhYWFhYMVxuICAgICAgICBYb3JBbmRTYWxzYShvdXQsIHRhaWwsIGlucHV0LCBpaSwgb3V0LCBoZWFkKTsgLy8gaGVhZFtpXSA9IFNhbHNhKGJsb2NrSW5bMippXSBeIHRhaWxbaS0xXSlcbiAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgdGFpbCArPSAxNjsgLy8gRmlyc3QgaXRlcmF0aW9uIG92ZXJ3cml0ZXMgdG1wIHZhbHVlIGluIHRhaWxcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCBoZWFkLCBpbnB1dCwgKGlpICs9IDE2KSwgb3V0LCB0YWlsKTsgLy8gdGFpbFtpXSA9IFNhbHNhKGJsb2NrSW5bMippKzFdIF4gaGVhZFtpXSlcbiAgICB9XG59XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgX29wdHMpIHtcbiAgICAvLyBNYXhtZW0gLSAxR0IrMUtCIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBvcHRzID0gKDAsIHV0aWxzX2pzXzEuY2hlY2tPcHRzKSh7XG4gICAgICAgIGRrTGVuOiAzMixcbiAgICAgICAgYXN5bmNUaWNrOiAxMCxcbiAgICAgICAgbWF4bWVtOiAxMDI0ICoqIDMgKyAxMDI0LFxuICAgIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBhc3luY1RpY2ssIG1heG1lbSwgb25Qcm9ncmVzcyB9ID0gb3B0cztcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoTik7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKHIpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShwKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoZGtMZW4pO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShhc3luY1RpY2spO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShtYXhtZW0pO1xuICAgIGlmIChvblByb2dyZXNzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9uUHJvZ3Jlc3MgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvZ3Jlc3NDYiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICBjb25zdCBibG9ja1NpemUgPSAxMjggKiByO1xuICAgIGNvbnN0IGJsb2NrU2l6ZTMyID0gYmxvY2tTaXplIC8gNDtcbiAgICBpZiAoTiA8PSAxIHx8IChOICYgKE4gLSAxKSkgIT09IDAgfHwgTiA+PSAyICoqIChibG9ja1NpemUgLyA4KSB8fCBOID4gMiAqKiAzMikge1xuICAgICAgICAvLyBOT1RFOiB3ZSBsaW1pdCBOIHRvIGJlIGxlc3MgdGhhbiAyKiozMiBiZWNhdXNlIG9mIDMyIGJpdCB2YXJpYW50IG9mIEludGVncmlmeSBmdW5jdGlvblxuICAgICAgICAvLyBUaGVyZSBpcyBubyBKUyBlbmdpbmVzIHRoYXQgYWxsb3dzIGFsb2NhdGUgbW9yZSB0aGFuIDRHQiBwZXIgc2luZ2xlIFVpbnQ4QXJyYXkgZm9yIG5vdywgYnV0IGNhbiBjaGFuZ2UgaW4gZnV0dXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogTiBtdXN0IGJlIGxhcmdlciB0aGFuIDEsIGEgcG93ZXIgb2YgMiwgbGVzcyB0aGFuIDJeKDEyOCAqIHIgLyA4KSBhbmQgbGVzcyB0aGFuIDJeMzInKTtcbiAgICB9XG4gICAgaWYgKHAgPCAwIHx8IHAgPiAoKDIgKiogMzIgLSAxKSAqIDMyKSAvIGJsb2NrU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogcCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKCgyXjMyIC0gMSkgKiAzMikgLyAoMTI4ICogciknKTtcbiAgICB9XG4gICAgaWYgKGRrTGVuIDwgMCB8fCBka0xlbiA+ICgyICoqIDMyIC0gMSkgKiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogZGtMZW4gc2hvdWxkIGJlIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICgyXjMyIC0gMSkgKiAzMicpO1xuICAgIH1cbiAgICBjb25zdCBtZW1Vc2VkID0gYmxvY2tTaXplICogKE4gKyBwKTtcbiAgICBpZiAobWVtVXNlZCA+IG1heG1lbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjcnlwdDogcGFyYW1ldGVycyB0b28gbGFyZ2UsICR7bWVtVXNlZH0gKDEyOCAqIHIgKiAoTiArIHApKSA+ICR7bWF4bWVtfSAobWF4bWVtKWApO1xuICAgIH1cbiAgICAvLyBbQjAuLi5CcOKIkjFdIOKGkCBQQktERjJITUFDLVNIQTI1NihQYXNzcGhyYXNlLCBTYWx0LCAxLCBibG9ja1NpemUqUGFyYWxsZWxpemF0aW9uRmFjdG9yKVxuICAgIC8vIFNpbmNlIGl0IGhhcyBvbmx5IG9uZSBpdGVyYXRpb24gdGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBhc3luYyB2YXJpYW50XG4gICAgY29uc3QgQiA9ICgwLCBwYmtkZjJfanNfMS5wYmtkZjIpKHNoYTI1Nl9qc18xLnNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHsgYzogMSwgZGtMZW46IGJsb2NrU2l6ZSAqIHAgfSk7XG4gICAgY29uc3QgQjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShCKTtcbiAgICAvLyBSZS11c2VkIGJldHdlZW4gcGFyYWxsZWwgaXRlcmF0aW9ucy4gQXJyYXkoaXRlcmF0aW9ucykgb2YgQlxuICAgIGNvbnN0IFYgPSAoMCwgdXRpbHNfanNfMS51MzIpKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSAqIE4pKTtcbiAgICBjb25zdCB0bXAgPSAoMCwgdXRpbHNfanNfMS51MzIpKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSkpO1xuICAgIGxldCBibG9ja01peENiID0gKCkgPT4geyB9O1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQmxvY2tNaXggPSAyICogTiAqIHA7XG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayBpZiBwcm9ncmVzcyBjaGFuZ2VzIGZyb20gMTAuMDEgdG8gMTAuMDJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tQZXIgPSBNYXRoLm1heChNYXRoLmZsb29yKHRvdGFsQmxvY2tNaXggLyAxMDAwMCksIDEpO1xuICAgICAgICBsZXQgYmxvY2tNaXhDbnQgPSAwO1xuICAgICAgICBibG9ja01peENiID0gKCkgPT4ge1xuICAgICAgICAgICAgYmxvY2tNaXhDbnQrKztcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICYmICghKGJsb2NrTWl4Q250ICUgY2FsbGJhY2tQZXIpIHx8IGJsb2NrTWl4Q250ID09PSB0b3RhbEJsb2NrTWl4KSlcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKGJsb2NrTWl4Q250IC8gdG90YWxCbG9ja01peCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9O1xufVxuZnVuY3Rpb24gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKSB7XG4gICAgY29uc3QgcmVzID0gKDAsIHBia2RmMl9qc18xLnBia2RmMikoc2hhMjU2X2pzXzEuc2hhMjU2LCBwYXNzd29yZCwgQiwgeyBjOiAxLCBka0xlbiB9KTtcbiAgICBCLmZpbGwoMCk7XG4gICAgVi5maWxsKDApO1xuICAgIHRtcC5maWxsKDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3NcbiAqIEBwYXJhbSBzYWx0IC0gc2FsdFxuICogQHBhcmFtIG9wdHMgLSBwYXJhbWV0ZXJzXG4gKiAtIGBOYCBpcyBjcHUvbWVtIHdvcmsgZmFjdG9yIChwb3dlciBvZiAyIGUuZy4gMioqMTgpXG4gKiAtIGByYCBpcyBibG9jayBzaXplICg4IGlzIGNvbW1vbiksIGZpbmUtdHVuZXMgc2VxdWVudGlhbCBtZW1vcnkgcmVhZCBzaXplIGFuZCBwZXJmb3JtYW5jZVxuICogLSBgcGAgaXMgcGFyYWxsZWxpemF0aW9uIGZhY3RvciAoMSBpcyBjb21tb24pXG4gKiAtIGBka0xlbmAgaXMgb3V0cHV0IGtleSBsZW5ndGggaW4gYnl0ZXMgZS5nLiAzMi5cbiAqIC0gYGFzeW5jVGlja2AgLSAoZGVmYXVsdDogMTApIG1heCB0aW1lIGluIG1zIGZvciB3aGljaCBhc3luYyBmdW5jdGlvbiBjYW4gYmxvY2sgZXhlY3V0aW9uXG4gKiAtIGBtYXhtZW1gIC0gKGRlZmF1bHQ6IGAxMDI0ICoqIDMgKyAxMDI0YCBha2EgMUdCKzFLQikuIEEgbGltaXQgdGhhdCB0aGUgYXBwIGNvdWxkIHVzZSBmb3Igc2NyeXB0XG4gKiAtIGBvblByb2dyZXNzYCAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgZXhlY3V0ZWQgZm9yIHByb2dyZXNzIHJlcG9ydFxuICogQHJldHVybnMgRGVyaXZlZCBrZXlcbiAqL1xuZnVuY3Rpb24gc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBmb3IgKGxldCBwaSA9IDA7IHBpIDwgcDsgcGkrKykge1xuICAgICAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplMzI7IGkrKylcbiAgICAgICAgICAgIFZbaV0gPSBCMzJbUGkgKyBpXTsgLy8gVlswXSA9IEJbaV1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBOIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH1cbiAgICAgICAgQmxvY2tNaXgoViwgKE4gLSAxKSAqIGJsb2NrU2l6ZTMyLCBCMzIsIFBpLCByKTsgLy8gUHJvY2VzcyBsYXN0IGVsZW1lbnRcbiAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgICAgLy8gRmlyc3QgdTMyIG9mIHRoZSBsYXN0IDY0LWJ5dGUgYmxvY2sgKHUzMiBpcyBMRSlcbiAgICAgICAgICAgIGNvbnN0IGogPSBCMzJbUGkgKyBibG9ja1NpemUzMiAtIDE2XSAlIE47IC8vIGogPSBJbnRlZ3JpZnkoWCkgJSBpdGVyYXRpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGJsb2NrU2l6ZTMyOyBrKyspXG4gICAgICAgICAgICAgICAgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxuICAgICAgICAgICAgQmxvY2tNaXgodG1wLCAwLCBCMzIsIFBpLCByKTsgLy8gQiA9IEJsb2NrTWl4KEIgXiBWW2pdKVxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuZXhwb3J0cy5zY3J5cHQgPSBzY3J5cHQ7XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2NyeXB0QXN5bmMocGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9ID0gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTMyOyBpKyspXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBhd2FpdCAoMCwgdXRpbHNfanNfMS5hc3luY0xvb3ApKE4gLSAxLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEJsb2NrTWl4KFYsIChOIC0gMSkgKiBibG9ja1NpemUzMiwgQjMyLCBQaSwgcik7IC8vIFByb2Nlc3MgbGFzdCBlbGVtZW50XG4gICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgYXdhaXQgKDAsIHV0aWxzX2pzXzEuYXN5bmNMb29wKShOLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHUzMiBvZiB0aGUgbGFzdCA2NC1ieXRlIGJsb2NrICh1MzIgaXMgTEUpXG4gICAgICAgICAgICBjb25zdCBqID0gQjMyW1BpICsgYmxvY2tTaXplMzIgLSAxNl0gJSBOOyAvLyBqID0gSW50ZWdyaWZ5KFgpICUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBibG9ja1NpemUzMjsgaysrKVxuICAgICAgICAgICAgICAgIHRtcFtrXSA9IEIzMltQaSArIGtdIF4gVltqICogYmxvY2tTaXplMzIgKyBrXTsgLy8gdG1wID0gQiBeIFZbal1cbiAgICAgICAgICAgIEJsb2NrTWl4KHRtcCwgMCwgQjMyLCBQaSwgcik7IC8vIEIgPSBCbG9ja01peChCIF4gVltqXSlcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuZXhwb3J0cy5zY3J5cHRBc3luYyA9IHNjcnlwdEFzeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyeXB0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/scrypt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/sha256.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/sha256.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_sha2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanM/OGFlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX3NoYTJfanNfMS5TSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDYpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMTEpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMTMpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/sha3.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/sha3.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_assert.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js\");\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0, _assert_js_1.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, _assert_js_1.exists)(this, false);\n        (0, _assert_js_1.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, _assert_js_1.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, _assert_js_1.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGVBQWU7QUFDdE8scUJBQXFCLG1CQUFPLENBQUMsdUZBQWM7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsaUZBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQix1R0FBdUc7QUFDdkcsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcz9mMjliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGFrZTI1NiA9IGV4cG9ydHMuc2hha2UxMjggPSBleHBvcnRzLmtlY2Nha181MTIgPSBleHBvcnRzLmtlY2Nha18zODQgPSBleHBvcnRzLmtlY2Nha18yNTYgPSBleHBvcnRzLmtlY2Nha18yMjQgPSBleHBvcnRzLnNoYTNfNTEyID0gZXhwb3J0cy5zaGEzXzM4NCA9IGV4cG9ydHMuc2hhM18yNTYgPSBleHBvcnRzLnNoYTNfMjI0ID0gZXhwb3J0cy5LZWNjYWsgPSBleHBvcnRzLmtlY2Nha1AgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgX3U2NF9qc18xID0gcmVxdWlyZShcIi4vX3U2NC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFNIQTMgKGtlY2NhaykgaXMgYmFzZWQgb24gYSBuZXcgZGVzaWduOiBiYXNpY2FsbHksIHRoZSBpbnRlcm5hbCBzdGF0ZSBpcyBiaWdnZXIgdGhhbiBvdXRwdXQgc2l6ZS5cbi8vIEl0J3MgY2FsbGVkIGEgc3BvbmdlIGZ1bmN0aW9uLlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyAoMCwgX3U2NF9qc18xLnNwbGl0KShfU0hBM19JT1RBLCB0cnVlKTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/ICgwLCBfdTY0X2pzXzEucm90bEJIKShoLCBsLCBzKSA6ICgwLCBfdTY0X2pzXzEucm90bFNIKShoLCBsLCBzKSk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gKDAsIF91NjRfanNfMS5yb3RsQkwpKGgsIGwsIHMpIDogKDAsIF91NjRfanNfMS5yb3RsU0wpKGgsIGwsIHMpKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0cy5rZWNjYWtQID0ga2VjY2FrUDtcbmNsYXNzIEtlY2NhayBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcywgZmFsc2UpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0cy5zaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMuc2hhM18zODQgPSBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMuc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLmtlY2Nha181MTIgPSBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cykoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnRzLnNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/cryptoNode.js\");\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsa0NBQWtDLEdBQUcsK0JBQStCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLFdBQVcsR0FBRyxVQUFVO0FBQ3BYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtHQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzPzJjOTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuY2hlY2tPcHRzID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9CeXRlcyA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmFzeW5jTG9vcCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLnJvdHIgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy51OCA9IHU4O1xuY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZXhwb3J0cy51MzIgPSB1MzI7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydHMuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWV4cG9ydHMuaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHM7XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/tslib/tslib.es6.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/node_modules/tslib/tslib.es6.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1AsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0RBQWtELFFBQVE7QUFDMUQseUNBQXlDLFFBQVE7QUFDakQseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQix1RkFBdUYsY0FBYztBQUN0SCx1QkFBdUIsZ0NBQWdDLHFDQUFxQywyQ0FBMkM7QUFDdkksNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLDZDQUE2QyxVQUFVLHNEQUFzRCxjQUFjO0FBQzVJLDBCQUEwQiw2QkFBNkIsb0JBQW9CLGdEQUFnRCxrQkFBa0I7QUFDN0k7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDTztBQUNQLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/Y2IwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/index.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/sender.js\");\n\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\n\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7O0FBRTNDLGtDQUFrQyxtQkFBTyxDQUFDLCtFQUFjO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLG1HQUF3QjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsK0VBQWM7O0FBRXpDO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcz83YTVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7XG5cbldlYlNvY2tldC5jcmVhdGVXZWJTb2NrZXRTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9zdHJlYW0nKTtcbldlYlNvY2tldC5TZXJ2ZXIgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQtc2VydmVyJyk7XG5XZWJTb2NrZXQuUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9yZWNlaXZlcicpO1xuV2ViU29ja2V0LlNlbmRlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlcicpO1xuXG5XZWJTb2NrZXQuV2ViU29ja2V0ID0gV2ViU29ja2V0O1xuV2ViU29ja2V0LldlYlNvY2tldFNlcnZlciA9IFdlYlNvY2tldC5TZXJ2ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/buffer-util.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = __webpack_require__(/*! bufferutil */ \"(ssr)/../../../node_modules/bufferutil/index.js\");\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsbUVBQVk7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcz8zZjU2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgYXJyYXkgb2YgYnVmZmVycyB0byBjb25jYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSByZXR1cm4gbGlzdFswXTtcblxuICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIHRhcmdldC5zZXQoYnVmLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IHRvdGFsTGVuZ3RoKSByZXR1cm4gdGFyZ2V0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gb3V0cHV0IFRoZSBidWZmZXIgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogVW5tYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX3VubWFzayhidWZmZXIsIG1hc2spIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xuICBpZiAoYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBkYXRhYCB0byBhIGBCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBidWZmZXJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xuICB0b0J1ZmZlci5yZWFkT25seSA9IHRydWU7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGRhdGE7XG5cbiAgbGV0IGJ1ZjtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICB0b0J1ZmZlci5yZWFkT25seSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxudHJ5IHtcbiAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfSxcbiAgICB0b0FycmF5QnVmZmVyLFxuICAgIHRvQnVmZmVyLFxuICAgIHVubWFzayhidWZmZXIsIG1hc2spIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC51bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICB9XG4gIH07XG59IGNhdGNoIChlKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbmNhdCxcbiAgICBtYXNrOiBfbWFzayxcbiAgICB0b0FycmF5QnVmZmVyLFxuICAgIHRvQnVmZmVyLFxuICAgIHVubWFzazogX3VubWFza1xuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/constants.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcz84MmFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUzogWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/event-target.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/event-target.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options = {}) {\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsa0NBQWtDLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxrQkFBa0I7QUFDckUsaURBQWlELGtCQUFrQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGtCQUFrQjtBQUN4RSx3REFBd0Qsa0JBQWtCO0FBQzFFLDBEQUEwRCxrQkFBa0I7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxrQkFBa0I7QUFDekUseURBQXlELGtCQUFrQjs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELGtCQUFrQjs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanM/Njk2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb3B0aW9ucyBvYmplY3Qgc3BlY2lmaWVzIGNoYXJhY3RlcmlzdGljcyBhYm91dFxuICAgKiAgICAgdGhlIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub25jZT1mYWxzZV0gQSBgQm9vbGVhbmAgaW5kaWNhdGluZyB0aGF0IHRoZVxuICAgKiAgICAgbGlzdGVuZXIgc2hvdWxkIGJlIGludm9rZWQgYXQgbW9zdCBvbmNlIGFmdGVyIGJlaW5nIGFkZGVkLiBJZiBgdHJ1ZWAsXG4gICAqICAgICB0aGUgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHdyYXBwZXI7XG5cbiAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudCgnbWVzc2FnZScsIHtcbiAgICAgICAgICBkYXRhOiBpc0JpbmFyeSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJywge1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXG4gICAgICAgICAgd2FzQ2xlYW46IHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0aGlzLl9jbG9zZUZyYW1lU2VudFxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BlbicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdvcGVuJyk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cmFwcGVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSA9ICEhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV07XG4gICAgd3JhcHBlcltrTGlzdGVuZXJdID0gbGlzdGVuZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/extension.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/extension.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsbUZBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBbUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1IsK0RBQStELEVBQUU7QUFDakU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLGlFQUFpRSxFQUFFO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0RBQStELEVBQUU7QUFDakU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxFQUFFLEdBQUcsRUFBRTtBQUMxRCwyQkFBMkI7QUFDM0IsZUFBZTtBQUNmO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanM/NWRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/limiter.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/limiter.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzPzI5ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0IsbUJBQW1CLG1CQUFPLENBQUMscUZBQWU7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVc7QUFDbkMsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJLEtBQUssTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBLFVBQVU7QUFDVixnREFBZ0QsSUFBSTtBQUNwRDs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanM/N2UzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/receiver.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/receiver.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(\n              RangeError,\n              'Max payload size exceeded',\n              false,\n              1009,\n              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n            )\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('message', buf, false);\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else if (data.length === 1) {\n        return error(\n          RangeError,\n          'invalid payload length 1',\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n        }\n\n        const buf = data.slice(2);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode] = statusCode;\n  return err;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFckMsMEJBQTBCLG1CQUFPLENBQUMsbUdBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYTtBQUN6QixRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMscUZBQWU7QUFDakUsUUFBUSxpQ0FBaUMsRUFBRSxtQkFBTyxDQUFDLG1GQUFjOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcz81YmZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJpbmFyeVR5cGU9bm9kZWJ1ZmZlcl0gVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZFxuICAgKiAgICAgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU2VydmVyPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0byBvcGVyYXRlIGluXG4gICAqICAgICBjbGllbnQgb3Igc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhb3B0aW9ucy5pc1NlcnZlcjtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gPSAhIW9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9idWZmZXJzID0gW107XG5cbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDAsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcblxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICBkc3Quc2V0KHRoaXMuX2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdID0gYnVmLnNsaWNlKG4pO1xuICAgICAgfVxuXG4gICAgICBuIC09IGJ1Zi5sZW5ndGg7XG4gICAgfSB3aGlsZSAobiA+IDApO1xuXG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0TG9vcChjYikge1xuICAgIGxldCBlcnI7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBgSU5GTEFUSU5HYFxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XG5cbiAgICBjYihlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5mbygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICBpZiAoKGJ1ZlswXSAmIDB4MzApICE9PSAweDAwKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzJfMydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAweDgwKSA9PT0gMHg4MDtcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAweDdmO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBvcGNvZGUgMCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDEgfHwgdGhpcy5fb3Bjb2RlID09PSAweDAyKSB7XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgcGF5bG9hZCBsZW5ndGggJHt0aGlzLl9wYXlsb2FkTGVuZ3RofWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01BU0sgbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX01BU0snXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ01BU0sgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9NQVNLJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5LFxuICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX0RBVEFfUEFZTE9BRF9MRU5HVEgnXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXREYXRhKGNiKSB7XG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX21hc2tlZCAmJlxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAxJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA5KSB7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgcmV0dXJuIGVycjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/sender.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/sender.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n\n\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\");\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQyxrQ0FBa0M7O0FBRTNEOztBQUViLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUUzQywwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDeEQsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYTtBQUM5QyxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsbUZBQWM7QUFDcEQsUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLHFGQUFlOztBQUU3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzPzQxYzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJebmV0fHRscyRcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcbmNvbnN0IG1hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMsIGdlbmVyYXRlTWFzaykge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuXG4gICAgaWYgKGdlbmVyYXRlTWFzaykge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xuICAgICAgdGhpcy5fbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHsoQnVmZmVyfFN0cmluZylbXX0gVGhlIGZyYW1lZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hc2s7XG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XG5cbiAgICAgIGlmIChvcHRpb25zLmdlbmVyYXRlTWFzaykge1xuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmRvbUZpbGxTeW5jKG1hc2ssIDAsIDQpO1xuICAgICAgfVxuXG4gICAgICBza2lwTWFza2luZyA9IChtYXNrWzBdIHwgbWFza1sxXSB8IG1hc2tbMl0gfCBtYXNrWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxuICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcblxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcbiAgICogICAgIG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG4gICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XG4gICAgbGV0IHJzdjEgPSBvcHRpb25zLmNvbXByZXNzO1xuXG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKFxuICAgICAgICByc3YxICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLnBhcmFtc1tcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5faXNTZXJ2ZXJcbiAgICAgICAgICAgID8gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICAgICAgOiAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgIF1cbiAgICAgICkge1xuICAgICAgICByc3YxID0gYnl0ZUxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgcmVhZE9ubHksXG4gICAgICAgIHJzdjFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgICAgIG9wY29kZSxcbiAgICAgICAgICByZWFkT25seSxcbiAgICAgICAgICByc3YxOiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgY2JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9kZWZsYXRpbmcgPSB0cnVlO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBjb21wcmVzc2VkJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKGVycik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlW2ldO1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAoIXRoaXMuX2RlZmxhdGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/stream.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcz9iOWZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0R1cGxleH0gVGhlIGR1cGxleCBzdHJlYW1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0U3RyZWFtKHdzLCBvcHRpb25zKSB7XG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnLCBpc0JpbmFyeSkge1xuICAgIGNvbnN0IGRhdGEgPVxuICAgICAgIWlzQmluYXJ5ICYmIGR1cGxleC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID8gbXNnLnRvU3RyaW5nKCkgOiBtc2c7XG5cbiAgICBpZiAoIWR1cGxleC5wdXNoKGRhdGEpKSB3cy5wYXVzZSgpO1xuICB9KTtcblxuICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAvLyBQcmV2ZW50IGB3cy50ZXJtaW5hdGUoKWAgZnJvbSBiZWluZyBjYWxsZWQgYnkgYGR1cGxleC5fZGVzdHJveSgpYC5cbiAgICAvL1xuICAgIC8vIC0gSWYgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIGJlZm9yZSB0aGUgYCdvcGVuJ2AgZXZlbnQsIHRoZW5cbiAgICAvLyAgIGB3cy50ZXJtaW5hdGUoKWAgaXMgYSBub29wIGFzIG5vIHNvY2tldCBpcyBhc3NpZ25lZC5cbiAgICAvLyAtIE90aGVyd2lzZSwgdGhlIGVycm9yIGlzIHJlLWVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2BcbiAgICAvLyAgIGV2ZW50IG9mIHRoZSBgUmVjZWl2ZXJgIG9iamVjdC4gVGhlIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VzIHRoZVxuICAgIC8vICAgY29ubmVjdGlvbiBieSBjYWxsaW5nIGB3cy5jbG9zZSgpYC4gVGhpcyBhbGxvd3MgYSBjbG9zZSBmcmFtZSB0byBiZVxuICAgIC8vICAgc2VudCB0byB0aGUgb3RoZXIgcGVlci4gSWYgYHdzLnRlcm1pbmF0ZSgpYCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhpcyxcbiAgICAvLyAgIHRoZW4gdGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBiZSBzZW50LlxuICAgIHRlcm1pbmF0ZU9uRGVzdHJveSA9IGZhbHNlO1xuICAgIGR1cGxleC5kZXN0cm95KGVycik7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xuICB9KTtcblxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DTE9TRUQpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICB9KTtcblxuICAgIGlmICh0ZXJtaW5hdGVPbkRlc3Ryb3kpIHdzLnRlcm1pbmF0ZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fZmluYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fZmluYWwoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBgX3NvY2tldGAgcHJvcGVydHkgaXMgYG51bGxgIGl0IG1lYW5zIHRoYXQgYHdzYCBpcyBhXG4gICAgLy8gY2xpZW50IHdlYnNvY2tldCBhbmQgdGhlIGhhbmRzaGFrZSBmYWlsZWQuIEluIGZhY3QsIHdoZW4gdGhpcyBoYXBwZW5zLCBhXG4gICAgLy8gc29ja2V0IGlzIG5ldmVyIGFzc2lnbmVkIHRvIHRoZSB3ZWJzb2NrZXQuIFdhaXQgZm9yIHRoZSBgJ2Vycm9yJ2AgZXZlbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgd2Vic29ja2V0LlxuICAgIGlmICh3cy5fc29ja2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAod3MuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIGlmIChkdXBsZXguX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkgZHVwbGV4LmRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3MuX3NvY2tldC5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIC8vIGBkdXBsZXhgIGlzIG5vdCBkZXN0cm95ZWQgaGVyZSBiZWNhdXNlIHRoZSBgJ2VuZCdgIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZW1pdHRlZCBvbiBgZHVwbGV4YCBhZnRlciB0aGlzIGAnZmluaXNoJ2AgZXZlbnQuIFRoZSBFT0Ygc2lnbmFsaW5nXG4gICAgICAgIC8vIGBudWxsYCBjaHVuayBpcywgaW4gZmFjdCwgcHVzaGVkIHdoZW4gdGhlIHdlYnNvY2tldCBlbWl0cyBgJ2Nsb3NlJ2AuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIHdzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIGR1cGxleC5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod3MuaXNQYXVzZWQpIHdzLnJlc3VtZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdzLnNlbmQoY2h1bmssIGNhbGxiYWNrKTtcbiAgfTtcblxuICBkdXBsZXgub24oJ2VuZCcsIGR1cGxleE9uRW5kKTtcbiAgZHVwbGV4Lm9uKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICByZXR1cm4gZHVwbGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdlYlNvY2tldFN0cmVhbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/subprotocol.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/subprotocol.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvc3VicHJvdG9jb2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxtRkFBYzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG1CQUFtQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsK0RBQStELEVBQUU7QUFDakU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcz8wYTc0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBoZWFkZXIgaW50byBhIHNldCBvZiBzdWJwcm90b2NvbCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtTZXR9IFRoZSBzdWJwcm90b2NvbCBuYW1lc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3QgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChpOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpICE9PSAwICYmXG4gICAgICAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSkgLyogJ1xcdCcgKi9cbiAgICApIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcblxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcblxuICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICB9XG5cbiAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gIHJldHVybiBwcm90b2NvbHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/validation.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/validation.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntry {\n  const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(ssr)/../../../node_modules/utf-8-validate/index.js\");\n\n  module.exports = {\n    isValidStatusCode,\n    isValidUTF8(buf) {\n      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    },\n    tokenChars\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    isValidStatusCode,\n    isValidUTF8: _isValidUTF8,\n    tokenChars\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsMkVBQWdCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzPzQ5ZjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdG9rZW5DaGFycyA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyA0OCAtIDYzXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAxLCAwIC8vIDExMiAtIDEyN1xuXTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDEwMDAgJiZcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNSAmJlxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBidWZmZXIgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LlxuICogUG9ydGVkIGZyb20gaHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrLyU3RW1nazI1L3Vjcy91dGY4X2NoZWNrLmMgYnlcbiAqIE1hcmt1cyBLdWhuLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBidWZgIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9pc1ZhbGlkVVRGOChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKChidWZbaV0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gMHh4eHh4eHhcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDEgPT09IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMiA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZTAgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwKSAvLyBTdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZjAgJiYgKGJ1ZltpICsgMV0gJiAweGYwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmNCAmJiBidWZbaSArIDFdID4gMHg4ZikgfHxcbiAgICAgICAgYnVmW2ldID4gMHhmNCAvLyA+IFUrMTBGRkZGXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudHJ5IHtcbiAgY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzVmFsaWRTdGF0dXNDb2RlLFxuICAgIGlzVmFsaWRVVEY4KGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAxNTAgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVmFsaWRVVEY4KGJ1Zik7XG4gICAgfSxcbiAgICB0b2tlbkNoYXJzXG4gIH07XG59IGNhdGNoIChlKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzVmFsaWRTdGF0dXNDb2RlLFxuICAgIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjgsXG4gICAgdG9rZW5DaGFyc1xuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/websocket-server.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/websocket-server.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst extension = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key']\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-Type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msd0NBQXdDOztBQUVqRTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFdkMsa0JBQWtCLG1CQUFPLENBQUMsaUZBQWE7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsbUdBQXNCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLHFGQUFlO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3ZDLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYTs7QUFFbEQsaUNBQWlDLEdBQUc7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQWtEO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQixhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHlCQUF5QjtBQUN0QztBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsMkJBQTJCO0FBQ3RDLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixNQUFNLEVBQUUsd0JBQXdCO0FBQ2xEO0FBQ0EseUJBQXlCLEVBQUUsSUFBSSxXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanM/NjhjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5uZXR8dGxzfGh0dHBzJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLldlYlNvY2tldD1XZWJTb2NrZXRdIFNwZWNpZmllcyB0aGUgYFdlYlNvY2tldGBcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPVxuICAgICAgcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG5cbiAgICBpZiAoXG4gICAgICByZXEubWV0aG9kICE9PSAnR0VUJyB8fFxuICAgICAgcmVxLmhlYWRlcnMudXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0JyB8fFxuICAgICAgIWtleSB8fFxuICAgICAgIWtleVJlZ2V4LnRlc3Qoa2V5KSB8fFxuICAgICAgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHx8XG4gICAgICAhdGhpcy5zaG91bGRIYW5kbGUocmVxKVxuICAgICkge1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRQcm90b2NvbCA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChzZWNXZWJTb2NrZXRQcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcm90b2NvbHMgPSBzdWJwcm90b2NvbC5wYXJzZShzZWNXZWJTb2NrZXRQcm90b2NvbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsKTtcblxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgcHJlbWF0dXJlIHNvY2tldCBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgdGhpcy5kZXN0cm95KCk7XG59XG5cbi8qKlxuICogQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2hlbiBwcmVjb25kaXRpb25zIGFyZSBub3QgZnVsZmlsbGVkLlxuICpcbiAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgaHR0cC5TVEFUVVNfQ09ERVNbY29kZV07XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvaHRtbCcsXG4gICAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAgIC4uLmhlYWRlcnNcbiAgICB9O1xuXG4gICAgc29ja2V0LndyaXRlKFxuICAgICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICAgJ1xcclxcblxcclxcbicgK1xuICAgICAgICBtZXNzYWdlXG4gICAgKTtcbiAgfVxuXG4gIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgc29ja2V0LmRlc3Ryb3koKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/ws/lib/websocket.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/websocket.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = __webpack_require__(/*! ./event-target */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\");\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalHost = parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (parsedUrl.host !== websocket._originalHost) {\n      //\n      // Match curl 7.77.0 behavior and drop the following headers. These\n      // headers are also dropped when following a redirect to a subdomain.\n      //\n      delete opts.headers.authorization;\n      delete opts.headers.cookie;\n      delete opts.headers.host;\n      opts.auth = undefined;\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req.aborted) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n}\n\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQyxtQ0FBbUM7O0FBRTVEOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDcEQsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLGdCQUFLOztBQUU3QiwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsK0VBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDJFQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlGQUFhO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHVGQUFnQjtBQUM1QixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsaUZBQWE7QUFDL0MsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxxRkFBZTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0I7QUFDM0UsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0QsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QyxRQUFRO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUIsR0FBRyxtQkFBbUI7QUFDNUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUixvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyw0Q0FBNEM7QUFDdkQ7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsR0FBRztBQUNkLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanM/OGQ5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5SZWFkYWJsZSRcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXInKTtcbmNvbnN0IFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBHVUlELFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZSxcbiAga0xpc3RlbmVyLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldCxcbiAgTk9PUFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7XG4gIEV2ZW50VGFyZ2V0OiB7IGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIgfVxufSA9IHJlcXVpcmUoJy4vZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCB7IGZvcm1hdCwgcGFyc2UgfSA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCB7IHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IHJlYWR5U3RhdGVzID0gWydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXTtcbmNvbnN0IHN1YnByb3RvY29sUmVnZXggPSAvXlshIyQlJicqK1xcLS4wLTlBLVpeX2B8YS16fl0rJC87XG5jb25zdCBwcm90b2NvbFZlcnNpb25zID0gWzgsIDEzXTtcbmNvbnN0IGNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBXSEFUV0cgaW50ZXJmYWNlIHNpbmNlIHdzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICogcmVxdWlyZWQgZGVmYXVsdCBcImJsb2JcIiB0eXBlIChpbnN0ZWFkIHdlIGRlZmluZSBhIGN1c3RvbSBcIm5vZGVidWZmZXJcIlxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25vcGVuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGVcbiAgICogICAgIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHtcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZW5kZXIgPSBuZXcgU2VuZGVyKHNvY2tldCwgdGhpcy5fZXh0ZW5zaW9ucywgb3B0aW9ucy5nZW5lcmF0ZU1hc2spO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICogICAgIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCAmJlxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxuICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIFNwZWNpZnkgYSB0aW1lb3V0IGZvciB0aGUgY2xvc2luZyBoYW5kc2hha2UgdG8gY29tcGxldGUuXG4gICAgLy9cbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95LmJpbmQodGhpcy5fc29ja2V0KSxcbiAgICAgIGNsb3NlVGltZW91dFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zb2NrZXQucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwaW5nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5waW5nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBvbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcG9uZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucG9uZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ2lzUGF1c2VkJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvbGxvd1JlZGlyZWN0cz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gZm9sbG93XG4gKiAgICAgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICogICAgIG1hc2tpbmcga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICogICAgIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcbiAqICAgICBhbGxvd2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT10cnVlXSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY3JlYXRlQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gICAgd2Vic29ja2V0Ll91cmwgPSBhZGRyZXNzLmhyZWY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHdlYnNvY2tldC5fdXJsID0gYWRkcmVzcztcbiAgfVxuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzVW5peFNvY2tldCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcbiAgbGV0IGludmFsaWRVUkxNZXNzYWdlO1xuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICd3czonICYmICFpc1NlY3VyZSAmJiAhaXNVbml4U29ja2V0KSB7XG4gICAgaW52YWxpZFVSTE1lc3NhZ2UgPVxuICAgICAgJ1RoZSBVUkxcXCdzIHByb3RvY29sIG11c3QgYmUgb25lIG9mIFwid3M6XCIsIFwid3NzOlwiLCBvciBcIndzK3VuaXg6XCInO1xuICB9IGVsc2UgaWYgKGlzVW5peFNvY2tldCAmJiAhcGFyc2VkVXJsLnBhdGhuYW1lKSB7XG4gICAgaW52YWxpZFVSTE1lc3NhZ2UgPSBcIlRoZSBVUkwncyBwYXRobmFtZSBpcyBlbXB0eVwiO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgaW52YWxpZFVSTE1lc3NhZ2UgPSAnVGhlIFVSTCBjb250YWlucyBhIGZyYWdtZW50IGlkZW50aWZpZXInO1xuICB9XG5cbiAgaWYgKGludmFsaWRVUkxNZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGludmFsaWRVUkxNZXNzYWdlKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGVmYXVsdFBvcnQgPSBpc1NlY3VyZSA/IDQ0MyA6IDgwO1xuICBjb25zdCBrZXkgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBjb25zdCBnZXQgPSBpc1NlY3VyZSA/IGh0dHBzLmdldCA6IGh0dHAuZ2V0O1xuICBjb25zdCBwcm90b2NvbFNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IHBlck1lc3NhZ2VEZWZsYXRlO1xuXG4gIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiA9IGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3Q7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IG9wdHMucHJvdG9jb2xWZXJzaW9uLFxuICAgICdTZWMtV2ViU29ja2V0LUtleSc6IGtleSxcbiAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXG4gICAgVXBncmFkZTogJ3dlYnNvY2tldCcsXG4gICAgLi4ub3B0cy5oZWFkZXJzXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHByb3RvY29sICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fFxuICAgICAgICBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgICdBbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZWQgc3VicHJvdG9jb2wgd2FzIHNwZWNpZmllZCdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xTZXQuYWRkKHByb3RvY29sKTtcbiAgICB9XG5cbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scy5qb2luKCcsJyk7XG4gIH1cbiAgaWYgKG9wdHMub3JpZ2luKSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLmhlYWRlcnMuT3JpZ2luID0gb3B0cy5vcmlnaW47XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgfHwgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICB9XG5cbiAgaWYgKGlzVW5peFNvY2tldCkge1xuICAgIGNvbnN0IHBhcnRzID0gb3B0cy5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvbGxvd1JlZGlyZWN0cykge1xuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3QgPSBwYXJzZWRVcmwuaG9zdDtcblxuICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzO1xuXG4gICAgICAvL1xuICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSB1c2VyIHByb3ZpZGVkIG9wdGlvbnMgc28gdGhhdCBoZWFkZXJzIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAvL1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgaGVhZGVyczoge30gfTtcblxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcnNlZFVybC5ob3N0ICE9PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdCkge1xuICAgICAgLy9cbiAgICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBkcm9wIHRoZSBmb2xsb3dpbmcgaGVhZGVycy4gVGhlc2VcbiAgICAgIC8vIGhlYWRlcnMgYXJlIGFsc28gZHJvcHBlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgc3ViZG9tYWluLlxuICAgICAgLy9cbiAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llO1xuICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xuICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxuICAgIC8vIElmIHRoZSBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlzIHNldCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGFzIGl0XG4gICAgLy8gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPVxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXEgPSAod2Vic29ja2V0Ll9yZXEgPSBnZXQob3B0cykpO1xuXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICByZXEub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcSA9PT0gbnVsbCB8fCByZXEuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgfSk7XG5cbiAgcmVxLm9uKCdyZXNwb25zZScsIChyZXMpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcblxuICAgIGlmIChcbiAgICAgIGxvY2F0aW9uICYmXG4gICAgICBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJlxuICAgICAgc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgIHN0YXR1c0NvZGUgPCA0MDBcbiAgICApIHtcbiAgICAgIGlmICgrK3dlYnNvY2tldC5fcmVkaXJlY3RzID4gb3B0cy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdNYXhpbXVtIHJlZGlyZWN0cyBleGNlZWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcS5hYm9ydCgpO1xuXG4gICAgICBsZXQgYWRkcjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYWRkciA9IG5ldyBVUkwobG9jYXRpb24sIGFkZHJlc3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2xvY2F0aW9ufWApO1xuICAgICAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkciwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKCF3ZWJzb2NrZXQuZW1pdCgndW5leHBlY3RlZC1yZXNwb25zZScsIHJlcSwgcmVzKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2UoXG4gICAgICAgIHdlYnNvY2tldCxcbiAgICAgICAgcmVxLFxuICAgICAgICBgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2U6ICR7cmVzLnN0YXR1c0NvZGV9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJlcS5vbigndXBncmFkZScsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgIHdlYnNvY2tldC5lbWl0KCd1cGdyYWRlJywgcmVzKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIHVzZXIgbWF5IGhhdmUgY2xvc2VkIHRoZSBjb25uZWN0aW9uIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYHVwZ3JhZGVgXG4gICAgLy8gZXZlbnQuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgaWYgKHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWFjY2VwdCddICE9PSBkaWdlc3QpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXJQcm90ID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdEVycm9yO1xuXG4gICAgaWYgKHNlcnZlclByb3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhIHN1YnByb3RvY29sIGJ1dCBub25lIHdhcyByZXF1ZXN0ZWQnO1xuICAgICAgfSBlbHNlIGlmICghcHJvdG9jb2xTZXQuaGFzKHNlcnZlclByb3QpKSB7XG4gICAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhbiBpbnZhbGlkIHN1YnByb3RvY29sJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBubyBzdWJwcm90b2NvbCc7XG4gICAgfVxuXG4gICAgaWYgKHByb3RFcnJvcikge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIHByb3RFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlclByb3QpIHdlYnNvY2tldC5fcHJvdG9jb2wgPSBzZXJ2ZXJQcm90O1xuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcblxuICAgIGlmIChzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgJ1NlcnZlciBzZW50IGEgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciBidXQgbm8gZXh0ZW5zaW9uICcgK1xuICAgICAgICAgICd3YXMgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBleHRlbnNpb25zO1xuXG4gICAgICB0cnkge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZXMgPSBPYmplY3Qua2V5cyhleHRlbnNpb25zKTtcblxuICAgICAgaWYgKFxuICAgICAgICBleHRlbnNpb25OYW1lcy5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXNbMF0gIT09IFBlck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVcbiAgICAgICkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1NlcnZlciBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIHRoYXQgd2FzIG5vdCByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdlYnNvY2tldC5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlO1xuICAgIH1cblxuICAgIHdlYnNvY2tldC5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBnZW5lcmF0ZU1hc2s6IG9wdHMuZ2VuZXJhdGVNYXNrLFxuICAgICAgbWF4UGF5bG9hZDogb3B0cy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRzLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBFbWl0IHRoZSBgJ2Vycm9yJ2AgYW5kIGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvciB0byBlbWl0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycikge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBuZXQuU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7bmV0LlNvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ldENvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgdGxzLlRMU1NvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3Rscy5UTFNTb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0bHNDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xuXG4gIGlmICghb3B0aW9ucy5zZXJ2ZXJuYW1lICYmIG9wdGlvbnMuc2VydmVybmFtZSAhPT0gJycpIHtcbiAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSBuZXQuaXNJUChvcHRpb25zLmhvc3QpID8gJycgOiBvcHRpb25zLmhvc3Q7XG4gIH1cblxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG9cbiAqICAgICBhYm9ydCBvciB0aGUgc29ja2V0IHRvIGRlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UpO1xuXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XG4gICAgc3RyZWFtLmFib3J0KCk7XG5cbiAgICBpZiAoc3RyZWFtLnNvY2tldCAmJiAhc3RyZWFtLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPbiBOb2RlLmpzID49IDE0LjMuMCBgcmVxdWVzdC5hYm9ydCgpYCBkb2VzIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgaWZcbiAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdCBjb21wbGV0ZWQuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE4NjkuXG4gICAgICAvL1xuICAgICAgc3RyZWFtLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgc3RyZWFtLm9uY2UoJ2Fib3J0Jywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcbiAqIHdoZW4gdGhlIGByZWFkeVN0YXRlYCBhdHRyaWJ1dGUgaXMgYENMT1NJTkdgIG9yIGBDTE9TRURgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBjYihlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKCF3ZWJzb2NrZXQuaXNQYXVzZWQpIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBiaW5hcnkgb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXdlYnNvY2tldC5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBsZXQgY2h1bms7XG5cbiAgLy9cbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxuICAvLyBgcmVjZWl2ZXJgIHN0cmVhbSBpcyBjbG9zZWQgYWZ0ZXIgd3JpdGluZyBhbnkgcmVtYWluaW5nIGJ1ZmZlcmVkIGRhdGEgdG9cbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgLiBJZiBpbnN0ZWFkLCB0aGUgc29ja2V0IGlzIHBhdXNlZCwgYW55IHBvc3NpYmxlIGJ1ZmZlcmVkXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuICAvL1xuICBpZiAoXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxuICAgICF3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcbiAgKSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/_version.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/_version.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\n/**\n *  The current version of Ethers.\n */\nexports.version = \"6.11.1\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1Qiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL192ZXJzaW9uLmpzPzFlYTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBEbyBOT1QgbW9kaWZ5IHRoaXMgZmlsZTsgc2VlIC9zcmMudHMvX2FkbWluL3VwZGF0ZS12ZXJzaW9uLnRzICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG4vKipcbiAqICBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIEV0aGVycy5cbiAqL1xuZXhwb3J0cy52ZXJzaW9uID0gXCI2LjExLjFcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/abi-coder.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/abi-coder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AbiCoder = void 0;\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst address_js_1 = __webpack_require__(/*! ./coders/address.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/address.js\");\nconst array_js_1 = __webpack_require__(/*! ./coders/array.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/array.js\");\nconst boolean_js_1 = __webpack_require__(/*! ./coders/boolean.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/boolean.js\");\nconst bytes_js_1 = __webpack_require__(/*! ./coders/bytes.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/bytes.js\");\nconst fixed_bytes_js_1 = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js\");\nconst null_js_1 = __webpack_require__(/*! ./coders/null.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/null.js\");\nconst number_js_1 = __webpack_require__(/*! ./coders/number.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/number.js\");\nconst string_js_1 = __webpack_require__(/*! ./coders/string.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/string.js\");\nconst tuple_js_1 = __webpack_require__(/*! ./coders/tuple.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/tuple.js\");\nconst fragments_js_1 = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/fragments.js\");\nconst index_js_2 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nlet defaultMaxInflation = 1024;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0, index_js_3.getBytes)(data);\n        data = (0, index_js_3.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        }\n        else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        }\n        else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\"string\"], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [reason]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            }\n            catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        }\n        else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\"uint256\"], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [code]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            }\n            catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        }\n        else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: (tx.to ? (0, index_js_2.getAddress)(tx.to) : null),\n        data: (tx.data || \"0x\")\n    };\n    if (tx.from) {\n        transaction.from = (0, index_js_2.getAddress)(tx.from);\n    }\n    return (0, index_js_3.makeError)(message, \"CALL_EXCEPTION\", {\n        action, data, reason, transaction, invocation, revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */\nclass AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new array_js_1.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new tuple_js_1.TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);\n        }\n        switch (param.baseType) {\n            case \"address\":\n                return new address_js_1.AddressCoder(param.name);\n            case \"bool\":\n                return new boolean_js_1.BooleanCoder(param.name);\n            case \"string\":\n                return new string_js_1.StringCoder(param.name);\n            case \"bytes\":\n                return new bytes_js_1.BytesCoder(param.name);\n            case \"\":\n                return new null_js_1.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new number_js_1.NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0, index_js_1.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new fixed_bytes_js_1.FixedBytesCoder(size, param.name);\n        }\n        (0, index_js_1.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */\n    getDefaultValue(types) {\n        const coders = types.map((type) => this.#getCoder(fragments_js_1.ParamType.from(type)));\n        const coder = new tuple_js_1.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */\n    encode(types, values) {\n        (0, index_js_1.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type) => this.#getCoder(fragments_js_1.ParamType.from(type)));\n        const coder = (new tuple_js_1.TupleCoder(coders, \"_\"));\n        const writer = new abstract_coder_js_1.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */\n    decode(types, data, loose) {\n        const coders = types.map((type) => this.#getCoder(fragments_js_1.ParamType.from(type)));\n        const coder = new tuple_js_1.TupleCoder(coders, \"_\");\n        return coder.decode(new abstract_coder_js_1.Reader(data, loose, defaultMaxInflation));\n    }\n    static _setDefaultMaxInflation(value) {\n        (0, index_js_1.assertArgument)(typeof (value) === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\n        defaultMaxInflation = value;\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */\n    static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */\n    static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n}\nexports.AbiCoder = AbiCoder;\n//# sourceMappingURL=abi-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvYWJpLWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyw0QkFBNEIsbUJBQU8sQ0FBQyx5R0FBNEI7QUFDaEUscUJBQXFCLG1CQUFPLENBQUMsMkZBQXFCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFtQjtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBcUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsdUZBQW1CO0FBQzlDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUF5QjtBQUMxRCxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBa0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMseUZBQW9CO0FBQ2hELG9CQUFvQixtQkFBTyxDQUFDLHlGQUFvQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBbUI7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMsaUZBQWdCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBb0MsR0FBRyxLQUFLO0FBQ3JGLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2FiaS1jb2Rlci5qcz9mMGNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgV2hlbiBzZW5kaW5nIHZhbHVlcyB0byBvciByZWNlaXZpbmcgdmFsdWVzIGZyb20gYSBbW0NvbnRyYWN0XV0sIHRoZVxuICogIGRhdGEgaXMgZ2VuZXJhbGx5IGVuY29kZWQgdXNpbmcgdGhlIFtBQkkgc3RhbmRhcmRdKGxpbmstc29sYy1hYmkpLlxuICpcbiAqICBUaGUgQWJpQ29kZXIgcHJvdmlkZXMgYSB1dGlsaXR5IHRvIGVuY29kZSB2YWx1ZXMgdG8gQUJJIGRhdGEgYW5kXG4gKiAgZGVjb2RlIHZhbHVlcyBmcm9tIEFCSSBkYXRhLlxuICpcbiAqICBNb3N0IG9mIHRoZSB0aW1lLCBkZXZlbG9wZXJzIHNob3VsZCBmYXZvdXIgdGhlIFtbQ29udHJhY3RdXSBjbGFzcyxcbiAqICB3aGljaCBmdXJ0aGVyIGFic3RyYWN0cyBhIGxvdCBvZiB0aGUgZmluZXIgZGV0YWlscyBvZiBBQkkgZGF0YS5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkFCSSBFbmNvZGluZ1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFiaUNvZGVyID0gdm9pZCAwO1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIik7XG5jb25zdCBhZGRyZXNzX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvYWRkcmVzcy5qc1wiKTtcbmNvbnN0IGFycmF5X2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvYXJyYXkuanNcIik7XG5jb25zdCBib29sZWFuX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvYm9vbGVhbi5qc1wiKTtcbmNvbnN0IGJ5dGVzX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvYnl0ZXMuanNcIik7XG5jb25zdCBmaXhlZF9ieXRlc19qc18xID0gcmVxdWlyZShcIi4vY29kZXJzL2ZpeGVkLWJ5dGVzLmpzXCIpO1xuY29uc3QgbnVsbF9qc18xID0gcmVxdWlyZShcIi4vY29kZXJzL251bGwuanNcIik7XG5jb25zdCBudW1iZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9udW1iZXIuanNcIik7XG5jb25zdCBzdHJpbmdfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9zdHJpbmcuanNcIik7XG5jb25zdCB0dXBsZV9qc18xID0gcmVxdWlyZShcIi4vY29kZXJzL3R1cGxlLmpzXCIpO1xuY29uc3QgZnJhZ21lbnRzX2pzXzEgPSByZXF1aXJlKFwiLi9mcmFnbWVudHMuanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbFxuY29uc3QgUGFuaWNSZWFzb25zID0gbmV3IE1hcCgpO1xuUGFuaWNSZWFzb25zLnNldCgweDAwLCBcIkdFTkVSSUNfUEFOSUNcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDEsIFwiQVNTRVJUX0ZBTFNFXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDExLCBcIk9WRVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDEyLCBcIkRJVklERV9CWV9aRVJPXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIxLCBcIkVOVU1fUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjIsIFwiQkFEX1NUT1JBR0VfREFUQVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMSwgXCJTVEFDS19VTkRFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzIsIFwiQVJSQVlfUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NDEsIFwiT1VUX09GX01FTU9SWVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg1MSwgXCJVTklOSVRJQUxJWkVEX0ZVTkNUSU9OX0NBTExcIik7XG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbmxldCBkZWZhdWx0Q29kZXIgPSBudWxsO1xubGV0IGRlZmF1bHRNYXhJbmZsYXRpb24gPSAxMDI0O1xuZnVuY3Rpb24gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgYWJpQ29kZXIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFwibWlzc2luZyByZXZlcnQgZGF0YVwiO1xuICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBudWxsO1xuICAgIGxldCByZXZlcnQgPSBudWxsO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImV4ZWN1dGlvbiByZXZlcnRlZFwiO1xuICAgICAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKShkYXRhKTtcbiAgICAgICAgZGF0YSA9ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGRhdGEpO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChubyBkYXRhIHByZXNlbnQ7IGxpa2VseSByZXF1aXJlKGZhbHNlKSBvY2N1cnJlZFwiO1xuICAgICAgICAgICAgcmVhc29uID0gXCJyZXF1aXJlKGZhbHNlKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCAlIDMyICE9PSA0KSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBkYXRhIGxlbmd0aClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XG4gICAgICAgICAgICAvLyBFcnJvcihzdHJpbmcpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlYXNvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtKU09OLnN0cmluZ2lmeShyZWFzb24pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBzdHJpbmcgZGF0YSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHg0ZTQ4N2I3MVwiKSB7XG4gICAgICAgICAgICAvLyBQYW5pYyh1aW50MjU2KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gTnVtYmVyKGFiaUNvZGVyLmRlY29kZShbXCJ1aW50MjU2XCJdLCBieXRlcy5zbGljZSg0KSlbMF0pO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2NvZGVdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBgUGFuaWMgZHVlIHRvICR7UGFuaWNSZWFzb25zLmdldChjb2RlKSB8fCBcIlVOS05PV05cIn0oJHtjb2RlfSlgO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtyZWFzb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcGFuaWMgY29kZSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICB0bzogKHR4LnRvID8gKDAsIGluZGV4X2pzXzIuZ2V0QWRkcmVzcykodHgudG8pIDogbnVsbCksXG4gICAgICAgIGRhdGE6ICh0eC5kYXRhIHx8IFwiMHhcIilcbiAgICB9O1xuICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmZyb20gPSAoMCwgaW5kZXhfanNfMi5nZXRBZGRyZXNzKSh0eC5mcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18zLm1ha2VFcnJvcikobWVzc2FnZSwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgIGFjdGlvbiwgZGF0YSwgcmVhc29uLCB0cmFuc2FjdGlvbiwgaW52b2NhdGlvbiwgcmV2ZXJ0XG4gICAgfSk7XG59XG4vKipcbiAqICBUaGUgKipBYmlDb2RlcioqIGlzIGEgbG93LWxldmVsIGNsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNvZGluZyBKYXZhU2NyaXB0XG4gKiAgdmFsdWVzIGludG8gYmluYXJ5IGRhdGEgYW5kIGRlY29kaW5nIGJpbmFyeSBkYXRhIGludG8gSmF2YVNjcmlwdCB2YWx1ZXMuXG4gKi9cbmNsYXNzIEFiaUNvZGVyIHtcbiAgICAjZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhcnJheV9qc18xLkFycmF5Q29kZXIodGhpcy4jZ2V0Q29kZXIocGFyYW0uYXJyYXlDaGlsZHJlbiksIHBhcmFtLmFycmF5TGVuZ3RoLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0uaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR1cGxlX2pzXzEuVHVwbGVDb2RlcihwYXJhbS5jb21wb25lbnRzLm1hcCgoYykgPT4gdGhpcy4jZ2V0Q29kZXIoYykpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYWRkcmVzc19qc18xLkFkZHJlc3NDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBib29sZWFuX2pzXzEuQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3RyaW5nX2pzXzEuU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGJ5dGVzX2pzXzEuQnl0ZXNDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG51bGxfanNfMS5OdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgXCIgKyBtYXRjaFsxXSArIFwiIGJpdCBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG51bWJlcl9qc18xLk51bWJlckNvZGVyKHNpemUgLyA4LCAobWF0Y2hbMV0gPT09IFwiaW50XCIpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBieXRlc1swLTldK1xuICAgICAgICBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKHNpemUgIT09IDAgJiYgc2l6ZSA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZml4ZWRfYnl0ZXNfanNfMS5GaXhlZEJ5dGVzQ29kZXIoc2l6ZSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgcGFyYW0udHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhIGBgdWludGBgIGlzIGJ5IGRlZmF1bHQgYGAwYGAgYW5kIGBgYm9vbGBgXG4gICAgICogIGlzIGJ5IGRlZmF1bHQgYGBmYWxzZWBgLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRWYWx1ZSh0eXBlcykge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKGZyYWdtZW50c19qc18xLlBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IHR1cGxlX2pzXzEuVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byBBQkkgZGF0YS5cbiAgICAgKlxuICAgICAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gICAgICovXG4gICAgZW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnRDb3VudCkodmFsdWVzLmxlbmd0aCwgdHlwZXMubGVuZ3RoLCBcInR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoZnJhZ21lbnRzX2pzXzEuUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSAobmV3IHR1cGxlX2pzXzEuVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBhYnN0cmFjdF9jb2Rlcl9qc18xLldyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgdGhlIEFCSSAlJWRhdGElJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlbG9vc2UlJSBkZWNvZGluZyBpcyBlbmFibGVkLCB0aGVuIHN0cmljdCBwYWRkaW5nIGlzXG4gICAgICogIG5vdCBlbmZvcmNlZC4gU29tZSBvbGRlciB2ZXJzaW9ucyBvZiBTb2xpZGl0eSBpbmNvcnJlY3RseVxuICAgICAqICBwYWRkZWQgZXZlbnQgZGF0YSBlbWl0dGVkIGZyb20gYGBleHRlcm5hbGBgIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoZnJhZ21lbnRzX2pzXzEuUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgdHVwbGVfanNfMS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVjb2RlKG5ldyBhYnN0cmFjdF9jb2Rlcl9qc18xLlJlYWRlcihkYXRhLCBsb29zZSwgZGVmYXVsdE1heEluZmxhdGlvbikpO1xuICAgIH1cbiAgICBzdGF0aWMgX3NldERlZmF1bHRNYXhJbmZsYXRpb24odmFsdWUpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcImludmFsaWQgZGVmYXVsdE1heEluZmxhdGlvbiBmYWN0b3JcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHRNYXhJbmZsYXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNoYXJlZCBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBkZWZhdWx0IFtbQWJpQ29kZXJdXS5cbiAgICAgKlxuICAgICAqICBPbiB0aGUgZmlyc3QgY2FsbCwgdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQgaW50ZXJuYWxseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVmYXVsdEFiaUNvZGVyKCkge1xuICAgICAgICBpZiAoZGVmYXVsdENvZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q29kZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFuIGV0aGVycy1jb21wYXRpYmxlIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXV0gRXJyb3IgZm9yIHRoZSBnaXZlblxuICAgICAqICByZXN1bHQgJSVkYXRhJSUgZm9yIHRoZSBbW0NhbGxFeGNlcHRpb25BY3Rpb25dXSAlJWFjdGlvbiUlIGFnYWluc3RcbiAgICAgKiAgdGhlIFRyYW5zYWN0aW9uICUldHglJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJpQ29kZXIgPSBBYmlDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/abi-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/bytes32.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/bytes32.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  About bytes32 strings...\n *\n *  @_docloc: api/utils:Bytes32 Strings\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeBytes32String = exports.encodeBytes32String = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  Encodes %%text%% as a Bytes32 string.\n */\nfunction encodeBytes32String(text) {\n    // Get the bytes\n    const bytes = (0, index_js_1.toUtf8Bytes)(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error(\"bytes32 string must be less than 32 bytes\");\n    }\n    // Zero-pad (implicitly null-terminates)\n    return (0, index_js_1.zeroPadBytes)(bytes, 32);\n}\nexports.encodeBytes32String = encodeBytes32String;\n/**\n *  Encodes the Bytes32-encoded %%bytes%% into a string.\n */\nfunction decodeBytes32String(_bytes) {\n    const data = (0, index_js_1.getBytes)(_bytes, \"bytes\");\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error(\"invalid bytes32 - not 32 bytes long\");\n    }\n    if (data[31] !== 0) {\n        throw new Error(\"invalid bytes32 string - no null terminator\");\n    }\n    // Find the null termination\n    let length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return (0, index_js_1.toUtf8String)(data.slice(0, length));\n}\nexports.decodeBytes32String = decodeBytes32String;\n//# sourceMappingURL=bytes32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvYnl0ZXMzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2J5dGVzMzIuanM/MzQ5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEFib3V0IGJ5dGVzMzIgc3RyaW5ncy4uLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3V0aWxzOkJ5dGVzMzIgU3RyaW5nc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLmVuY29kZUJ5dGVzMzJTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgRW5jb2RlcyAlJXRleHQlJSBhcyBhIEJ5dGVzMzIgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGVCeXRlczMyU3RyaW5nKHRleHQpIHtcbiAgICAvLyBHZXQgdGhlIGJ5dGVzXG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMS50b1V0ZjhCeXRlcykodGV4dCk7XG4gICAgLy8gQ2hlY2sgd2UgaGF2ZSByb29tIGZvciBudWxsLXRlcm1pbmF0aW9uXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDMxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ5dGVzMzIgc3RyaW5nIG11c3QgYmUgbGVzcyB0aGFuIDMyIGJ5dGVzXCIpO1xuICAgIH1cbiAgICAvLyBaZXJvLXBhZCAoaW1wbGljaXRseSBudWxsLXRlcm1pbmF0ZXMpXG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnplcm9QYWRCeXRlcykoYnl0ZXMsIDMyKTtcbn1cbmV4cG9ydHMuZW5jb2RlQnl0ZXMzMlN0cmluZyA9IGVuY29kZUJ5dGVzMzJTdHJpbmc7XG4vKipcbiAqICBFbmNvZGVzIHRoZSBCeXRlczMyLWVuY29kZWQgJSVieXRlcyUlIGludG8gYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUJ5dGVzMzJTdHJpbmcoX2J5dGVzKSB7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgLy8gTXVzdCBiZSAzMiBieXRlcyB3aXRoIGEgbnVsbC10ZXJtaW5hdGlvblxuICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIC0gbm90IDMyIGJ5dGVzIGxvbmdcIik7XG4gICAgfVxuICAgIGlmIChkYXRhWzMxXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgc3RyaW5nIC0gbm8gbnVsbCB0ZXJtaW5hdG9yXCIpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBudWxsIHRlcm1pbmF0aW9uXG4gICAgbGV0IGxlbmd0aCA9IDMxO1xuICAgIHdoaWxlIChkYXRhW2xlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHN0cmluZyB2YWx1ZVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS50b1V0ZjhTdHJpbmcpKGRhdGEuc2xpY2UoMCwgbGVuZ3RoKSk7XG59XG5leHBvcnRzLmRlY29kZUJ5dGVzMzJTdHJpbmcgPSBkZWNvZGVCeXRlczMyU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMzMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/bytes32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n * @_ignore:\n */\nexports.WordSize = 32;\nconst Padding = new Uint8Array(exports.WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nclass Result extends Array {\n    #names;\n    /**\n     *  @private\n     */\n    constructor(...args) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof (name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, (new Map()));\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0, index_js_1.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function (...args) {\n                            return value.apply((this === receiver) ? target : this, args);\n                        };\n                    }\n                    else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target : this, [prop]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray() {\n        const result = [];\n        this.forEach((item, index) => {\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject() {\n        return this.#names.reduce((accum, name, index) => {\n            (0, index_js_1.assert)(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n            return accum;\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */\n    slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const result = [], names = [];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    filter(callback, thisArg) {\n        const result = [], names = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    map(callback, thisArg) {\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name) {\n        const index = this.#names.indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\nexports.Result = Result;\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nfunction checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexports.checkResultErrors = checkResultErrors;\nfunction getValue(value) {\n    let bytes = (0, index_js_1.toBeArray)(value);\n    (0, index_js_1.assert)(bytes.length <= exports.WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", { buffer: bytes, length: exports.WordSize, offset: bytes.length });\n    if (bytes.length !== exports.WordSize) {\n        bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */\nclass Coder {\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    name;\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    type;\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    localName;\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    dynamic;\n    constructor(name, type, localName, dynamic) {\n        (0, index_js_1.defineProperties)(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0, index_js_1.assertArgument)(false, message, this.localName, value);\n    }\n}\nexports.Coder = Coder;\n/**\n *  @_ignore\n */\nclass Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor() {\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0, index_js_1.concat)(this.#data);\n    }\n    get length() { return this.#dataLength; }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0, index_js_1.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0, index_js_1.getBytesCopy)(value);\n        const paddingOffset = bytes.length % exports.WordSize;\n        if (paddingOffset) {\n            bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += exports.WordSize;\n        return (value) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\nexports.Writer = Writer;\n/**\n *  @_ignore\n */\nclass Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    allowLoose;\n    #data;\n    #offset;\n    #bytesRead;\n    #parent;\n    #maxInflation;\n    constructor(data, allowLoose, maxInflation) {\n        (0, index_js_1.defineProperties)(this, { allowLoose: !!allowLoose });\n        this.#data = (0, index_js_1.getBytesCopy)(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;\n        this.#offset = 0;\n    }\n    get data() { return (0, index_js_1.hexlify)(this.#data); }\n    get dataLength() { return this.#data.length; }\n    get consumed() { return this.#offset; }\n    get bytes() { return new Uint8Array(this.#data); }\n    #incrementBytesRead(count) {\n        if (this.#parent) {\n            return this.#parent.#incrementBytesRead(count);\n        }\n        this.#bytesRead += count;\n        // Check for excessive inflation (see: #4537)\n        (0, index_js_1.assert)(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n            buffer: (0, index_js_1.getBytesCopy)(this.#data), offset: this.#offset,\n            length: count, info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            }\n            else {\n                (0, index_js_1.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0, index_js_1.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));\n    }\n    readIndex() {\n        return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));\n    }\n}\nexports.Reader = Reader;\n//# sourceMappingURL=abstract-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLHlCQUF5QixHQUFHLGNBQWMsR0FBRyxnQkFBZ0I7QUFDL0csbUJBQW1CLG1CQUFPLENBQUMscUZBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsS0FBSztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esd0dBQXdHLCtEQUErRDtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdDQUFnQztBQUNqRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvS0FBb0ssb0JBQW9CO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzP2RkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWRlciA9IGV4cG9ydHMuV3JpdGVyID0gZXhwb3J0cy5Db2RlciA9IGV4cG9ydHMuY2hlY2tSZXN1bHRFcnJvcnMgPSBleHBvcnRzLlJlc3VsdCA9IGV4cG9ydHMuV29yZFNpemUgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0cy5Xb3JkU2l6ZSA9IDMyO1xuY29uc3QgUGFkZGluZyA9IG5ldyBVaW50OEFycmF5KGV4cG9ydHMuV29yZFNpemUpO1xuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XG4vLyAtIGB0aGVuYCBpcyB1c2VkIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBQcm9taXNlIGZvciBhd2FpdFxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiB0aHJvd0Vycm9yKG5hbWUsIGVycm9yKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBFcnJvcihgZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nICR7bmFtZX1gKTtcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgd3JhcHBlZDtcbn1cbi8qKlxuICogIEEgW1tSZXN1bHRdXSBpcyBhIHN1Yi1jbGFzcyBvZiBBcnJheSwgd2hpY2ggYWxsb3dzIGFjY2Vzc2luZyBhbnlcbiAqICBvZiBpdHMgdmFsdWVzIGVpdGhlciBwb3NpdGlvbmFsbHkgYnkgaXRzIGluZGV4IG9yLCBpZiBrZXlzIGFyZVxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2FiaVxuICovXG5jbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XG4gICAgI25hbWVzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVG8gcHJvcGVybHkgc3ViLWNsYXNzIEFycmF5IHNvIHRoZSBvdGhlciBidWlsdC1pblxuICAgICAgICAvLyBmdW5jdGlvbnMgd29yaywgdGhlIGNvbnN0cnVjdG9yIGhhcyB0byBiZWhhdmUgZmFpcmx5XG4gICAgICAgIC8vIHdlbGwuIFNvLCBpbiB0aGUgZXZlbnQgd2UgYXJlIGNyZWF0ZWQgdmlhIGZyb21JdGVtcygpXG4gICAgICAgIC8vIHdlIGJ1aWxkIHRoZSByZWFkLW9ubHkgUmVzdWx0IG9iamVjdCB3ZSB3YW50LCBidXQgb25cbiAgICAgICAgLy8gYW55IG90aGVyIGlucHV0LCB3ZSB1c2UgdGhlIGRlZmF1bHQgY29uc3RydWN0b3JcbiAgICAgICAgLy8gY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgaXRlbXM6IEFycmF5PGFueT4sIGtleXM/OiBBcnJheTxudWxsIHwgc3RyaW5nPik7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gYXJnc1swXTtcbiAgICAgICAgbGV0IGl0ZW1zID0gYXJnc1sxXTtcbiAgICAgICAgbGV0IG5hbWVzID0gKGFyZ3NbMl0gfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGxldCB3cmFwID0gdHJ1ZTtcbiAgICAgICAgaWYgKGd1YXJkICE9PSBfZ3VhcmQpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gYXJncztcbiAgICAgICAgICAgIG5hbWVzID0gW107XG4gICAgICAgICAgICB3cmFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuJ3QganVzdCBwYXNzIGluIC4uLml0ZW1zIHNpbmNlIGFuIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgIC8vIGlzIGEgc3BlY2lhbCBjYXNlIGluIHRoZSBzdXBlci5cbiAgICAgICAgc3VwZXIoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsgdGhpc1tpbmRleF0gPSBpdGVtOyB9KTtcbiAgICAgICAgLy8gRmluZCBhbGwgdW5pcXVlIGtleXNcbiAgICAgICAgY29uc3QgbmFtZUNvdW50cyA9IG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0uc2V0KG5hbWUsIChhY2N1bS5nZXQobmFtZSkgfHwgMCkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwgKG5ldyBNYXAoKSkpO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGtleSB0aGF0cyBub3QgdW5pcXVlXG4gICAgICAgIHRoaXMuI25hbWVzID0gT2JqZWN0LmZyZWV6ZShpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKCF3cmFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSB3cmFwcGVkIFJlc3VsdCBpcyBpbW11dGFibGVcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgLy8gUHJveHkgaW5kaWNlcyBhbmQgbmFtZXMgc28gd2UgY2FuIHRyYXAgZGVmZXJyZWQgZXJyb3JzXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9ICgwLCBpbmRleF9qc18xLmdldE51bWJlcikocHJvcCwgXCIlaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmVzdWx0IHJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9ucyB3b3JrIHdpdGggcHJpdmF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkjbm9fcHJpdmF0ZV9wcm9wZXJ0eV9mb3J3YXJkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghKHByb3AgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgbmFtZSBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRWYWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI25hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKG5hbWUgIT0gbnVsbCwgXCJ2YWx1ZSBhdCBpbmRleCAkeyBpbmRleCB9IHVubmFtZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b09iamVjdCgpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIHZhbHVlcyBmb3IgbmFtZXMgdGhhdCBkb24ndCBjb25mbGljdFxuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBhY2N1bSkpIHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgbmFtZXMucHVzaCh0aGlzLiNuYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgZmlsdGVyKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaCh0aGlzLiNuYW1lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgbWFwKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgJSVuYW1lJSUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBhIGtleSB3aG9zZSBuYW1lIGNvbmZsaWN0cyB3aXRoXG4gICAgICogIGEgbWV0aG9kIG9uIGEgW1tSZXN1bHRdXSBvciBpdHMgc3VwZXJjbGFzcyBBcnJheSwgb3IgYW55XG4gICAgICogIEphdmFTY3JpcHQga2V5d29yZCwgdGhpcyBlbnN1cmVzIGFsbCBuYW1lZCB2YWx1ZXMgYXJlIHN0aWxsXG4gICAgICogIGFjY2Vzc2libGUgYnkgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCB2YWx1ZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1Jlc3VsdF1dIGZvciAlJWl0ZW1zJSUgd2l0aCBlYWNoIGVudHJ5XG4gICAgICogIGFsc28gYWNjZXNzaWJsZSBieSBpdHMgY29ycmVzcG9uZGluZyBuYW1lIGluICUla2V5cyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSXRlbXMoaXRlbXMsIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCBpdGVtcywga2V5cyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXN1bHQgPSBSZXN1bHQ7XG4vKipcbiAqICBSZXR1cm5zIGFsbCBlcnJvcnMgZm91bmQgaW4gYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xuICogIG5vdCBpbXBhY3QgdGhlIGFiaWxpdHkgdG8gY29udGludWUgcGFyc2luZyBkYXRhLCB0aGV5IGFyZVxuICogIGRlZmVycmVkIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5IGFjY2Vzc2VkLiBIZW5jZSBhIGZhdWx0eSBzdHJpbmdcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXG4gKlxuICogIEhvd2V2ZXIsIHNvbWV0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIGFjY2VzcywgaWRlbnRpZnkgb3JcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIEBfZG9jbG9jIGFwaS9hYmlcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gY2hlY2tSZXN1bHRFcnJvcnM7XG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBieXRlcyA9ICgwLCBpbmRleF9qc18xLnRvQmVBcnJheSkodmFsdWUpO1xuICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoYnl0ZXMubGVuZ3RoIDw9IGV4cG9ydHMuV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBleHBvcnRzLldvcmRTaXplLCBvZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBleHBvcnRzLldvcmRTaXplKSB7XG4gICAgICAgIGJ5dGVzID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSgoMCwgaW5kZXhfanNfMS5jb25jYXQpKFtQYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIGV4cG9ydHMuV29yZFNpemUpLCBieXRlc10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgQ29kZXIge1xuICAgIC8vIFRoZSBjb2RlciBuYW1lOlxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZSwgYXJyYXksIGV0Yy5cbiAgICBuYW1lO1xuICAgIC8vIFRoZSBmdWxseSBleHBhbmRlZCB0eXBlLCBpbmNsdWRpbmcgY29tcG9zaXRlIHR5cGVzOlxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZShhZGRyZXNzLGJ5dGVzKSwgdWludDI1NlszXVs0XVtdLCAgZXRjLlxuICAgIHR5cGU7XG4gICAgLy8gVGhlIGxvY2FsTmFtZSBib3VuZCBpbiB0aGUgc2lnbmF0dXJlLCBpbiB0aGlzIGV4YW1wbGUgaXQgaXMgXCJiYXpcIjpcbiAgICAvLyAgIC0gdHVwbGUoYWRkcmVzcyBmb28sIHVpbnQgYmFyKSBiYXpcbiAgICBsb2NhbE5hbWU7XG4gICAgLy8gV2hldGhlciB0aGlzIHR5cGUgaXMgZHluYW1pYzpcbiAgICAvLyAgLSBEeW5hbWljOiBieXRlcywgc3RyaW5nLCBhZGRyZXNzW10sIHR1cGxlKGJvb2xlYW5bXSksIGV0Yy5cbiAgICAvLyAgLSBOb3QgRHluYW1pYzogYWRkcmVzcywgdWludDI1NiwgYm9vbGVhblszXSwgdHVwbGUoYWRkcmVzcywgdWludDgpXG4gICAgZHluYW1pYztcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZXIgPSBDb2Rlcjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIFdyaXRlciB7XG4gICAgLy8gQW4gYXJyYXkgb2YgV29yZFNpemUgbGVuZ3RoZWQgb2JqZWN0cyB0byBjb25jYXRlbmF0aW9uXG4gICAgI2RhdGE7XG4gICAgI2RhdGFMZW5ndGg7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuY29uY2F0KSh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGFMZW5ndGg7IH1cbiAgICAjd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YSgoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKHdyaXRlci5kYXRhKSk7XG4gICAgfVxuICAgIC8vIEFycmF5aXNoIGl0ZW07IHBhZCBvbiB0aGUgcmlnaHQgdG8gKm5lYXJlc3QqIFdvcmRTaXplXG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIGV4cG9ydHMuV29yZFNpemU7XG4gICAgICAgIGlmIChwYWRkaW5nT2Zmc2V0KSB7XG4gICAgICAgICAgICBieXRlcyA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoKDAsIGluZGV4X2pzXzEuY29uY2F0KShbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIC8vIE51bWVyaWMgaXRlbTsgcGFkIG9uIHRoZSBsZWZ0ICp0byogV29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0cyBhIG51bWVyaWMgcGxhY2UtaG9sZGVyLCByZXR1cm5pbmcgYSBjYWxsYmFjayB0aGF0IGNhblxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuI2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZXhwb3J0cy5Xb3JkU2l6ZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZGF0YVtvZmZzZXRdID0gZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuV3JpdGVyID0gV3JpdGVyO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgUmVhZGVyIHtcbiAgICAvLyBBbGxvd3MgaW5jb21wbGV0ZSB1bnBhZGRlZCBkYXRhIHRvIGJlIHJlYWQ7IG90aGVyd2lzZSBhbiBlcnJvclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGRlYWwgd2l0aCBhbiBvbGQgU29saWRpdHkgYnVnLCBpbiB3aGljaCBldmVudCBkYXRhIGZvclxuICAgIC8vIGV4dGVybmFsIChub3QgcHVibGljIHRob2d1aCkgd2FzIHRpZ2h0bHkgcGFja2VkLlxuICAgIGFsbG93TG9vc2U7XG4gICAgI2RhdGE7XG4gICAgI29mZnNldDtcbiAgICAjYnl0ZXNSZWFkO1xuICAgICNwYXJlbnQ7XG4gICAgI21heEluZmxhdGlvbjtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlLCBtYXhJbmZsYXRpb24pIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhbGxvd0xvb3NlOiAhIWFsbG93TG9vc2UgfSk7XG4gICAgICAgIHRoaXMuI2RhdGEgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKGRhdGEpO1xuICAgICAgICB0aGlzLiNieXRlc1JlYWQgPSAwO1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhJbmZsYXRpb24gPSAobWF4SW5mbGF0aW9uICE9IG51bGwpID8gbWF4SW5mbGF0aW9uIDogMTAyNDtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KSh0aGlzLiNkYXRhKTsgfVxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNkYXRhKTsgfVxuICAgICNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudC4jaW5jcmVtZW50Qnl0ZXNSZWFkKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNieXRlc1JlYWQgKz0gY291bnQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBleGNlc3NpdmUgaW5mbGF0aW9uIChzZWU6ICM0NTM3KVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHRoaXMuI21heEluZmxhdGlvbiA8IDEgfHwgdGhpcy4jYnl0ZXNSZWFkIDw9IHRoaXMuI21heEluZmxhdGlvbiAqIHRoaXMuZGF0YUxlbmd0aCwgYGNvbXByZXNzZWQgQUJJIGRhdGEgZXhjZWVkcyBpbmZsYXRpb24gcmF0aW8gb2YgJHt0aGlzLiNtYXhJbmZsYXRpb259ICggc2VlOiBodHRwczovXFwvZ2l0aHViLmNvbS9ldGhlcnMtaW8vZXRoZXJzLmpzL2lzc3Vlcy80NTM3IClgLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSh0aGlzLiNkYXRhKSwgb2Zmc2V0OiB0aGlzLiNvZmZzZXQsXG4gICAgICAgICAgICBsZW5ndGg6IGNvdW50LCBpbmZvOiB7XG4gICAgICAgICAgICAgICAgYnl0ZXNSZWFkOiB0aGlzLiNieXRlc1JlYWQsXG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aDogdGhpcy5kYXRhTGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjcGVla0J5dGVzKG9mZnNldCwgbGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYWxpZ25lZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyBleHBvcnRzLldvcmRTaXplKSAqIGV4cG9ydHMuV29yZFNpemU7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TG9vc2UgJiYgbG9vc2UgJiYgdGhpcy4jb2Zmc2V0ICsgbGVuZ3RoIDw9IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIFwiZGF0YSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXI6ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodGhpcy4jZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy4jZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCwgdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHN1Yi1yZWFkZXIgd2l0aCB0aGUgc2FtZSB1bmRlcmx5aW5nIGRhdGEsIGJ1dCBvZmZzZXRcbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIodGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQgKyBvZmZzZXQpLCB0aGlzLmFsbG93TG9vc2UsIHRoaXMuI21heEluZmxhdGlvbik7XG4gICAgICAgIHJlYWRlci4jcGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcbiAgICB9XG4gICAgLy8gUmVhZCBieXRlc1xuICAgIHJlYWRCeXRlcyhsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMuI3BlZWtCeXRlcygwLCBsZW5ndGgsICEhbG9vc2UpO1xuICAgICAgICB0aGlzLiNpbmNyZW1lbnRCeXRlc1JlYWQobGVuZ3RoKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGUgbGVuZ3RoLi5lbmQgYnl0ZXMgYXJlIGFsbCAwP1xuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gUmVhZCBhIG51bWVyaWMgdmFsdWVzXG4gICAgcmVhZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEudG9CaWdJbnQpKHRoaXMucmVhZEJ5dGVzKGV4cG9ydHMuV29yZFNpemUpKTtcbiAgICB9XG4gICAgcmVhZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEudG9OdW1iZXIpKHRoaXMucmVhZEJ5dGVzKGV4cG9ydHMuV29yZFNpemUpKTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRlciA9IFJlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/address.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/address.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddressCoder = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst maths_js_1 = __webpack_require__(/*! ../../utils/maths.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  @_ignore\n */\nclass AddressCoder extends abstract_coder_js_1.Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = typed_js_1.Typed.dereference(_value, \"string\");\n        try {\n            value = (0, index_js_1.getAddress)(value);\n        }\n        catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0, index_js_1.getAddress)((0, maths_js_1.toBeHex)(reader.readValue(), 20));\n    }\n}\nexports.AddressCoder = AddressCoder;\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLHlGQUF3QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsMEVBQWE7QUFDeEMsNEJBQTRCLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvYWRkcmVzcy5qcz9lZjkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBtYXRoc19qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL21hdGhzLmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKCgwLCBtYXRoc19qc18xLnRvQmVIZXgpKHJlYWRlci5yZWFkVmFsdWUoKSwgMjApKTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3NDb2RlciA9IEFkZHJlc3NDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/anonymous.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/anonymous.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnonymousCoder = void 0;\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */\nclass AnonymousCoder extends abstract_coder_js_1.Coder {\n    coder;\n    constructor(coder) {\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\nexports.AnonymousCoder = AnonymousCoder;\n//# sourceMappingURL=anonymous.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Fub255bW91cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsNEJBQTRCLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvYW5vbnltb3VzLmpzPzRiNmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFub255bW91c0NvZGVyID0gdm9pZCAwO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCIpO1xuLyoqXG4gKiAgQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuICpcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvZGVyO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyKSB7XG4gICAgICAgIHN1cGVyKGNvZGVyLm5hbWUsIGNvZGVyLnR5cGUsIFwiX1wiLCBjb2Rlci5keW5hbWljKTtcbiAgICAgICAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgfVxufVxuZXhwb3J0cy5Bbm9ueW1vdXNDb2RlciA9IEFub255bW91c0NvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5vbnltb3VzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/anonymous.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/array.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/array.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArrayCoder = exports.unpack = exports.pack = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst anonymous_js_1 = __webpack_require__(/*! ./anonymous.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/anonymous.js\");\n/**\n *  @_ignore\n */\nfunction pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            (0, index_js_1.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n            (0, index_js_1.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n            unique[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        (0, index_js_1.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0, index_js_1.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new abstract_coder_js_1.Writer();\n    let dynamicWriter = new abstract_coder_js_1.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nexports.pack = pack;\n/**\n *  @_ignore\n */\nfunction unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if ((0, index_js_1.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if ((0, index_js_1.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return abstract_coder_js_1.Result.fromItems(values, keys);\n}\nexports.unpack = unpack;\n/**\n *  @_ignore\n */\nclass ArrayCoder extends abstract_coder_js_1.Coder {\n    coder;\n    length;\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        (0, index_js_1.defineProperties)(this, { coder, length });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = typed_js_1.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0, index_js_1.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0, index_js_1.assert)(count * abstract_coder_js_1.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", { buffer: reader.bytes, offset: count * abstract_coder_js_1.WordSize, length: reader.dataLength });\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new anonymous_js_1.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n}\nexports.ArrayCoder = ArrayCoder;\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2FycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGNBQWMsR0FBRyxZQUFZO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLHFGQUFzQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQywwRUFBYTtBQUN4Qyw0QkFBNEIsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCw0QkFBNEIsT0FBTyxpQkFBaUI7QUFDNUssbUlBQW1JLDRCQUE0QixPQUFPLGlCQUFpQjtBQUN2TDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SUFBOEksK0ZBQStGO0FBQzdPO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9hcnJheS5qcz9mZjM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcnJheUNvZGVyID0gZXhwb3J0cy51bnBhY2sgPSBleHBvcnRzLnBhY2sgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbmNvbnN0IGFub255bW91c19qc18xID0gcmVxdWlyZShcIi4vYW5vbnltb3VzLmpzXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XG4gICAgbGV0IGFycmF5VmFsdWVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgdW5pcXVlID0ge307XG4gICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKG5hbWUsIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoIXVuaXF1ZVtuYW1lXSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICB1bmlxdWVbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShjb2RlcnMubGVuZ3RoID09PSBhcnJheVZhbHVlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IGFic3RyYWN0X2NvZGVyX2pzXzEuV3JpdGVyKCk7XG4gICAgbGV0IGR5bmFtaWNXcml0ZXIgPSBuZXcgYWJzdHJhY3RfY29kZXJfanNfMS5Xcml0ZXIoKTtcbiAgICBsZXQgdXBkYXRlRnVuY3MgPSBbXTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFycmF5VmFsdWVzW2luZGV4XTtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGR5bmFtaWMgb2Zmc2V0IChmb3IgdGhlIGZ1dHVyZSBwb2ludGVyKVxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPZmZzZXQgPSBkeW5hbWljV3JpdGVyLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgZHluYW1pYyB2YWx1ZSBpbnRvIHRoZSBkeW5hbWljV3JpdGVyXG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0byBwb3B1bGF0ZSB0aGUgY29ycmVjdCBvZmZzZXQgb25jZSB3ZSBhcmUgZG9uZVxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmMgPSBzdGF0aWNXcml0ZXIud3JpdGVVcGRhdGFibGVWYWx1ZSgpO1xuICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaCgoYmFzZU9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMoYmFzZU9mZnNldCArIGR5bmFtaWNPZmZzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoc3RhdGljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBCYWNrZmlsbCBhbGwgdGhlIGR5bmFtaWMgb2Zmc2V0cywgbm93IHRoYXQgd2Uga25vdyB0aGUgc3RhdGljIGxlbmd0aFxuICAgIHVwZGF0ZUZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKTsgfSk7XG4gICAgbGV0IGxlbmd0aCA9IHdyaXRlci5hcHBlbmRXcml0ZXIoc3RhdGljV3JpdGVyKTtcbiAgICBsZW5ndGggKz0gd3JpdGVyLmFwcGVuZFdyaXRlcihkeW5hbWljV3JpdGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5wYWNrID0gcGFjaztcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHVucGFjayhyZWFkZXIsIGNvZGVycykge1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByZWFkZXIucmVhZEluZGV4KCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUob2Zmc2V0UmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc0Vycm9yKShlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc0Vycm9yKShlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlc3RpZ2F0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChjb2Rlci5sb2NhbE5hbWUgfHwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFic3RyYWN0X2NvZGVyX2pzXzEuUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xufVxuZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgYWJzdHJhY3RfY29kZXJfanNfMS5Db2RlciB7XG4gICAgY29kZXI7XG4gICAgbGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHN1cGVyKFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBjb2RlciwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlZF9qc18xLlR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJhcnJheVwiKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50Q291bnQpKHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoY291bnQgKiBhYnN0cmFjdF9jb2Rlcl9qc18xLldvcmRTaXplIDw9IHJlYWRlci5kYXRhTGVuZ3RoLCBcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiByZWFkZXIuYnl0ZXMsIG9mZnNldDogY291bnQgKiBhYnN0cmFjdF9jb2Rlcl9qc18xLldvcmRTaXplLCBsZW5ndGg6IHJlYWRlci5kYXRhTGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgYW5vbnltb3VzX2pzXzEuQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCBjb2RlcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJyYXlDb2RlciA9IEFycmF5Q29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/boolean.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/boolean.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BooleanCoder = void 0;\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  @_ignore\n */\nclass BooleanCoder extends abstract_coder_js_1.Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = typed_js_1.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n}\nexports.BooleanCoder = BooleanCoder;\n//# sourceMappingURL=boolean.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Jvb2xlYW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFhO0FBQ3hDLDRCQUE0QixtQkFBTyxDQUFDLGtHQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Jvb2xlYW4uanM/ZGYyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQm9vbGVhbkNvZGVyID0gdm9pZCAwO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIEJvb2xlYW5Db2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYm9vbFwiKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAhIXJlYWRlci5yZWFkVmFsdWUoKTtcbiAgICB9XG59XG5leHBvcnRzLkJvb2xlYW5Db2RlciA9IEJvb2xlYW5Db2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/boolean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/bytes.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/bytes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BytesCoder = exports.DynamicBytesCoder = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  @_ignore\n */\nclass DynamicBytesCoder extends abstract_coder_js_1.Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0, index_js_1.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\nexports.DynamicBytesCoder = DynamicBytesCoder;\n/**\n *  @_ignore\n */\nclass BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0, index_js_1.hexlify)(super.decode(reader));\n    }\n}\nexports.BytesCoder = BytesCoder;\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHlCQUF5QjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDakQsNEJBQTRCLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvYnl0ZXMuanM/NDcxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnl0ZXNDb2RlciA9IGV4cG9ydHMuRHluYW1pY0J5dGVzQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRHluYW1pY0J5dGVzQ29kZXIgPSBEeW5hbWljQnl0ZXNDb2Rlcjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIEJ5dGVzQ29kZXIgZXh0ZW5kcyBEeW5hbWljQnl0ZXNDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYnl0ZXNcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnl0ZXNDb2RlciA9IEJ5dGVzQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FixedBytesCoder = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  @_ignore\n */\nclass FixedBytesCoder extends abstract_coder_js_1.Coder {\n    size;\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0, index_js_1.defineProperties)(this, { size }, { size: \"number\" });\n    }\n    defaultValue() {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0, index_js_1.getBytesCopy)(typed_js_1.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0, index_js_1.hexlify)(reader.readBytes(this.size));\n    }\n}\nexports.FixedBytesCoder = FixedBytesCoder;\n//# sourceMappingURL=fixed-bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsMEVBQWE7QUFDeEMsNEJBQTRCLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTSxJQUFJLGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzP2Y5NmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpeGVkQnl0ZXNDb2RlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCB0eXBlZF9qc18xID0gcmVxdWlyZShcIi4uL3R5cGVkLmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgYWJzdHJhY3RfY29kZXJfanNfMS5Db2RlciB7XG4gICAgc2l6ZTtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBcImJ5dGVzXCIgKyBTdHJpbmcoc2l6ZSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHNpemUgfSwgeyBzaXplOiBcIm51bWJlclwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSh0eXBlZF9qc18xLlR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRml4ZWRCeXRlc0NvZGVyID0gRml4ZWRCeXRlc0NvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/null.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/null.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NullCoder = void 0;\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */\nclass NullCoder extends abstract_coder_js_1.Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n}\nexports.NullCoder = NullCoder;\n//# sourceMappingURL=null.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL251bGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLDRCQUE0QixtQkFBTyxDQUFDLGtHQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvbnVsbC5qcz9kMmM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OdWxsQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIE51bGxDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5OdWxsQ29kZXIgPSBOdWxsQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/null.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/number.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/number.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NumberCoder = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */\nclass NumberCoder extends abstract_coder_js_1.Coder {\n    size;\n    signed;\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        (0, index_js_1.defineProperties)(this, { size, signed }, { size: \"number\", signed: \"boolean\" });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0, index_js_1.getBigInt)(typed_js_1.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0, index_js_1.mask)(BN_MAX_UINT256, abstract_coder_js_1.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0, index_js_1.mask)(maxUintValue, (this.size * 8) - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0, index_js_1.toTwos)(value, 8 * abstract_coder_js_1.WordSize);\n        }\n        else if (value < BN_0 || value > (0, index_js_1.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0, index_js_1.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0, index_js_1.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n}\nexports.NumberCoder = NumberCoder;\n//# sourceMappingURL=number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CLG1CQUFPLENBQUMscUZBQXNCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDBFQUFhO0FBQ3hDLDRCQUE0QixtQkFBTyxDQUFDLGtHQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsY0FBYyxJQUFJLG1DQUFtQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvbnVtYmVyLmpzPzExODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk51bWJlckNvZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHR5cGVkX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZWQuanNcIik7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgTnVtYmVyQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBzaXplO1xuICAgIHNpZ25lZDtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBzaWduZWQsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gKChzaWduZWQgPyBcImludFwiIDogXCJ1aW50XCIpICsgKHNpemUgKiA4KSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHNpemUsIHNpZ25lZCB9LCB7IHNpemU6IFwibnVtYmVyXCIsIHNpZ25lZDogXCJib29sZWFuXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSAoMCwgaW5kZXhfanNfMS5nZXRCaWdJbnQpKHR5cGVkX2pzXzEuVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gKDAsIGluZGV4X2pzXzEubWFzaykoQk5fTUFYX1VJTlQyNTYsIGFic3RyYWN0X2NvZGVyX2pzXzEuV29yZFNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRzID0gKDAsIGluZGV4X2pzXzEubWFzaykobWF4VWludFZhbHVlLCAodGhpcy5zaXplICogOCkgLSAxKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJvdW5kcyB8fCB2YWx1ZSA8IC0oYm91bmRzICsgQk5fMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSAoMCwgaW5kZXhfanNfMS50b1R3b3MpKHZhbHVlLCA4ICogYWJzdHJhY3RfY29kZXJfanNfMS5Xb3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCBCTl8wIHx8IHZhbHVlID4gKDAsIGluZGV4X2pzXzEubWFzaykobWF4VWludFZhbHVlLCB0aGlzLnNpemUgKiA4KSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICgwLCBpbmRleF9qc18xLm1hc2spKHJlYWRlci5yZWFkVmFsdWUoKSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgaW5kZXhfanNfMS5mcm9tVHdvcykodmFsdWUsIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLk51bWJlckNvZGVyID0gTnVtYmVyQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/string.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/string.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StringCoder = void 0;\nconst utf8_js_1 = __webpack_require__(/*! ../../utils/utf8.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/utf8.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst bytes_js_1 = __webpack_require__(/*! ./bytes.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/bytes.js\");\n/**\n *  @_ignore\n */\nclass StringCoder extends bytes_js_1.DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0, utf8_js_1.toUtf8Bytes)(typed_js_1.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0, utf8_js_1.toUtf8String)(super.decode(reader));\n    }\n}\nexports.StringCoder = StringCoder;\n//# sourceMappingURL=string.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsa0JBQWtCLG1CQUFPLENBQUMsbUZBQXFCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFhO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3N0cmluZy5qcz82NzFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpbmdDb2RlciA9IHZvaWQgMDtcbmNvbnN0IHV0ZjhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy91dGY4LmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGJ5dGVzX2pzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgYnl0ZXNfanNfMS5EeW5hbWljQnl0ZXNDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwic3RyaW5nXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW5jb2RlKHdyaXRlciwgKDAsIHV0ZjhfanNfMS50b1V0ZjhCeXRlcykodHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGY4X2pzXzEudG9VdGY4U3RyaW5nKShzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdDb2RlciA9IFN0cmluZ0NvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/tuple.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/tuple.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TupleCoder = void 0;\nconst properties_js_1 = __webpack_require__(/*! ../../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst array_js_1 = __webpack_require__(/*! ./array.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/array.js\");\n/**\n *  @_ignore\n */\nclass TupleCoder extends abstract_coder_js_1.Coder {\n    coders;\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        (0, properties_js_1.defineProperties)(this, { coders: Object.freeze(coders.slice()) });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = typed_js_1.Typed.dereference(_value, \"tuple\");\n        return (0, array_js_1.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0, array_js_1.unpack)(reader, this.coders);\n    }\n}\nexports.TupleCoder = TupleCoder;\n//# sourceMappingURL=tuple.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3R1cGxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQix3QkFBd0IsbUJBQU8sQ0FBQywrRkFBMkI7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsMEVBQWE7QUFDeEMsNEJBQTRCLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzREFBc0QsdUNBQXVDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvdHVwbGUuanM/MjNhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHVwbGVDb2RlciA9IHZvaWQgMDtcbmNvbnN0IHByb3BlcnRpZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9wcm9wZXJ0aWVzLmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbmNvbnN0IGFycmF5X2pzXzEgPSByZXF1aXJlKFwiLi9hcnJheS5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIFR1cGxlQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb2RlcnM7XG4gICAgY29uc3RydWN0b3IoY29kZXJzLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoXCJ0dXBsZShcIiArIHR5cGVzLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICAgICAgICBzdXBlcihcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBjb2RlcnM6IE9iamVjdC5mcmVlemUoY29kZXJzLnNsaWNlKCkpIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2Ugb25seSBvdXRwdXQgbmFtZWQgcHJvcGVydGllcyBmb3IgdW5pcXVlbHkgbmFtZWQgY29kZXJzXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gdGhpcy5jb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIEFkZCBuYW1lZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVkX2pzXzEuVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInR1cGxlXCIpO1xuICAgICAgICByZXR1cm4gKDAsIGFycmF5X2pzXzEucGFjaykod3JpdGVyLCB0aGlzLmNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAoMCwgYXJyYXlfanNfMS51bnBhY2spKHJlYWRlciwgdGhpcy5jb2RlcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHVwbGVDb2RlciA9IFR1cGxlQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/fragments.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/fragments.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable override\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view override\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\", \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() { return this.#offset; }\n    get length() { return this.#tokens.length - this.#offset; }\n    constructor(tokens) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() { return new TokenString(this.#tokens); }\n    reset() { this.#offset = 0; }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({}, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            const top = this.peek();\n            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while (this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return (top.type === type) ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while (offset < text.length) {\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            }\n            else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                (tokens[token.match]).match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n            }\n            else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            }\n            else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            }\n            else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    (tokens[tokens.length - 1]).value = (0, index_js_1.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (tokens[tokens.length - 1]).text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || (allowed && !allowed.has(keyword))) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0, index_js_1.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0, index_js_1.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0, index_js_1.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    }\n    else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nclass ParamType {\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    name;\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    type;\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    baseType;\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    indexed;\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    components;\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayLength;\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayChildren;\n    /**\n     *  @private\n     */\n    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\n        (0, index_js_1.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0, index_js_1.defineProperties)(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n        }\n        else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray() {\n        return (this.baseType === \"array\");\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple() {\n        return (this.baseType === \"tuple\");\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable() {\n        return (this.indexed != null);\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            }\n            else {\n                if (value == null || typeof (value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param) => {\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function () { setValue(await result); })());\n        }\n        else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value, process) {\n        const promises = [];\n        const result = [value];\n        this.#walkAsync(promises, value, process, (value) => {\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            }\n            catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${comps.map((c) => c.format()).join(\",\")})`;\n            }\n            else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = (obj.peekType(\"ID\") ? obj.pop().text : \"\");\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0, index_js_1.assertArgument)(!name || (typeof (name) === \"string\" && name.match(regexId)), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0, index_js_1.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value) {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\nexports.ParamType = ParamType;\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nclass Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    type;\n    /**\n     *  The inputs for the fragment.\n     */\n    inputs;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs) {\n        (0, index_js_1.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0, index_js_1.defineProperties)(this, { type, inputs });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            }\n            catch (e) { }\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n        }\n        else if (typeof (obj) === \"object\") {\n            // JSON ABI\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n            (0, index_js_1.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0, index_js_1.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\nexports.Fragment = Fragment;\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nclass NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    name;\n    /**\n     *  @private\n     */\n    constructor(guard, type, name, inputs) {\n        super(guard, type, inputs);\n        (0, index_js_1.assertArgument)(typeof (name) === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0, index_js_1.defineProperties)(this, { name });\n    }\n}\nexports.NamedFragment = NamedFragment;\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nclass ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n    /**\n     *  The Custom Error selector.\n     */\n    get selector() {\n        return (0, index_js_2.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\nexports.ErrorFragment = ErrorFragment;\n/**\n *  A Fragment which represents an Event.\n */\nclass EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    anonymous;\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs, anonymous) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        (0, index_js_1.defineProperties)(this, { anonymous });\n    }\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash() {\n        return (0, index_js_2.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n    static getTopicHash(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\nexports.EventFragment = EventFragment;\n/**\n *  A Fragment which represents a constructor.\n */\nclass ConstructorFragment extends Fragment {\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    payable;\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs, payable, gas) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        (0, index_js_1.defineProperties)(this, { payable, gas });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */\n    format(format) {\n        (0, index_js_1.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\" : \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [`constructor${joinParams(format, this.inputs)}`];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\"constructor\"]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\nexports.ConstructorFragment = ConstructorFragment;\n/**\n *  A Fragment which represents a method.\n */\nclass FallbackFragment extends Fragment {\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    constructor(guard, inputs, payable) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        (0, index_js_1.defineProperties)(this, { payable });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */\n    format(format) {\n        const type = ((this.inputs.length === 0) ? \"receive\" : \"fallback\");\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\" : \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n            (0, index_js_1.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0, index_js_1.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\"payable\"]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            else {\n                inputs = [ParamType.from(\"bytes\")];\n            }\n            const mutability = consumeMutability(obj);\n            (0, index_js_1.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [ParamType.from(\"bytes\")];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0, index_js_1.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\nexports.FallbackFragment = FallbackFragment;\n/**\n *  A Fragment which represents a method.\n */\nclass FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    constant;\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    outputs;\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    stateMutability;\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, name, stateMutability, inputs, outputs, gas) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        (0, index_js_1.defineProperties)(this, { constant, gas, outputs, payable, stateMutability });\n    }\n    /**\n     *  The Function selector.\n     */\n    get selector() {\n        return (0, index_js_2.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n    static getSelector(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof (obj.constant) === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            }\n            else if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\nexports.FunctionFragment = FunctionFragment;\n/**\n *  A Fragment which represents a structure.\n */\nclass StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */\n    format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\nexports.StructFragment = StructFragment;\n//# sourceMappingURL=fragments.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvZnJhZ21lbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUI7QUFDek4sbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFrQjtBQUM3QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sTUFBTSxVQUFVLEVBQUUseUJBQXlCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQSwyQkFBMkIsV0FBVyxHQUFHLFdBQVc7QUFDcEQ7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPLEtBQUssT0FBTyxJQUFJLFFBQVE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCLGNBQWMsT0FBTztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQW9CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSyxRQUFRLFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjLElBQUksa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQXVEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBdUQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsV0FBVztBQUNsRjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUztBQUN4RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhCQUE4QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw4QkFBOEI7QUFDOUUsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQ0FBb0M7QUFDcEYsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSw4QkFBOEI7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUNBQWlDO0FBQ2pGLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0Esa0JBQWtCLEtBQUssSUFBSSwrQkFBK0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUNBQWlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrREFBa0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsK0JBQStCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9mcmFnbWVudHMuanM/MjI0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgZnJhZ21lbnQgaXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIEFCSSwgd2hpY2ggbWF5IHJlcHJlc2VudCBhbnkgb2Y6XG4gKlxuICogIC0gW0Z1bmN0aW9uc10oRnVuY3Rpb25GcmFnbWVudClcbiAqICAtIFtFdmVudHNdKEV2ZW50RnJhZ21lbnQpXG4gKiAgLSBbQ29uc3RydWN0b3JzXShDb25zdHJ1Y3RvckZyYWdtZW50KVxuICogIC0gQ3VzdG9tIFtFcnJvcnNdKEVycm9yRnJhZ21lbnQpXG4gKiAgLSBbRmFsbGJhY2sgb3IgUmVjZWl2ZV0oRmFsbGJhY2tGcmFnbWVudCkgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpGcmFnbWVudHMgIFthYm91dC1mcmFnbWVudHNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RydWN0RnJhZ21lbnQgPSBleHBvcnRzLkZ1bmN0aW9uRnJhZ21lbnQgPSBleHBvcnRzLkZhbGxiYWNrRnJhZ21lbnQgPSBleHBvcnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQgPSBleHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBleHBvcnRzLkVycm9yRnJhZ21lbnQgPSBleHBvcnRzLk5hbWVkRnJhZ21lbnQgPSBleHBvcnRzLkZyYWdtZW50ID0gZXhwb3J0cy5QYXJhbVR5cGUgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuO1xuLy8gWyBcImFcIiwgXCJiXCIgXSA9PiB7IFwiYVwiOiAxLCBcImJcIjogMSB9XG5mdW5jdGlvbiBzZXRpZnkoaXRlbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgaXRlbXMuZm9yRWFjaCgoaykgPT4gcmVzdWx0LmFkZChrKSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbn1cbmNvbnN0IF9rd1Zpc2liRGVwbG95ID0gXCJleHRlcm5hbCBwdWJsaWMgcGF5YWJsZSBvdmVycmlkZVwiO1xuY29uc3QgS3dWaXNpYkRlcGxveSA9IHNldGlmeShfa3dWaXNpYkRlcGxveS5zcGxpdChcIiBcIikpO1xuLy8gVmlzaWJpbGl0eSBLZXl3b3Jkc1xuY29uc3QgX2t3VmlzaWIgPSBcImNvbnN0YW50IGV4dGVybmFsIGludGVybmFsIHBheWFibGUgcHJpdmF0ZSBwdWJsaWMgcHVyZSB2aWV3IG92ZXJyaWRlXCI7XG5jb25zdCBLd1Zpc2liID0gc2V0aWZ5KF9rd1Zpc2liLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dUeXBlcyA9IFwiY29uc3RydWN0b3IgZXJyb3IgZXZlbnQgZmFsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZSBzdHJ1Y3RcIjtcbmNvbnN0IEt3VHlwZXMgPSBzZXRpZnkoX2t3VHlwZXMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd01vZGlmaWVycyA9IFwiY2FsbGRhdGEgbWVtb3J5IHN0b3JhZ2UgcGF5YWJsZSBpbmRleGVkXCI7XG5jb25zdCBLd01vZGlmaWVycyA9IHNldGlmeShfa3dNb2RpZmllcnMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd090aGVyID0gXCJ0dXBsZSByZXR1cm5zXCI7XG4vLyBBbGwgS2V5d29yZHNcbmNvbnN0IF9rZXl3b3JkcyA9IFtfa3dUeXBlcywgX2t3TW9kaWZpZXJzLCBfa3dPdGhlciwgX2t3VmlzaWJdLmpvaW4oXCIgXCIpO1xuY29uc3QgS2V5d29yZHMgPSBzZXRpZnkoX2tleXdvcmRzLnNwbGl0KFwiIFwiKSk7XG4vLyBTaW5nbGUgY2hhcmFjdGVyIHRva2Vuc1xuY29uc3QgU2ltcGxlVG9rZW5zID0ge1xuICAgIFwiKFwiOiBcIk9QRU5fUEFSRU5cIiwgXCIpXCI6IFwiQ0xPU0VfUEFSRU5cIixcbiAgICBcIltcIjogXCJPUEVOX0JSQUNLRVRcIiwgXCJdXCI6IFwiQ0xPU0VfQlJBQ0tFVFwiLFxuICAgIFwiLFwiOiBcIkNPTU1BXCIsIFwiQFwiOiBcIkFUXCJcbn07XG4vLyBQYXJzZXIgcmVnZXhlcyB0byBjb25zdW1lIHRoZSBuZXh0IHRva2VuXG5jb25zdCByZWdleFdoaXRlc3BhY2VQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXCIpO1xuY29uc3QgcmVnZXhOdW1iZXJQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbMC05XSspXCIpO1xuY29uc3QgcmVnZXhJZFByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcIik7XG4vLyBQYXJzZXIgcmVnZXhzIHRvIGNoZWNrIHZhbGlkaXR5XG5jb25zdCByZWdleElkID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKSRcIik7XG5jb25zdCByZWdleFR5cGUgPSBuZXcgUmVnRXhwKFwiXihhZGRyZXNzfGJvb2x8Ynl0ZXMoWzAtOV0qKXxzdHJpbmd8dT9pbnQoWzAtOV0qKSkkXCIpO1xuY2xhc3MgVG9rZW5TdHJpbmcge1xuICAgICNvZmZzZXQ7XG4gICAgI3Rva2VucztcbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy4jb2Zmc2V0OyB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3Rva2Vucy5sZW5ndGggLSB0aGlzLiNvZmZzZXQ7IH1cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMpIHtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy4jdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7XG4gICAgfVxuICAgIGNsb25lKCkgeyByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucyk7IH1cbiAgICByZXNldCgpIHsgdGhpcy4jb2Zmc2V0ID0gMDsgfVxuICAgICNzdWJUb2tlblN0cmluZyhmcm9tID0gMCwgdG8gPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zLnNsaWNlKGZyb20sIHRvKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICAgICAgICAgICAgICBtYXRjaDogKHQubWF0Y2ggLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rQmFjazogKHQubGlua0JhY2sgLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rTmV4dDogKHQubGlua05leHQgLSBmcm9tKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGFsbG93ZWQ7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiS0VZV09SRFwiIHx8ICFhbGxvd2VkLmhhcyh0b3AudGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQga2V5d29yZCAke3RvcC50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9OyBnb3QgJHt0b3AudHlwZX0gJHtKU09OLnN0cmluZ2lmeSh0b3AudGV4dCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyBhIFwiKFwiIFRPS0VOUyBcIilcIlxuICAgIHBvcFBhcmVuKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIHRvcC5tYXRjaCArIDEpO1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSB0b3AubWF0Y2ggKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSBpdGVtcyB3aXRoaW4gXCIoXCIgSVRFTTEgXCIsXCIgSVRFTTIgXCIsXCIgLi4uIFwiKVwiXG4gICAgcG9wUGFyYW1zKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy4jb2Zmc2V0IDwgdG9wLm1hdGNoIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IHRoaXMucGVlaygpLmxpbmtOZXh0O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgbGluaykpO1xuICAgICAgICAgICAgdGhpcy4jb2Zmc2V0ID0gbGluaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNvZmZzZXQgPSB0b3AubWF0Y2ggKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB0b3AgVG9rZW4sIHRocm93aW5nIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ID49IHRoaXMuI3Rva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm91dC1vZi1ib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3Rva2Vuc1t0aGlzLiNvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHZhbHVlLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYGFsbG93ZWRgXG4gICAgcGVla0tleXdvcmQoYWxsb3dlZCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWtUeXBlKFwiS0VZV09SRFwiKTtcbiAgICAgICAgcmV0dXJuICh0b3AgIT0gbnVsbCAmJiBhbGxvd2VkLmhhcyh0b3ApKSA/IHRvcCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYFxuICAgIHBlZWtUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgcmV0dXJuICh0b3AudHlwZSA9PT0gdHlwZSkgPyB0b3AudGV4dCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdG9rZW47IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI29mZnNldDsgaSA8IHRoaXMuI3Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLiN0b2tlbnNbaV07XG4gICAgICAgICAgICB0b2tlbnMucHVzaChgJHt0b2tlbi50eXBlfToke3Rva2VuLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGA8VG9rZW5TdHJpbmcgJHt0b2tlbnMuam9pbihcIiBcIil9PmA7XG4gICAgfVxufVxuZnVuY3Rpb24gbGV4KHRleHQpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBjb25zdCB0aHJvd0Vycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpID8gSlNPTi5zdHJpbmdpZnkodGV4dFtvZmZzZXRdKSA6IFwiJEVPSVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdG9rZW4gJHt0b2tlbn0gYXQgJHtvZmZzZXR9OiAke21lc3NhZ2V9YCk7XG4gICAgfTtcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcbiAgICBsZXQgY29tbWFzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vIFN0cmlwIG9mZiBhbnkgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIGxldCBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhXaGl0ZXNwYWNlUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IHsgZGVwdGg6IGJyYWNrZXRzLmxlbmd0aCwgbGlua0JhY2s6IC0xLCBsaW5rTmV4dDogLTEsIG1hdGNoOiAtMSwgdHlwZTogXCJcIiwgdGV4dDogXCJcIiwgb2Zmc2V0LCB2YWx1ZTogLTEgfTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBsZXQgdHlwZSA9IChTaW1wbGVUb2tlbnNbY3VyWzBdXSB8fCBcIlwiKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IGN1clswXTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIkNMT1NFX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJubyBtYXRjaGluZyBvcGVuIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoID0gYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5tYXRjaF0pLm1hdGNoID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdG9rZW4uZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ09NTUFcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT1BFTl9CUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJCUkFDS0VUXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNMT1NFX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgQ0xPU0VfQlJBQ0tFVFxuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlID09PSBcIk5VTUJFUlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHZhbHVlICsgc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudmFsdWUgPSAoMCwgaW5kZXhfanNfMS5nZXROdW1iZXIpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSBcIkJSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG9wZW5pbmcgYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnRleHQgKz0gc3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhJZFByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKEtleXdvcmRzLmhhcyh0b2tlbi50ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIktFWVdPUkRcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50ZXh0Lm1hdGNoKHJlZ2V4VHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJUWVBFXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJJRFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhOdW1iZXJQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIk5VTUJFUlwiO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VuICR7SlNPTi5zdHJpbmdpZnkoY3VyWzBdKX0gYXQgcG9zaXRpb24gJHtvZmZzZXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodG9rZW5zLm1hcCgodCkgPT4gT2JqZWN0LmZyZWV6ZSh0KSkpO1xufVxuLy8gQ2hlY2sgb25seSBvbmUgb2YgYGFsbG93ZWRgIGlzIGluIGBzZXRgXG5mdW5jdGlvbiBhbGxvd1NpbmdsZShzZXQsIGFsbG93ZWQpIHtcbiAgICBsZXQgaW5jbHVkZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhbGxvd2VkLmtleXMoKSkge1xuICAgICAgICBpZiAoc2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBpbmNsdWRlZC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluY2x1ZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25mbGljdGluZyB0eXBlczogJHtpbmNsdWRlZC5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxufVxuLy8gRnVuY3Rpb25zIHRvIHByb2Nlc3MgYSBTb2xpZGl0eSBTaWduYXR1cmUgVG9rZW5TdHJpbmcgZnJvbSBsZWZ0LXRvLXJpZ2h0IGZvci4uLlxuLy8gLi4udGhlIG5hbWUgd2l0aCBhbiBvcHRpb25hbCB0eXBlLCByZXR1cm5pbmcgdGhlIG5hbWVcbmZ1bmN0aW9uIGNvbnN1bWVOYW1lKHR5cGUsIHRva2Vucykge1xuICAgIGlmICh0b2tlbnMucGVla0tleXdvcmQoS3dUeXBlcykpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICBpZiAoa2V5d29yZCAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9LCBnb3QgJHtrZXl3b3JkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnMucG9wVHlwZShcIklEXCIpO1xufVxuLy8gLi4uYWxsIGtleXdvcmRzIG1hdGNoaW5nIGFsbG93ZWQsIHJldHVybmluZyB0aGUga2V5d29yZHNcbmZ1bmN0aW9uIGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIGFsbG93ZWQpIHtcbiAgICBjb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkID0gdG9rZW5zLnBlZWtUeXBlKFwiS0VZV09SRFwiKTtcbiAgICAgICAgaWYgKGtleXdvcmQgPT0gbnVsbCB8fCAoYWxsb3dlZCAmJiAhYWxsb3dlZC5oYXMoa2V5d29yZCkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoa2V5d29yZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIGtleXdvcmRzOiAke0pTT04uc3RyaW5naWZ5KGtleXdvcmQpfWApO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRzLmFkZChrZXl3b3JkKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoa2V5d29yZHMpO1xufVxuLy8gLi4uYWxsIHZpc2liaWxpdHkga2V5d29yZHMsIHJldHVybmluZyB0aGUgY29hbGVzY2VkIG11dGFiaWxpdHlcbmZ1bmN0aW9uIGNvbnN1bWVNdXRhYmlsaXR5KHRva2Vucykge1xuICAgIGxldCBtb2RpZmllcnMgPSBjb25zdW1lS2V5d29yZHModG9rZW5zLCBLd1Zpc2liKTtcbiAgICAvLyBEZXRlY3QgY29uZmxpY3RpbmcgbW9kaWZpZXJzXG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJjb25zdGFudCBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcInB1cmUgdmlldyBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcbiAgICAvLyBQcm9jZXNzIG11dGFiaWxpdHkgc3RhdGVzXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJ2aWV3XCIpKSB7XG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwdXJlXCIpKSB7XG4gICAgICAgIHJldHVybiBcInB1cmVcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwYXlhYmxlXCIpKSB7XG4gICAgICAgIHJldHVybiBcInBheWFibGVcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJub25wYXlhYmxlXCIpKSB7XG4gICAgICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBsZWdhY3kgYGNvbnN0YW50YCBsYXN0XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJjb25zdGFudFwiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcbn1cbi8vIC4uLmEgcGFyYW1ldGVyIGxpc3QsIHJldHVybmluZyB0aGUgUGFyYW1UeXBlIGxpc3RcbmZ1bmN0aW9uIGNvbnN1bWVQYXJhbXModG9rZW5zLCBhbGxvd0luZGV4ZWQpIHtcbiAgICByZXR1cm4gdG9rZW5zLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCwgYWxsb3dJbmRleGVkKSk7XG59XG4vLyAuLi5hIGdhcyBsaW1pdCwgcmV0dXJuaW5nIGEgQmlnTnVtYmVyIG9yIG51bGwgaWYgbm9uZVxuZnVuY3Rpb24gY29uc3VtZUdhcyh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiQVRcIikpIHtcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiTlVNQkVSXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0QmlnSW50KSh0b2tlbnMucG9wKCkudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBnYXNcIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3VtZUVvaSh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW5zIGF0IG9mZnNldCAke3Rva2Vucy5vZmZzZXR9OiAke3Rva2Vucy50b1N0cmluZygpfWApO1xuICAgIH1cbn1cbmNvbnN0IHJlZ2V4QXJyYXlUeXBlID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmZ1bmN0aW9uIHZlcmlmeUJhc2ljVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4VHlwZSk7XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKG1hdGNoLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwidWludFwiKSB7XG4gICAgICAgIHJldHVybiBcInVpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaW50MjU2XCI7XG4gICAgfVxuICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAvLyBieXRlc1hYXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXRjaFszXSkge1xuICAgICAgICAvLyBpbnRYWCBvciB1aW50WFhcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIE1ha2UgdGhlIEZyYWdtZW50IGNvbnN0cnVjdG9ycyBlZmZlY3RpdmVseSBwcml2YXRlXG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfaW50ZXJuYWxcIik7XG5jb25zdCBQYXJhbVR5cGVJbnRlcm5hbCA9IFwiX1BhcmFtVHlwZUludGVybmFsXCI7XG5jb25zdCBFcnJvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9FcnJvckludGVybmFsXCI7XG5jb25zdCBFdmVudEZyYWdtZW50SW50ZXJuYWwgPSBcIl9FdmVudEludGVybmFsXCI7XG5jb25zdCBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9Db25zdHJ1Y3RvckludGVybmFsXCI7XG5jb25zdCBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgPSBcIl9GYWxsYmFja0ludGVybmFsXCI7XG5jb25zdCBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgPSBcIl9GdW5jdGlvbkludGVybmFsXCI7XG5jb25zdCBTdHJ1Y3RGcmFnbWVudEludGVybmFsID0gXCJfU3RydWN0SW50ZXJuYWxcIjtcbi8qKlxuICogIEVhY2ggaW5wdXQgYW5kIG91dHB1dCBvZiBhIFtbRnJhZ21lbnRdXSBpcyBhbiBBcnJheSBvZiAqKlBhcmFtVHlwZSoqLlxuICovXG5jbGFzcyBQYXJhbVR5cGUge1xuICAgIC8qKlxuICAgICAqICBUaGUgbG9jYWwgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIChvciBgYFwiXCJgYCBpZiB1bmJvdW5kKVxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxseSBxdWFsaWZpZWQgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZShhZGRyZXNzKVwiYGAsXG4gICAgICogIGBgXCJ1aW50MjU2WzNdW11cImBgKVxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBiYXNlIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGVcImBgLCBgYFwiYXJyYXlcImBgKVxuICAgICAqL1xuICAgIGJhc2VUeXBlO1xuICAgIC8qKlxuICAgICAqICBUcnVlIGlmIHRoZSBwYXJhbWV0ZXJzIGlzIGluZGV4ZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1pbmRleGFibGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBpbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29tcG9uZW50cyBmb3IgdGhlIHR1cGxlLlxuICAgICAqXG4gICAgICogIEZvciBub24tdHVwbGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBjb21wb25lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJyYXkgbGVuZ3RoLCBvciBgYC0xYGAgZm9yIGR5bmFtaWMtbGVuZ3RoZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUxlbmd0aDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgZWFjaCBjaGlsZCBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFycmF5Q2hpbGRyZW47XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIlBhcmFtVHlwZVwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBQYXJhbVR5cGVJbnRlcm5hbCB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBPYmplY3QuZnJlZXplKGNvbXBvbmVudHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJheUxlbmd0aCAhPSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsXG4gICAgICpcbiAgICAgKiAgYGBzaWdoYXNoXCIgPT4gXCIodWludDI1NixhZGRyZXNzKVwiYGBcbiAgICAgKlxuICAgICAqICBgYFwibWluaW1hbFwiID0+IFwidHVwbGUodWludDI1NixhZGRyZXNzKSBpbmRleGVkXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJmdWxsXCIgPT4gXCJ0dXBsZSh1aW50MjU2IGZvbywgYWRkcmVzcyBiYXIpIGluZGV4ZWQgYmF6XCJgYFxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSh0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJlc3VsdC50eXBlICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLmluZGV4ZWQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKChjKSA9PiBKU09OLnBhcnNlKGMuZm9ybWF0KGZvcm1hdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAvLyBBcnJheVxuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICByZXN1bHQgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiKFwiICsgdGhpcy5jb21wb25lbnRzLm1hcCgoY29tcCkgPT4gY29tcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgaW5kZXhlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJmdWxsXCIgJiYgdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gQXJyYXkgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbYXJyYXlDaGlsZHJlbl1dXG4gICAgICogIGFuZCBbW2FycmF5TGVuZ3RoXV0gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhIFR1cGxlIHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2NvbXBvbmVudHNdXVxuICAgICAqICBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc1R1cGxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gSW5kZXhhYmxlIHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2luZGV4ZWRdXVxuICAgICAqICBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0luZGV4YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4ZWQgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgY2FsbGluZyAlJXByb2Nlc3MlJVxuICAgICAqICBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXG4gICAgICovXG4gICAgd2Fsayh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IChfdGhpcy5hcnJheUNoaWxkcmVuLndhbGsodiwgcHJvY2VzcykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYsIGkpID0+IChfdGhpcy5jb21wb25lbnRzW2ldLndhbGsodiwgcHJvY2VzcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsIHNldFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5hcnJheUNoaWxkcmVuO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZFR5cGUuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mICh2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcG9uZW50cy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW0ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBvYmplY3QgdmFsdWUgd2l0aCB1bm5hbWVkIGNvbXBvbmVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW0ubmFtZSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgY29tcG9uZW50ICR7cGFyYW0ubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2luZGV4XS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgc2V0VmFsdWUoYXdhaXQgcmVzdWx0KTsgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgYXN5bmNocm9ub3VzbHkgY2FsbGluZ1xuICAgICAqICAlJXByb2Nlc3MlJSBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgdXNlZCB0byByZXNvbHZlIEVOUyBuYWVzIGJ5IHdhbGtpbmcgYW5kIHJlc29sdmluZyBlYWNoXG4gICAgICogIGBgXCJhZGRyZXNzXCJgYCB0eXBlLlxuICAgICAqL1xuICAgIGFzeW5jIHdhbGtBc3luYyh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbdmFsdWVdO1xuICAgICAgICB0aGlzLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUGFyYW1UeXBlKiogZm9yICUlb2JqJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVhbGxvd0luZGV4ZWQlJSB0aGVuIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIGlzIHBlcm1pdHRlZCxcbiAgICAgKiAgb3RoZXJ3aXNlIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgaWYgKFBhcmFtVHlwZS5pc1BhcmFtVHlwZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tKGxleChvYmopLCBhbGxvd0luZGV4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgcGFyYW0gdHlwZVwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IFwiXCIsIGJhc2VUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIGxldCBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInR1cGxlXCJdKSkuaGFzKFwidHVwbGVcIikgfHwgb2JqLnBlZWtUeXBlKFwiT1BFTl9QQVJFTlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFR1cGxlXG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcInR1cGxlXCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBvYmoucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0KSk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGB0dXBsZSgke2NvbXBzLm1hcCgoYykgPT4gYy5mb3JtYXQoKSkuam9pbihcIixcIil9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxcbiAgICAgICAgICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai5wb3BUeXBlKFwiVFlQRVwiKSk7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEFycmF5XG4gICAgICAgICAgICBsZXQgYXJyYXlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyYXlMZW5ndGggPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKG9iai5sZW5ndGggJiYgb2JqLnBlZWtUeXBlKFwiQlJBQ0tFVFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyYWNrZXQgPSBvYmoucG9wKCk7IC8vYXJyYXlzW2ldO1xuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW4gPSBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgXCJcIiwgdHlwZSwgYmFzZVR5cGUsIG51bGwsIGNvbXBzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGggPSBicmFja2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHR5cGUgKz0gYnJhY2tldC50ZXh0O1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbmRleGVkID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRzID0gY29uc3VtZUtleXdvcmRzKG9iaiwgS3dNb2RpZmllcnMpO1xuICAgICAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhcImluZGV4ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IChvYmoucGVla1R5cGUoXCJJRFwiKSA/IG9iai5wb3AoKS50ZXh0IDogXCJcIik7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxlZnRvdmVyIHRva2Vuc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IG9iai5uYW1lO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoIW5hbWUgfHwgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSksIFwiaW52YWxpZCBuYW1lXCIsIFwib2JqLm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGxldCBpbmRleGVkID0gb2JqLmluZGV4ZWQ7XG4gICAgICAgIGlmIChpbmRleGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShhbGxvd0luZGV4ZWQsIFwicGFyYW1ldGVyIGNhbm5vdCBiZSBpbmRleGVkXCIsIFwib2JqLmluZGV4ZWRcIiwgb2JqLmluZGV4ZWQpO1xuICAgICAgICAgICAgaW5kZXhlZCA9ICEhaW5kZXhlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IG9iai50eXBlO1xuICAgICAgICBsZXQgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheVR5cGUpO1xuICAgICAgICBpZiAoYXJyYXlNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBwYXJzZUludChhcnJheU1hdGNoWzJdIHx8IFwiLTFcIik7XG4gICAgICAgICAgICBjb25zdCBhcnJheUNoaWxkcmVuID0gUGFyYW1UeXBlLmZyb20oe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFycmF5TWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogb2JqLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwiYXJyYXlcIiwgaW5kZXhlZCwgbnVsbCwgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcInR1cGxlXCIgfHwgdHlwZS5zdGFydHNXaXRoKFwidHVwbGUoXCIgLyogZml4OiApICovKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCIoXCIgLyogZml4OiApICovKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcHMgPSAob2JqLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBvYmouY29tcG9uZW50cy5tYXAoKGMpID0+IFBhcmFtVHlwZS5mcm9tKGMpKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB0dXBsZSA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwidHVwbGVcIiwgaW5kZXhlZCwgY29tcHMsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHVzZSBsZXhlciB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB0dXBsZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai50eXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIHR5cGUsIGluZGV4ZWQsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhICoqUGFyYW1UeXBlKiouXG4gICAgICovXG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBQYXJhbVR5cGVJbnRlcm5hbCk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJhbVR5cGUgPSBQYXJhbVR5cGU7XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudCBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5jbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5wdXRzIGZvciB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgaW5wdXRzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0UHJpdmF0ZSkoZ3VhcmQsIF9ndWFyZCwgXCJGcmFnbWVudFwiKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgdHlwZSwgaW5wdXRzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZyYWdtZW50KiogZm9yICUlb2JqJSUsIHdpY2ggY2FuIGJlIGFueSBzdXBwb3J0ZWRcbiAgICAgKiAgQUJJIGZyZ2FtZW50IHR5cGUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIEpTT04uLi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRnJhZ21lbnQuZnJvbShKU09OLnBhcnNlKG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlLCB1c2UgdGhlIGh1bWFuLXJlYWRhYmxlIGxleGVyXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBIdW1hbi1yZWFkYWJsZSBBQkkgKGFscmVhZHkgbGV4ZWQpXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBlZWtLZXl3b3JkKEt3VHlwZXMpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gSlNPTiBBQklcbiAgICAgICAgICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBgdW5zdXBwb3J0ZWQgdHlwZTogJHtvYmoudHlwZX1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIkZyYWdtZW50LmZyb21cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIGZyZ2FtZW50IG9iamVjdFwiLCBcIm9ialwiLCBvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbQ29uc3RydWN0b3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0NvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0Vycm9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFcnJvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFdmVudEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tGdW5jdGlvbkZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tTdHJ1Y3RGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1N0cnVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnRcbiAqICB3aGljaCBoYXMgYSBuYW1lIGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmNsYXNzIE5hbWVkRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCksIFwiaW52YWxpZCBpZGVudGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWVkRnJhZ21lbnQgPSBOYW1lZEZyYWdtZW50O1xuZnVuY3Rpb24gam9pblBhcmFtcyhmb3JtYXQsIHBhcmFtcykge1xuICAgIHJldHVybiBcIihcIiArIHBhcmFtcy5tYXAoKHApID0+IHAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSAvL0N1c3RvbSBFcnJvci8vLlxuICovXG5jbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJlcnJvclwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEVycm9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBDdXN0b20gRXJyb3Igc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuaWQpKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkVycm9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJlcnJvclwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cbiAgICAgKiAgKipFcnJvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEVycm9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuZXhwb3J0cy5FcnJvckZyYWdtZW50ID0gRXJyb3JGcmFnbWVudDtcbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhbiBFdmVudC5cbiAqL1xuY2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoaXMgZXZlbnQgaXMgYW5vbnltb3VzLlxuICAgICAqL1xuICAgIGFub255bW91cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXZlbnRcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFdmVudEZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYW5vbnltb3VzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEV2ZW50IHRvcGljIGhhc2guXG4gICAgICovXG4gICAgZ2V0IHRvcGljSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmlkKSh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV2ZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJldmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIgJiYgdGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRvcGljIGhhc2ggZm9yIGFuIGV2ZW50IHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRvcGljSGFzaChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBwYXJhbXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFdmVudEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgZXZlbnQgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXZlbnRcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGFub255bW91cyA9ICEhY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImFub255bW91c1wiXSkpLmhhcyhcImFub255bW91c1wiKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwLCB0cnVlKSkgOiBbXSwgISFvYmouYW5vbnltb3VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cbiAgICAgKiAgKipFdmVudEZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuZXhwb3J0cy5FdmVudEZyYWdtZW50ID0gRXZlbnRGcmFnbWVudDtcbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIGNvbnN0cnVjdG9yLlxuICovXG5jbGFzcyBDb25zdHJ1Y3RvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBjb25zdHJ1Y3RvciBjYW4gcmVjZWl2ZSBhbiBlbmRvd21lbnQuXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCBmb3IgZGVwbG95bWVudCBvciBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cywgcGF5YWJsZSwgZ2FzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwYXlhYmxlLCBnYXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc3RydWN0b3IgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiwgXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCIgfSk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwidW5kZWZpbmVkXCIpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbYGNvbnN0cnVjdG9yJHtqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpfWBdO1xuICAgICAgICBpZiAodGhpcy5wYXlhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqQ29uc3RydWN0b3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGNvbnN0dWN0b3IgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImNvbnN0cnVjdG9yXCJdKSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBLd1Zpc2liRGVwbG95KS5oYXMoXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBpbnB1dHMsIHBheWFibGUsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sICEhb2JqLnBheWFibGUsIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqQ29uc3RydWN0b3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IENvbnN0cnVjdG9yRnJhZ21lbnQ7XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXG4gKi9cbmNsYXNzIEZhbGxiYWNrRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBpbnB1dHMsIHBheWFibGUpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZmFsbGJhY2tcIiwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgcGF5YWJsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmYWxsYmFjayBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9ICgodGhpcy5pbnB1dHMubGVuZ3RoID09PSAwKSA/IFwicmVjZWl2ZVwiIDogXCJmYWxsYmFja1wiKTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTXV0YWJpbGl0eSA9ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IHR5cGUsIHN0YXRlTXV0YWJpbGl0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dHlwZX0oKSR7dGhpcy5wYXlhYmxlID8gXCIgcGF5YWJsZVwiIDogXCJcIn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZhbGxiYWNrRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZhbGxiYWNrRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG9iai50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkodG9wSXNWYWxpZCwgXCJ0eXBlIG11c3QgYmUgZmFsbGJhY2sgb3IgcmVjZWl2ZVwiLCBcIm9ialwiLCBlcnJvck9iaik7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBvcEtleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xuICAgICAgICAgICAgLy8gcmVjZWl2ZSgpXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGlucHV0cy5sZW5ndGggPT09IDAsIGByZWNlaXZlIGNhbm5vdCBoYXZlIGFyZ3VtZW50c2AsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJwYXlhYmxlXCJdKSk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKCkgW3BheWFibGVdXG4gICAgICAgICAgICAvLyBmYWxsYmFjayhieXRlcykgW3BheWFibGVdIHJldHVybnMgKGJ5dGVzKVxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkobXV0YWJpbGl0eSA9PT0gXCJub25wYXlhYmxlXCIgfHwgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIsIFwiZmFsbGJhY2sgY2Fubm90IGJlIGNvbnN0YW50c1wiLCBcIm9iai5zdGF0ZU11dGFiaWxpdHlcIiwgbXV0YWJpbGl0eSk7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkob3V0cHV0cy5sZW5ndGggPT09IDEgJiYgb3V0cHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBvdXRwdXRzXCIsIFwib2JqLm91dHB1dHNcIiwgb3V0cHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiZmFsbGJhY2tcIikge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9IChvYmouc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIHBheWFibGUpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGYWxsYmFja0ZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuZXhwb3J0cy5GYWxsYmFja0ZyYWdtZW50ID0gRmFsbGJhY2tGcmFnbWVudDtcbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cbiAgICAgKi9cbiAgICBjb25zdGFudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJldHVybmVkIHR5cGVzIGZvciB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvdXRwdXRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXG4gICAgICogIG9yIGBgcHVyZWBgKVxuICAgICAqL1xuICAgIHN0YXRlTXV0YWJpbGl0eTtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGNvbnN0IHBheWFibGUgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgY29uc3RhbnQsIGdhcywgb3V0cHV0cywgcGF5YWJsZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEZ1bmN0aW9uIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmlkKSh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMubWFwKChvKSA9PiBKU09OLnBhcnNlKG8uZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnN0YXRlTXV0YWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRzICYmIHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcInJldHVybnNcIik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goam9pblBhcmFtcyhmb3JtYXQsIHRoaXMub3V0cHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzZWxlY3RvciBmb3IgYSBmdW5jdGlvbiB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3RvcihuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBcInZpZXdcIiwgcGFyYW1zLCBbXSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGdW5jdGlvbkZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xuICAgICAgICBpZiAoc3RhdGVNdXRhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiB2ZXJpZnlTdGF0ZSBmb3Igc3RhdGVNdXRhYmlsaXR5IChlLmcuIHRocm93IGlmXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZ1bmN0aW9uRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRnVuY3Rpb25GcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmN0aW9uRnJhZ21lbnQgPSBGdW5jdGlvbkZyYWdtZW50O1xuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgc3RydWN0dXJlLlxuICovXG5jbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogU3RydWN0RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJ1Y3QgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlN0cnVjdEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgc3RydWN0IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcInN0cnVjdFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvLyBAVE9ETzogZml4IHRoaXMgcmV0dXJuIHR5cGVcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqU3RydWN0RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gU3RydWN0RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3RGcmFnbWVudCA9IFN0cnVjdEZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/fragments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The Application Binary Interface (ABI) describes how method input\n *  parameters should be encoded, their results decoded, and how to\n *  decode events and errors.\n *\n *  See [About ABIs](docs-abi) for more details how they are used.\n *\n *  @_section api/abi:Application Binary Interface  [about-abi]\n *  @_navTitle: ABI\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Typed = exports.Result = exports.TransactionDescription = exports.LogDescription = exports.ErrorDescription = exports.Interface = exports.Indexed = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.Fragment = exports.FallbackFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.encodeBytes32String = exports.decodeBytes32String = exports.AbiCoder = void 0;\n//////\nvar abi_coder_js_1 = __webpack_require__(/*! ./abi-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/abi-coder.js\");\nObject.defineProperty(exports, \"AbiCoder\", ({ enumerable: true, get: function () { return abi_coder_js_1.AbiCoder; } }));\nvar bytes32_js_1 = __webpack_require__(/*! ./bytes32.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/bytes32.js\");\nObject.defineProperty(exports, \"decodeBytes32String\", ({ enumerable: true, get: function () { return bytes32_js_1.decodeBytes32String; } }));\nObject.defineProperty(exports, \"encodeBytes32String\", ({ enumerable: true, get: function () { return bytes32_js_1.encodeBytes32String; } }));\nvar fragments_js_1 = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/fragments.js\");\nObject.defineProperty(exports, \"ConstructorFragment\", ({ enumerable: true, get: function () { return fragments_js_1.ConstructorFragment; } }));\nObject.defineProperty(exports, \"ErrorFragment\", ({ enumerable: true, get: function () { return fragments_js_1.ErrorFragment; } }));\nObject.defineProperty(exports, \"EventFragment\", ({ enumerable: true, get: function () { return fragments_js_1.EventFragment; } }));\nObject.defineProperty(exports, \"FallbackFragment\", ({ enumerable: true, get: function () { return fragments_js_1.FallbackFragment; } }));\nObject.defineProperty(exports, \"Fragment\", ({ enumerable: true, get: function () { return fragments_js_1.Fragment; } }));\nObject.defineProperty(exports, \"FunctionFragment\", ({ enumerable: true, get: function () { return fragments_js_1.FunctionFragment; } }));\nObject.defineProperty(exports, \"NamedFragment\", ({ enumerable: true, get: function () { return fragments_js_1.NamedFragment; } }));\nObject.defineProperty(exports, \"ParamType\", ({ enumerable: true, get: function () { return fragments_js_1.ParamType; } }));\nObject.defineProperty(exports, \"StructFragment\", ({ enumerable: true, get: function () { return fragments_js_1.StructFragment; } }));\nvar interface_js_1 = __webpack_require__(/*! ./interface.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/interface.js\");\nObject.defineProperty(exports, \"checkResultErrors\", ({ enumerable: true, get: function () { return interface_js_1.checkResultErrors; } }));\nObject.defineProperty(exports, \"Indexed\", ({ enumerable: true, get: function () { return interface_js_1.Indexed; } }));\nObject.defineProperty(exports, \"Interface\", ({ enumerable: true, get: function () { return interface_js_1.Interface; } }));\nObject.defineProperty(exports, \"ErrorDescription\", ({ enumerable: true, get: function () { return interface_js_1.ErrorDescription; } }));\nObject.defineProperty(exports, \"LogDescription\", ({ enumerable: true, get: function () { return interface_js_1.LogDescription; } }));\nObject.defineProperty(exports, \"TransactionDescription\", ({ enumerable: true, get: function () { return interface_js_1.TransactionDescription; } }));\nObject.defineProperty(exports, \"Result\", ({ enumerable: true, get: function () { return interface_js_1.Result; } }));\nvar typed_js_1 = __webpack_require__(/*! ./typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nObject.defineProperty(exports, \"Typed\", ({ enumerable: true, get: function () { return typed_js_1.Typed; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsY0FBYyxHQUFHLDhCQUE4QixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyxnQkFBZ0IsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxnQkFBZ0I7QUFDaGU7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDN0MsNENBQTJDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3RILG1CQUFtQixtQkFBTyxDQUFDLDZFQUFjO0FBQ3pDLHVEQUFzRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMxSSx1REFBc0QsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDMUkscUJBQXFCLG1CQUFPLENBQUMsaUZBQWdCO0FBQzdDLHVEQUFzRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUM1SSxpREFBZ0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDaEksaURBQWdELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ2hJLG9EQUFtRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN0SSw0Q0FBMkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDdEgsb0RBQW1ELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3RJLGlEQUFnRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNoSSw2Q0FBNEMsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDeEgsa0RBQWlELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2xJLHFCQUFxQixtQkFBTyxDQUFDLGlGQUFnQjtBQUM3QyxxREFBb0QsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDeEksMkNBQTBDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3BILDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SCxvREFBbUQsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDdEksa0RBQWlELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2xJLDBEQUF5RCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUNsSiwwQ0FBeUMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDbEgsaUJBQWlCLG1CQUFPLENBQUMseUVBQVk7QUFDckMseUNBQXdDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQzVHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2luZGV4LmpzP2QyMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBUaGUgQXBwbGljYXRpb24gQmluYXJ5IEludGVyZmFjZSAoQUJJKSBkZXNjcmliZXMgaG93IG1ldGhvZCBpbnB1dFxuICogIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGVuY29kZWQsIHRoZWlyIHJlc3VsdHMgZGVjb2RlZCwgYW5kIGhvdyB0b1xuICogIGRlY29kZSBldmVudHMgYW5kIGVycm9ycy5cbiAqXG4gKiAgU2VlIFtBYm91dCBBQklzXShkb2NzLWFiaSkgZm9yIG1vcmUgZGV0YWlscyBob3cgdGhleSBhcmUgdXNlZC5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS9hYmk6QXBwbGljYXRpb24gQmluYXJ5IEludGVyZmFjZSAgW2Fib3V0LWFiaV1cbiAqICBAX25hdlRpdGxlOiBBQklcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlZCA9IGV4cG9ydHMuUmVzdWx0ID0gZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IGV4cG9ydHMuRXJyb3JEZXNjcmlwdGlvbiA9IGV4cG9ydHMuSW50ZXJmYWNlID0gZXhwb3J0cy5JbmRleGVkID0gZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGV4cG9ydHMuU3RydWN0RnJhZ21lbnQgPSBleHBvcnRzLlBhcmFtVHlwZSA9IGV4cG9ydHMuTmFtZWRGcmFnbWVudCA9IGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IGV4cG9ydHMuRnJhZ21lbnQgPSBleHBvcnRzLkZhbGxiYWNrRnJhZ21lbnQgPSBleHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBleHBvcnRzLkVycm9yRnJhZ21lbnQgPSBleHBvcnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQgPSBleHBvcnRzLmVuY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLmRlY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLkFiaUNvZGVyID0gdm9pZCAwO1xuLy8vLy8vXG52YXIgYWJpX2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYmktY29kZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYmlDb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpX2NvZGVyX2pzXzEuQWJpQ29kZXI7IH0gfSk7XG52YXIgYnl0ZXMzMl9qc18xID0gcmVxdWlyZShcIi4vYnl0ZXMzMi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUJ5dGVzMzJTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzMzJfanNfMS5kZWNvZGVCeXRlczMyU3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQnl0ZXMzMlN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMzMl9qc18xLmVuY29kZUJ5dGVzMzJTdHJpbmc7IH0gfSk7XG52YXIgZnJhZ21lbnRzX2pzXzEgPSByZXF1aXJlKFwiLi9mcmFnbWVudHMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25zdHJ1Y3RvckZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHNfanNfMS5Db25zdHJ1Y3RvckZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRXJyb3JGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50RnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLkV2ZW50RnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGYWxsYmFja0ZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHNfanNfMS5GYWxsYmFja0ZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLkZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25GcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRnVuY3Rpb25GcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVkRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLk5hbWVkRnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLlBhcmFtVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cnVjdEZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHNfanNfMS5TdHJ1Y3RGcmFnbWVudDsgfSB9KTtcbnZhciBpbnRlcmZhY2VfanNfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrUmVzdWx0RXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcmZhY2VfanNfMS5jaGVja1Jlc3VsdEVycm9yczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluZGV4ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLkluZGV4ZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmZhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLkludGVyZmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLkVycm9yRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dEZXNjcmlwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJmYWNlX2pzXzEuTG9nRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvbkRlc2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcmZhY2VfanNfMS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcmZhY2VfanNfMS5SZXN1bHQ7IH0gfSk7XG52YXIgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVkX2pzXzEuVHlwZWQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/interface.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/interface.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abi_coder_js_1 = __webpack_require__(/*! ./abi-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/abi-coder.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nObject.defineProperty(exports, \"checkResultErrors\", ({ enumerable: true, get: function () { return abstract_coder_js_1.checkResultErrors; } }));\nObject.defineProperty(exports, \"Result\", ({ enumerable: true, get: function () { return abstract_coder_js_1.Result; } }));\nconst fragments_js_1 = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/fragments.js\");\nconst typed_js_1 = __webpack_require__(/*! ./typed.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nclass LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    fragment;\n    /**\n     *  The name of the Event.\n     */\n    name;\n    /**\n     *  The full Event signature.\n     */\n    signature;\n    /**\n     *  The topic hash for the Event.\n     */\n    topic;\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    args;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, topic, args) {\n        const name = fragment.name, signature = fragment.format();\n        (0, index_js_3.defineProperties)(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\nexports.LogDescription = LogDescription;\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nclass TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    fragment;\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    name;\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    args;\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    signature;\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    selector;\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    value;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, selector, args, value) {\n        const name = fragment.name, signature = fragment.format();\n        (0, index_js_3.defineProperties)(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\nexports.TransactionDescription = TransactionDescription;\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nclass ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    fragment;\n    /**\n     *  The name of the Error.\n     */\n    name;\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    args;\n    /**\n     *  The full Error signature.\n     */\n    signature;\n    /**\n     *  The selector for the Error.\n     */\n    selector;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, selector, args) {\n        const name = fragment.name, signature = fragment.format();\n        (0, index_js_3.defineProperties)(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\nexports.ErrorDescription = ErrorDescription;\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nclass Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    hash;\n    /**\n     *  @_ignore:\n     */\n    _isIndexed;\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */\n    constructor(hash) {\n        (0, index_js_3.defineProperties)(this, { hash, _isIndexed: true });\n    }\n}\nexports.Indexed = Indexed;\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\"string\"],\n        reason: (message) => {\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\"uint256\"],\n        reason: (code) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nclass Interface {\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    fragments;\n    /**\n     *  The Contract constructor.\n     */\n    deploy;\n    /**\n     *  The Fallback method, if any.\n     */\n    fallback;\n    /**\n     *  If receiving ether is supported.\n     */\n    receive;\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments) {\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi) {\n            try {\n                frags.push(fragments_js_1.Fragment.from(a));\n            }\n            catch (error) {\n                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);\n            }\n        }\n        (0, index_js_3.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0, index_js_3.defineProperties)(this, { deploy: fragment });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    }\n                    else {\n                        (0, index_js_3.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0, index_js_3.defineProperties)(this, {\n                deploy: fragments_js_1.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0, index_js_3.defineProperties)(this, { fallback, receive });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal) {\n        const format = (minimal ? \"minimal\" : \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson() {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder() {\n        return abi_coder_js_1.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0, index_js_3.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!typed_js_1.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0, index_js_3.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(fragments_js_1.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0, index_js_3.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n    hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#functions.get(name)), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0, index_js_3.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!typed_js_1.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0, index_js_3.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(fragments_js_1.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0, index_js_3.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n    hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#events.get(name)), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key, values) {\n        if ((0, index_js_3.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return fragments_js_1.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return fragments_js_1.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            }\n            else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0, index_js_3.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = fragments_js_1.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return fragments_js_1.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return fragments_js_1.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#errors.get(name)), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n    _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getError(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getError(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0, index_js_3.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0, index_js_3.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0, index_js_3.getBytesCopy)(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            }\n            catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0, index_js_3.assert)(false, message, \"BAD_DATA\", {\n            value: (0, index_js_3.hexlify)(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0, index_js_3.getBytes)(_data, \"data\");\n        const error = abi_coder_js_1.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0, index_js_3.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                }\n                catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0, index_js_3.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0, index_js_3.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return (0, index_js_2.id)(value);\n            }\n            else if (param.type === \"bytes\") {\n                return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            else if (param.type.match(/^u?int/)) {\n                value = (0, index_js_3.toBeHex)(value); // @TODO: Should this toTwos??\n            }\n            else if (param.type.match(/^bytes/)) {\n                value = (0, index_js_3.zeroPadBytes)(value, 32);\n            }\n            else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\"address\"], [value]);\n            }\n            return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);\n        };\n        values.forEach((value, index) => {\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0, index_js_3.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0, index_js_3.assertArgument)(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0, index_js_2.id)(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push((0, index_js_1.keccak256)(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this.#abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(fragments_js_1.ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, (0, index_js_3.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                }\n                else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                }\n                else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        value = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return abstract_coder_js_1.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx) {\n        const data = (0, index_js_3.getBytes)(tx.data, \"tx.data\");\n        const value = (0, index_js_3.getBigInt)((tx.value != null) ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */\n    parseError(data) {\n        const hexData = (0, index_js_3.hexlify)(data);\n        const fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof (value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // Maybe an interface from an older version, or from a symlinked copy\n        if (typeof (value.format) === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n}\nexports.Interface = Interface;\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsd0JBQXdCLEdBQUcsOEJBQThCLEdBQUcsc0JBQXNCLEdBQUcsY0FBYyxHQUFHLHlCQUF5QjtBQUNySyxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDL0MsNEJBQTRCLG1CQUFPLENBQUMseUdBQTRCO0FBQ2hFLHFEQUFvRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUM3SSwwQ0FBeUMsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDdkgsdUJBQXVCLG1CQUFPLENBQUMsaUZBQWdCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsd0JBQXdCO0FBQ3pFO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQixHQUFHLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0JBQWtCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBKQUEwSixNQUFNO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpREFBaUQsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csU0FBUztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsU0FBUztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLFNBQVM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsNENBQTRDO0FBQzFELGNBQWMsaURBQWlEOztBQUUvRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySUFBMkksY0FBYztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOElBQThJLGNBQWM7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csa0JBQWtCLDRCQUE0Qiw2REFBNkQ7QUFDN007QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsbUNBQW1DO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvaW50ZXJmYWNlLmpzP2NhMmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBUaGUgSW50ZXJmYWNlIGNsYXNzIGlzIGEgbG93LWxldmVsIGNsYXNzIHRoYXQgYWNjZXB0cyBhblxuICogIEFCSSBhbmQgcHJvdmlkZXMgYWxsIHRoZSBuZWNlc3NhcnkgZnVuY3Rpb25hbGl0eSB0byBlbmNvZGVcbiAqICBhbmQgZGVjb2RlIHBhcmFtYXRlcnMgdG8gYW5kIHJlc3VsdHMgZnJvbSBtZXRob2RzLCBldmVudHNcbiAqICBhbmQgZXJyb3JzLlxuICpcbiAqICBJdCBhbHNvIHByb3ZpZGVzIHNldmVyYWwgY29udmVuaWVuY2UgbWV0aG9kcyB0byBhdXRvbWF0aWNhbGx5XG4gKiAgc2VhcmNoIGFuZCBmaW5kIG1hdGNoaW5nIHRyYW5zYWN0aW9ucyBhbmQgZXZlbnRzIHRvIHBhcnNlIHRoZW0uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpOkludGVyZmFjZXMgIFtpbnRlcmZhY2VzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVyZmFjZSA9IGV4cG9ydHMuSW5kZXhlZCA9IGV4cG9ydHMuRXJyb3JEZXNjcmlwdGlvbiA9IGV4cG9ydHMuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiA9IGV4cG9ydHMuTG9nRGVzY3JpcHRpb24gPSBleHBvcnRzLlJlc3VsdCA9IGV4cG9ydHMuY2hlY2tSZXN1bHRFcnJvcnMgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBhYmlfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2FiaS1jb2Rlci5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGVja1Jlc3VsdEVycm9yc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3RfY29kZXJfanNfMS5jaGVja1Jlc3VsdEVycm9yczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3VsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3RfY29kZXJfanNfMS5SZXN1bHQ7IH0gfSk7XG5jb25zdCBmcmFnbWVudHNfanNfMSA9IHJlcXVpcmUoXCIuL2ZyYWdtZW50cy5qc1wiKTtcbmNvbnN0IHR5cGVkX2pzXzEgPSByZXF1aXJlKFwiLi90eXBlZC5qc1wiKTtcbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlTG9nXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhIExvZyB0byBpdHMgZXZlbnRcbiAqICBmb3IgcGFyc2luZywgYSAqKkxvZ0Rlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmNsYXNzIExvZ0Rlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGUgYGB0b3BpYzBgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3BpYyBoYXNoIGZvciB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgdG9waWM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIEV2ZW50IHdpdGggYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHRvcGljLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIHNpZ25hdHVyZSwgdG9waWMsIGFyZ3NcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IExvZ0Rlc2NyaXB0aW9uO1xuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VUcmFuc2FjdGlvbl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2hcbiAqICBhIHRyYW5zYWN0aW9uIGRhdGEgdG8gaXRzIGZ1bmN0aW9uIGZvciBwYXJzaW5nLFxuICogIGEgKipUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRnVuY3Rpb24gc2lnbmF0dXJlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2VsZWN0b3I7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZhbHVlYGAgKGluIHdlaSkgZnJvbSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCBzZWxlY3RvciwgYXJncywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvciwgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gVHJhbnNhY3Rpb25EZXNjcmlwdGlvbjtcbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlRXJyb3JdXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGFuXG4gKiAgZXJyb3IgZm9yIGEgY2FsbCByZXN1bHQgZm9yIHBhcnNpbmcsIGFuICoqRXJyb3JEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5jbGFzcyBFcnJvckRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEVycm9yIHdpdGggYGByZXZlcnRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFcnJvciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FcnJvckRlc2NyaXB0aW9uID0gRXJyb3JEZXNjcmlwdGlvbjtcbi8qKlxuICogIEFuICoqSW5kZXhlZCoqIGlzIHVzZWQgYXMgYSB2YWx1ZSB3aGVuIGEgdmFsdWUgdGhhdCBkb2VzIG5vdFxuICogIGZpdCB3aXRoaW4gYSB0b3BpYyAoaS5lLiBub3QgYSBmaXhlZC1sZW5ndGgsIDMyLWJ5dGUgdHlwZSkuIEl0XG4gKiAgaXMgdGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlLCBhbmQgdXNlZCBmb3IgdHlwZXMgc3VjaCBhc1xuICogIGFycmF5cywgdHVwbGVzLCBieXRlcyBhbmQgc3RyaW5ncy5cbiAqL1xuY2xhc3MgSW5kZXhlZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSBsb2dnZWQuXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX2lzSW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJXZhbHVlJSUgaXMgYW4gKipJbmRleGVkKiouXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgZm9yIHByb3BlcnR5IGFjY2Vzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNJbmRleGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhhc2gpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBoYXNoLCBfaXNJbmRleGVkOiB0cnVlIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5kZXhlZCA9IEluZGV4ZWQ7XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjEzL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sP2hpZ2hsaWdodD1wYW5pYyNwYW5pYy12aWEtYXNzZXJ0LWFuZC1lcnJvci12aWEtcmVxdWlyZVxuY29uc3QgUGFuaWNSZWFzb25zID0ge1xuICAgIFwiMFwiOiBcImdlbmVyaWMgcGFuaWNcIixcbiAgICBcIjFcIjogXCJhc3NlcnQoZmFsc2UpXCIsXG4gICAgXCIxN1wiOiBcImFyaXRobWV0aWMgb3ZlcmZsb3dcIixcbiAgICBcIjE4XCI6IFwiZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIixcbiAgICBcIjMzXCI6IFwiZW51bSBvdmVyZmxvd1wiLFxuICAgIFwiMzRcIjogXCJpbnZhbGlkIGVuY29kZWQgc3RvcmFnZSBieXRlIGFycmF5IGFjY2Vzc2VkXCIsXG4gICAgXCI0OVwiOiBcIm91dC1vZi1ib3VuZHMgYXJyYXkgYWNjZXNzOyBwb3BwaW5nIG9uIGFuIGVtcHR5IGFycmF5XCIsXG4gICAgXCI1MFwiOiBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiLFxuICAgIFwiNjVcIjogXCJvdXQgb2YgbWVtb3J5XCIsXG4gICAgXCI4MVwiOiBcInVuaW5pdGlhbGl6ZWQgZnVuY3Rpb25cIixcbn07XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgaW5wdXRzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgIHJlYXNvbjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9YDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIweDRlNDg3YjcxXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgaW5wdXRzOiBbXCJ1aW50MjU2XCJdLFxuICAgICAgICByZWFzb246IChjb2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVhc29uID0gXCJ1bmtub3duIHBhbmljIGNvZGVcIjtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDAgJiYgY29kZSA8PSAweGZmICYmIFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAweCR7Y29kZS50b1N0cmluZygxNil9ICgke3JlYXNvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqICBBbiBJbnRlcmZhY2UgYWJzdHJhY3RzIG1hbnkgb2YgdGhlIGxvdy1sZXZlbCBkZXRhaWxzIGZvclxuICogIGVuY29kaW5nIGFuZCBkZWNvZGluZyB0aGUgZGF0YSBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiAgQW4gQUJJIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBlbmNvZGUgZGF0YSB0byBzZW5kIHRvXG4gKiAgYSBDb250cmFjdCwgaG93IHRvIGRlY29kZSB0aGUgcmVzdWx0cyBhbmQgZXZlbnRzIGFuZCBob3cgdG9cbiAqICBpbnRlcnByZXQgcmV2ZXJ0IGVycm9ycy5cbiAqXG4gKiAgVGhlIEFCSSBjYW4gYmUgc3BlY2lmaWVkIGJ5IFthbnkgc3VwcG9ydGVkIGZvcm1hdF0oSW50ZXJmYWNlQWJpKS5cbiAqL1xuY2xhc3MgSW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiAgQWxsIHRoZSBDb250cmFjdCBBQkkgbWVtYmVycyAoaS5lLiBtZXRob2RzLCBldmVudHMsIGVycm9ycywgZXRjKS5cbiAgICAgKi9cbiAgICBmcmFnbWVudHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBkZXBsb3k7XG4gICAgLyoqXG4gICAgICogIFRoZSBGYWxsYmFjayBtZXRob2QsIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgSWYgcmVjZWl2aW5nIGV0aGVyIGlzIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICByZWNlaXZlO1xuICAgICNlcnJvcnM7XG4gICAgI2V2ZW50cztcbiAgICAjZnVuY3Rpb25zO1xuICAgIC8vICAgICNzdHJ1Y3RzOiBNYXA8c3RyaW5nLCBTdHJ1Y3RGcmFnbWVudD47XG4gICAgI2FiaUNvZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgSW50ZXJmYWNlIGZvciB0aGUgJSVmcmFnbWVudHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGFiaSA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudHMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhYmkgPSBKU09OLnBhcnNlKGZyYWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhYmkgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNlcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2V2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gICAgICAgIHRoaXMuI3N0cnVjdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGZyYWdzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBhYmkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhZ3MucHVzaChmcmFnbWVudHNfanNfMS5GcmFnbWVudC5mcm9tKGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbV2FybmluZ10gSW52YWxpZCBGcmFnbWVudCAke0pTT04uc3RyaW5naWZ5KGEpfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudHM6IE9iamVjdC5mcmVlemUoZnJhZ3MpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBkZXBsb3k6IGZyYWdtZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSghZmFsbGJhY2sgfHwgZnJhZ21lbnQucGF5YWJsZSAhPT0gZmFsbGJhY2sucGF5YWJsZSwgXCJjb25mbGljdGluZyBmYWxsYmFjayBmcmFnbWVudHNcIiwgYGZyYWdtZW50c1ske2luZGV4fV1gLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjayA9IGZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IGZhbGxiYWNrLnBheWFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcIm91dHB1dFwiLCAoPEZ1bmN0aW9uRnJhZ21lbnQ+ZnJhZ21lbnQpLm91dHB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNmdW5jdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUd28gaWRlbnRpY2FsIGVudHJpZXM7IGlnbm9yZSBpdFxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoYnVja2V0LmhhcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0LnNldChzaWduYXR1cmUsIGZyYWdtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgYWRkIGEgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZGVwbG95OiBmcmFnbWVudHNfanNfMS5Db25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGZhbGxiYWNrLCByZWNlaXZlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgZW50aXJlIEh1bWFuLVJlYWRhYmxlIEFCSSwgYXMgYW4gYXJyYXkgb2ZcbiAgICAgKiAgc2lnbmF0dXJlcywgb3B0aW9uYWxseSBhcyAlJW1pbmltYWwlJSBzdHJpbmdzLCB3aGljaFxuICAgICAqICByZW1vdmVzIHBhcmFtZXRlciBuYW1lcyBhbmQgdW5uZWNlZXNhcnkgc3BhY2VzLlxuICAgICAqL1xuICAgIGZvcm1hdChtaW5pbWFsKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IChtaW5pbWFsID8gXCJtaW5pbWFsXCIgOiBcImZ1bGxcIik7XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoZm9ybWF0KSk7XG4gICAgICAgIHJldHVybiBhYmk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIEpTT04tZW5jb2RlZCBBQkkuIFRoaXMgaXMgdGhlIGZvcm1hdCBTb2xpZGl5XG4gICAgICogIHJldHVybnMuXG4gICAgICovXG4gICAgZm9ybWF0SnNvbigpIHtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlLWJ1bmRsZSB0aGUgSlNPTiBmcmFnbWVudHMgYSBiaXRcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFiaS5tYXAoKGopID0+IEpTT04ucGFyc2UoaikpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBBQkkgY29kZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZW5jb2RlIGFuZCBkZWNvZGUgYmluYXJ5XG4gICAgICogIGRhdGEuXG4gICAgICovXG4gICAgZ2V0QWJpQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBhYmlfY29kZXJfanNfMS5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKTtcbiAgICB9XG4gICAgLy8gRmluZCBhIGZ1bmN0aW9uIGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICAjZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMsIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgIC8vIFNlbGVjdG9yXG4gICAgICAgIGlmICgoMCwgaW5kZXhfanNfMy5pc0hleFN0cmluZykoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZnVuY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9ICh2YWx1ZXMubGVuZ3RoID4gMCkgPyB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBhbGxvd09wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlZF9qc18xLlR5cGVkLmlzVHlwZWQobGFzdFZhbHVlKSAmJiBsYXN0VmFsdWUudHlwZSA9PT0gXCJvdmVycmlkZXNcIikge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd09wdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBhdGlibGUgbGVuZ3RoLiBUaGUgYXJnc1xuICAgICAgICAgICAgICAgIC8vIG1heSBjb250YWluIGFuIG92ZXJyaWRlcywgc28gdGhlIG1hdGNoIG1heSBoYXZlIG4gb3IgbiAtIDEgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzICE9PSB2YWx1ZUxlbmd0aCAmJiAoIWFsbG93T3B0aW9ucyB8fCBpbnB1dHMgIT09IHZhbHVlTGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgVHlwZWQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHR5cGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVkX2pzXzEuVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIGxhc3QgdmFsdWUgaXMgc29tZXRoaW5nIHRoYXQgY2Fubm90IHBvc3NpYmx5IGJlIGFuIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFyZyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobGFzdEFyZykgfHwgdHlwZW9mIChsYXN0QXJnKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBhbWJpZ3VvdXMgZnVuY3Rpb24gZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Z1bmN0aW9ucy5nZXQoZnJhZ21lbnRzX2pzXzEuRnVuY3Rpb25GcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBmdW5jdGlvbiBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSBmdW5jdGlvbiBzZWxlY3RvcixcbiAgICAgKiAgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb25OYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYSBmdW5jdGlvbiBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvclxuICAgICAqICBmdW5jdGlvbiBzaWduYXR1cmUpIGlzIHByZXNlbnQgaW4gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhIGZ1bmN0aW9uIG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tGdW5jdGlvbkZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSBmdW5jdGlvblxuICAgICAqICBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGZ1bmN0aW9ucyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZnVuY3Rpb24gaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRGdW5jdGlvbihrZXksIHZhbHVlcyB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZnVuY3Rpb25zLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNmdW5jdGlvbnMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Z1bmN0aW9ucy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIGFuIGV2ZW50IGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICAjZ2V0RXZlbnQoa2V5LCB2YWx1ZXMsIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgIC8vIEV2ZW50VG9waWNcbiAgICAgICAgaWYgKCgwLCBpbmRleF9qc18zLmlzSGV4U3RyaW5nKShrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRvcGljID09PSBmcmFnbWVudC50b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWRfanNfMS5UeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPiAxICYmIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgYW1iaWd1b3VzIGV2ZW50IGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KGZyYWdtZW50c19qc18xLkV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZXZlbnQgbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RXZlbnROYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYW4gZXZlbnQgdG9waWMgaGFzaCwgZXZlbnQgbmFtZSBvclxuICAgICAqICBldmVudCBzaWduYXR1cmUpIGlzIHByZXNlbnQgaW4gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhbiBldmVudCBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRXZlbnRGcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRXZlbnQoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0V2ZW50RnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGV2ZW50cyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZXZlbnQgaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEV2ZW50KGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRFdmVudChrZXksIHZhbHVlcyB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZXZlbnRzLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEV2ZW50KGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNldmVudHMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2V2ZW50cy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Vycm9yRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGFuIGVycm9yXG4gICAgICogIHNlbGVjdG9yLCBlcnJvciBuYW1lIG9yIGVycm9yIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXJyb3JzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBlcnJvciBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXJyb3Ioa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCgwLCBpbmRleF9qc18zLmlzSGV4U3RyaW5nKShrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKEJ1aWx0aW5FcnJvcnNbc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50c19qc18xLkVycm9yRnJhZ21lbnQuZnJvbShCdWlsdGluRXJyb3JzW3NlbGVjdG9yXS5zaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNlcnJvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZyYWdtZW50LnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHNfanNfMS5FcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50c19qc18xLkVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBhbWJpZ3VvdXMgZXJyb3IgZGVzY3JpcHRpb24gKGkuZS4gJHttYXRjaFN0cn0pYCwgXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAga2V5ID0gZnJhZ21lbnRzX2pzXzEuRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3Ioc3RyaW5nKVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHNfanNfMS5FcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNlcnJvcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFcnJvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgLypcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogQXJyYXk8RnJhZ21lbnQ+ID0gWyBdO1xuXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RXJyb3IoPHN0cmluZz5mcmFnbWVudCkpOyB9IGNhdGNoIChfKSB7IH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGZyYWdtZW50XCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbn1cbiAgICAqL1xuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICAvKlxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxuICAgICAgICByZXR1cm4gaWQoZnJhZ21lbnQuZm9ybWF0KCkpO1xuICAgIH1cbiAgICAqL1xuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGVycm9yIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18zLmRhdGFTbGljZSkoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCAoMCwgaW5kZXhfanNfMy5kYXRhU2xpY2UpKGRhdGEsIDQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHRyYW5zYWN0aW9uIHJldmVydCBkYXRhIGZvciBhIGNhbGwgcmVzdWx0IHRoYXRcbiAgICAgKiAgcmV2ZXJ0ZWQgZnJvbSB0aGUgdGhlIENvbnRyYWN0IHdpdGggdGhlIHNlcGNpZmllZCAlJWVycm9yJSVcbiAgICAgKiAgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoIHRoZSAlJXZhbHVlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cbiAgICAgKi9cbiAgICBlbmNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuY29uY2F0KShbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSAlJWRhdGElJSBmcm9tIGEgdHJhbnNhY3Rpb24gYGB0eC5kYXRhYGAgZm9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18zLmRhdGFTbGljZSkoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCAoMCwgaW5kZXhfanNfMy5kYXRhU2xpY2UpKGRhdGEsIDQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIGBgdHguZGF0YWBgIGZvciBhIHRyYW5zYWN0aW9uIHRoYXQgY2FsbHMgdGhlIGZ1bmN0aW9uXG4gICAgICogIHNwZWNpZmllZCAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGhcbiAgICAgKiAgdGhlICUldmFsdWVzJSUuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5jb25jYXQpKFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiaW52YWxpZCBsZW5ndGggZm9yIHJlc3VsdCBkYXRhXCI7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXNDb3B5KShkYXRhKTtcbiAgICAgICAgaWYgKChieXRlcy5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5vdXRwdXRzLCBieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJjb3VsZCBub3QgZGVjb2RlIHJlc3VsdCBkYXRhXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCByZXR1cm5lZCBkYXRhIHdpdGggbm8gZXJyb3IsIGJ1dCB0aGUgZGF0YSBpcyBqdW5rXG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgdmFsdWU6ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGJ5dGVzKSxcbiAgICAgICAgICAgIGluZm86IHsgbWV0aG9kOiBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VFcnJvcihfZGF0YSwgdHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKShfZGF0YSwgXCJkYXRhXCIpO1xuICAgICAgICBjb25zdCBlcnJvciA9IGFiaV9jb2Rlcl9qc18xLkFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKFwiY2FsbFwiLCB0eCwgZGF0YSk7XG4gICAgICAgIC8vIE5vdCBhIGJ1aWx0LWluIGVycm9yOyB0cnkgZmluZGluZyBhIGN1c3RvbSBlcnJvclxuICAgICAgICBjb25zdCBjdXN0b21QcmVmaXggPSBcImV4ZWN1dGlvbiByZXZlcnRlZCAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoY3VzdG9tUHJlZml4KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShkYXRhLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWYpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVmLm5hbWUsIHNpZ25hdHVyZTogZWYuZm9ybWF0KCksIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7ZXJyb3IucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkIChjb3VsdCBub3QgZGVjb2RlIGN1c3RvbSBlcnJvcilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJzZWQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpIHdpdGggJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmhleGxpZnkpKHRoaXMuI2FiaUNvZGVyLmVuY29kZShmcmFnbWVudC5vdXRwdXRzLCB2YWx1ZXMgfHwgW10pKTtcbiAgICB9XG4gICAgLypcbiAgICAgICAgc3BlbHVuayhpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+LCBwcm9jZXNzZnVuYzogKHR5cGU6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gUHJvbWlzZTxhbnk+KTogUHJvbWlzZTxBcnJheTxhbnk+PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlczogQXJyYXk8UHJvbWlzZTw+PiA9IFsgXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSBmdW5jdGlvbih0eXBlOiBQYXJhbVR5cGUsIHZhbHVlOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NlbmQodHlwZS5jaGlsZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZS4gPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGRlc2NlbmQgPSBmdW5jdGlvbiAoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55Pikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7IHRocm93IG5ldyBFcnJvcihcImxlbmd0aCBtaXNtYXRjaFwiKTsgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8YW55PiA9IFsgXTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICovXG4gICAgLy8gQ3JlYXRlIHRoZSBmaWx0ZXIgZm9yIHRoZSBldmVudCB3aXRoIHNlYXJjaCBjcml0ZXJpYSAoZS5nLiBmb3IgZXRoX2ZpbHRlckxvZylcbiAgICBlbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHZhbHVlcy5sZW5ndGggPD0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgYHRvbyBtYW55IGFyZ3VtZW50cyBmb3IgJHtmcmFnbWVudC5mb3JtYXQoKX1gLCBcIlVORVhQRUNURURfQVJHVU1FTlRcIiwgeyBjb3VudDogdmFsdWVzLmxlbmd0aCwgZXhwZWN0ZWRDb3VudDogZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCB9KTtcbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XG4gICAgICAgIGlmICghZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaChmcmFnbWVudC50b3BpY0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBVc2UgdGhlIGNvZGVycyBmb3IgdGhpczsgdG8gcHJvcGVybHkgc3VwcG9ydCB0dXBsZXMsIGV0Yy5cbiAgICAgICAgY29uc3QgZW5jb2RlVG9waWMgPSAocGFyYW0sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5pZCkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmtlY2NhazI1NikoKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIiAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc18zLnRvQmVIZXgpKHZhbHVlKTsgLy8gQFRPRE86IFNob3VsZCB0aGlzIHRvVHdvcz8/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9eYnl0ZXMvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzMuemVyb1BhZEJ5dGVzKSh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLnplcm9QYWRWYWx1ZSkoKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZnJhZ21lbnQuaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA9PSBudWxsLCBcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpbSBvZmYgdHJhaWxpbmcgbnVsbHNcbiAgICAgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdG9waWNzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BpY3M7XG4gICAgfVxuICAgIGVuY29kZUV2ZW50TG9nKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVmFsdWVzID0gW107XG4gICAgICAgIGlmICghZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaChmcmFnbWVudC50b3BpY0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCgoMCwgaW5kZXhfanNfMi5pZCkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKCgwLCBpbmRleF9qc18xLmtlY2NhazI1NikodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuI2FiaUNvZGVyLmVuY29kZShbcGFyYW0udHlwZV0sIFt2YWx1ZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZGF0YVR5cGVzLCBkYXRhVmFsdWVzKSxcbiAgICAgICAgICAgIHRvcGljczogdG9waWNzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIERlY29kZSBhIGZpbHRlciBmb3IgdGhlIGV2ZW50IGFuZCB0aGUgc2VhcmNoIGNyaXRlcmlhXG4gICAgZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMy5pc0hleFN0cmluZykodG9waWNzWzBdLCAzMikgJiYgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgPT09IGV2ZW50VG9waWMsIFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgXCJ0b3BpY3NbMF1cIiwgdG9waWNzWzBdKTtcbiAgICAgICAgICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IG5vbkluZGV4ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IFtdO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKGZyYWdtZW50c19qc18xLlBhcmFtVHlwZS5mcm9tKHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IHBhcmFtLm5hbWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vbkluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdEluZGV4ZWQgPSAodG9waWNzICE9IG51bGwpID8gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGluZGV4ZWQsICgwLCBpbmRleF9qc18zLmNvbmNhdCkodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJhbS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFic3RyYWN0X2NvZGVyX2pzXzEuUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgdHJhbnNhY3Rpb24sIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBmdW5jdGlvbiBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBjYW5ub3QgYmUgZm91bmQsIHJldHVybiBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSh0eC5kYXRhLCBcInR4LmRhdGFcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSgodHgudmFsdWUgIT0gbnVsbCkgPyB0eC52YWx1ZSA6IDAsIFwidHgudmFsdWVcIik7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbigoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShkYXRhLnNsaWNlKDAsIDQpKSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncywgdmFsdWUpO1xuICAgIH1cbiAgICBwYXJzZUNhbGxSZXN1bHQoZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHJlY2VpcHQgbG9nLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBldmVudCBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXZlbnQgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXZlbnQgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VMb2cobG9nKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCB8fCBmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBJZiBhbm9ueW1vdXMsIGFuZCB0aGUgb25seSBtZXRob2QsIGFuZCB0aGUgaW5wdXQgY291bnQgbWF0Y2hlcywgc2hvdWxkIHdlIHBhcnNlP1xuICAgICAgICAvLyAgICAgICAgUHJvYmFibHkgbm90LCBiZWNhdXNlIGp1c3QgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBldmVudCBpbiB0aGUgQUJJIGRvZXNcbiAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqdXN0IGEgZnJhZ21lbnQ/XG4gICAgICAgIHJldHVybiBuZXcgTG9nRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnRvcGljSGFzaCwgdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHJldmVydCBkYXRhLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBlcnJvciBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXJyb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXJyb3IgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VFcnJvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhleERhdGEgPSAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShkYXRhKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKCgwLCBpbmRleF9qc18zLmRhdGFTbGljZSkoaGV4RGF0YSwgMCwgNCkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgKDAsIGluZGV4X2pzXzMuZGF0YVNsaWNlKShoZXhEYXRhLCA0KSk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JEZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ludGVyZmFjZV1dIGZyb20gdGhlIEFCSSAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUldmFsdWUlJSBtYXkgYmUgcHJvdmlkZWQgYXMgYW4gZXhpc3RpbmcgW1tJbnRlcmZhY2VdXSBvYmplY3QsXG4gICAgICogIGEgSlNPTi1lbmNvZGVkIEFCSSBvciBhbnkgSHVtYW4tUmVhZGFibGUgQUJJIGZvcm1hdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICAvLyBBbHJlYWR5IGFuIEludGVyZmFjZSwgd2hpY2ggaXMgaW1tdXRhYmxlXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVyZmFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTT05cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF5YmUgYW4gaW50ZXJmYWNlIGZyb20gYW4gb2xkZXIgdmVyc2lvbiwgb3IgZnJvbSBhIHN5bWxpbmtlZCBjb3B5XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgZnJhZ21lbnRzXG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyZmFjZSA9IEludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/typed.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Typed = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, { signed, width });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${(size) ? size : \"\"}`, value, { size });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */\nclass Typed {\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    type;\n    /**\n     *  The actual value.\n     */\n    value;\n    #options;\n    /**\n     *  @_ignore:\n     */\n    _typedSymbol;\n    /**\n     *  @_ignore:\n     */\n    constructor(gaurd, type, value, options) {\n        if (options == null) {\n            options = null;\n        }\n        (0, index_js_1.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0, index_js_1.defineProperties)(this, { _typedSymbol, type, value });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */\n    format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v) => v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */\n    defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */\n    minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */\n    maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */\n    isBigInt() {\n        return !!(this.type.match(/^u?int[0-9]+$/));\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */\n    isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */\n    isString() {\n        return (this.type === \"string\");\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */\n    get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */\n    get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return (this.value).length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */\n    static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static uint8(v) { return n(v, 8); }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */\n    static uint16(v) { return n(v, 16); }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */\n    static uint24(v) { return n(v, 24); }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */\n    static uint32(v) { return n(v, 32); }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */\n    static uint40(v) { return n(v, 40); }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */\n    static uint48(v) { return n(v, 48); }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */\n    static uint56(v) { return n(v, 56); }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */\n    static uint64(v) { return n(v, 64); }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */\n    static uint72(v) { return n(v, 72); }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */\n    static uint80(v) { return n(v, 80); }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */\n    static uint88(v) { return n(v, 88); }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */\n    static uint96(v) { return n(v, 96); }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */\n    static uint104(v) { return n(v, 104); }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */\n    static uint112(v) { return n(v, 112); }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */\n    static uint120(v) { return n(v, 120); }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */\n    static uint128(v) { return n(v, 128); }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */\n    static uint136(v) { return n(v, 136); }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */\n    static uint144(v) { return n(v, 144); }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */\n    static uint152(v) { return n(v, 152); }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */\n    static uint160(v) { return n(v, 160); }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */\n    static uint168(v) { return n(v, 168); }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */\n    static uint176(v) { return n(v, 176); }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */\n    static uint184(v) { return n(v, 184); }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */\n    static uint192(v) { return n(v, 192); }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */\n    static uint200(v) { return n(v, 200); }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */\n    static uint208(v) { return n(v, 208); }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */\n    static uint216(v) { return n(v, 216); }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */\n    static uint224(v) { return n(v, 224); }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */\n    static uint232(v) { return n(v, 232); }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */\n    static uint240(v) { return n(v, 240); }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */\n    static uint248(v) { return n(v, 248); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint256(v) { return n(v, 256); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint(v) { return n(v, 256); }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */\n    static int8(v) { return n(v, -8); }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */\n    static int16(v) { return n(v, -16); }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */\n    static int24(v) { return n(v, -24); }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */\n    static int32(v) { return n(v, -32); }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */\n    static int40(v) { return n(v, -40); }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */\n    static int48(v) { return n(v, -48); }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */\n    static int56(v) { return n(v, -56); }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */\n    static int64(v) { return n(v, -64); }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */\n    static int72(v) { return n(v, -72); }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */\n    static int80(v) { return n(v, -80); }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */\n    static int88(v) { return n(v, -88); }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */\n    static int96(v) { return n(v, -96); }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */\n    static int104(v) { return n(v, -104); }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */\n    static int112(v) { return n(v, -112); }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */\n    static int120(v) { return n(v, -120); }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */\n    static int128(v) { return n(v, -128); }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */\n    static int136(v) { return n(v, -136); }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */\n    static int144(v) { return n(v, -144); }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */\n    static int152(v) { return n(v, -152); }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */\n    static int160(v) { return n(v, -160); }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */\n    static int168(v) { return n(v, -168); }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */\n    static int176(v) { return n(v, -176); }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */\n    static int184(v) { return n(v, -184); }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */\n    static int192(v) { return n(v, -192); }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */\n    static int200(v) { return n(v, -200); }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */\n    static int208(v) { return n(v, -208); }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */\n    static int216(v) { return n(v, -216); }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */\n    static int224(v) { return n(v, -224); }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */\n    static int232(v) { return n(v, -232); }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */\n    static int240(v) { return n(v, -240); }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */\n    static int248(v) { return n(v, -248); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int256(v) { return n(v, -256); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int(v) { return n(v, -256); }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */\n    static bytes1(v) { return b(v, 1); }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */\n    static bytes2(v) { return b(v, 2); }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */\n    static bytes3(v) { return b(v, 3); }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */\n    static bytes4(v) { return b(v, 4); }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */\n    static bytes5(v) { return b(v, 5); }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */\n    static bytes6(v) { return b(v, 6); }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */\n    static bytes7(v) { return b(v, 7); }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */\n    static bytes8(v) { return b(v, 8); }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */\n    static bytes9(v) { return b(v, 9); }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */\n    static bytes10(v) { return b(v, 10); }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */\n    static bytes11(v) { return b(v, 11); }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */\n    static bytes12(v) { return b(v, 12); }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */\n    static bytes13(v) { return b(v, 13); }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */\n    static bytes14(v) { return b(v, 14); }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */\n    static bytes15(v) { return b(v, 15); }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */\n    static bytes16(v) { return b(v, 16); }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */\n    static bytes17(v) { return b(v, 17); }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */\n    static bytes18(v) { return b(v, 18); }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */\n    static bytes19(v) { return b(v, 19); }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */\n    static bytes20(v) { return b(v, 20); }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */\n    static bytes21(v) { return b(v, 21); }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */\n    static bytes22(v) { return b(v, 22); }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */\n    static bytes23(v) { return b(v, 23); }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */\n    static bytes24(v) { return b(v, 24); }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */\n    static bytes25(v) { return b(v, 25); }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */\n    static bytes26(v) { return b(v, 26); }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */\n    static bytes27(v) { return b(v, 27); }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */\n    static bytes28(v) { return b(v, 28); }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */\n    static bytes29(v) { return b(v, 29); }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */\n    static bytes30(v) { return b(v, 30); }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */\n    static bytes31(v) { return b(v, 31); }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */\n    static bytes32(v) { return b(v, 32); }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */\n    static address(v) { return new Typed(_gaurd, \"address\", v); }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */\n    static bool(v) { return new Typed(_gaurd, \"bool\", !!v); }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */\n    static bytes(v) { return new Typed(_gaurd, \"bytes\", v); }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */\n    static string(v) { return new Typed(_gaurd, \"string\", v); }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */\n    static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */\n    static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */\n    static isTyped(value) {\n        return (value\n            && typeof (value) === \"object\"\n            && \"_typedSymbol\" in value\n            && value._typedSymbol === _typedSymbol);\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */\n    static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n}\nexports.Typed = Typed;\n//# sourceMappingURL=typed.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvdHlwZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsS0FBSyxNQUFNLFlBQVksZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CLFlBQVksTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBNEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsS0FBSyxRQUFRLFdBQVc7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL3R5cGVkLmpzP2Q3MjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBBIFR5cGVkIG9iamVjdCBhbGxvd3MgYSB2YWx1ZSB0byBoYXZlIGl0cyB0eXBlIGV4cGxpY2l0bHlcbiAqICBzcGVjaWZpZWQuXG4gKlxuICogIEZvciBleGFtcGxlLCBpbiBTb2xpZGl0eSwgdGhlIHZhbHVlIGBgNDVgYCBjb3VsZCByZXByZXNlbnQgYVxuICogIGBgdWludDhgYCBvciBhIGBgdWludDI1NmBgLiBUaGUgdmFsdWUgYGAweDEyMzRgYCBjb3VsZCByZXByZXNlbnRcbiAqICBhIGBgYnl0ZXMyYGAgb3IgYGBieXRlc2BgLlxuICpcbiAqICBTaW5jZSBKYXZhU2NyaXB0IGhhcyBubyBtZWFuaW5nZnVsIHdheSB0byBleHBsaWNpdGx5IGluZm9ybSBhbnlcbiAqICBBUElzIHdoaWNoIHdoYXQgdGhlIHR5cGUgaXMsIHRoaXMgYWxsb3dzIHRyYW5zcGFyZW50IGludGVyb3BlcmF0aW9uXG4gKiAgd2l0aCBTb2xkaXR5LlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9hYmk6VHlwZWQgVmFsdWVzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHlwZWQgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgX2dhdXJkID0ge307XG5mdW5jdGlvbiBuKHZhbHVlLCB3aWR0aCkge1xuICAgIGxldCBzaWduZWQgPSBmYWxzZTtcbiAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgIHNpZ25lZCA9IHRydWU7XG4gICAgICAgIHdpZHRoICo9IC0xO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGAke3NpZ25lZCA/IFwiXCIgOiBcInVcIn1pbnQke3dpZHRofWAsIHZhbHVlLCB7IHNpZ25lZCwgd2lkdGggfSk7XG59XG5mdW5jdGlvbiBiKHZhbHVlLCBzaXplKSB7XG4gICAgLy8gQFRPRE86IENoZWNrIHJhbmdlIGlzIHZhbGlkIGZvciB2YWx1ZVxuICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBgYnl0ZXMkeyhzaXplKSA/IHNpemUgOiBcIlwifWAsIHZhbHVlLCB7IHNpemUgfSk7XG59XG5jb25zdCBfdHlwZWRTeW1ib2wgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc190eXBlZFwiKTtcbi8qKlxuICogIFRoZSAqKlR5cGVkKiogY2xhc3MgdG8gd3JhcCB2YWx1ZXMgcHJvdmlkaW5nIGV4cGxpY2l0IHR5cGUgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIFR5cGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUsIGFzIGEgU29saWRpdHktY29tcGF0aWJsZSB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF90eXBlZFN5bWJvbDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2F1cmQsIHR5cGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydFByaXZhdGUpKF9nYXVyZCwgZ2F1cmQsIFwiVHlwZWRcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgX3R5cGVkU3ltYm9sLCB0eXBlLCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWx1ZSBpcyB2YWxpZFxuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRm9ybWF0IHRoZSB0eXBlIGFzIGEgSHVtYW4tUmVhZGFibGUgdHlwZS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJkeW5hbWljQXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYHR1cGxlKCR7dGhpcy52YWx1ZS5tYXAoKHYpID0+IHYuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIHR5cGUuXG4gICAgICovXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5pbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1pblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1heFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZEJpZ0ludF1dLlxuICAgICAqL1xuICAgIGlzQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy50eXBlLm1hdGNoKC9edT9pbnRbMC05XSskLykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkRGF0YV1dLlxuICAgICAqL1xuICAgIGlzRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zdGFydHNXaXRoKFwiYnl0ZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRTdHJpbmddXS5cbiAgICAgKi9cbiAgICBpc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IFwic3RyaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHVwbGUgbmFtZSwgaWYgdGhpcyBpcyBhIHR1cGxlLiBUaHJvd3Mgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldCB0dXBsZU5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGEgdHVwbGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGlzIHR5cGUgYXMgYW4gYXJyYXlcbiAgICAvLyAtIGBudWxsYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyB1bmZvcmNlZCwgaXQgY291bGQgYmUgZHluYW1pY1xuICAgIC8vIC0gYC0xYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyBkeW5hbWljXG4gICAgLy8gLSBhbnkgb3RoZXIgdmFsdWUgaW5kaWNhdGVzIGl0IGlzIGEgc3RhdGljIGFycmF5IGFuZCBpcyBpdHMgbGVuZ3RoXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdHlwZSBvciBgYC0xYGAgaWYgaXQgaXMgZHluYW1pYy5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIHR5cGUgaXMgbm90IGFuIGFycmF5LlxuICAgICAqL1xuICAgIGdldCBhcnJheUxlbmd0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlR5cGVkKiogb2YgJSV0eXBlJSUgd2l0aCB0aGUgJSV2YWx1ZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCB0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OCh2KSB7IHJldHVybiBuKHYsIDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTYodikgeyByZXR1cm4gbih2LCAxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNCh2KSB7IHJldHVybiBuKHYsIDI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDMyKHYpIHsgcmV0dXJuIG4odiwgMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDAodikgeyByZXR1cm4gbih2LCA0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ0OCh2KSB7IHJldHVybiBuKHYsIDQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDU2KHYpIHsgcmV0dXJuIG4odiwgNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NjQodikgeyByZXR1cm4gbih2LCA2NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ3Mih2KSB7IHJldHVybiBuKHYsIDcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgwKHYpIHsgcmV0dXJuIG4odiwgODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50ODgodikgeyByZXR1cm4gbih2LCA4OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ5Nih2KSB7IHJldHVybiBuKHYsIDk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMDQodikgeyByZXR1cm4gbih2LCAxMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDExMih2KSB7IHJldHVybiBuKHYsIDExMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTIwKHYpIHsgcmV0dXJuIG4odiwgMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMjgodikgeyByZXR1cm4gbih2LCAxMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEzNih2KSB7IHJldHVybiBuKHYsIDEzNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTUyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNTIodikgeyByZXR1cm4gbih2LCAxNTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2MCh2KSB7IHJldHVybiBuKHYsIDE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTY4KHYpIHsgcmV0dXJuIG4odiwgMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNzYodikgeyByZXR1cm4gbih2LCAxNzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE4NCh2KSB7IHJldHVybiBuKHYsIDE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE5MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTkyKHYpIHsgcmV0dXJuIG4odiwgMTkyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDAodikgeyByZXR1cm4gbih2LCAyMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIwOCh2KSB7IHJldHVybiBuKHYsIDIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjE2KHYpIHsgcmV0dXJuIG4odiwgMjE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMjQodikgeyByZXR1cm4gbih2LCAyMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIzMih2KSB7IHJldHVybiBuKHYsIDIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQwKHYpIHsgcmV0dXJuIG4odiwgMjQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNDgodikgeyByZXR1cm4gbih2LCAyNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI1Nih2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDgodikgeyByZXR1cm4gbih2LCAtOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYodikgeyByZXR1cm4gbih2LCAtMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0KHYpIHsgcmV0dXJuIG4odiwgLTI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQzMih2KSB7IHJldHVybiBuKHYsIC0zMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NDAodikgeyByZXR1cm4gbih2LCAtNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQ4KHYpIHsgcmV0dXJuIG4odiwgLTQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ1Nih2KSB7IHJldHVybiBuKHYsIC01Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NjQodikgeyByZXR1cm4gbih2LCAtNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDcyKHYpIHsgcmV0dXJuIG4odiwgLTcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4MCh2KSB7IHJldHVybiBuKHYsIC04MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODgodikgeyByZXR1cm4gbih2LCAtODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDk2KHYpIHsgcmV0dXJuIG4odiwgLTk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTA0KHYpIHsgcmV0dXJuIG4odiwgLTEwNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDExMih2KSB7IHJldHVybiBuKHYsIC0xMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMjAodikgeyByZXR1cm4gbih2LCAtMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTI4KHYpIHsgcmV0dXJuIG4odiwgLTEyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEzNih2KSB7IHJldHVybiBuKHYsIC0xMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNDQodikgeyByZXR1cm4gbih2LCAtMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNTIodikgeyByZXR1cm4gbih2LCAtMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYwKHYpIHsgcmV0dXJuIG4odiwgLTE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2OCh2KSB7IHJldHVybiBuKHYsIC0xNjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNzYodikgeyByZXR1cm4gbih2LCAtMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTg0KHYpIHsgcmV0dXJuIG4odiwgLTE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTkyKHYpIHsgcmV0dXJuIG4odiwgLTE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIwMCh2KSB7IHJldHVybiBuKHYsIC0yMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDgodikgeyByZXR1cm4gbih2LCAtMjA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjE2KHYpIHsgcmV0dXJuIG4odiwgLTIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIyNCh2KSB7IHJldHVybiBuKHYsIC0yMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMzIodikgeyByZXR1cm4gbih2LCAtMjMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQwKHYpIHsgcmV0dXJuIG4odiwgLTI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0OCh2KSB7IHJldHVybiBuKHYsIC0yNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNTYodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMSh2KSB7IHJldHVybiBiKHYsIDEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIodikgeyByZXR1cm4gYih2LCAyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzKHYpIHsgcmV0dXJuIGIodiwgMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNCh2KSB7IHJldHVybiBiKHYsIDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczUodikgeyByZXR1cm4gYih2LCA1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM2KHYpIHsgcmV0dXJuIGIodiwgNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNyh2KSB7IHJldHVybiBiKHYsIDcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczgodikgeyByZXR1cm4gYih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM5KHYpIHsgcmV0dXJuIGIodiwgOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEwKHYpIHsgcmV0dXJuIGIodiwgMTApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMSh2KSB7IHJldHVybiBiKHYsIDExKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTIodikgeyByZXR1cm4gYih2LCAxMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEzKHYpIHsgcmV0dXJuIGIodiwgMTMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNCh2KSB7IHJldHVybiBiKHYsIDE0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTUodikgeyByZXR1cm4gYih2LCAxNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE2KHYpIHsgcmV0dXJuIGIodiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNyh2KSB7IHJldHVybiBiKHYsIDE3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTgodikgeyByZXR1cm4gYih2LCAxOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE5KHYpIHsgcmV0dXJuIGIodiwgMTkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMCh2KSB7IHJldHVybiBiKHYsIDIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjEodikgeyByZXR1cm4gYih2LCAyMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIyKHYpIHsgcmV0dXJuIGIodiwgMjIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMyh2KSB7IHJldHVybiBiKHYsIDIzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjQodikgeyByZXR1cm4gYih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI1KHYpIHsgcmV0dXJuIGIodiwgMjUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNih2KSB7IHJldHVybiBiKHYsIDI2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjcodikgeyByZXR1cm4gYih2LCAyNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI4KHYpIHsgcmV0dXJuIGIodiwgMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOSh2KSB7IHJldHVybiBiKHYsIDI5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzAodikgeyByZXR1cm4gYih2LCAzMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMxKHYpIHsgcmV0dXJuIGIodiwgMzEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMih2KSB7IHJldHVybiBiKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBhZGRyZXNzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGFkZHJlc3ModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhZGRyZXNzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJvb2xgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9vbCh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJvb2xcIiwgISF2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJ5dGVzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHN0cmluZ2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmcodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJzdHJpbmdcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYXJyYXlgYCB0eXBlIGZvciAlJXYlJSwgYWxsb3dpbmcgJSVkeW5hbWljJSUgbGVuZ3RoLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheSh2LCBkeW5hbWljKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFycmF5XCIsIHYsIGR5bmFtaWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdHVwbGVgYCB0eXBlIGZvciAlJXYlJSwgd2l0aCB0aGUgb3B0aW9uYWwgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIHR1cGxlKHYsIG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwidHVwbGVcIiwgdiwgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBvdmVycmlkZXModikge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJvdmVycmlkZXNcIiwgT2JqZWN0LmFzc2lnbih7fSwgdikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgJSV2YWx1ZSUlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1R5cGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWVcbiAgICAgICAgICAgICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAmJiBcIl90eXBlZFN5bWJvbFwiIGluIHZhbHVlXG4gICAgICAgICAgICAmJiB2YWx1ZS5fdHlwZWRTeW1ib2wgPT09IF90eXBlZFN5bWJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGUgdmFsdWUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UsIHZhbGlkYXRlcyB0aGUgdW5kZXJseWluZyB2YWx1ZVxuICAgICAqICBhbmQgcmV0dXJucyBpdCwgb3RoZXJ3aXNlIHJldHVybnMgdmFsdWUgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIGZ1bmN0aW9ucyB0aGF0IHdpdGggdG8gYWNjZXB0IGVpdGhlciBhIFtbVHlwZWRdXVxuICAgICAqICBvYmplY3Qgb3IgdmFsdWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGU6IGV4cGVjZXRkICR7dHlwZX0sIGdvdCAke3ZhbHVlLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZWQgPSBUeXBlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/abi/typed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/address/address.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/address/address.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getIcapAddress = exports.getAddress = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0, index_js_2.getBytes)((0, index_js_1.keccak256)(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nfunction getAddress(address) {\n    (0, index_js_2.assertArgument)(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0, index_js_2.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0, index_js_2.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0, index_js_2.assertArgument)(false, \"invalid address\", \"address\", address);\n}\nexports.getAddress = getAddress;\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nfunction getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\nexports.getIcapAddress = getIcapAddress;\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsa0JBQWtCO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUUsWUFBWSxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2FkZHJlc3MuanM/YmRmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMzYgPSBCaWdJbnQoMzYpO1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvLyAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuICAgIC8vICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAvLyAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMS5rZWNjYWsyNTYpKGV4cGFuZGVkKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gPj4gNCkgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAweDBmKSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgY2hhcnMuam9pbihcIlwiKTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9CYW5rX0FjY291bnRfTnVtYmVyXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlXG5jb25zdCBpYmFuTG9va3VwID0ge307XG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZyhpKV0gPSBTdHJpbmcoaSk7XG59XG5mb3IgKGxldCBpID0gMDsgaSA8IDI2OyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBpKV0gPSBTdHJpbmcoMTAgKyBpKTtcbn1cbi8vIEhvdyBtYW55IGRlY2ltYWwgZGlnaXRzIGNhbiB3ZSBwcm9jZXNzPyAoZm9yIDY0LWJpdCBmbG9hdCwgdGhpcyBpcyAxNSlcbi8vIGkuZS4gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XG5jb25zdCBzYWZlRGlnaXRzID0gMTU7XG5mdW5jdGlvbiBpYmFuQ2hlY2tzdW0oYWRkcmVzcykge1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvVXBwZXJDYXNlKCk7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDQpICsgYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgKyBcIjAwXCI7XG4gICAgbGV0IGV4cGFuZGVkID0gYWRkcmVzcy5zcGxpdChcIlwiKS5tYXAoKGMpID0+IHsgcmV0dXJuIGliYW5Mb29rdXBbY107IH0pLmpvaW4oXCJcIik7XG4gICAgLy8gSmF2YXNjcmlwdCBjYW4gaGFuZGxlIGludGVnZXJzIHNhZmVseSB1cCB0byAxNSAoZGVjaW1hbCkgZGlnaXRzXG4gICAgd2hpbGUgKGV4cGFuZGVkLmxlbmd0aCA+PSBzYWZlRGlnaXRzKSB7XG4gICAgICAgIGxldCBibG9jayA9IGV4cGFuZGVkLnN1YnN0cmluZygwLCBzYWZlRGlnaXRzKTtcbiAgICAgICAgZXhwYW5kZWQgPSBwYXJzZUludChibG9jaywgMTApICUgOTcgKyBleHBhbmRlZC5zdWJzdHJpbmcoYmxvY2subGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IGNoZWNrc3VtID0gU3RyaW5nKDk4IC0gKHBhcnNlSW50KGV4cGFuZGVkLCAxMCkgJSA5NykpO1xuICAgIHdoaWxlIChjaGVja3N1bS5sZW5ndGggPCAyKSB7XG4gICAgICAgIGNoZWNrc3VtID0gXCIwXCIgKyBjaGVja3N1bTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtO1xufVxuO1xuY29uc3QgQmFzZTM2ID0gKGZ1bmN0aW9uICgpIHtcbiAgICA7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCJbaV07XG4gICAgICAgIHJlc3VsdFtrZXldID0gQmlnSW50KGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufSkoKTtcbmZ1bmN0aW9uIGZyb21CYXNlMzYodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHJlc3VsdCA9IEJOXzA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgKiBCTl8zNiArIEJhc2UzNlt2YWx1ZVtpXV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgbm9ybWFsaXplZCBhbmQgY2hlY2tzdW1lZCBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJS5cbiAqICBUaGlzIGFjY2VwdHMgbm9uLWNoZWNrc3VtIGFkZHJlc3NlcywgY2hlY2tzdW0gYWRkcmVzc2VzIGFuZFxuICogIFtbZ2V0SWNhcEFkZHJlc3NdXSBmb3JtYXRzLlxuICpcbiAqICBUaGUgY2hlY2tzdW0gaW4gRXRoZXJldW0gdXNlcyB0aGUgY2FwaXRhbGl6YXRpb24gKHVwcGVyLWNhc2VcbiAqICB2cyBsb3dlci1jYXNlKSBvZiB0aGUgY2hhcmFjdGVycyB3aXRoaW4gYW4gYWRkcmVzcyB0byBlbmNvZGVcbiAqICBpdHMgY2hlY2tzdW0sIHdoaWNoIG9mZmVycywgb24gYXZlcmFnZSwgYSBjaGVja3N1bSBvZiAxNS1iaXRzLlxuICpcbiAqICBJZiAlJWFkZHJlc3MlJSBjb250YWlucyBib3RoIHVwcGVyLWNhc2UgYW5kIGxvd2VyLWNhc2UsIGl0IGlzXG4gKiAgYXNzdW1lZCB0byBhbHJlYWR5IGJlIGEgY2hlY2tzdW0gYWRkcmVzcyBhbmQgaXRzIGNoZWNrc3VtIGlzXG4gKiAgdmFsaWRhdGVkLCBhbmQgaWYgdGhlIGFkZHJlc3MgZmFpbHMgaXRzIGV4cGVjdGVkIGNoZWNrc3VtIGFuXG4gKiAgZXJyb3IgaXMgdGhyb3duLlxuICpcbiAqICBJZiB5b3Ugd2lzaCB0aGUgY2hlY2tzdW0gb2YgJSVhZGRyZXNzJSUgdG8gYmUgaWdub3JlLCBpdCBzaG91bGRcbiAqICBiZSBjb252ZXJ0ZWQgdG8gbG93ZXItY2FzZSAoaS5lLiBgYC50b0xvd2VyY2FzZSgpYGApIGJlZm9yZVxuICogIGJlaW5nIHBhc3NlZCBpbi4gVGhpcyBzaG91bGQgYmUgYSB2ZXJ5IHJhcmUgc2l0dWF0aW9uIHRob3VnaCxcbiAqICB0aGF0IHlvdSB3aXNoIHRvIGJ5cGFzcyB0aGUgc2FmZWdhdXJkcyBpbiBwbGFjZSB0byBwcm90ZWN0XG4gKiAgYWdhaW5zdCBhbiBhZGRyZXNzIHRoYXQgaGFzIGJlZW4gaW5jb3JyZWN0bHkgY29waWVkIGZyb20gYW5vdGhlclxuICogIHNvdXJjZS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBBZGRzIHRoZSBjaGVja3N1bSAodmlhIHVwcGVyLWNhc2luZyBzcGVjaWZpYyBsZXR0ZXJzKVxuICogICAgZ2V0QWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnZlcnRzIElDQVAgYWRkcmVzcyBhbmQgYWRkcyBjaGVja3N1bVxuICogICAgZ2V0QWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBhbiBhZGRyZXNzIGNvbnRhaW5zIG1peGVkIGNhc2UsXG4gKiAgICAvLyBidXQgdGhlIGNoZWNrc3VtIGZhaWxzXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAoYWRkcmVzcykgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XG4gICAgICAgIC8vIE1pc3NpbmcgdGhlIDB4IHByZWZpeFxuICAgICAgICBpZiAoIWFkZHJlc3Muc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIC8vIEl0IGlzIGEgY2hlY2tzdW1tZWQgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSghYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSB8fCByZXN1bHQgPT09IGFkZHJlc3MsIFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG59XG5leHBvcnRzLmdldEFkZHJlc3MgPSBnZXRBZGRyZXNzO1xuLyoqXG4gKiAgVGhlIFtJQ0FQIEFkZHJlc3MgZm9ybWF0XShsaW5rLWljYXApIGZvcm1hdCBpcyBhbiBlYXJseSBjaGVja3N1bVxuICogIGZvcm1hdCB3aGljaCBhdHRlbXB0cyB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGJhbmtpbmdcbiAqICBpbmR1c3RyeSBbSUJBTiBmb3JtYXRdKGxpbmstd2lraS1pYmFuKSBmb3IgYmFuayBhY2NvdW50cy5cbiAqXG4gKiAgSXQgaXMgbm8gbG9uZ2VyIGNvbW1vbiBvciBhIHJlY29tbWVuZGVkIGZvcm1hdC5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgSUNBUCBjaGVja3N1bSBpcyB3cm9uZ1xuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszN1wiKTtcbiAqICAgIC8vX2Vycm9yOlxuICovXG5mdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy9sZXQgYmFzZTM2ID0gX2Jhc2UxNlRvMzYoZ2V0QWRkcmVzcyhhZGRyZXNzKS5zdWJzdHJpbmcoMikpLnRvVXBwZXJDYXNlKCk7XG4gICAgbGV0IGJhc2UzNiA9IEJpZ0ludChnZXRBZGRyZXNzKGFkZHJlc3MpKS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKTtcbiAgICB3aGlsZSAoYmFzZTM2Lmxlbmd0aCA8IDMwKSB7XG4gICAgICAgIGJhc2UzNiA9IFwiMFwiICsgYmFzZTM2O1xuICAgIH1cbiAgICByZXR1cm4gXCJYRVwiICsgaWJhbkNoZWNrc3VtKFwiWEUwMFwiICsgYmFzZTM2KSArIGJhc2UzNjtcbn1cbmV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBnZXRJY2FwQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/address/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/address/checks.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/address/checks.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst address_js_1 = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/address.js\");\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nfunction isAddressable(value) {\n    return (value && typeof (value.getAddress) === \"function\");\n}\nexports.isAddressable = isAddressable;\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nfunction isAddress(value) {\n    try {\n        (0, address_js_1.getAddress)(value);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexports.isAddress = isAddress;\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0, index_js_1.assert)(typeof (target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        (0, index_js_1.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0, address_js_1.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nfunction resolveAddress(target, resolver) {\n    if (typeof (target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0, address_js_1.getAddress)(target);\n        }\n        (0, index_js_1.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n        return checkAddress(target, resolver.resolveName(target));\n    }\n    else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    }\n    else if (target && typeof (target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n}\nexports.resolveAddress = resolveAddress;\n//# sourceMappingURL=checks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2NoZWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUI7QUFDbEUsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLGlGQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RyxlQUFlO0FBQ3hILDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0Esa0hBQWtILDBCQUEwQjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FkZHJlc3MvY2hlY2tzLmpzP2UxMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3MgPSBleHBvcnRzLmlzQWRkcmVzc2FibGUgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWRkcmVzc19qc18xID0gcmVxdWlyZShcIi4vYWRkcmVzcy5qc1wiKTtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gb2JqZWN0IHdoaWNoIGltcGxlbWVudHMgdGhlXG4gKiAgW1tBZGRyZXNzYWJsZV1dIGludGVyZmFjZS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBXYWxsZXRzIGFuZCBBYnN0cmFjdFNpZ25lciBzdWItY2xhc3Nlc1xuICogICAgaXNBZGRyZXNzYWJsZShXYWxsZXQuY3JlYXRlUmFuZG9tKCkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udHJhY3RzXG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChcImRhaS50b2tlbnMuZXRoZXJzLmV0aFwiLCBbIF0sIHByb3ZpZGVyKVxuICogICAgaXNBZGRyZXNzYWJsZShjb250cmFjdClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gaXNBZGRyZXNzYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydHMuaXNBZGRyZXNzYWJsZSA9IGlzQWRkcmVzc2FibGU7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBWYWxpZCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBWYWxpZCBJQ0FQIGFkZHJlc3NcbiAqICAgIGlzQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSW52YWxpZCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSW52YWxpZCBJQ0FQIGNoZWNrc3VtXG4gKiAgICBpc0FkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBOb3QgYW4gYWRkcmVzcyAoYW4gRU5TIG5hbWUgcmVxdWlyZXMgYSBwcm92aWRlZCBhbmQgYW5cbiAqICAgIC8vIGFzeW5jaHJvbm91cyBBUEkgdG8gYWNjZXNzKVxuICogICAgaXNBZGRyZXNzKFwicmljbW9vLmV0aFwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBpc0FkZHJlc3ModmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0FkZHJlc3MgPSBpc0FkZHJlc3M7XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkodHlwZW9mICh0YXJnZXQpICE9PSBcInN0cmluZ1wiLCBcInVuY29uZmlndXJlZCBuYW1lXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwgeyB2YWx1ZTogdGFyZ2V0IH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBBZGRyZXNzTGlrZSB2YWx1ZTsgZGlkIG5vdCByZXNvbHZlIHRvIGEgdmFsdWUgYWRkcmVzc1wiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGFkZHJlc3NfanNfMS5nZXRBZGRyZXNzKShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYW4gYWRkcmVzcyBmb3IgdGhlICUldGFyZ2V0JSUsIHdoaWNoIG1heSBiZSBhbnlcbiAqICBzdXBwb3J0ZWQgYWRkcmVzcyB0eXBlLCBhbiBbW0FkZHJlc3NhYmxlXV0gb3IgYSBQcm9taXNlIHdoaWNoXG4gKiAgcmVzb2x2ZXMgdG8gYW4gYWRkcmVzcy5cbiAqXG4gKiAgSWYgYW4gRU5TIG5hbWUgaXMgcHJvdmlkZWQsIGJ1dCB0aGF0IG5hbWUgaGFzIG5vdCBiZWVuIGNvcnJlY3RseVxuICogIGNvbmZpZ3VyZWQgYSBbW1VuY29uZmlndXJlZE5hbWVFcnJvcl1dIGlzIHRocm93bi5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBhZGRyID0gXCIweDZCMTc1NDc0RTg5MDk0QzQ0RGE5OGI5NTRFZWRlQUM0OTUyNzFkMEZcIlxuICpcbiAqICAgIC8vIEFkZHJlc3NlcyBhcmUgcmV0dXJuIHN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3MgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhQcm9taXNlLnJlc29sdmUoYWRkcikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gRU5TIG5hbWVzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQWRkcmVzc2FibGUgb2JqZWN0cyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHIsIFsgXSlcbiAqICAgIHJlc29sdmVBZGRyZXNzKGNvbnRyYWN0LCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBVbmNvbmZpZ3VyZWQgRU5TIG5hbWVzIHJlamVjdFxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJub3RoaW5nLWhlcmUucmljbW9vLmV0aFwiLCBwcm92aWRlcilcbiAqICAgIC8vX2Vycm9yOlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyByZXF1aXJlIGEgTmFtZVJlc29sdmVyIG9iamVjdCBwYXNzZWQgaW5cbiAqICAgIC8vIChub3RpY2UgdGhlIHByb3ZpZGVyIHdhcyBvbWl0dGVkKVxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJub3RoaW5nLWhlcmUucmljbW9vLmV0aFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzKHRhcmdldCwgcmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0YXJnZXQubWF0Y2goL14weFswLTlhLWZdezQwfSQvaSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShyZXNvbHZlciAhPSBudWxsLCBcIkVOUyByZXNvbHV0aW9uIHJlcXVpcmVzIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FkZHJlc3NhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldC5nZXRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mICh0YXJnZXQudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG5leHBvcnRzLnJlc29sdmVBZGRyZXNzID0gcmVzb2x2ZUFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/address/checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/address/contract-address.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/address/contract-address.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getCreate2Address = exports.getCreateAddress = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst address_js_1 = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/address.js\");\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */\nfunction getCreateAddress(tx) {\n    const from = (0, address_js_1.getAddress)(tx.from);\n    const nonce = (0, index_js_2.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    }\n    else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    }\n    else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([from, nonceHex])), 12));\n}\nexports.getCreateAddress = getCreateAddress;\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */\nfunction getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0, address_js_1.getAddress)(_from);\n    const salt = (0, index_js_2.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0, index_js_2.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0, index_js_2.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)([\"0xff\", from, salt, initCodeHash])), 12));\n}\nexports.getCreate2Address = getCreate2Address;\n//# sourceMappingURL=contract-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsd0JBQXdCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLG9GQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsaUZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzPzI3NTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENyZWF0ZTJBZGRyZXNzID0gZXhwb3J0cy5nZXRDcmVhdGVBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWRkcmVzc19qc18xID0gcmVxdWlyZShcIi4vYWRkcmVzcy5qc1wiKTtcbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEVgYCBmb3IgJSV0eCUlLlxuICpcbiAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXG4gKiAgZGVwbG95ZWQgdG8gYnkgYW4gRU9BIHdoZW4gc2VuZGluZyBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24gKGkuZS5cbiAqICB3aGVuIHRoZSBgYHRvYGAgYWRkcmVzcyBpcyBgYG51bGxgYCkuXG4gKlxuICogIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGEgY29udHJhY3QsIGJ5IHVzaW5nIHRoZSBjb250cmFjdCdzIGFkZHJlc3MgYXMgdGhlXG4gKiAgYGB0b2BgIGFuZCB0aGUgY29udHJhY3QncyBub25jZS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiO1xuICogICAgbm9uY2UgPSA1O1xuICpcbiAqICAgIGdldENyZWF0ZUFkZHJlc3MoeyBmcm9tLCBub25jZSB9KTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gZ2V0Q3JlYXRlQWRkcmVzcyh0eCkge1xuICAgIGNvbnN0IGZyb20gPSAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKHR4LmZyb20pO1xuICAgIGNvbnN0IG5vbmNlID0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KSh0eC5ub25jZSwgXCJ0eC5ub25jZVwiKTtcbiAgICBsZXQgbm9uY2VIZXggPSBub25jZS50b1N0cmluZygxNik7XG4gICAgaWYgKG5vbmNlSGV4ID09PSBcIjBcIikge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9uY2VIZXgubGVuZ3RoICUgMikge1xuICAgICAgICBub25jZUhleCA9IFwiMHgwXCIgKyBub25jZUhleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIHJldHVybiAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKCgwLCBpbmRleF9qc18yLmRhdGFTbGljZSkoKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfMi5lbmNvZGVSbHApKFtmcm9tLCBub25jZUhleF0pKSwgMTIpKTtcbn1cbmV4cG9ydHMuZ2V0Q3JlYXRlQWRkcmVzcyA9IGdldENyZWF0ZUFkZHJlc3M7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXG4gKlxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cbiAqXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXG4gKlxuICogICAgLy8gVGhlIHNhbHRcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcbiAqXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcbiAqICAgIGluaXRDb2RlSGFzaCA9IGtlY2NhazI1Nihpbml0Q29kZSlcbiAqXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKF9mcm9tLCBfc2FsdCwgX2luaXRDb2RlSGFzaCkge1xuICAgIGNvbnN0IGZyb20gPSAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKF9mcm9tKTtcbiAgICBjb25zdCBzYWx0ID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKF9zYWx0LCBcInNhbHRcIik7XG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKF9pbml0Q29kZUhhc2gsIFwiaW5pdENvZGVIYXNoXCIpO1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShzYWx0Lmxlbmd0aCA9PT0gMzIsIFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBfc2FsdCk7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xuICAgIHJldHVybiAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKCgwLCBpbmRleF9qc18yLmRhdGFTbGljZSkoKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfMi5jb25jYXQpKFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGdldENyZWF0ZTJBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/address/contract-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/address/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/address/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Addresses are a fundamental part of interacting with Ethereum. They\n *  represent the gloabal identity of Externally Owned Accounts (accounts\n *  backed by a private key) and contracts.\n *\n *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem\n *  of contracts, standards and libraries which enable looking up an\n *  address for an ENS name.\n *\n *  These functions help convert between various formats, validate\n *  addresses and safely resolve ENS names.\n *\n *  @_section: api/address:Addresses  [about-addresses]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = void 0;\nnull;\nvar address_js_1 = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/address.js\");\nObject.defineProperty(exports, \"getAddress\", ({ enumerable: true, get: function () { return address_js_1.getAddress; } }));\nObject.defineProperty(exports, \"getIcapAddress\", ({ enumerable: true, get: function () { return address_js_1.getIcapAddress; } }));\nvar contract_address_js_1 = __webpack_require__(/*! ./contract-address.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/contract-address.js\");\nObject.defineProperty(exports, \"getCreateAddress\", ({ enumerable: true, get: function () { return contract_address_js_1.getCreateAddress; } }));\nObject.defineProperty(exports, \"getCreate2Address\", ({ enumerable: true, get: function () { return contract_address_js_1.getCreate2Address; } }));\nvar checks_js_1 = __webpack_require__(/*! ./checks.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/checks.js\");\nObject.defineProperty(exports, \"isAddressable\", ({ enumerable: true, get: function () { return checks_js_1.isAddressable; } }));\nObject.defineProperty(exports, \"isAddress\", ({ enumerable: true, get: function () { return checks_js_1.isAddress; } }));\nObject.defineProperty(exports, \"resolveAddress\", ({ enumerable: true, get: function () { return checks_js_1.resolveAddress; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0I7QUFDdks7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBYztBQUN6Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgsa0RBQWlELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2hJLDRCQUE0QixtQkFBTyxDQUFDLG1HQUF1QjtBQUMzRCxvREFBbUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDN0kscURBQW9ELEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQy9JLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFhO0FBQ3ZDLGlEQUFnRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM3SCw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWRkcmVzcy9pbmRleC5qcz85ZWJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQWRkcmVzc2VzIGFyZSBhIGZ1bmRhbWVudGFsIHBhcnQgb2YgaW50ZXJhY3Rpbmcgd2l0aCBFdGhlcmV1bS4gVGhleVxuICogIHJlcHJlc2VudCB0aGUgZ2xvYWJhbCBpZGVudGl0eSBvZiBFeHRlcm5hbGx5IE93bmVkIEFjY291bnRzIChhY2NvdW50c1xuICogIGJhY2tlZCBieSBhIHByaXZhdGUga2V5KSBhbmQgY29udHJhY3RzLlxuICpcbiAqICBUaGUgRXRoZXJldW0gTmFtaW5nIFNlcnZpY2UgKEVOUykgcHJvdmlkZXMgYW4gaW50ZXJjb25uZWN0ZWQgZWNvc3lzdGVtXG4gKiAgb2YgY29udHJhY3RzLCBzdGFuZGFyZHMgYW5kIGxpYnJhcmllcyB3aGljaCBlbmFibGUgbG9va2luZyB1cCBhblxuICogIGFkZHJlc3MgZm9yIGFuIEVOUyBuYW1lLlxuICpcbiAqICBUaGVzZSBmdW5jdGlvbnMgaGVscCBjb252ZXJ0IGJldHdlZW4gdmFyaW91cyBmb3JtYXRzLCB2YWxpZGF0ZVxuICogIGFkZHJlc3NlcyBhbmQgc2FmZWx5IHJlc29sdmUgRU5TIG5hbWVzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9hZGRyZXNzOkFkZHJlc3NlcyAgW2Fib3V0LWFkZHJlc3Nlc11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlQWRkcmVzcyA9IGV4cG9ydHMuaXNBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3NhYmxlID0gZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q3JlYXRlQWRkcmVzcyA9IGV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSB2b2lkIDA7XG5udWxsO1xudmFyIGFkZHJlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzX2pzXzEuZ2V0QWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEljYXBBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzX2pzXzEuZ2V0SWNhcEFkZHJlc3M7IH0gfSk7XG52YXIgY29udHJhY3RfYWRkcmVzc19qc18xID0gcmVxdWlyZShcIi4vY29udHJhY3QtYWRkcmVzcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENyZWF0ZUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0X2FkZHJlc3NfanNfMS5nZXRDcmVhdGVBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q3JlYXRlMkFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0X2FkZHJlc3NfanNfMS5nZXRDcmVhdGUyQWRkcmVzczsgfSB9KTtcbnZhciBjaGVja3NfanNfMSA9IHJlcXVpcmUoXCIuL2NoZWNrcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQWRkcmVzc2FibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrc19qc18xLmlzQWRkcmVzc2FibGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0FkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrc19qc18xLmlzQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGVja3NfanNfMS5yZXNvbHZlQWRkcmVzczsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/constants/addresses.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/addresses.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZeroAddress = void 0;\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */\nexports.ZeroAddress = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvYWRkcmVzc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29uc3RhbnRzL2FkZHJlc3Nlcy5qcz9iNGE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5aZXJvQWRkcmVzcyA9IHZvaWQgMDtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSB6ZXJvIGFkZHJlc3MuXG4gKlxuICogICgqKmkuZS4qKiBgYFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJgYClcbiAqL1xuZXhwb3J0cy5aZXJvQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/constants/addresses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/constants/hashes.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/hashes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZeroHash = void 0;\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */\nexports.ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvaGFzaGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29uc3RhbnRzL2hhc2hlcy5qcz81MTI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5aZXJvSGFzaCA9IHZvaWQgMDtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSB6ZXJvIGhhc2guXG4gKlxuICogICgqKmkuZS4qKiBgYFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJgYClcbiAqL1xuZXhwb3J0cy5aZXJvSGFzaCA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/constants/hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/constants/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Some common constants useful for Ethereum.\n *\n *  @_section: api/constants: Constants  [about-constants]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessagePrefix = exports.EtherSymbol = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = exports.ZeroHash = exports.ZeroAddress = void 0;\nvar addresses_js_1 = __webpack_require__(/*! ./addresses.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/addresses.js\");\nObject.defineProperty(exports, \"ZeroAddress\", ({ enumerable: true, get: function () { return addresses_js_1.ZeroAddress; } }));\nvar hashes_js_1 = __webpack_require__(/*! ./hashes.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/hashes.js\");\nObject.defineProperty(exports, \"ZeroHash\", ({ enumerable: true, get: function () { return hashes_js_1.ZeroHash; } }));\nvar numbers_js_1 = __webpack_require__(/*! ./numbers.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/numbers.js\");\nObject.defineProperty(exports, \"N\", ({ enumerable: true, get: function () { return numbers_js_1.N; } }));\nObject.defineProperty(exports, \"WeiPerEther\", ({ enumerable: true, get: function () { return numbers_js_1.WeiPerEther; } }));\nObject.defineProperty(exports, \"MaxUint256\", ({ enumerable: true, get: function () { return numbers_js_1.MaxUint256; } }));\nObject.defineProperty(exports, \"MinInt256\", ({ enumerable: true, get: function () { return numbers_js_1.MinInt256; } }));\nObject.defineProperty(exports, \"MaxInt256\", ({ enumerable: true, get: function () { return numbers_js_1.MaxInt256; } }));\nvar strings_js_1 = __webpack_require__(/*! ./strings.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/strings.js\");\nObject.defineProperty(exports, \"EtherSymbol\", ({ enumerable: true, get: function () { return strings_js_1.EtherSymbol; } }));\nObject.defineProperty(exports, \"MessagePrefix\", ({ enumerable: true, get: function () { return strings_js_1.MessagePrefix; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLFNBQVMsR0FBRyxnQkFBZ0IsR0FBRyxtQkFBbUI7QUFDbkwscUJBQXFCLG1CQUFPLENBQUMsdUZBQWdCO0FBQzdDLCtDQUE4QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM1SCxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBYTtBQUN2Qyw0Q0FBMkMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbkgsbUJBQW1CLG1CQUFPLENBQUMsbUZBQWM7QUFDekMscUNBQW9DLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQ3RHLCtDQUE4QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMxSCw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgsNkNBQTRDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3RILDZDQUE0QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN0SCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBYztBQUN6QywrQ0FBOEMsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDMUgsaURBQWdELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzlIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29uc3RhbnRzL2luZGV4LmpzP2Q2NDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBTb21lIGNvbW1vbiBjb25zdGFudHMgdXNlZnVsIGZvciBFdGhlcmV1bS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvY29uc3RhbnRzOiBDb25zdGFudHMgIFthYm91dC1jb25zdGFudHNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZVByZWZpeCA9IGV4cG9ydHMuRXRoZXJTeW1ib2wgPSBleHBvcnRzLk1heEludDI1NiA9IGV4cG9ydHMuTWluSW50MjU2ID0gZXhwb3J0cy5NYXhVaW50MjU2ID0gZXhwb3J0cy5XZWlQZXJFdGhlciA9IGV4cG9ydHMuTiA9IGV4cG9ydHMuWmVyb0hhc2ggPSBleHBvcnRzLlplcm9BZGRyZXNzID0gdm9pZCAwO1xudmFyIGFkZHJlc3Nlc19qc18xID0gcmVxdWlyZShcIi4vYWRkcmVzc2VzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWmVyb0FkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3Nlc19qc18xLlplcm9BZGRyZXNzOyB9IH0pO1xudmFyIGhhc2hlc19qc18xID0gcmVxdWlyZShcIi4vaGFzaGVzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWmVyb0hhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc19qc18xLlplcm9IYXNoOyB9IH0pO1xudmFyIG51bWJlcnNfanNfMSA9IHJlcXVpcmUoXCIuL251bWJlcnMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudW1iZXJzX2pzXzEuTjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlaVBlckV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudW1iZXJzX2pzXzEuV2VpUGVyRXRoZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYXhVaW50MjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudW1iZXJzX2pzXzEuTWF4VWludDI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1pbkludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyc19qc18xLk1pbkludDI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1heEludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyc19qc18xLk1heEludDI1NjsgfSB9KTtcbnZhciBzdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJTeW1ib2xcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ3NfanNfMS5FdGhlclN5bWJvbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VQcmVmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ3NfanNfMS5NZXNzYWdlUHJlZml4OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/constants/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/constants/numbers.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/numbers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = void 0;\n/**\n *  A constant for the order N for the secp256k1 curve.\n *\n *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)\n */\nexports.N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n/**\n *  A constant for the number of wei in a single ether.\n *\n *  (**i.e.** ``1000000000000000000n``)\n */\nexports.WeiPerEther = BigInt(\"1000000000000000000\");\n/**\n *  A constant for the maximum value for a ``uint256``.\n *\n *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)\n */\nexports.MaxUint256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  A constant for the minimum value for an ``int256``.\n *\n *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)\n */\nexports.MinInt256 = BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\") * BigInt(-1);\n/**\n *  A constant for the maximum value for an ``int256``.\n *\n *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)\n */\nexports.MaxInt256 = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n//# sourceMappingURL=numbers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9udW1iZXJzLmpzPzRmMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1heEludDI1NiA9IGV4cG9ydHMuTWluSW50MjU2ID0gZXhwb3J0cy5NYXhVaW50MjU2ID0gZXhwb3J0cy5XZWlQZXJFdGhlciA9IGV4cG9ydHMuTiA9IHZvaWQgMDtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBvcmRlciBOIGZvciB0aGUgc2VjcDI1NmsxIGN1cnZlLlxuICpcbiAqICAoKippLmUuKiogYGAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFuYGApXG4gKi9cbmV4cG9ydHMuTiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBudW1iZXIgb2Ygd2VpIGluIGEgc2luZ2xlIGV0aGVyLlxuICpcbiAqICAoKippLmUuKiogYGAxMDAwMDAwMDAwMDAwMDAwMDAwbmBgKVxuICovXG5leHBvcnRzLldlaVBlckV0aGVyID0gQmlnSW50KFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBtYXhpbXVtIHZhbHVlIGZvciBhIGBgdWludDI1NmBgLlxuICpcbiAqICAoKippLmUuKiogYGAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuYGApXG4gKi9cbmV4cG9ydHMuTWF4VWludDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBtaW5pbXVtIHZhbHVlIGZvciBhbiBgYGludDI1NmBgLlxuICpcbiAqICAoKippLmUuKiogYGAtODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMG5gYClcbiAqL1xuZXhwb3J0cy5NaW5JbnQyNTYgPSBCaWdJbnQoXCIweDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikgKiBCaWdJbnQoLTEpO1xuLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIG1heGltdW0gdmFsdWUgZm9yIGFuIGBgaW50MjU2YGAuXG4gKlxuICogICgqKmkuZS4qKiBgYDB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm5gYClcbiAqL1xuZXhwb3J0cy5NYXhJbnQyNTYgPSBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/constants/numbers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/constants/strings.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/strings.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// NFKC (composed)             // (decomposed)\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessagePrefix = exports.EtherSymbol = void 0;\n/**\n *  A constant for the ether symbol (normalized using NFKC).\n *\n *  (**i.e.** ``\"\\\\u039e\"``)\n */\nexports.EtherSymbol = \"\\u039e\"; // \"\\uD835\\uDF63\";\n/**\n *  A constant for the [[link-eip-191]] personal message prefix.\n *\n *  (**i.e.** ``\"\\\\x19Ethereum Signed Message:\\\\n\"``)\n */\nexports.MessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvc3RyaW5ncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9zdHJpbmdzLmpzPzY3MGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBORktDIChjb21wb3NlZCkgICAgICAgICAgICAgLy8gKGRlY29tcG9zZWQpXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2VQcmVmaXggPSBleHBvcnRzLkV0aGVyU3ltYm9sID0gdm9pZCAwO1xuLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIGV0aGVyIHN5bWJvbCAobm9ybWFsaXplZCB1c2luZyBORktDKS5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCJcXFxcdTAzOWVcImBgKVxuICovXG5leHBvcnRzLkV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBbW2xpbmstZWlwLTE5MV1dIHBlcnNvbmFsIG1lc3NhZ2UgcHJlZml4LlxuICpcbiAqICAoKippLmUuKiogYGBcIlxcXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXFxcblwiYGApXG4gKi9cbmV4cG9ydHMuTWVzc2FnZVByZWZpeCA9IFwiXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/constants/strings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/contract/contract.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/contract/contract.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;\nconst index_js_1 = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst wrappers_js_1 = __webpack_require__(/*! ./wrappers.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/wrappers.js\");\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return (value && typeof (value.call) === \"function\");\n}\nfunction canEstimate(value) {\n    return (value && typeof (value.estimateGas) === \"function\");\n}\nfunction canResolve(value) {\n    return (value && typeof (value.resolveName) === \"function\");\n}\nfunction canSend(value) {\n    return (value && typeof (value.sendTransaction) === \"function\");\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    fragment;\n    constructor(contract, fragment, args) {\n        (0, index_js_3.defineProperties)(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = (async function () {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v) => (0, index_js_2.resolveAddress)(v, resolver)));\n                        }\n                        return (0, index_js_2.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value[feature]) === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof (value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nasync function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = index_js_1.Typed.dereference(arg, \"overrides\");\n    (0, index_js_3.assertArgument)(typeof (_overrides) === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0, provider_js_1.copyRequest)(_overrides);\n    (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\nexports.copyOverrides = copyOverrides;\n/**\n *  @_ignore:\n */\nasync function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = index_js_1.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0, index_js_2.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nexports.resolveArgs = resolveArgs;\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function (overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = (await copyOverrides(overrides, [\"data\"]));\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0, index_js_2.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = ((0, index_js_3.getBigInt)((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0, index_js_3.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        (0, index_js_3.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function (overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        }\n        catch (error) {\n            if ((0, index_js_3.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function (overrides) {\n        const runner = contract.runner;\n        (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides) => {\n        return await send(overrides);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function (...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0, index_js_2.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0, index_js_3.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function (...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function (...args) {\n        const runner = contract.runner;\n        (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function (...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        }\n        catch (error) {\n            if ((0, index_js_3.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const method = function (...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n            (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return (value && typeof (value) === \"object\" && (\"getTopicFilter\" in value) &&\n        (typeof (value.getTopicFilter) === \"function\") && value.fragment);\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function (name) {\n            if ((0, index_js_3.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    }\n    else if (event === \"*\") {\n        topics = [null];\n    }\n    else if (typeof (event) === \"string\") {\n        if ((0, index_js_3.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [event];\n        }\n        else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n        }\n    }\n    else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    }\n    else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [fragment.topicHash];\n    }\n    else {\n        (0, index_js_3.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t) => {\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return { fragment, tag, topics };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0, index_js_3.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", { operation });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = (addr ? addr : contract);\n        const filter = { address, topics };\n        const listener = (log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener) => {\n                    return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            }\n            else {\n                emit(contract, event, [], (listener) => {\n                    return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = () => {\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async () => {\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = { tag, listeners: [], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        }\n        catch (error) { }\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return (count > 0);\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    }\n    catch (error) { }\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\"then\"];\nclass BaseContract {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    target;\n    /**\n     *  The contract Interface.\n     */\n    interface;\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    runner;\n    /**\n     *  All the Events available on this contract.\n     */\n    filters;\n    /**\n     *  @_ignore:\n     */\n    [internal];\n    /**\n     *  The fallback or receive function if any.\n     */\n    fallback;\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target, abi, runner, _deployTx) {\n        (0, index_js_3.assertArgument)(typeof (target) === \"string\" || (0, index_js_2.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = index_js_1.Interface.from(abi);\n        (0, index_js_3.defineProperties)(this, { target, runner, interface: iface });\n        Object.defineProperty(this, internal, { value: {} });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof (target) === \"string\") {\n            if ((0, index_js_3.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            }\n            else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0, index_js_3.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) {\n                        throw (0, index_js_3.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        }\n        else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (typeof (prop) === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                }\n                catch (error) {\n                    if (!(0, index_js_3.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0, index_js_3.defineProperties)(this, { filters });\n        (0, index_js_3.defineProperties)(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                }\n                catch (error) {\n                    if (!(0, index_js_3.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress() { return await getInternal(this).addrPromise; }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr : (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            if (foundFragment) {\n                try {\n                    return new wrappers_js_1.EventLog(log, this.interface, foundFragment);\n                }\n                catch (error) {\n                    return new wrappers_js_1.UndecodedEventLog(log, error);\n                }\n            }\n            return new provider_js_1.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    ;\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nexports.BaseContract = BaseContract;\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nclass Contract extends _ContractBase() {\n}\nexports.Contract = Contract;\n//# sourceMappingURL=contract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC9jb250cmFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxxQkFBcUI7QUFDckYsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWlCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNoRDtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsZ0dBQTBCO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxtQkFBbUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksOEJBQThCO0FBQ2xLO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtJQUFrSSwwQkFBMEI7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSw4QkFBOEI7QUFDbEs7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0lBQWtJLDBCQUEwQjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxtQkFBbUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxXQUFXO0FBQzNILFlBQVksd0JBQXdCO0FBQ3BDLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtDQUFrQztBQUNuRixnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5Ryw4QkFBOEI7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEgsZ0NBQWdDO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0JBQStCOztBQUV0RTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMseUJBQXlCO0FBQ3pCO0FBQ0EsZ0hBQWdILDBCQUEwQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29udHJhY3QvY29udHJhY3QuanM/YjE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3QgPSBleHBvcnRzLkJhc2VDb250cmFjdCA9IGV4cG9ydHMucmVzb2x2ZUFyZ3MgPSBleHBvcnRzLmNvcHlPdmVycmlkZXMgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FiaS9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbi8vIGltcG9ydCBmcm9tIHByb3ZpZGVyLnRzIGluc3RlYWQgb2YgaW5kZXgudHMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBcbi8vIGZyb20gRXRoZXJzY2FuUHJvdmlkZXJcbmNvbnN0IHByb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHdyYXBwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi93cmFwcGVycy5qc1wiKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5mdW5jdGlvbiBjYW5DYWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmNhbGwpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuRXN0aW1hdGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZXN0aW1hdGVHYXMpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuUmVzb2x2ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZXNvbHZlTmFtZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5TZW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnNlbmRUcmFuc2FjdGlvbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjYW5SZXNvbHZlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBQcmVwYXJlZFRvcGljRmlsdGVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGZyYWdtZW50O1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGZyYWdtZW50IH0pO1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChmcmFnbWVudC5pbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKHYpID0+ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKSh2LCByZXNvbHZlcikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykodmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0VG9waWNGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmaWx0ZXI7XG4gICAgfVxufVxuLy8gQSA9IEFyZ3VtZW50cyBwYXNzZWQgaW4gYXMgYSB0dXBsZVxuLy8gUiA9IFRoZSByZXN1bHQgdHlwZSBvZiB0aGUgY2FsbCAoaS5lLiBpZiBvbmx5IG9uZSByZXR1cm4gdHlwZSxcbi8vICAgICB0aGUgcXVhbGlmaWVkIHR5cGUsIG90aGVyd2lzZSBSZXN1bHQpXG4vLyBEID0gVGhlIHR5cGUgdGhlIGRlZmF1bHQgY2FsbCB3aWxsIHJldHVybiAoaS5lLiBSIGZvciB2aWV3L3B1cmUsXG4vLyAgICAgVHJhbnNhY3Rpb25SZXNwb25zZSBvdGhlcndpc2UpXG4vL2V4cG9ydCBpbnRlcmZhY2UgQ29udHJhY3RNZXRob2Q8QSBleHRlbmRzIEFycmF5PGFueT4gPSBBcnJheTxhbnk+LCBSID0gYW55LCBEIGV4dGVuZHMgUiB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSA9IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZT4ge1xuZnVuY3Rpb24gZ2V0UnVubmVyKHZhbHVlLCBmZWF0dXJlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnByb3ZpZGVyICYmIHR5cGVvZiAodmFsdWUucHJvdmlkZXJbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFByb3ZpZGVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5wcm92aWRlciB8fCBudWxsO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvcHlPdmVycmlkZXMoYXJnLCBhbGxvd2VkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBvdmVycmlkZXMgcGFzc2VkIGluIGFyZSBhIHZhbGlkIG92ZXJyaWRlcyBvYmplY3RcbiAgICBjb25zdCBfb3ZlcnJpZGVzID0gaW5kZXhfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShhcmcsIFwib3ZlcnJpZGVzXCIpO1xuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKF9vdmVycmlkZXMpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgb3ZlcnJpZGVzIHBhcmFtZXRlclwiLCBcIm92ZXJyaWRlc1wiLCBhcmcpO1xuICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSAod2UnbGwgZGVlcC1pZnkgYW55dGhpbmcgbmVlZGVkIGR1cmluZyBub3JtYWxpemluZylcbiAgICBjb25zdCBvdmVycmlkZXMgPSAoMCwgcHJvdmlkZXJfanNfMS5jb3B5UmVxdWVzdCkoX292ZXJyaWRlcyk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKG92ZXJyaWRlcy50byA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwidG9cIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgdG9cIiwgXCJvdmVycmlkZXMudG9cIiwgb3ZlcnJpZGVzLnRvKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkob3ZlcnJpZGVzLmRhdGEgPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcImRhdGFcIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgZGF0YVwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIG92ZXJyaWRlcy5kYXRhKTtcbiAgICAvLyBSZXNvbHZlIGFueSBmcm9tXG4gICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgIG92ZXJyaWRlcy5mcm9tID0gb3ZlcnJpZGVzLmZyb207XG4gICAgfVxuICAgIHJldHVybiBvdmVycmlkZXM7XG59XG5leHBvcnRzLmNvcHlPdmVycmlkZXMgPSBjb3B5T3ZlcnJpZGVzO1xuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBcmdzKF9ydW5uZXIsIGlucHV0cywgYXJncykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoX3J1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gaW5kZXhfanNfMS5UeXBlZC5kZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIucmVzb2x2ZUFkZHJlc3MpKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn1cbmV4cG9ydHMucmVzb2x2ZUFyZ3MgPSByZXNvbHZlQXJncztcbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEZhbGxiYWNrKGNvbnRyYWN0KSB7XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGNvbnN0IHR4ID0gKGF3YWl0IGNvcHlPdmVycmlkZXMob3ZlcnJpZGVzLCBbXCJkYXRhXCJdKSk7XG4gICAgICAgIHR4LnRvID0gYXdhaXQgY29udHJhY3QuZ2V0QWRkcmVzcygpO1xuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgdHguZnJvbSA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKSh0eC5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IGNvbnRyYWN0LmludGVyZmFjZTtcbiAgICAgICAgY29uc3Qgbm9WYWx1ZSA9ICgoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKCh0eC52YWx1ZSB8fCBCTl8wKSwgXCJvdmVycmlkZXMudmFsdWVcIikgPT09IEJOXzApO1xuICAgICAgICBjb25zdCBub0RhdGEgPSAoKHR4LmRhdGEgfHwgXCIweFwiKSA9PT0gXCIweFwiKTtcbiAgICAgICAgaWYgKGlmYWNlLmZhbGxiYWNrICYmICFpZmFjZS5mYWxsYmFjay5wYXlhYmxlICYmIGlmYWNlLnJlY2VpdmUgJiYgIW5vRGF0YSAmJiAhbm9WYWx1ZSkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZSBvciBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzXCIsIG92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IHBheWFibGUgY29udHJhY3RzIHRvIHNldCBub24temVybyB2YWx1ZVxuICAgICAgICBjb25zdCBwYXlhYmxlID0gaWZhY2UucmVjZWl2ZSB8fCAoaWZhY2UuZmFsbGJhY2sgJiYgaWZhY2UuZmFsbGJhY2sucGF5YWJsZSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShwYXlhYmxlIHx8IG5vVmFsdWUsIFwiY2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXMudmFsdWVcIiwgdHgudmFsdWUpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IGZhbGxiYWNrIGNvbnRyYWN0cyB0byBzZXQgbm9uLWVtcHR5IGRhdGFcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNDYWxsRXhjZXB0aW9uKShlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IHdyYXBwZXJzX2pzXzEuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZChvdmVycmlkZXMpO1xuICAgIH07XG4gICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykobWV0aG9kLCB7XG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZE1ldGhvZChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXksIGFyZ3MpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IGF3YWl0IGNvcHlPdmVycmlkZXMoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKShvdmVycmlkZXMuZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvcjogZnJhZ21lbnQgaW5wdXRzIGRvZXNuJ3QgbWF0Y2ggYXJndW1lbnRzOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCByZXNvbHZlQXJncyhjb250cmFjdC5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIGF3YWl0ICgwLCBpbmRleF9qc18zLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICB0bzogY29udHJhY3QuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgZGF0YTogY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKVxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhdGljQ2FsbFJlc3VsdCguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGxSZXN1bHQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNDYWxsRXhjZXB0aW9uKShlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIGlmIChmcmFnbWVudC5jb25zdGFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN0YXRpY0NhbGwoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQoLi4uYXJncyk7XG4gICAgfTtcbiAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKShtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uTmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbCwgc3RhdGljQ2FsbFJlc3VsdCxcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXkpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRXZlbnQoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5LCBhcmdzKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlcGFyZWRUb3BpY0ZpbHRlcihjb250cmFjdCwgZ2V0RnJhZ21lbnQoLi4uYXJncyksIGFyZ3MpO1xuICAgIH07XG4gICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudE5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG4vLyBUaGUgY29tYmluYXRpb24gb2YgVHlwZVNjcnlwZSwgUHJpdmF0ZSBGaWVsZHMgYW5kIFByb3hpZXMgbWFrZXNcbi8vIHRoZSB3b3JsZCBnbyBib29tOyBzbyB3ZSBoaWRlIHZhcmlhYmxlcyB3aXRoIHNvbWUgdHJpY2tlcnkga2VlcGluZ1xuLy8gYSBzeW1ib2wgYXR0YWNoZWQgdG8gZWFjaCBCYXNlQ29udHJhY3Qgd2hpY2ggaXRzIHN1Yi1jbGFzcyAoZXZlblxuLy8gdmlhIGEgUHJveHkpIGNhbiByZWFjaCBhbmQgdXNlIHRvIGxvb2sgdXAgaXRzIGludGVybmFsIHZhbHVlcy5cbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNJbnRlcm5hbF9jb250cmFjdFwiKTtcbmNvbnN0IGludGVybmFsVmFsdWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHNldEludGVybmFsKGNvbnRyYWN0LCB2YWx1ZXMpIHtcbiAgICBpbnRlcm5hbFZhbHVlcy5zZXQoY29udHJhY3RbaW50ZXJuYWxdLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwoY29udHJhY3QpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZXMuZ2V0KGNvbnRyYWN0W2ludGVybmFsXSk7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUb3BpY0ZpbHRlclwiIGluIHZhbHVlKSAmJlxuICAgICAgICAodHlwZW9mICh2YWx1ZS5nZXRUb3BpY0ZpbHRlcikgPT09IFwiZnVuY3Rpb25cIikgJiYgdmFsdWUuZnJhZ21lbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpIHtcbiAgICBsZXQgdG9waWNzO1xuICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgLy8gQ29udmVydCBuYW1lZCBldmVudHMgdG8gdG9waWNIYXNoIGFuZCBnZXQgdGhlIGZyYWdtZW50IGZvclxuICAgIC8vIGV2ZW50cyB3aGljaCBuZWVkIGRlY29uc3RydWN0aW5nLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBjb25zdCB0b3BpY0hhc2hpZnkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc18zLmlzSGV4U3RyaW5nKShuYW1lLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KG5hbWUpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXJyYXkgb2YgVG9waWNzIGFuZCBOYW1lczsgZS5nLiBgWyBcIjB4MTIzNC4uLjg5YWJcIiwgXCJUcmFuc2ZlcihhZGRyZXNzKVwiIF1gXG4gICAgICAgIHRvcGljcyA9IGV2ZW50Lm1hcCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXAodG9waWNIYXNoaWZ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3BpY0hhc2hpZnkoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgdG9waWNzID0gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKGV2ZW50LCAzMikpIHtcbiAgICAgICAgICAgIC8vIFRvcGljIEhhc2hcbiAgICAgICAgICAgIHRvcGljcyA9IFtldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOYW1lIG9yIFNpZ25hdHVyZTsgZS5nLiBgXCJUcmFuc2ZlclwiLCBgXCJUcmFuc2ZlcihhZGRyZXNzKVwiYFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0RlZmVycmVkKGV2ZW50KSkge1xuICAgICAgICAvLyBEZWZlcnJlZCBUb3BpYyBGaWx0ZXI7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2Zlcihmcm9tKWBcbiAgICAgICAgdG9waWNzID0gYXdhaXQgZXZlbnQuZ2V0VG9waWNGaWx0ZXIoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJmcmFnbWVudFwiIGluIGV2ZW50KSB7XG4gICAgICAgIC8vIENvbnRyYWN0RXZlbnQ7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2ZlcmBcbiAgICAgICAgZnJhZ21lbnQgPSBldmVudC5mcmFnbWVudDtcbiAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5rbm93biBldmVudCBuYW1lXCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdG9waWNzIGFuZCBzb3J0IFRvcGljU2V0c1xuICAgIHRvcGljcyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShuZXcgU2V0KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKS52YWx1ZXMoKSk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgY29uc3QgdGFnID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pLmpvaW4oXCImXCIpO1xuICAgIHJldHVybiB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFzU3ViKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIHJldHVybiBzdWJzLmdldCgoYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpKS50YWcpIHx8IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWIoY29udHJhY3QsIG9wZXJhdGlvbiwgZXZlbnQpIHtcbiAgICAvLyBNYWtlIHN1cmUgb3VyIHJ1bm5lciBjYW4gYWN0dWFsbHkgc3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHN1YnNjcmliaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCk7XG4gICAgY29uc3QgeyBhZGRyLCBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgbGV0IHN1YiA9IHN1YnMuZ2V0KHRhZyk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IGNvbnRyYWN0KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmcmFnbWVudCBpcyBudWxsLCB3ZSBkbyBub3QgZGVjb25zdHJ1Y3QgdGhlIGFyZ3MgdG8gZW1pdFxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZm91bmRGcmFnbWVudCA9IGZvdW5kRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGZyYWdtZW50ID8gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykgOiBbXTtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdEV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBfZm91bmRGcmFnbWVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBbXSwgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdFVua25vd25FdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN0YXJ0aW5nID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0aW5nLnB1c2gocHJvdmlkZXIub24oZmlsdGVyLCBsaXN0ZW5lcikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0ZWQgPSBzdGFydGluZztcbiAgICAgICAgICAgIHN0YXJ0aW5nID0gW107XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzdGFydGVkKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLm9mZihmaWx0ZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3ViID0geyB0YWcsIGxpc3RlbmVyczogW10sIHN0YXJ0LCBzdG9wIH07XG4gICAgICAgIHN1YnMuc2V0KHRhZywgc3ViKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Yjtcbn1cbi8vIFdlIHVzZSB0aGlzIHRvIGVuc3VyZSBvbmUgZW1pdCByZXNvbHZlcyBiZWZvcmUgZmlyaW5nIHRoZSBuZXh0IHRvXG4vLyBlbnN1cmUgY29ycmVjdCBvcmRlcmluZyAobm90ZSB0aGlzIGNhbm5vdCB0aHJvdyBhbmQganVzdCBhZGRzIHRoZVxuLy8gbm90aWNlIHRvIHRoZSBldmVudCBxdWV1IHVzaW5nIHNldFRpbWVvdXQpLlxubGV0IGxhc3RFbWl0ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5hc3luYyBmdW5jdGlvbiBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKGNvbnRyYWN0LCBldmVudCk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhc3NBcmdzID0gQXJyYXkuZnJvbShhcmdzKTtcbiAgICAgICAgaWYgKHBheWxvYWRGdW5jKSB7XG4gICAgICAgICAgICBwYXNzQXJncy5wdXNoKHBheWxvYWRGdW5jKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChjb250cmFjdCwgLi4ucGFzc0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiAhb25jZTtcbiAgICB9KTtcbiAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgZ2V0SW50ZXJuYWwoY29udHJhY3QpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgIH1cbiAgICByZXR1cm4gKGNvdW50ID4gMCk7XG59XG5hc3luYyBmdW5jdGlvbiBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICBjb25zdCByZXN1bHRQcm9taXNlID0gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYyk7XG4gICAgbGFzdEVtaXQgPSByZXN1bHRQcm9taXNlO1xuICAgIHJldHVybiBhd2FpdCByZXN1bHRQcm9taXNlO1xufVxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY2xhc3MgQmFzZUNvbnRyYWN0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRhcmdldCB0byBjb25uZWN0IHRvLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIGFuIGFkZHJlc3MsIEVOUyBuYW1lIG9yIGFueSBbW0FkZHJlc3NhYmxlXV0sIHN1Y2ggYXNcbiAgICAgKiAgYW5vdGhlciBjb250cmFjdC4gVG8gZ2V0IHRoZSByZXNvdmxlZCBhZGRyZXNzLCB1c2UgdGhlIGBgZ2V0QWRkcmVzc2BgXG4gICAgICogIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHJ1bm5lci4gVGhpcyBpcyBnZW5lcmFsbHkgYSBbW1Byb3ZpZGVyXV0gb3IgYVxuICAgICAqICBbW1NpZ25lcl1dLCB3aGljaCBkaWN0YXRlcyB3aGF0IG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSAqKkNvbnRyYWN0KiogY29ubmVjdGVkIHRvIGEgW1tQcm92aWRlcl1dIG1heVxuICAgICAqICBvbmx5IGV4ZWN1dGUgcmVhZC1vbmx5IG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIEV2ZW50cyBhdmFpbGFibGUgb24gdGhpcyBjb250cmFjdC5cbiAgICAgKi9cbiAgICBmaWx0ZXJzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBbaW50ZXJuYWxdO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmFsbGJhY2sgb3IgcmVjZWl2ZSBmdW5jdGlvbiBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgY29udHJhY3QgY29ubmVjdGVkIHRvICUldGFyZ2V0JSUgd2l0aCB0aGUgJSVhYmklJSBhbmRcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gYSAlJXJ1bm5lciUlIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBiZWhhbGZcbiAgICAgKiAgb2YuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhYmksIHJ1bm5lciwgX2RlcGxveVR4KSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIgfHwgKDAsIGluZGV4X2pzXzIuaXNBZGRyZXNzYWJsZSkodGFyZ2V0KSwgXCJpbnZhbGlkIHZhbHVlIGZvciBDb250cmFjdCB0YXJnZXRcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gaW5kZXhfanNfMS5JbnRlcmZhY2UuZnJvbShhYmkpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHRhcmdldCwgcnVubmVyLCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IHt9IH0pO1xuICAgICAgICBsZXQgYWRkclByb21pc2U7XG4gICAgICAgIGxldCBhZGRyID0gbnVsbDtcbiAgICAgICAgbGV0IGRlcGxveVR4ID0gbnVsbDtcbiAgICAgICAgaWYgKF9kZXBsb3lUeCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihydW5uZXIpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICAgICAgZGVwbG95VHggPSBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCBfZGVwbG95VHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXJnZXQgYXMgdGhlIGFkZHJlc3NcbiAgICAgICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc18zLmlzSGV4U3RyaW5nKSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYWRkciA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBnZXRSdW5uZXIocnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuUmVzb2x2ZShyZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGluZGV4X2pzXzMubWFrZUVycm9yKShcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IG5hbWUgcmVzb2x1dGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGluZGV4X2pzXzMubWFrZUVycm9yKShcImFuIEVOUyBuYW1lIHVzZWQgZm9yIGEgY29udHJhY3QgdGFyZ2V0IG11c3QgYmUgY29ycmVjdGx5IGNvbmZpZ3VyZWRcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkclByb21pc2UgPSB0YXJnZXQuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG91ciBwcml2YXRlIHZhbHVlc1xuICAgICAgICBzZXRJbnRlcm5hbCh0aGlzLCB7IGFkZHJQcm9taXNlLCBhZGRyLCBkZXBsb3lUeCwgc3VicyB9KTtcbiAgICAgICAgLy8gQWRkIHRoZSBldmVudCBmaWx0ZXJzXG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBpbmRleF9qc18zLmlzRXJyb3IpKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApIHx8IHRoaXMuaW50ZXJmYWNlLmhhc0V2ZW50KFN0cmluZyhwcm9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGZpbHRlcnMgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAoKGlmYWNlLnJlY2VpdmUgfHwgaWZhY2UuZmFsbGJhY2spID8gKGJ1aWxkV3JhcHBlZEZhbGxiYWNrKHRoaXMpKSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gYSBQcm94eSB0aGF0IHdpbGwgcmVzcG9uZCB0byBmdW5jdGlvbnNcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5kZWZpbmVkIHByb3BlcnRpZXMgc2hvdWxkIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEZ1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgaW5kZXhfanNfMy5pc0Vycm9yKShlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5pbnRlcmZhY2UuaGFzRnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgdGFyZ2V0IGFuZCBBQkksIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRoaXMudGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgcnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIEFCSSBhbmQgcnVubmVyLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSV0YXJnZXQlJS5cbiAgICAgKi9cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHRoaXMucnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcmVzb2x2ZWQgYWRkcmVzcyBvZiB0aGlzIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiBhd2FpdCBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyUHJvbWlzZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRlcGxveWVkIGJ5dGVjb2RlIG9yIG51bGwgaWYgbm8gYnl0ZWNvZGUgaXMgZm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95ZWRDb2RlKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShwcm92aWRlciwgXCJydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRDb2RlXCIgfSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoaXMgQ29udHJhY3Qgb25jZSB0aGUgYnl0ZWNvZGUgaGFzIGJlZW4gZGVwbG95ZWQsIG9yXG4gICAgICogIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBkZXBsb3llZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRGVwbG95bWVudCgpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGVwbG95ZW1lbnQgdHJhbnNhY3Rpb247IGp1c3QgdXNlIHRoYXQgKHRocm93cyBpZiBkZXBsb3llbWVudCBmYWlscylcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN1YnNjcmliZSB0byBhIHByb3ZpZGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHByb3ZpZGVyICE9IG51bGwsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIndhaXRGb3JEZXBsb3ltZW50XCIgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja0NvZGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCBjaGVja0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hlY2tDb2RlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0cmFuc2FjdGlvbiB1c2VkIHRvIGRlcGxveSB0aGlzIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaWYgdGhpcyBpbnN0YW5jZSB3YXMgcmV0dXJuZWQgZnJvbSBhXG4gICAgICogIFtbQ29udHJhY3RGYWN0b3J5XV0uXG4gICAgICovXG4gICAgZGVwbG95bWVudFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWwodGhpcykuZGVwbG95VHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBtZXRob2QgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBidWlsZFdyYXBwZWRNZXRob2QodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGV2ZW50IGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBldmVudCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEV2ZW50KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkV3JhcHBlZEV2ZW50KHRoaXMsIGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeVRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qXG4gICAgLy8gQFRPRE86IHRoaXMgaXMgYSBub24tYmFja3dhcmRzIGNvbXBhdGlibGUgY2hhbmdlLCBidXQgd2lsbCBiZSBhZGRlZFxuICAgIC8vICAgICAgICBpbiB2NyBhbmQgaW4gYSBwb3RlbnRpYWwgU21hcnRDb250cmFjdCBjbGFzcyBpbiBhbiB1cGNvbWluZ1xuICAgIC8vICAgICAgICB2NiByZWxlYXNlXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2g6IHN0cmluZyk6IFByb21pc2U8bnVsbCB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0PiB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLFxuICAgICAgICAgICAgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlUcmFuc2FjdGlvblwiIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgcmVjZWlwdCk7XG4gICAgfVxuICAgICovXG4gICAgLyoqXG4gICAgICogIFByb3ZpZGUgaGlzdG9yaWMgYWNjZXNzIHRvIGV2ZW50IGRhdGEgZm9yICUlZXZlbnQlJSBpbiB0aGUgcmFuZ2VcbiAgICAgKiAgJSVmcm9tQmxvY2slJSAoZGVmYXVsdDogYGAwYGApIHRvICUldG9CbG9jayUlIChkZWZhdWx0OiBgYFwibGF0ZXN0XCJgYClcbiAgICAgKiAgaW5jbHVzaXZlLlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2ssIHRvQmxvY2spIHtcbiAgICAgICAgaWYgKGZyb21CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0Jsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWRkciwgYWRkclByb21pc2UgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogKGF3YWl0IGFkZHJQcm9taXNlKSk7XG4gICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyh0aGlzLCBldmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzLCBmcm9tQmxvY2ssIHRvQmxvY2sgfTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeUZpbHRlclwiIH0pO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKSkubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdyYXBwZXJzX2pzXzEuRXZlbnRMb2cobG9nLCB0aGlzLmludGVyZmFjZSwgZm91bmRGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdyYXBwZXJzX2pzXzEuVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLkxvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvblwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJSwgYnV0IHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiAgYWZ0ZXIgaXQgaXMgZmlyZWQgb25jZS5cbiAgICAgKi9cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvbmNlXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVtaXQgYW4gJSVldmVudCUlIGNhbGxpbmcgYWxsIGxpc3RlbmVycyB3aXRoICUlYXJncyUlLlxuICAgICAqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIGFueSBsaXN0ZW5lcnMgd2VyZSBjYWxsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW1pdCh0aGlzLCBldmVudCwgYXJncywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvZiAlJWV2ZW50JSUgb3IgdGhlIHRvdGFsIG51bWJlclxuICAgICAqICBvZiBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byAlJWV2ZW50JSUgb3IgYWxsIGxpc3RlbmVyc1xuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgdGhlICUlbGlzdGVuZXIlJSBmcm9tIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmVcbiAgICAgKiAgYWxsIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGlmXG4gICAgICogIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YWcsIHN0b3AgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHN1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29uXS5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb2ZmXS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQ2xhc3MgZm9yIHRoZSAlJWFiaSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZENsYXNzKGFiaSkge1xuICAgICAgICBjbGFzcyBDdXN0b21Db250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBydW5uZXIgPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoYWRkcmVzcywgYWJpLCBydW5uZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDdXN0b21Db250cmFjdDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQmFzZUNvbnRyYWN0IHdpdGggYSBzcGVjaWZpZWQgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHRhcmdldCwgYWJpLCBydW5uZXIpIHtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IHRoaXModGFyZ2V0LCBhYmksIHJ1bm5lcik7XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VDb250cmFjdCA9IEJhc2VDb250cmFjdDtcbmZ1bmN0aW9uIF9Db250cmFjdEJhc2UoKSB7XG4gICAgcmV0dXJuIEJhc2VDb250cmFjdDtcbn1cbi8qKlxuICogIEEgW1tCYXNlQ29udHJhY3RdXSB3aXRoIG5vIHR5cGUgZ3VhcmRzIG9uIGl0cyBtZXRob2RzIG9yIGV2ZW50cy5cbiAqL1xuY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBfQ29udHJhY3RCYXNlKCkge1xufVxuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/contract/contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/contract/factory.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/contract/factory.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractFactory = void 0;\nconst index_js_1 = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst contract_js_1 = __webpack_require__(/*! ./contract.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/contract.js\");\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */\nclass ContractFactory {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    bytecode;\n    /**\n     *  The ContractRunner to deploy the Contract as.\n     */\n    runner;\n    /**\n     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n     *  optionally connected to %%runner%%.\n     *\n     *  The %%bytecode%% may be the ``bytecode`` property within the\n     *  standard Solidity JSON output.\n     */\n    constructor(abi, bytecode, runner) {\n        const iface = index_js_1.Interface.from(abi);\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n        if (bytecode instanceof Uint8Array) {\n            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n        }\n        else {\n            if (typeof (bytecode) === \"object\") {\n                bytecode = bytecode.object;\n            }\n            if (!bytecode.startsWith(\"0x\")) {\n                bytecode = \"0x\" + bytecode;\n            }\n            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n        }\n        (0, index_js_3.defineProperties)(this, {\n            bytecode, interface: iface, runner: (runner || null)\n        });\n    }\n    attach(target) {\n        return new contract_js_1.BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Resolves to the transaction to deploy the contract, passing %%args%%\n     *  into the constructor.\n     */\n    async getDeployTransaction(...args) {\n        let overrides = {};\n        const fragment = this.interface.deploy;\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await (0, contract_js_1.copyOverrides)(args.pop());\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"incorrect number of arguments to constructor\");\n        }\n        const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);\n        const data = (0, index_js_3.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\n        return Object.assign({}, overrides, { data });\n    }\n    /**\n     *  Resolves to the Contract deployed by passing %%args%% into the\n     *  constructor.\n     *\n     *  This will resolve to the Contract before it has been deployed to the\n     *  network, so the [[BaseContract-waitForDeployment]] should be used before\n     *  sending any transactions to it.\n     */\n    async deploy(...args) {\n        const tx = await this.getDeployTransaction(...args);\n        (0, index_js_3.assert)(this.runner && typeof (this.runner.sendTransaction) === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const sentTx = await this.runner.sendTransaction(tx);\n        const address = (0, index_js_2.getCreateAddress)(sentTx);\n        return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);\n    }\n    /**\n     *  Return a new **ContractFactory** with the same ABI and bytecode,\n     *  but connected to %%runner%%.\n     */\n    connect(runner) {\n        return new ContractFactory(this.interface, this.bytecode, runner);\n    }\n    /**\n     *  Create a new **ContractFactory** from the standard Solidity JSON output.\n     */\n    static fromSolidity(output, runner) {\n        (0, index_js_3.assertArgument)(output != null, \"bad compiler output\", \"output\", output);\n        if (typeof (output) === \"string\") {\n            output = JSON.parse(output);\n        }\n        const abi = output.abi;\n        let bytecode = \"\";\n        if (output.bytecode) {\n            bytecode = output.bytecode;\n        }\n        else if (output.evm && output.evm.bytecode) {\n            bytecode = output.evm.bytecode;\n        }\n        return new this(abi, bytecode, runner);\n    }\n}\nexports.ContractFactory = ContractFactory;\n//# sourceMappingURL=factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC9mYWN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZSxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnRyYWN0L2ZhY3RvcnkuanM/MGFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hYmkvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgY29udHJhY3RfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyYWN0LmpzXCIpO1xuLy8gQSA9IEFyZ3VtZW50cyB0byB0aGUgY29uc3RydWN0b3Jcbi8vIEkgPSBJbnRlcmZhY2Ugb2YgZGVwbG95ZWQgY29udHJhY3RzXG4vKipcbiAqICBBICoqQ29udHJhY3RGYWN0b3J5KiogaXMgdXNlZCB0byBkZXBsb3kgYSBDb250cmFjdCB0byB0aGUgYmxvY2tjaGFpbi5cbiAqL1xuY2xhc3MgQ29udHJhY3RGYWN0b3J5IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBkZXBsb3ltZW50IGJ5dGVjb2RlLiBPZnRlbiBjYWxsZWQgdGhlIGluaXRjb2RlLlxuICAgICAqL1xuICAgIGJ5dGVjb2RlO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3RSdW5uZXIgdG8gZGVwbG95IHRoZSBDb250cmFjdCBhcy5cbiAgICAgKi9cbiAgICBydW5uZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkNvbnRyYWN0RmFjdG9yeSoqIHdpdGggJSVhYmklJSBhbmQgJSVieXRlY29kZSUlLFxuICAgICAqICBvcHRpb25hbGx5IGNvbm5lY3RlZCB0byAlJXJ1bm5lciUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJWJ5dGVjb2RlJSUgbWF5IGJlIHRoZSBgYGJ5dGVjb2RlYGAgcHJvcGVydHkgd2l0aGluIHRoZVxuICAgICAqICBzdGFuZGFyZCBTb2xpZGl0eSBKU09OIG91dHB1dC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhYmksIGJ5dGVjb2RlLCBydW5uZXIpIHtcbiAgICAgICAgY29uc3QgaWZhY2UgPSBpbmRleF9qc18xLkludGVyZmFjZS5mcm9tKGFiaSk7XG4gICAgICAgIC8vIERlcmVmZXJlbmNlIFNvbGlkaXR5IGJ5dGVjb2RlIG9iamVjdHMgYW5kIGFsbG93IGEgbWlzc2luZyBgMHhgLXByZWZpeFxuICAgICAgICBpZiAoYnl0ZWNvZGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBieXRlY29kZSA9ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKCgwLCBpbmRleF9qc18zLmdldEJ5dGVzKShieXRlY29kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYnl0ZWNvZGUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgYnl0ZWNvZGUgPSBieXRlY29kZS5vYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJ5dGVjb2RlLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgICAgIGJ5dGVjb2RlID0gXCIweFwiICsgYnl0ZWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlY29kZSA9ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKCgwLCBpbmRleF9qc18zLmdldEJ5dGVzKShieXRlY29kZSkpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlLCBpbnRlcmZhY2U6IGlmYWNlLCBydW5uZXI6IChydW5uZXIgfHwgbnVsbClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb250cmFjdF9qc18xLkJhc2VDb250cmFjdCh0YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gdG8gZGVwbG95IHRoZSBjb250cmFjdCwgcGFzc2luZyAlJWFyZ3MlJVxuICAgICAqICBpbnRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBsb3lUcmFuc2FjdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5kZXBsb3k7XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IGF3YWl0ICgwLCBjb250cmFjdF9qc18xLmNvcHlPdmVycmlkZXMpKGFyZ3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gY29uc3RydWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgKDAsIGNvbnRyYWN0X2pzXzEucmVzb2x2ZUFyZ3MpKHRoaXMucnVubmVyLCBmcmFnbWVudC5pbnB1dHMsIGFyZ3MpO1xuICAgICAgICBjb25zdCBkYXRhID0gKDAsIGluZGV4X2pzXzMuY29uY2F0KShbdGhpcy5ieXRlY29kZSwgdGhpcy5pbnRlcmZhY2UuZW5jb2RlRGVwbG95KHJlc29sdmVkQXJncyldKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIENvbnRyYWN0IGRlcGxveWVkIGJ5IHBhc3NpbmcgJSVhcmdzJSUgaW50byB0aGVcbiAgICAgKiAgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHJlc29sdmUgdG8gdGhlIENvbnRyYWN0IGJlZm9yZSBpdCBoYXMgYmVlbiBkZXBsb3llZCB0byB0aGVcbiAgICAgKiAgbmV0d29yaywgc28gdGhlIFtbQmFzZUNvbnRyYWN0LXdhaXRGb3JEZXBsb3ltZW50XV0gc2hvdWxkIGJlIHVzZWQgYmVmb3JlXG4gICAgICogIHNlbmRpbmcgYW55IHRyYW5zYWN0aW9ucyB0byBpdC5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3koLi4uYXJncykge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95VHJhbnNhY3Rpb24oLi4uYXJncyk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkodGhpcy5ydW5uZXIgJiYgdHlwZW9mICh0aGlzLnJ1bm5lci5zZW5kVHJhbnNhY3Rpb24pID09PSBcImZ1bmN0aW9uXCIsIFwiZmFjdG9yeSBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlbnRUeCA9IGF3YWl0IHRoaXMucnVubmVyLnNlbmRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW5kZXhfanNfMi5nZXRDcmVhdGVBZGRyZXNzKShzZW50VHgpO1xuICAgICAgICByZXR1cm4gbmV3IGNvbnRyYWN0X2pzXzEuQmFzZUNvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lciwgc2VudFR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyAqKkNvbnRyYWN0RmFjdG9yeSoqIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBieXRlY29kZSxcbiAgICAgKiAgYnV0IGNvbm5lY3RlZCB0byAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RGYWN0b3J5KHRoaXMuaW50ZXJmYWNlLCB0aGlzLmJ5dGVjb2RlLCBydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQ29udHJhY3RGYWN0b3J5KiogZnJvbSB0aGUgc3RhbmRhcmQgU29saWRpdHkgSlNPTiBvdXRwdXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Tb2xpZGl0eShvdXRwdXQsIHJ1bm5lcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkob3V0cHV0ICE9IG51bGwsIFwiYmFkIGNvbXBpbGVyIG91dHB1dFwiLCBcIm91dHB1dFwiLCBvdXRwdXQpO1xuICAgICAgICBpZiAodHlwZW9mIChvdXRwdXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJpID0gb3V0cHV0LmFiaTtcbiAgICAgICAgbGV0IGJ5dGVjb2RlID0gXCJcIjtcbiAgICAgICAgaWYgKG91dHB1dC5ieXRlY29kZSkge1xuICAgICAgICAgICAgYnl0ZWNvZGUgPSBvdXRwdXQuYnl0ZWNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0cHV0LmV2bSAmJiBvdXRwdXQuZXZtLmJ5dGVjb2RlKSB7XG4gICAgICAgICAgICBieXRlY29kZSA9IG91dHB1dC5ldm0uYnl0ZWNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGFiaSwgYnl0ZWNvZGUsIHJ1bm5lcik7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBDb250cmFjdEZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/contract/factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/contract/index.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/contract/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndecodedEventLog = exports.EventLog = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractUnknownEventPayload = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = void 0;\n/**\n *  A **Contract** object is a meta-class (a class whose definition is\n *  defined at runtime), which communicates with a deployed smart contract\n *  on the blockchain and provides a simple JavaScript interface to call\n *  methods, send transaction, query historic logs and listen for its events.\n *\n *  @_section: api/contract:Contracts  [about-contracts]\n */\nvar contract_js_1 = __webpack_require__(/*! ./contract.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/contract.js\");\nObject.defineProperty(exports, \"BaseContract\", ({ enumerable: true, get: function () { return contract_js_1.BaseContract; } }));\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return contract_js_1.Contract; } }));\nvar factory_js_1 = __webpack_require__(/*! ./factory.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/factory.js\");\nObject.defineProperty(exports, \"ContractFactory\", ({ enumerable: true, get: function () { return factory_js_1.ContractFactory; } }));\nvar wrappers_js_1 = __webpack_require__(/*! ./wrappers.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/wrappers.js\");\nObject.defineProperty(exports, \"ContractEventPayload\", ({ enumerable: true, get: function () { return wrappers_js_1.ContractEventPayload; } }));\nObject.defineProperty(exports, \"ContractUnknownEventPayload\", ({ enumerable: true, get: function () { return wrappers_js_1.ContractUnknownEventPayload; } }));\nObject.defineProperty(exports, \"ContractTransactionReceipt\", ({ enumerable: true, get: function () { return wrappers_js_1.ContractTransactionReceipt; } }));\nObject.defineProperty(exports, \"ContractTransactionResponse\", ({ enumerable: true, get: function () { return wrappers_js_1.ContractTransactionResponse; } }));\nObject.defineProperty(exports, \"EventLog\", ({ enumerable: true, get: function () { return wrappers_js_1.EventLog; } }));\nObject.defineProperty(exports, \"UndecodedEventLog\", ({ enumerable: true, get: function () { return wrappers_js_1.UndecodedEventLog; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxnQkFBZ0IsR0FBRyxtQ0FBbUMsR0FBRyxrQ0FBa0MsR0FBRyxtQ0FBbUMsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyxvQkFBb0I7QUFDaFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFlO0FBQzNDLGdEQUErQyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM3SCw0Q0FBMkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDckgsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWM7QUFDekMsbURBQWtELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ2xJLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFlO0FBQzNDLHdEQUF1RCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUM3SSwrREFBOEQsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDM0osOERBQTZELEVBQUUscUNBQXFDLG9EQUFvRCxFQUFDO0FBQ3pKLCtEQUE4RCxFQUFFLHFDQUFxQyxxREFBcUQsRUFBQztBQUMzSiw0Q0FBMkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDckgscURBQW9ELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3ZJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29udHJhY3QvaW5kZXguanM/Yjg3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5kZWNvZGVkRXZlbnRMb2cgPSBleHBvcnRzLkV2ZW50TG9nID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0ID0gZXhwb3J0cy5Db250cmFjdFVua25vd25FdmVudFBheWxvYWQgPSBleHBvcnRzLkNvbnRyYWN0RXZlbnRQYXlsb2FkID0gZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBleHBvcnRzLkNvbnRyYWN0ID0gZXhwb3J0cy5CYXNlQ29udHJhY3QgPSB2b2lkIDA7XG4vKipcbiAqICBBICoqQ29udHJhY3QqKiBvYmplY3QgaXMgYSBtZXRhLWNsYXNzIChhIGNsYXNzIHdob3NlIGRlZmluaXRpb24gaXNcbiAqICBkZWZpbmVkIGF0IHJ1bnRpbWUpLCB3aGljaCBjb21tdW5pY2F0ZXMgd2l0aCBhIGRlcGxveWVkIHNtYXJ0IGNvbnRyYWN0XG4gKiAgb24gdGhlIGJsb2NrY2hhaW4gYW5kIHByb3ZpZGVzIGEgc2ltcGxlIEphdmFTY3JpcHQgaW50ZXJmYWNlIHRvIGNhbGxcbiAqICBtZXRob2RzLCBzZW5kIHRyYW5zYWN0aW9uLCBxdWVyeSBoaXN0b3JpYyBsb2dzIGFuZCBsaXN0ZW4gZm9yIGl0cyBldmVudHMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2NvbnRyYWN0OkNvbnRyYWN0cyAgW2Fib3V0LWNvbnRyYWN0c11cbiAqL1xudmFyIGNvbnRyYWN0X2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmFjdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfanNfMS5CYXNlQ29udHJhY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfanNfMS5Db250cmFjdDsgfSB9KTtcbnZhciBmYWN0b3J5X2pzXzEgPSByZXF1aXJlKFwiLi9mYWN0b3J5LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWN0b3J5X2pzXzEuQ29udHJhY3RGYWN0b3J5OyB9IH0pO1xudmFyIHdyYXBwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi93cmFwcGVycy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0RXZlbnRQYXlsb2FkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkNvbnRyYWN0RXZlbnRQYXlsb2FkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50TG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkV2ZW50TG9nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5kZWNvZGVkRXZlbnRMb2dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdyYXBwZXJzX2pzXzEuVW5kZWNvZGVkRXZlbnRMb2c7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/contract/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/contract/wrappers.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/contract/wrappers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.UndecodedEventLog = exports.EventLog = void 0;\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nclass EventLog extends provider_js_1.Log {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The matching event.\n     */\n    fragment;\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    args;\n    /**\n     * @_ignore:\n     */\n    constructor(log, iface, fragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0, index_js_1.defineProperties)(this, { args, fragment, interface: iface });\n    }\n    /**\n     *  The name of the event.\n     */\n    get eventName() { return this.fragment.name; }\n    /**\n     *  The signature of the event.\n     */\n    get eventSignature() { return this.fragment.format(); }\n}\nexports.EventLog = EventLog;\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nclass UndecodedEventLog extends provider_js_1.Log {\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    error;\n    /**\n     * @_ignore:\n     */\n    constructor(log, error) {\n        super(log, log.provider);\n        (0, index_js_1.defineProperties)(this, { error });\n    }\n}\nexports.UndecodedEventLog = UndecodedEventLog;\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nclass ContractTransactionReceipt extends provider_js_1.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */\n    get logs() {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                }\n                catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\nexports.ContractTransactionReceipt = ContractTransactionReceipt;\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nclass ContractTransactionResponse extends provider_js_1.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(confirms, timeout) {\n        const receipt = await super.wait(confirms, timeout);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\nexports.ContractTransactionResponse = ContractTransactionResponse;\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nclass ContractUnknownEventPayload extends index_js_1.EventPayload {\n    /**\n     *  The log with no matching events.\n     */\n    log;\n    /**\n     *  @_event:\n     */\n    constructor(contract, listener, filter, log) {\n        super(contract, listener, filter);\n        (0, index_js_1.defineProperties)(this, { log });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */\n    async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */\n    async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */\n    async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\nexports.ContractUnknownEventPayload = ContractUnknownEventPayload;\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nclass ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */\n    constructor(contract, listener, filter, fragment, _log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0, index_js_1.defineProperties)(this, { args, fragment });\n    }\n    /**\n     *  The event name.\n     */\n    get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */\n    get eventSignature() {\n        return this.fragment.format();\n    }\n}\nexports.ContractEventPayload = ContractEventPayload;\n//# sourceMappingURL=wrappers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC93cmFwcGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyxtQ0FBbUMsR0FBRyxtQ0FBbUMsR0FBRyxrQ0FBa0MsR0FBRyx5QkFBeUIsR0FBRyxnQkFBZ0I7QUFDNUw7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLGdHQUEwQjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29udHJhY3Qvd3JhcHBlcnMuanM/N2Y4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3RFdmVudFBheWxvYWQgPSBleHBvcnRzLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCA9IGV4cG9ydHMuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuVW5kZWNvZGVkRXZlbnRMb2cgPSBleHBvcnRzLkV2ZW50TG9nID0gdm9pZCAwO1xuLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuY29uc3QgcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuY2xhc3MgRXZlbnRMb2cgZXh0ZW5kcyBwcm92aWRlcl9qc18xLkxvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZXZlbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZXZlbnQgYnkgYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGlmYWNlLCBmcmFnbWVudCkge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBpZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50LCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudE5hbWUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTsgfVxufVxuZXhwb3J0cy5FdmVudExvZyA9IEV2ZW50TG9nO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuY2xhc3MgVW5kZWNvZGVkRXZlbnRMb2cgZXh0ZW5kcyBwcm92aWRlcl9qc18xLkxvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBlcnJvciBlbmNvdW50ZWQgd2hlbiB0cnlpbmcgdG8gZGVjb2RlIHRoZSBsb2cuXG4gICAgICovXG4gICAgZXJyb3I7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBlcnJvcikge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgZXJyb3IgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmRlY29kZWRFdmVudExvZyA9IFVuZGVjb2RlZEV2ZW50TG9nO1xuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxuICogIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gKi9cbmNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IGV4dGVuZHMgcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlY2VpcHQge1xuICAgICNpZmFjZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNpZmFjZSA9IGlmYWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBsb2dzIGZvciBhbnkgW1tMb2ddXSB3aGljaCBoYXMgYSBtYXRjaGluZyBldmVudCBpbiB0aGVcbiAgICAgKiAgQ29udHJhY3QgQUJJLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBsb2cudG9waWNzLmxlbmd0aCA/IHRoaXMuI2lmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRMb2cobG9nLCB0aGlzLiNpZmFjZSwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0ID0gQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ7XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKiogd2lsbCByZXR1cm4gYVxuICogIFtbQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHRdXSB3aGVuIHdhaXRlZCBvbi5cbiAqL1xuY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIGV4dGVuZHMgcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChjb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgc3VwZXIud2FpdChjb25maXJtcywgdGltZW91dCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlO1xuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBkb2VzIG5vdCBtYXRjaCBhbnkgZXZlbnRzIGluIHRoZSBBQkkuXG4gKi9cbmNsYXNzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCBleHRlbmRzIGluZGV4X2pzXzEuRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cbiAgICAgKi9cbiAgICBsb2c7XG4gICAgLyoqXG4gICAgICogIEBfZXZlbnQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbG9nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCA9IENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZDtcbi8qKlxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBpcyBrbm93bi5cbiAqL1xuY2xhc3MgQ29udHJhY3RFdmVudFBheWxvYWQgZXh0ZW5kcyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgZnJhZ21lbnQsIF9sb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIG5ldyBFdmVudExvZyhfbG9nLCBjb250cmFjdC5pbnRlcmZhY2UsIGZyYWdtZW50KSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIHRoaXMubG9nLmRhdGEsIHRoaXMubG9nLnRvcGljcyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYXJncywgZnJhZ21lbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RFdmVudFBheWxvYWQgPSBDb250cmFjdEV2ZW50UGF5bG9hZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/contract/wrappers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/crypto.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/crypto.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = exports.pbkdf2Sync = exports.createHmac = exports.createHash = void 0;\nvar crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nObject.defineProperty(exports, \"createHash\", ({ enumerable: true, get: function () { return crypto_1.createHash; } }));\nObject.defineProperty(exports, \"createHmac\", ({ enumerable: true, get: function () { return crypto_1.createHmac; } }));\nObject.defineProperty(exports, \"pbkdf2Sync\", ({ enumerable: true, get: function () { return crypto_1.pbkdf2Sync; } }));\nObject.defineProperty(exports, \"randomBytes\", ({ enumerable: true, get: function () { return crypto_1.randomBytes; } }));\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQjtBQUNsRixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsOENBQTZDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3BILDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCw4Q0FBNkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDcEgsK0NBQThDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3RIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL2NyeXB0by5qcz81MThiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMucGJrZGYyU3luYyA9IGV4cG9ydHMuY3JlYXRlSG1hYyA9IGV4cG9ydHMuY3JlYXRlSGFzaCA9IHZvaWQgMDtcbnZhciBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVIYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcnlwdG9fMS5jcmVhdGVIYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlSG1hY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3J5cHRvXzEuY3JlYXRlSG1hYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBia2RmMlN5bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyeXB0b18xLnBia2RmMlN5bmM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYW5kb21CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3J5cHRvXzEucmFuZG9tQnl0ZXM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/hmac.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/hmac.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.computeHmac = void 0;\n/**\n *  An **HMAC** enables verification that a given key was used\n *  to authenticate a payload.\n *\n *  See: [[link-wiki-hmac]]\n *\n *  @_subsection: api/crypto:HMAC  [about-hmac]\n */\nconst crypto_js_1 = __webpack_require__(/*! ./crypto.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet locked = false;\nconst _computeHmac = function (algorithm, key, data) {\n    return (0, crypto_js_1.createHmac)(algorithm, key).update(data).digest();\n};\nlet __computeHmac = _computeHmac;\n/**\n *  Return the HMAC for %%data%% using the %%key%% key with the underlying\n *  %%algo%% used for compression.\n *\n *  @example:\n *    key = id(\"some-secret\")\n *\n *    // Compute the HMAC\n *    computeHmac(\"sha256\", key, \"0x1337\")\n *    //_result:\n *\n *    // To compute the HMAC of UTF-8 data, the data must be\n *    // converted to UTF-8 bytes\n *    computeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\n *    //_result:\n *\n */\nfunction computeHmac(algorithm, _key, _data) {\n    const key = (0, index_js_1.getBytes)(_key, \"key\");\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__computeHmac(algorithm, key, data));\n}\nexports.computeHmac = computeHmac;\ncomputeHmac._ = _computeHmac;\ncomputeHmac.lock = function () { locked = true; };\ncomputeHmac.register = function (func) {\n    if (locked) {\n        throw new Error(\"computeHmac is locked\");\n    }\n    __computeHmac = func;\n};\nObject.freeze(computeHmac);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9obWFjLmpzP2UzOGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVIbWFjID0gdm9pZCAwO1xuLyoqXG4gKiAgQW4gKipITUFDKiogZW5hYmxlcyB2ZXJpZmljYXRpb24gdGhhdCBhIGdpdmVuIGtleSB3YXMgdXNlZFxuICogIHRvIGF1dGhlbnRpY2F0ZSBhIHBheWxvYWQuXG4gKlxuICogIFNlZTogW1tsaW5rLXdpa2ktaG1hY11dXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpITUFDICBbYWJvdXQtaG1hY11cbiAqL1xuY29uc3QgY3J5cHRvX2pzXzEgPSByZXF1aXJlKFwiLi9jcnlwdG8uanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2NvbXB1dGVIbWFjID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuICgwLCBjcnlwdG9fanNfMS5jcmVhdGVIbWFjKShhbGdvcml0aG0sIGtleSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmxldCBfX2NvbXB1dGVIbWFjID0gX2NvbXB1dGVIbWFjO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBITUFDIGZvciAlJWRhdGElJSB1c2luZyB0aGUgJSVrZXklJSBrZXkgd2l0aCB0aGUgdW5kZXJseWluZ1xuICogICUlYWxnbyUlIHVzZWQgZm9yIGNvbXByZXNzaW9uLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGtleSA9IGlkKFwic29tZS1zZWNyZXRcIilcbiAqXG4gKiAgICAvLyBDb21wdXRlIHRoZSBITUFDXG4gKiAgICBjb21wdXRlSG1hYyhcInNoYTI1NlwiLCBrZXksIFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVG8gY29tcHV0ZSB0aGUgSE1BQyBvZiBVVEYtOCBkYXRhLCB0aGUgZGF0YSBtdXN0IGJlXG4gKiAgICAvLyBjb252ZXJ0ZWQgdG8gVVRGLTggYnl0ZXNcbiAqICAgIGNvbXB1dGVIbWFjKFwic2hhMjU2XCIsIGtleSwgdG9VdGY4Qnl0ZXMoXCJIZWxsbyBXb3JsZFwiKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVIbWFjKGFsZ29yaXRobSwgX2tleSwgX2RhdGEpIHtcbiAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX2tleSwgXCJrZXlcIik7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShfX2NvbXB1dGVIbWFjKGFsZ29yaXRobSwga2V5LCBkYXRhKSk7XG59XG5leHBvcnRzLmNvbXB1dGVIbWFjID0gY29tcHV0ZUhtYWM7XG5jb21wdXRlSG1hYy5fID0gX2NvbXB1dGVIbWFjO1xuY29tcHV0ZUhtYWMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbmNvbXB1dGVIbWFjLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbXB1dGVIbWFjIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19jb21wdXRlSG1hYyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShjb21wdXRlSG1hYyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A fundamental building block of Ethereum is the underlying\n *  cryptographic primitives.\n *\n *  @_section: api/crypto:Cryptographic Functions   [about-crypto]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lock = exports.Signature = exports.SigningKey = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = void 0;\nnull;\n// We import all these so we can export lock()\nconst hmac_js_1 = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/hmac.js\");\nObject.defineProperty(exports, \"computeHmac\", ({ enumerable: true, get: function () { return hmac_js_1.computeHmac; } }));\nconst keccak_js_1 = __webpack_require__(/*! ./keccak.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/keccak.js\");\nObject.defineProperty(exports, \"keccak256\", ({ enumerable: true, get: function () { return keccak_js_1.keccak256; } }));\nconst ripemd160_js_1 = __webpack_require__(/*! ./ripemd160.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/ripemd160.js\");\nObject.defineProperty(exports, \"ripemd160\", ({ enumerable: true, get: function () { return ripemd160_js_1.ripemd160; } }));\nconst pbkdf2_js_1 = __webpack_require__(/*! ./pbkdf2.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/pbkdf2.js\");\nObject.defineProperty(exports, \"pbkdf2\", ({ enumerable: true, get: function () { return pbkdf2_js_1.pbkdf2; } }));\nconst random_js_1 = __webpack_require__(/*! ./random.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/random.js\");\nObject.defineProperty(exports, \"randomBytes\", ({ enumerable: true, get: function () { return random_js_1.randomBytes; } }));\nconst scrypt_js_1 = __webpack_require__(/*! ./scrypt.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/scrypt.js\");\nObject.defineProperty(exports, \"scrypt\", ({ enumerable: true, get: function () { return scrypt_js_1.scrypt; } }));\nObject.defineProperty(exports, \"scryptSync\", ({ enumerable: true, get: function () { return scrypt_js_1.scryptSync; } }));\nconst sha2_js_1 = __webpack_require__(/*! ./sha2.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/sha2.js\");\nObject.defineProperty(exports, \"sha256\", ({ enumerable: true, get: function () { return sha2_js_1.sha256; } }));\nObject.defineProperty(exports, \"sha512\", ({ enumerable: true, get: function () { return sha2_js_1.sha512; } }));\nvar signing_key_js_1 = __webpack_require__(/*! ./signing-key.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/signing-key.js\");\nObject.defineProperty(exports, \"SigningKey\", ({ enumerable: true, get: function () { return signing_key_js_1.SigningKey; } }));\nvar signature_js_1 = __webpack_require__(/*! ./signature.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/signature.js\");\nObject.defineProperty(exports, \"Signature\", ({ enumerable: true, get: function () { return signature_js_1.Signature; } }));\n/**\n *  Once called, prevents any future change to the underlying cryptographic\n *  primitives using the ``.register`` feature for hooks.\n */\nfunction lock() {\n    hmac_js_1.computeHmac.lock();\n    keccak_js_1.keccak256.lock();\n    pbkdf2_js_1.pbkdf2.lock();\n    random_js_1.randomBytes.lock();\n    ripemd160_js_1.ripemd160.lock();\n    scrypt_js_1.scrypt.lock();\n    scrypt_js_1.scryptSync.lock();\n    sha2_js_1.sha256.lock();\n    sha2_js_1.sha512.lock();\n    random_js_1.randomBytes.lock();\n}\nexports.lock = lock;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDbE87QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFXO0FBQ3JDLCtDQUE4QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN2SCxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsdUJBQXVCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQy9DLDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SCxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QywwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyw4Q0FBNkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDdkgsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVc7QUFDckMsMENBQXlDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQzdHLDBDQUF5QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM3Ryx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDakQsOENBQTZDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzVILHFCQUFxQixtQkFBTyxDQUFDLG9GQUFnQjtBQUM3Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vaW5kZXguanM/N2VhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2sgb2YgRXRoZXJldW0gaXMgdGhlIHVuZGVybHlpbmdcbiAqICBjcnlwdG9ncmFwaGljIHByaW1pdGl2ZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2NyeXB0bzpDcnlwdG9ncmFwaGljIEZ1bmN0aW9ucyAgIFthYm91dC1jcnlwdG9dXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9jayA9IGV4cG9ydHMuU2lnbmF0dXJlID0gZXhwb3J0cy5TaWduaW5nS2V5ID0gZXhwb3J0cy5zY3J5cHRTeW5jID0gZXhwb3J0cy5zY3J5cHQgPSBleHBvcnRzLnBia2RmMiA9IGV4cG9ydHMuc2hhNTEyID0gZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLnJpcGVtZDE2MCA9IGV4cG9ydHMua2VjY2FrMjU2ID0gZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMuY29tcHV0ZUhtYWMgPSB2b2lkIDA7XG5udWxsO1xuLy8gV2UgaW1wb3J0IGFsbCB0aGVzZSBzbyB3ZSBjYW4gZXhwb3J0IGxvY2soKVxuY29uc3QgaG1hY19qc18xID0gcmVxdWlyZShcIi4vaG1hYy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXB1dGVIbWFjXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBobWFjX2pzXzEuY29tcHV0ZUhtYWM7IH0gfSk7XG5jb25zdCBrZWNjYWtfanNfMSA9IHJlcXVpcmUoXCIuL2tlY2Nhay5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImtlY2NhazI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2VjY2FrX2pzXzEua2VjY2FrMjU2OyB9IH0pO1xuY29uc3QgcmlwZW1kMTYwX2pzXzEgPSByZXF1aXJlKFwiLi9yaXBlbWQxNjAuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyaXBlbWQxNjBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJpcGVtZDE2MF9qc18xLnJpcGVtZDE2MDsgfSB9KTtcbmNvbnN0IHBia2RmMl9qc18xID0gcmVxdWlyZShcIi4vcGJrZGYyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGJrZGYyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYmtkZjJfanNfMS5wYmtkZjI7IH0gfSk7XG5jb25zdCByYW5kb21fanNfMSA9IHJlcXVpcmUoXCIuL3JhbmRvbS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJhbmRvbUJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByYW5kb21fanNfMS5yYW5kb21CeXRlczsgfSB9KTtcbmNvbnN0IHNjcnlwdF9qc18xID0gcmVxdWlyZShcIi4vc2NyeXB0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NyeXB0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY3J5cHRfanNfMS5zY3J5cHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY3J5cHRTeW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY3J5cHRfanNfMS5zY3J5cHRTeW5jOyB9IH0pO1xuY29uc3Qgc2hhMl9qc18xID0gcmVxdWlyZShcIi4vc2hhMi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl9qc18xLnNoYTI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTUxMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl9qc18xLnNoYTUxMjsgfSB9KTtcbnZhciBzaWduaW5nX2tleV9qc18xID0gcmVxdWlyZShcIi4vc2lnbmluZy1rZXkuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaWduaW5nS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWduaW5nX2tleV9qc18xLlNpZ25pbmdLZXk7IH0gfSk7XG52YXIgc2lnbmF0dXJlX2pzXzEgPSByZXF1aXJlKFwiLi9zaWduYXR1cmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaWduYXR1cmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hdHVyZV9qc18xLlNpZ25hdHVyZTsgfSB9KTtcbi8qKlxuICogIE9uY2UgY2FsbGVkLCBwcmV2ZW50cyBhbnkgZnV0dXJlIGNoYW5nZSB0byB0aGUgdW5kZXJseWluZyBjcnlwdG9ncmFwaGljXG4gKiAgcHJpbWl0aXZlcyB1c2luZyB0aGUgYGAucmVnaXN0ZXJgYCBmZWF0dXJlIGZvciBob29rcy5cbiAqL1xuZnVuY3Rpb24gbG9jaygpIHtcbiAgICBobWFjX2pzXzEuY29tcHV0ZUhtYWMubG9jaygpO1xuICAgIGtlY2Nha19qc18xLmtlY2NhazI1Ni5sb2NrKCk7XG4gICAgcGJrZGYyX2pzXzEucGJrZGYyLmxvY2soKTtcbiAgICByYW5kb21fanNfMS5yYW5kb21CeXRlcy5sb2NrKCk7XG4gICAgcmlwZW1kMTYwX2pzXzEucmlwZW1kMTYwLmxvY2soKTtcbiAgICBzY3J5cHRfanNfMS5zY3J5cHQubG9jaygpO1xuICAgIHNjcnlwdF9qc18xLnNjcnlwdFN5bmMubG9jaygpO1xuICAgIHNoYTJfanNfMS5zaGEyNTYubG9jaygpO1xuICAgIHNoYTJfanNfMS5zaGE1MTIubG9jaygpO1xuICAgIHJhbmRvbV9qc18xLnJhbmRvbUJ5dGVzLmxvY2soKTtcbn1cbmV4cG9ydHMubG9jayA9IGxvY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/keccak.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/keccak.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keccak256 = void 0;\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/sha3.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet locked = false;\nconst _keccak256 = function (data) {\n    return (0, sha3_1.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nfunction keccak256(_data) {\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__keccak256(data));\n}\nexports.keccak256 = keccak256;\nkeccak256._ = _keccak256;\nkeccak256.lock = function () { locked = true; };\nkeccak256.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256);\n//# sourceMappingURL=keccak.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8va2VjY2FrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsZUFBZSxtQkFBTyxDQUFDLDBGQUFvQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9rZWNjYWsuanM/M2RjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIENyeXB0b2dyYXBoaWMgaGFzaGluZyBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zIFthYm91dC1jcnlwdG8taGFzaGluZ11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5rZWNjYWsyNTYgPSB2b2lkIDA7XG5jb25zdCBzaGEzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9rZWNjYWsyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiAoMCwgc2hhM18xLmtlY2Nha18yNTYpKGRhdGEpO1xufTtcbmxldCBfX2tlY2NhazI1NiA9IF9rZWNjYWsyNTY7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIEtFQ0NBSzI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBUaGUgJSVkYXRhJSUgKiptdXN0KiogYmUgYSBkYXRhIHJlcHJlc2VudGF0aW9uLCB0byBjb21wdXRlIHRoZVxuICogIGhhc2ggb2YgVVRGLTggZGF0YSB1c2UgdGhlIFtbaWRdXSBmdW5jdGlvbi5cbiAqXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICogIEBleGFtcGxlOlxuICogICAga2VjY2FrMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFN0cmluZ3MgYXJlIGFzc3VtZWQgdG8gYmUgRGF0YUhleFN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqICAgIC8vIHRocm93LiBUbyBoYXNoIFVURi04IGRhdGEsIHNlZSB0aGUgbm90ZSBhYm92ZS5cbiAqICAgIGtlY2NhazI1NihcIkhlbGxvIFdvcmxkXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZnVuY3Rpb24ga2VjY2FrMjU2KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShfX2tlY2NhazI1NihkYXRhKSk7XG59XG5leHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1NjtcbmtlY2NhazI1Ni5fID0gX2tlY2NhazI1NjtcbmtlY2NhazI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xua2VjY2FrMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZWNjYWsyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2tlY2NhazI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShrZWNjYWsyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VjY2FrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/pbkdf2.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/pbkdf2.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A **Password-Based Key-Derivation Function** is designed to create\n *  a sequence of bytes suitible as a **key** from a human-rememberable\n *  password.\n *\n *  @_subsection: api/crypto:Passwords  [about-pbkdf]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pbkdf2 = void 0;\nconst crypto_js_1 = __webpack_require__(/*! ./crypto.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet locked = false;\nconst _pbkdf2 = function (password, salt, iterations, keylen, algo) {\n    return (0, crypto_js_1.pbkdf2Sync)(password, salt, iterations, keylen, algo);\n};\nlet __pbkdf2 = _pbkdf2;\n/**\n *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\n *  the %%salt%% and using %%iterations%% of %%algo%%.\n *\n *  This PBKDF is outdated and should not be used in new projects, but is\n *  required to decrypt older files.\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the PBKDF2\n *    pbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n *    //_result:\n */\nfunction pbkdf2(_password, _salt, iterations, keylen, algo) {\n    const password = (0, index_js_1.getBytes)(_password, \"password\");\n    const salt = (0, index_js_1.getBytes)(_salt, \"salt\");\n    return (0, index_js_1.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));\n}\nexports.pbkdf2 = pbkdf2;\npbkdf2._ = _pbkdf2;\npbkdf2.lock = function () { locked = true; };\npbkdf2.register = function (func) {\n    if (locked) {\n        throw new Error(\"pbkdf2 is locked\");\n    }\n    __pbkdf2 = func;\n};\nObject.freeze(pbkdf2);\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcGJrZGYyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9wYmtkZjIuanM/ODU1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgKipQYXNzd29yZC1CYXNlZCBLZXktRGVyaXZhdGlvbiBGdW5jdGlvbioqIGlzIGRlc2lnbmVkIHRvIGNyZWF0ZVxuICogIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3VpdGlibGUgYXMgYSAqKmtleSoqIGZyb20gYSBodW1hbi1yZW1lbWJlcmFibGVcbiAqICBwYXNzd29yZC5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlBhc3N3b3JkcyAgW2Fib3V0LXBia2RmXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBia2RmMiA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b19qc18xID0gcmVxdWlyZShcIi4vY3J5cHRvLmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9wYmtkZjIgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykge1xuICAgIHJldHVybiAoMCwgY3J5cHRvX2pzXzEucGJrZGYyU3luYykocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbyk7XG59O1xubGV0IF9fcGJrZGYyID0gX3Bia2RmMjtcbi8qKlxuICogIFJldHVybiB0aGUgW1tsaW5rLXBia2RmMl1dIGZvciAlJWtleWxlbiUlIGJ5dGVzIGZvciAlJXBhc3N3b3JkJSUgdXNpbmdcbiAqICB0aGUgJSVzYWx0JSUgYW5kIHVzaW5nICUlaXRlcmF0aW9ucyUlIG9mICUlYWxnbyUlLlxuICpcbiAqICBUaGlzIFBCS0RGIGlzIG91dGRhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzLCBidXQgaXNcbiAqICByZXF1aXJlZCB0byBkZWNyeXB0IG9sZGVyIGZpbGVzLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgUEJLREYyXG4gKiAgICBwYmtkZjIocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgMTYsIFwic2hhMjU2XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHBia2RmMihfcGFzc3dvcmQsIF9zYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pIHtcbiAgICBjb25zdCBwYXNzd29yZCA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfcGFzc3dvcmQsIFwicGFzc3dvcmRcIik7XG4gICAgY29uc3Qgc2FsdCA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfc2FsdCwgXCJzYWx0XCIpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShfX3Bia2RmMihwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKSk7XG59XG5leHBvcnRzLnBia2RmMiA9IHBia2RmMjtcbnBia2RmMi5fID0gX3Bia2RmMjtcbnBia2RmMi5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xucGJrZGYyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBia2RmMiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fcGJrZGYyID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHBia2RmMik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/pbkdf2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/random.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/random.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = void 0;\n/**\n *  A **Cryptographically Secure Random Value** is one that has been\n *  generated with additional care take to prevent side-channels\n *  from allowing others to detect it and prevent others from through\n *  coincidence generate the same values.\n *\n *  @_subsection: api/crypto:Random Values  [about-crypto-random]\n */\nconst crypto_js_1 = __webpack_require__(/*! ./crypto.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\");\nlet locked = false;\nconst _randomBytes = function (length) {\n    return new Uint8Array((0, crypto_js_1.randomBytes)(length));\n};\nlet __randomBytes = _randomBytes;\n/**\n *  Return %%length%% bytes of cryptographically secure random data.\n *\n *  @example:\n *    randomBytes(8)\n *    //_result:\n */\nfunction randomBytes(length) {\n    return __randomBytes(length);\n}\nexports.randomBytes = randomBytes;\nrandomBytes._ = _randomBytes;\nrandomBytes.lock = function () { locked = true; };\nrandomBytes.register = function (func) {\n    if (locked) {\n        throw new Error(\"randomBytes is locked\");\n    }\n    __randomBytes = func;\n};\nObject.freeze(randomBytes);\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcmFuZG9tLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcmFuZG9tLmpzP2U5OTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gdm9pZCAwO1xuLyoqXG4gKiAgQSAqKkNyeXB0b2dyYXBoaWNhbGx5IFNlY3VyZSBSYW5kb20gVmFsdWUqKiBpcyBvbmUgdGhhdCBoYXMgYmVlblxuICogIGdlbmVyYXRlZCB3aXRoIGFkZGl0aW9uYWwgY2FyZSB0YWtlIHRvIHByZXZlbnQgc2lkZS1jaGFubmVsc1xuICogIGZyb20gYWxsb3dpbmcgb3RoZXJzIHRvIGRldGVjdCBpdCBhbmQgcHJldmVudCBvdGhlcnMgZnJvbSB0aHJvdWdoXG4gKiAgY29pbmNpZGVuY2UgZ2VuZXJhdGUgdGhlIHNhbWUgdmFsdWVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86UmFuZG9tIFZhbHVlcyAgW2Fib3V0LWNyeXB0by1yYW5kb21dXG4gKi9cbmNvbnN0IGNyeXB0b19qc18xID0gcmVxdWlyZShcIi4vY3J5cHRvLmpzXCIpO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3JhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSgoMCwgY3J5cHRvX2pzXzEucmFuZG9tQnl0ZXMpKGxlbmd0aCkpO1xufTtcbmxldCBfX3JhbmRvbUJ5dGVzID0gX3JhbmRvbUJ5dGVzO1xuLyoqXG4gKiAgUmV0dXJuICUlbGVuZ3RoJSUgYnl0ZXMgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBkYXRhLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJhbmRvbUJ5dGVzKDgpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuICAgIHJldHVybiBfX3JhbmRvbUJ5dGVzKGxlbmd0aCk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG5yYW5kb21CeXRlcy5fID0gX3JhbmRvbUJ5dGVzO1xucmFuZG9tQnl0ZXMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbnJhbmRvbUJ5dGVzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhbmRvbUJ5dGVzIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19yYW5kb21CeXRlcyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShyYW5kb21CeXRlcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/random.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/ripemd160.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/ripemd160.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ripemd160 = void 0;\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/ripemd160.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet locked = false;\nconst _ripemd160 = function (data) {\n    return (0, ripemd160_1.ripemd160)(data);\n};\nlet __ripemd160 = _ripemd160;\n/**\n *  Compute the cryptographic RIPEMD-160 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    ripemd160(\"0x\")\n *    //_result:\n *\n *    ripemd160(\"0x1337\")\n *    //_result:\n *\n *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */\nfunction ripemd160(_data) {\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__ripemd160(data));\n}\nexports.ripemd160 = ripemd160;\nripemd160._ = _ripemd160;\nripemd160.lock = function () { locked = true; };\nripemd160.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"ripemd160 is locked\");\n    }\n    __ripemd160 = func;\n};\nObject.freeze(ripemd160);\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcmlwZW1kMTYwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixvQkFBb0IsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9yaXBlbWQxNjAuanM/MmU3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmlwZW1kMTYwID0gdm9pZCAwO1xuY29uc3QgcmlwZW1kMTYwXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjBcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3JpcGVtZDE2MCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuICgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKGRhdGEpO1xufTtcbmxldCBfX3JpcGVtZDE2MCA9IF9yaXBlbWQxNjA7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFJJUEVNRC0xNjAgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgcmlwZW1kMTYwKFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICByaXBlbWQxNjAoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICByaXBlbWQxNjAobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZnVuY3Rpb24gcmlwZW1kMTYwKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShfX3JpcGVtZDE2MChkYXRhKSk7XG59XG5leHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcbnJpcGVtZDE2MC5fID0gX3JpcGVtZDE2MDtcbnJpcGVtZDE2MC5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xucmlwZW1kMTYwLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyaXBlbWQxNjAgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3JpcGVtZDE2MCA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShyaXBlbWQxNjApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/ripemd160.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/scrypt.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/scrypt.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scryptSync = exports.scrypt = void 0;\nconst scrypt_1 = __webpack_require__(/*! @noble/hashes/scrypt */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/scrypt.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet lockedSync = false, lockedAsync = false;\nconst _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {\n    return await (0, scrypt_1.scryptAsync)(passwd, salt, { N, r, p, dkLen, onProgress });\n};\nconst _scryptSync = function (passwd, salt, N, r, p, dkLen) {\n    return (0, scrypt_1.scrypt)(passwd, salt, { N, r, p, dkLen });\n};\nlet __scryptAsync = _scryptAsync;\nlet __scryptSync = _scryptSync;\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nasync function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {\n    const passwd = (0, index_js_1.getBytes)(_passwd, \"passwd\");\n    const salt = (0, index_js_1.getBytes)(_salt, \"salt\");\n    return (0, index_js_1.hexlify)(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\n}\nexports.scrypt = scrypt;\nscrypt._ = _scryptAsync;\nscrypt.lock = function () { lockedAsync = true; };\nscrypt.register = function (func) {\n    if (lockedAsync) {\n        throw new Error(\"scrypt is locked\");\n    }\n    __scryptAsync = func;\n};\nObject.freeze(scrypt);\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nfunction scryptSync(_passwd, _salt, N, r, p, dkLen) {\n    const passwd = (0, index_js_1.getBytes)(_passwd, \"passwd\");\n    const salt = (0, index_js_1.getBytes)(_salt, \"salt\");\n    return (0, index_js_1.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nexports.scryptSync = scryptSync;\nscryptSync._ = _scryptSync;\nscryptSync.lock = function () { lockedSync = true; };\nscryptSync.register = function (func) {\n    if (lockedSync) {\n        throw new Error(\"scryptSync is locked\");\n    }\n    __scryptSync = func;\n};\nObject.freeze(scryptSync);\n//# sourceMappingURL=scrypt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2NyeXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGNBQWM7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsOEZBQXNCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QztBQUNBO0FBQ0EsMkRBQTJELDRCQUE0QjtBQUN2RjtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9zY3J5cHQuanM/MGVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NyeXB0U3luYyA9IGV4cG9ydHMuc2NyeXB0ID0gdm9pZCAwO1xuY29uc3Qgc2NyeXB0XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zY3J5cHRcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xubGV0IGxvY2tlZFN5bmMgPSBmYWxzZSwgbG9ja2VkQXN5bmMgPSBmYWxzZTtcbmNvbnN0IF9zY3J5cHRBc3luYyA9IGFzeW5jIGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0ICgwLCBzY3J5cHRfMS5zY3J5cHRBc3luYykocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzIH0pO1xufTtcbmNvbnN0IF9zY3J5cHRTeW5jID0gZnVuY3Rpb24gKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pIHtcbiAgICByZXR1cm4gKDAsIHNjcnlwdF8xLnNjcnlwdCkocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuIH0pO1xufTtcbmxldCBfX3NjcnlwdEFzeW5jID0gX3NjcnlwdEFzeW5jO1xubGV0IF9fc2NyeXB0U3luYyA9IF9zY3J5cHRTeW5jO1xuLyoqXG4gKiAgVGhlIFtbbGluay13aWtpLXNjcnlwdF1dIHVzZXMgYSBtZW1vcnkgYW5kIGNwdSBoYXJkIG1ldGhvZCBvZlxuICogIGRlcml2YXRpb24gdG8gaW5jcmVhc2UgdGhlIHJlc291cmNlIGNvc3QgdG8gYnJ1dGUtZm9yY2UgYSBwYXNzd29yZFxuICogIGZvciBhIGdpdmVuIGtleS5cbiAqXG4gKiAgVGhpcyBtZWFucyB0aGlzIGFsZ29yaXRobSBpcyBpbnRlbnRpb25hbGx5IHNsb3csIGFuZCBjYW4gYmUgdHVuZWQgdG9cbiAqICBiZWNvbWUgc2xvd2VyLiBBcyBjb21wdXRhdGlvbiBhbmQgbWVtb3J5IHNwZWVkIGltcHJvdmUgb3ZlciB0aW1lLFxuICogIGluY3JlYXNpbmcgdGhlIGRpZmZpY3VsdHkgbWFpbnRhaW5zIHRoZSBjb3N0IG9mIGFuIGF0dGFja2VyLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaWYgYSB0YXJnZXQgdGltZSBvZiA1IHNlY29uZHMgaXMgdXNlZCwgYSBsZWdpdGltYXRlIHVzZXJcbiAqICB3aGljaCBrbm93cyB0aGVpciBwYXNzd29yZCByZXF1aXJlcyBvbmx5IDUgc2Vjb25kcyB0byB1bmxvY2sgdGhlaXJcbiAqICBhY2NvdW50LiBBIDYgY2hhcmFjdGVyIHBhc3N3b3JkIGhhcyA2OCBiaWxsaW9uIHBvc3NpYmlsaXRpZXMsIHdoaWNoXG4gKiAgd291bGQgcmVxdWlyZSBhbiBhdHRhY2tlciB0byBpbnZlc3Qgb3ZlciAxMCwwMDAgeWVhcnMgb2YgQ1BVIHRpbWUuIFRoaXNcbiAqICBpcyBvZiBjb3Vyc2UgYSBjcnVkZSBleGFtcGxlIChhcyBwYXNzd29yZCBnZW5lcmFsbHkgYXJlbid0IHJhbmRvbSksXG4gKiAgYnV0IGRlbW9uc3RyYXRlcyB0byB2YWx1ZSBvZiBpbXBvc2luZyBsYXJnZSBjb3N0cyB0byBkZWNyeXB0aW9uLlxuICpcbiAqICBGb3IgdGhpcyByZWFzb24sIGlmIGJ1aWxkaW5nIGEgVUkgd2hpY2ggaW52b2x2ZWQgZGVjcnlwdGluZyBvclxuICogIGVuY3J5cHRpbmcgZGF0c2EgdXNpbmcgc2NyeXB0LCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYVxuICogIFtbUHJvZ3Jlc3NDYWxsYmFja11dIChhcyBldmVudCBzaG9ydCBwZXJpb2RzIGNhbiBzZWVtIGxpayBhbiBldGVybml0eVxuICogIGlmIHRoZSBVSSBmcmVlemVzKS4gSW5jbHVkaW5nIHRoZSBwaHJhc2UgLy9cImRlY3J5cHRpbmdcIi8vIGluIHRoZSBVSVxuICogIGNhbiBhbHNvIGhlbHAsIGFzc3VyaW5nIHRoZSB1c2VyIHRoZWlyIHdhaXRpbmcgaXMgZm9yIGEgZ29vZCByZWFzb24uXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlBhc3N3b3Jkc1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgc2NyeXB0XG4gKiAgICBzY3J5cHQocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNjcnlwdChfcGFzc3dkLCBfc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzKSB7XG4gICAgY29uc3QgcGFzc3dkID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9wYXNzd2QsIFwicGFzc3dkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX3NhbHQsIFwic2FsdFwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoYXdhaXQgX19zY3J5cHRBc3luYyhwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcykpO1xufVxuZXhwb3J0cy5zY3J5cHQgPSBzY3J5cHQ7XG5zY3J5cHQuXyA9IF9zY3J5cHRBc3luYztcbnNjcnlwdC5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWRBc3luYyA9IHRydWU7IH07XG5zY3J5cHQucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWRBc3luYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3J5cHQgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NjcnlwdEFzeW5jID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNjcnlwdCk7XG4vKipcbiAqICBQcm92aWRlcyBhIHN5bmNocm9ub3VzIHZhcmlhbnQgb2YgW1tzY3J5cHRdXS5cbiAqXG4gKiAgVGhpcyB3aWxsIGNvbXBsZXRlbHkgbG9jayB1cCBhbmQgZnJlZXplIHRoZSBVSSBpbiBhIGJyb3dzZXIgYW5kIHdpbGxcbiAqICBwcmV2ZW50IGFueSBldmVudCBsb29wIGZyb20gcHJvZ3Jlc3NpbmcuIEZvciB0aGlzIHJlYXNvbiwgaXQgaXNcbiAqICBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmFyaWFudF0oc2NyeXB0KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86UGFzc3dvcmRzXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVGhlIHBhc3N3b3JkIG11c3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLCBhbmQgaXQgaXMgZ2VuZXJhbGx5XG4gKiAgICAvLyBiZXN0IHByYWN0aWNlcyB0byBlbnN1cmUgdGhlIHN0cmluZyBoYXMgYmVlbiBub3JtYWxpemVkLiBNYW55XG4gKiAgICAvLyBmb3JtYXRzIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhlIG5vcm1hbGl6YXRpb24gZm9ybSB0byB1c2UuXG4gKiAgICBwYXNzd29yZCA9IFwiaGVsbG9cIlxuICogICAgcGFzc3dvcmRCeXRlcyA9IHRvVXRmOEJ5dGVzKHBhc3N3b3JkLCBcIk5GS0NcIilcbiAqXG4gKiAgICBzYWx0ID0gaWQoXCJzb21lLXNhbHRcIilcbiAqXG4gKiAgICAvLyBDb21wdXRlIHRoZSBzY3J5cHRcbiAqICAgIHNjcnlwdFN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHNjcnlwdFN5bmMoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XG4gICAgY29uc3QgcGFzc3dkID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9wYXNzd2QsIFwicGFzc3dkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX3NhbHQsIFwic2FsdFwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19zY3J5cHRTeW5jKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pKTtcbn1cbmV4cG9ydHMuc2NyeXB0U3luYyA9IHNjcnlwdFN5bmM7XG5zY3J5cHRTeW5jLl8gPSBfc2NyeXB0U3luYztcbnNjcnlwdFN5bmMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkU3luYyA9IHRydWU7IH07XG5zY3J5cHRTeW5jLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkU3luYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3J5cHRTeW5jIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zY3J5cHRTeW5jID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNjcnlwdFN5bmMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyeXB0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/scrypt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/sha2.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/sha2.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha512 = exports.sha256 = void 0;\nconst crypto_js_1 = __webpack_require__(/*! ./crypto.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst _sha256 = function (data) {\n    return (0, crypto_js_1.createHash)(\"sha256\").update(data).digest();\n};\nconst _sha512 = function (data) {\n    return (0, crypto_js_1.createHash)(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */\nfunction sha256(_data) {\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__sha256(data));\n}\nexports.sha256 = sha256;\nsha256._ = _sha256;\nsha256.lock = function () { locked256 = true; };\nsha256.register = function (func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */\nfunction sha512(_data) {\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__sha512(data));\n}\nexports.sha512 = sha512;\nsha512._ = _sha512;\nsha512.lock = function () { locked512 = true; };\nsha512.register = function (func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256);\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2hhMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL3NoYTIuanM/M2RjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhNTEyID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fanNfMSA9IHJlcXVpcmUoXCIuL2NyeXB0by5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBfc2hhMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gKDAsIGNyeXB0b19qc18xLmNyZWF0ZUhhc2gpKFwic2hhMjU2XCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5jb25zdCBfc2hhNTEyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gKDAsIGNyeXB0b19qc18xLmNyZWF0ZUhhc2gpKFwic2hhNTEyXCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5sZXQgX19zaGEyNTYgPSBfc2hhMjU2O1xubGV0IF9fc2hhNTEyID0gX3NoYTUxMjtcbmxldCBsb2NrZWQyNTYgPSBmYWxzZSwgbG9ja2VkNTEyID0gZmFsc2U7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHNoYTI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmZ1bmN0aW9uIHNoYTI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19zaGEyNTYoZGF0YSkpO1xufVxuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5zaGEyNTYuXyA9IF9zaGEyNTY7XG5zaGEyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkMjU2ID0gdHJ1ZTsgfTtcbnNoYTI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDI1Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGEyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTUxMiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBzaGE1MTIoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHNoYTUxMihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19zaGE1MTIoZGF0YSkpO1xufVxuZXhwb3J0cy5zaGE1MTIgPSBzaGE1MTI7XG5zaGE1MTIuXyA9IF9zaGE1MTI7XG5zaGE1MTIubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkNTEyID0gdHJ1ZTsgfTtcbnNoYTUxMi5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDUxMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGE1MTIgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTUxMiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/signature.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/signature.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Signature = void 0;\nconst index_js_1 = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return (0, index_js_2.zeroPadValue)((0, index_js_2.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nclass Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get r() { return this.#r; }\n    set r(value) {\n        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = (0, index_js_2.hexlify)(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */\n    get s() { return this.#s; }\n    set s(_value) {\n        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = (0, index_js_2.hexlify)(_value);\n        (0, index_js_2.assertArgument)(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n    get v() { return this.#v; }\n    set v(value) {\n        const v = (0, index_js_2.getNumber)(value, \"value\");\n        (0, index_js_2.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get networkV() { return this.#networkV; }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n    get yParity() {\n        return (this.v === 27) ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n    get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0, index_js_2.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0, index_js_2.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n    get compactSerialized() {\n        return (0, index_js_2.concat)([this.r, this.yParityAndS]);\n    }\n    /**\n     *  The serialized representation.\n     */\n    get serialized() {\n        return (0, index_js_2.concat)([this.r, this.s, (this.yParity ? \"0x1c\" : \"0x1b\")]);\n    }\n    /**\n     *  @private\n     */\n    constructor(guard, r, s, v) {\n        (0, index_js_2.assertPrivate)(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n    clone() {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n    toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: ((networkV != null) ? networkV.toString() : null),\n            r: this.r, s: this.s, v: this.v,\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n    static getChainId(v) {\n        const bv = (0, index_js_2.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if ((bv == BN_27) || (bv == BN_28)) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0, index_js_2.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n    static getChainIdV(chainId, v) {\n        return ((0, index_js_2.getBigInt)(chainId) * BN_2) + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n    static getNormalizedV(v) {\n        const bv = (0, index_js_2.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0, index_js_2.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return (bv & BN_1) ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n    static from(sig) {\n        function assertError(check, message) {\n            (0, index_js_2.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, index_js_1.ZeroHash, index_js_1.ZeroHash, 27);\n        }\n        if (typeof (sig) === \"string\") {\n            const bytes = (0, index_js_2.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0, index_js_2.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = (s[0] & 0x80) ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0, index_js_2.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0, index_js_2.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, (0, index_js_2.hexlify)(s), v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = (function (s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0, index_js_2.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0, index_js_2.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0, index_js_2.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        })(sig.s, sig.yParityAndS);\n        assertError(((0, index_js_2.getBytes)(s)[0] & 0x80) == 0, \"non-canonical s\");\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = (function (_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0, index_js_2.getBigInt)(_v);\n                return {\n                    networkV: ((v >= BN_35) ? v : undefined),\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0, index_js_2.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return { v: (((0, index_js_2.getBytes)(yParityAndS)[0] & 0x80) ? 28 : 27) };\n            }\n            if (yParity != null) {\n                switch ((0, index_js_2.getNumber)(yParity, \"sig.yParity\")) {\n                    case 0: return { v: 27 };\n                    case 1: return { v: 28 };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        })(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0, index_js_2.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n}\nexports.Signature = Signature;\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixtQkFBbUIsbUJBQU8sQ0FBQywwRkFBdUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxPQUFPLFNBQVMsT0FBTyxjQUFjLGFBQWEsY0FBYyxnQkFBZ0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQjtBQUNsQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9zaWduYXR1cmUuanM/MjgxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2lnbmF0dXJlID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLy8gQ29uc3RhbnRzXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHRvVWludDI1Nih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi56ZXJvUGFkVmFsdWUpKCgwLCBpbmRleF9qc18yLnRvQmVBcnJheSkodmFsdWUpLCAzMik7XG59XG4vKipcbiAqICBBIFNpZ25hdHVyZSAgQFRPRE9cbiAqXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlNpZ25pbmdcbiAqL1xuY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAjcjtcbiAgICAjcztcbiAgICAjdjtcbiAgICAjbmV0d29ya1Y7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHJgYCB2YWx1ZSBmb3IgYSBzaWduYXV0cmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyByZXByZXNlbnRzIHRoZSBgYHhgYCBjb29yZGluYXRlIG9mIGEgXCJyZWZlcmVuY2VcIiBvclxuICAgICAqICBjaGFsbGVuZ2UgcG9pbnQsIGZyb20gd2hpY2ggdGhlIGBgeWBgIGNhbiBiZSBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBnZXQgcigpIHsgcmV0dXJuIHRoaXMuI3I7IH1cbiAgICBzZXQgcih2YWx1ZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzIuZGF0YUxlbmd0aCkodmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHJcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3IgPSAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGBzYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBzKCkgeyByZXR1cm4gdGhpcy4jczsgfVxuICAgIHNldCBzKF92YWx1ZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzIuZGF0YUxlbmd0aCkoX3ZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCBzXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShfdmFsdWUpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkocGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDAsIDMpKSA8IDgsIFwibm9uLWNhbm9uaWNhbCBzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiNzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGEgZ2l2ZW4gYGB4YGAgdmFsdWUgZm9yIGBgcmBgIGhhcyB0d28gcG9zc2libGUgdmFsdWVzIGZvclxuICAgICAqICBpdHMgY29ycmVzcG9uZGluIGBgeWBgLCB0aGUgYGB2YGAgaW5kaWNhdGVzIHdoaWNoIG9mIHRoZSB0d28gYGB5YGBcbiAgICAgKiAgdmFsdWVzIHRvIHVzZS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBub3JtYWxpemVkIHRvIHRoZSB2YWx1ZXMgYGAyN2BgIG9yIGBgMjhgYCBmb3IgbGVnYWN5XG4gICAgICogIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGdldCB2KCkgeyByZXR1cm4gdGhpcy4jdjsgfVxuICAgIHNldCB2KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHYgPSAoMCwgaW5kZXhfanNfMi5nZXROdW1iZXIpKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodiA9PT0gMjcgfHwgdiA9PT0gMjgsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEVJUC0xNTUgYGB2YGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbmV0d29ya1YoKSB7IHJldHVybiB0aGlzLiNuZXR3b3JrVjsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgZm9yIEVJUC0xNTUgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBsZWdhY3lDaGFpbklkKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5nZXRDaGFpbklkKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgeVBhcml0eWBgIGZvciB0aGUgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNlZSBgYHZgYCBmb3IgbW9yZSBkZXRhaWxzIG9uIGhvdyB0aGlzIHZhbHVlIGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52ID09PSAyNykgPyAwIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgYHlQYXJpdHlgYFxuICAgICAqICBhbmQgYGBzYGAgY29tcGFjdGVkIGludG8gYSBzaW5nbGUgYGBieXRlczMyYGAuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHlBbmRTKCkge1xuICAgICAgICAvLyBUaGUgRUlQLTIwOTggY29tcGFjdCByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCB5UGFyaXR5QW5kUyA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKSh0aGlzLnMpO1xuICAgICAgICBpZiAodGhpcy55UGFyaXR5KSB7XG4gICAgICAgICAgICB5UGFyaXR5QW5kU1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KSh5UGFyaXR5QW5kUyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgY29tcGFjdFNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5jb25jYXQpKFt0aGlzLnIsIHRoaXMueVBhcml0eUFuZFNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuY29uY2F0KShbdGhpcy5yLCB0aGlzLnMsICh0aGlzLnlQYXJpdHkgPyBcIjB4MWNcIiA6IFwiMHgxYlwiKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgciwgcywgdikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIlNpZ25hdHVyZVwiKTtcbiAgICAgICAgdGhpcy4jciA9IHI7XG4gICAgICAgIHRoaXMuI3MgPSBzO1xuICAgICAgICB0aGlzLiN2ID0gdjtcbiAgICAgICAgdGhpcy4jbmV0d29ya1YgPSBudWxsO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiBgU2lnbmF0dXJlIHsgcjogXCIke3RoaXMucn1cIiwgczogXCIke3RoaXMuc31cIiwgeVBhcml0eTogJHt0aGlzLnlQYXJpdHl9LCBuZXR3b3JrVjogJHt0aGlzLm5ldHdvcmtWfSB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgaWRlbnRpY2FsIFtbU2lnbmF0dXJlXV0uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHRoaXMuciwgdGhpcy5zLCB0aGlzLnYpO1xuICAgICAgICBpZiAodGhpcy5uZXR3b3JrVikge1xuICAgICAgICAgICAgY2xvbmUuI25ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggYGBKU09OLnN0cmluZ2lmeWBgLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwic2lnbmF0dXJlXCIsXG4gICAgICAgICAgICBuZXR3b3JrVjogKChuZXR3b3JrViAhPSBudWxsKSA/IG5ldHdvcmtWLnRvU3RyaW5nKCkgOiBudWxsKSxcbiAgICAgICAgICAgIHI6IHRoaXMuciwgczogdGhpcy5zLCB2OiB0aGlzLnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBjaGFpbiBJRCBmcm9tIHRoZSBgYHZgYCBpbiBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWQodikge1xuICAgICAgICBjb25zdCBidiA9ICgwLCBpbmRleF9qc18yLmdldEJpZ0ludCkodiwgXCJ2XCIpO1xuICAgICAgICAvLyBUaGUgdiBpcyBub3QgYW4gRUlQLTE1NSB2LCBzbyBpdCBpcyB0aGUgdW5zcGVjaWZpZWQgY2hhaW4gSURcbiAgICAgICAgaWYgKChidiA9PSBCTl8yNykgfHwgKGJ2ID09IEJOXzI4KSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFkIHZhbHVlIGZvciBhbiBFSVAtMTU1IHZcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGJ2ID49IEJOXzM1LCBcImludmFsaWQgRUlQLTE1NSB2XCIsIFwidlwiLCB2KTtcbiAgICAgICAgcmV0dXJuIChidiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBgYHZgYCBmb3IgYSBjaGFpbiBJRCBmb3IgYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgTGVnYWN5IHRyYW5zYWN0aW9ucyB3aGljaCB1c2UgW1tsaW5rLWVpcC0xNTVdXSBoaWphY2sgdGhlIGBgdmBgXG4gICAgICogIHByb3BlcnR5IHRvIGluY2x1ZGUgdGhlIGNoYWluIElELlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjgpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWRWKGNoYWluSWQsIHYpIHtcbiAgICAgICAgcmV0dXJuICgoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKGNoYWluSWQpICogQk5fMikgKyBCaWdJbnQoMzUgKyB2IC0gMjcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgbm9ybWFsaXplZCBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgZnJvbSBhIGBgeVBhcmlydHlgYCxcbiAgICAgKiAgYSBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgb3IgYSBsZWdhY3kgW1tsaW5rLWVpcC0xNTVdXSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICAvLyBUaGUgdmFsdWVzIDAgYW5kIDEgaW1wbHkgdiBpcyBhY3R1YWxseSB5UGFyaXR5XG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDApXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gTGVnYWN5IG5vbi1FSVAtMTU1OSB0cmFuc2FjdGlvbiAoaS5lLiAyNyBvciAyOClcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMjcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gTGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb24gKGkuZS4gPj0gMzUpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIEludmFsaWQgdmFsdWVzIHRocm93XG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDUpXG4gICAgICogICAgLy9fZXJyb3I6XG4gICAgICovXG4gICAgc3RhdGljIGdldE5vcm1hbGl6ZWRWKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKHYpO1xuICAgICAgICBpZiAoYnYgPT09IEJOXzAgfHwgYnYgPT09IEJOXzI3KSB7XG4gICAgICAgICAgICByZXR1cm4gMjc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ2ID09PSBCTl8xIHx8IGJ2ID09PSBCTl8yOCkge1xuICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShidiA+PSBCTl8zNSwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICAvLyBPdGhlcndpc2UsIEVJUC0xNTUgdiBtZWFucyBvZGQgaXMgMjcgYW5kIGV2ZW4gaXMgMjhcbiAgICAgICAgcmV0dXJuIChidiAmIEJOXzEpID8gMjcgOiAyODtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tTaWduYXR1cmVdXS5cbiAgICAgKlxuICAgICAqICBJZiBubyAlJXNpZyUlIGlzIHByb3ZpZGVkLCBhIG5ldyBbW1NpZ25hdHVyZV1dIGlzIGNyZWF0ZWRcbiAgICAgKiAgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJXNpZyUlIGlzIGEgc3RyaW5nLCBpdCBpcyBwYXJzZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc2lnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEVycm9yKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoY2hlY2ssIG1lc3NhZ2UsIFwic2lnbmF0dXJlXCIsIHNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoc2lnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgaW5kZXhfanNfMS5aZXJvSGFzaCwgaW5kZXhfanNfMS5aZXJvSGFzaCwgMjcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKHNpZywgXCJzaWduYXR1cmVcIik7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zbGljZSgzMiwgNjQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAoc1swXSAmIDB4ODApID8gMjggOiAyNztcbiAgICAgICAgICAgICAgICBzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zbGljZSgzMiwgNjQpO1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKChzWzBdICYgMHg4MCkgPT09IDAsIFwibm9uLWNhbm9uaWNhbCBzXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoYnl0ZXNbNjRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsICgwLCBpbmRleF9qc18yLmhleGxpZnkpKHMpLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgcmF3IHNpZ25hdHVyZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZyBpbnN0YW5jZW9mIFNpZ25hdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZy5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByXG4gICAgICAgIGNvbnN0IF9yID0gc2lnLnI7XG4gICAgICAgIGFzc2VydEVycm9yKF9yICE9IG51bGwsIFwibWlzc2luZyByXCIpO1xuICAgICAgICBjb25zdCByID0gdG9VaW50MjU2KF9yKTtcbiAgICAgICAgLy8gR2V0IHM7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCBzID0gKGZ1bmN0aW9uIChzLCB5UGFyaXR5QW5kUykge1xuICAgICAgICAgICAgaWYgKHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1VpbnQyNTYocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eUFuZFMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKCgwLCBpbmRleF9qc18yLmlzSGV4U3RyaW5nKSh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykoeVBhcml0eUFuZFMpO1xuICAgICAgICAgICAgICAgIGJ5dGVzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmhleGxpZnkpKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3Npbmcgc1wiKTtcbiAgICAgICAgfSkoc2lnLnMsIHNpZy55UGFyaXR5QW5kUyk7XG4gICAgICAgIGFzc2VydEVycm9yKCgoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykocylbMF0gJiAweDgwKSA9PSAwLCBcIm5vbi1jYW5vbmljYWwgc1wiKTtcbiAgICAgICAgLy8gR2V0IHY7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCB7IG5ldHdvcmtWLCB2IH0gPSAoZnVuY3Rpb24gKF92LCB5UGFyaXR5QW5kUywgeVBhcml0eSkge1xuICAgICAgICAgICAgaWYgKF92ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KShfdik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Y6ICgodiA+PSBCTl8zNSkgPyB2IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgdjogU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKHYpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoKDAsIGluZGV4X2pzXzIuaXNIZXhTdHJpbmcpKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2OiAoKCgwLCBpbmRleF9qc18yLmdldEJ5dGVzKSh5UGFyaXR5QW5kUylbMF0gJiAweDgwKSA/IDI4IDogMjcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICgoMCwgaW5kZXhfanNfMi5nZXROdW1iZXIpKHlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4geyB2OiAyNyB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB7IHY6IDI4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3NpbmcgdlwiKTtcbiAgICAgICAgfSkoc2lnLnYsIHNpZy55UGFyaXR5QW5kUywgc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XG4gICAgICAgIGlmIChuZXR3b3JrVikge1xuICAgICAgICAgICAgcmVzdWx0LiNuZXR3b3JrViA9IG5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG11bHRpcGxlIG9mIHYsIHlQYXJpdHksIHlQYXJpdHlBbmRTIHdlIGdpdmVuLCBjaGVjayB0aGV5IG1hdGNoXG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5ID09IG51bGwgfHwgKDAsIGluZGV4X2pzXzIuZ2V0TnVtYmVyKShzaWcueVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSA9PT0gcmVzdWx0LnlQYXJpdHksIFwieVBhcml0eSBtaXNtYXRjaFwiKTtcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHlBbmRTID09IG51bGwgfHwgc2lnLnlQYXJpdHlBbmRTID09PSByZXN1bHQueVBhcml0eUFuZFMsIFwieVBhcml0eUFuZFMgbWlzbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5TaWduYXR1cmUgPSBTaWduYXR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/crypto/signing-key.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/signing-key.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SigningKey = void 0;\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst signature_js_1 = __webpack_require__(/*! ./signature.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/signature.js\");\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */\nclass SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey) {\n        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = (0, index_js_1.hexlify)(privateKey);\n    }\n    /**\n     *  The private key.\n     */\n    get privateKey() { return this.#privateKey; }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */\n    get publicKey() { return SigningKey.computePublicKey(this.#privateKey); }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */\n    get compressedPublicKey() { return SigningKey.computePublicKey(this.#privateKey, true); }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */\n    sign(digest) {\n        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = secp256k1_1.secp256k1.sign((0, index_js_1.getBytesCopy)(digest), (0, index_js_1.getBytesCopy)(this.#privateKey), {\n            lowS: true\n        });\n        return signature_js_1.Signature.from({\n            r: (0, index_js_1.toBeHex)(sig.r, 32),\n            s: (0, index_js_1.toBeHex)(sig.s, 32),\n            v: (sig.recovery ? 0x1c : 0x1b)\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */\n    computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0, index_js_1.hexlify)(secp256k1_1.secp256k1.getSharedSecret((0, index_js_1.getBytesCopy)(this.#privateKey), (0, index_js_1.getBytes)(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */\n    static computePublicKey(key, compressed) {\n        let bytes = (0, index_js_1.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = secp256k1_1.secp256k1.getPublicKey(bytes, !!compressed);\n            return (0, index_js_1.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(bytes);\n        return (0, index_js_1.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */\n    static recoverPublicKey(digest, signature) {\n        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = signature_js_1.Signature.from(signature);\n        let secpSig = secp256k1_1.secp256k1.Signature.fromCompact((0, index_js_1.getBytesCopy)((0, index_js_1.concat)([sig.r, sig.s])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey((0, index_js_1.getBytesCopy)(digest));\n        (0, index_js_1.assertArgument)(pubKey != null, \"invalid signautre for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */\n    static addPoints(p0, p1, compressed) {\n        const pub0 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n}\nexports.SigningKey = SigningKey;\n//# sourceMappingURL=signing-key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2lnbmluZy1rZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBeUI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9zaWduaW5nLWtleS5qcz81MDdmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQWRkIGRldGFpbHMgYWJvdXQgc2lnbmluZyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86U2lnbmluZyAgW2Fib3V0LXNpZ25pbmddXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2lnbmluZ0tleSA9IHZvaWQgMDtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHNpZ25hdHVyZV9qc18xID0gcmVxdWlyZShcIi4vc2lnbmF0dXJlLmpzXCIpO1xuLyoqXG4gKiAgQSAqKlNpZ25pbmdLZXkqKiBwcm92aWRlcyBoaWdoLWxldmVsIGFjY2VzcyB0byB0aGUgZWxsaXB0aWMgY3VydmVcbiAqICBjcnlwdG9ncmFwaHkgKEVDQykgb3BlcmF0aW9ucyBhbmQga2V5IG1hbmFnZW1lbnQuXG4gKi9cbmNsYXNzIFNpZ25pbmdLZXkge1xuICAgICNwcml2YXRlS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqU2lnbmluZ0tleSoqIGZvciAlJXByaXZhdGVLZXklJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMS5kYXRhTGVuZ3RoKShwcml2YXRlS2V5KSA9PT0gMzIsIFwiaW52YWxpZCBwcml2YXRlIGtleVwiLCBcInByaXZhdGVLZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICB0aGlzLiNwcml2YXRlS2V5ID0gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkocHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLiNwcml2YXRlS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgMHgwNGBgIGFuZCBiZSAxMzJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAxMzAgaGV4YWRlY2ltYWwgbmliYmxlcykuXG4gICAgICovXG4gICAgZ2V0IHB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5KTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCBlaXRoZXIgdGhlIHByZWZpeCBgYDB4MDJgYCBvciBgYDB4MDNgYFxuICAgICAqICBhbmQgYmUgNjggY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMzMgaGV4YWRlY2ltYWxcbiAgICAgKiAgbmliYmxlcylcbiAgICAgKi9cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5LCB0cnVlKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkICUlZGlnZXN0JSUuXG4gICAgICovXG4gICAgc2lnbihkaWdlc3QpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18xLmRhdGFMZW5ndGgpKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBzaWcgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuc2lnbigoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKGRpZ2VzdCksICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodGhpcy4jcHJpdmF0ZUtleSksIHtcbiAgICAgICAgICAgIGxvd1M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmVfanNfMS5TaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiAoMCwgaW5kZXhfanNfMS50b0JlSGV4KShzaWcuciwgMzIpLFxuICAgICAgICAgICAgczogKDAsIGluZGV4X2pzXzEudG9CZUhleCkoc2lnLnMsIDMyKSxcbiAgICAgICAgICAgIHY6IChzaWcucmVjb3ZlcnkgPyAweDFjIDogMHgxYilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBbW2xpbmstd2lraS1lY2RoXV0gc2hhcmVkIHNlY3JldCBiZXR3ZWVuIHRoaXNcbiAgICAgKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSAlJW90aGVyJSUga2V5LlxuICAgICAqXG4gICAgICogIFRoZSAlJW90aGVyJSUga2V5IG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksXG4gICAgICogIGEgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHViaWMga2V5IG9yIGFwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBCZXN0IHByYWN0aWNlIGlzIHVzdWFsbHkgdG8gdXNlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIG9uIHRoZVxuICAgICAqICByZXR1cm5lZCB2YWx1ZSBiZWZvcmUgdXNpbmcgaXQgYXMgYSBzeW1ldHJpYyBzZWNyZXQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbjEgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTFcIikpXG4gICAgICogICAgc2lnbjIgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTJcIikpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhhdCBwcml2QS5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkIpLi4uXG4gICAgICogICAgc2lnbjEuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMi5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gcHJpdkIuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJBKS5cbiAgICAgKiAgICBzaWduMi5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24xLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcikge1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkob3RoZXIpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoc2VjcDI1NmsxXzEuc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldCgoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKHRoaXMuI3ByaXZhdGVLZXkpLCAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykocHViS2V5KSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yICUla2V5JSUsIG9wdGlvbmFsbHkgJSVjb21wcmVzc2VkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUla2V5JSUgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSwgYVxuICAgICAqICBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24gPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKTtcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5LCB0cnVlKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCBmYWxzZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgQ29tcHJlc3NlZCBhIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIHRydWUpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKGtleSwgXCJrZXlcIik7XG4gICAgICAgIC8vIHByaXZhdGUga2V5XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuZ2V0UHVibGljS2V5KGJ5dGVzLCAhIWNvbXByZXNzZWQpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmhleGxpZnkpKHB1YktleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmF3IHB1YmxpYyBrZXk7IHVzZSB1bmNvbXByZXNzZWQga2V5IHdpdGggMHgwNCBwcmVmaXhcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YiA9IG5ldyBVaW50OEFycmF5KDY1KTtcbiAgICAgICAgICAgIHB1YlswXSA9IDB4MDQ7XG4gICAgICAgICAgICBwdWIuc2V0KGJ5dGVzLCAxKTtcbiAgICAgICAgICAgIGJ5dGVzID0gcHViO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmhleGxpZnkpKHBvaW50LnRvUmF3Qnl0ZXMoY29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcHVibGljIGtleSBmb3IgdGhlIHByaXZhdGUga2V5IHdoaWNoIHByb2R1Y2VkIHRoZVxuICAgICAqICAlJXNpZ25hdHVyZSUlIGZvciB0aGUgZ2l2ZW4gJSVkaWdlc3QlJS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBrZXkgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKVxuICAgICAqICAgIGRpZ2VzdCA9IGlkKFwiaGVsbG8gd29ybGRcIilcbiAgICAgKiAgICBzaWcgPSBrZXkuc2lnbihkaWdlc3QpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhlIHNpZ25lciBwdWJsaWMga2V5Li4uXG4gICAgICogICAga2V5LnB1YmxpY0tleVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHRoZSByZWNvdmVyZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzEuZGF0YUxlbmd0aCkoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNpZ25hdHVyZV9qc18xLlNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSk7XG4gICAgICAgIGxldCBzZWNwU2lnID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tQ29tcGFjdCgoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKCgwLCBpbmRleF9qc18xLmNvbmNhdCkoW3NpZy5yLCBzaWcuc10pKSk7XG4gICAgICAgIHNlY3BTaWcgPSBzZWNwU2lnLmFkZFJlY292ZXJ5Qml0KHNpZy55UGFyaXR5KTtcbiAgICAgICAgY29uc3QgcHViS2V5ID0gc2VjcFNpZy5yZWNvdmVyUHVibGljS2V5KCgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoZGlnZXN0KSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShwdWJLZXkgIT0gbnVsbCwgXCJpbnZhbGlkIHNpZ25hdXRyZSBmb3IgZGlnZXN0XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWJLZXkudG9IZXgoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcG9pbnQgcmVzdWx0aW5nIGZyb20gYWRkaW5nIHRoZSBlbGxpcGljIGN1cnZlIHBvaW50c1xuICAgICAqICAlJXAwJSUgYW5kICUlcDElJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBhIGNvbW1vbiBmdW5jdGlvbiBtb3N0IGRldmVsb3BlcnMgc2hvdWxkIHJlcXVpcmUsIGJ1dFxuICAgICAqICBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIHByaXZhY3ktc3BlY2lmaWMgdGVjaG5pcXVlcy5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBbW0hETm9kZVdhbGxldF1dIHRvIGNvbXB1dGUgY2hpbGRcbiAgICAgKiAgYWRkcmVzc2VzIGZyb20gcGFyZW50IHB1YmxpYyBrZXlzIGFuZCBjaGFpbiBjb2Rlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUG9pbnRzKHAwLCBwMSwgY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBwdWIwID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMCkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgY29uc3QgcHViMSA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDEpLnN1YnN0cmluZygyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWIwLmFkZChwdWIxKS50b0hleCghIWNvbXByZXNzZWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2lnbmluZ0tleSA9IFNpZ25pbmdLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduaW5nLWtleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/crypto/signing-key.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/ethers.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/ethers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/////////////////////////////\n//\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = exports.UndecodedEventLog = exports.EventLog = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.MessagePrefix = exports.EtherSymbol = exports.ZeroHash = exports.N = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.ZeroAddress = exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = exports.Typed = exports.TransactionDescription = exports.Result = exports.LogDescription = exports.Interface = exports.Indexed = exports.ErrorDescription = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.FallbackFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.AbiCoder = exports.encodeBytes32String = exports.decodeBytes32String = exports.version = void 0;\nexports.EtherscanPlugin = exports.EnsPlugin = exports.Network = exports.EnsResolver = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.AbstractProvider = exports.VoidSigner = exports.NonceManager = exports.AbstractSigner = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.getDefaultProvider = exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = exports.SigningKey = exports.Signature = exports.lock = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = void 0;\nexports.toBeArray = exports.getUint = exports.getNumber = exports.getBigInt = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.isError = exports.isCallException = exports.makeError = exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.resolveProperties = exports.defineProperties = exports.zeroPadValue = exports.zeroPadBytes = exports.stripZerosLeft = exports.isBytesLike = exports.isHexString = exports.hexlify = exports.getBytesCopy = exports.getBytes = exports.dataSlice = exports.dataLength = exports.concat = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = exports.showThrottleMessage = exports.copyRequest = exports.UnmanagedSubscriber = exports.SocketSubscriber = exports.SocketPendingSubscriber = exports.SocketEventSubscriber = exports.SocketBlockSubscriber = exports.MulticoinProviderPlugin = exports.NetworkPlugin = exports.GasCostPlugin = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = void 0;\nexports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.decryptCrowdsaleJson = exports.isKeystoreJson = exports.isCrowdsaleJson = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.Wallet = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.BaseWallet = exports.Mnemonic = exports.uuidV4 = exports.encodeRlp = exports.decodeRlp = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.mask = exports.toTwos = exports.fromTwos = exports.toQuantity = exports.toNumber = exports.toBeHex = exports.toBigInt = void 0;\nvar _version_js_1 = __webpack_require__(/*! ./_version.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/_version.js\");\nObject.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return _version_js_1.version; } }));\nvar index_js_1 = __webpack_require__(/*! ./abi/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nObject.defineProperty(exports, \"decodeBytes32String\", ({ enumerable: true, get: function () { return index_js_1.decodeBytes32String; } }));\nObject.defineProperty(exports, \"encodeBytes32String\", ({ enumerable: true, get: function () { return index_js_1.encodeBytes32String; } }));\nObject.defineProperty(exports, \"AbiCoder\", ({ enumerable: true, get: function () { return index_js_1.AbiCoder; } }));\nObject.defineProperty(exports, \"ConstructorFragment\", ({ enumerable: true, get: function () { return index_js_1.ConstructorFragment; } }));\nObject.defineProperty(exports, \"ErrorFragment\", ({ enumerable: true, get: function () { return index_js_1.ErrorFragment; } }));\nObject.defineProperty(exports, \"EventFragment\", ({ enumerable: true, get: function () { return index_js_1.EventFragment; } }));\nObject.defineProperty(exports, \"Fragment\", ({ enumerable: true, get: function () { return index_js_1.Fragment; } }));\nObject.defineProperty(exports, \"FallbackFragment\", ({ enumerable: true, get: function () { return index_js_1.FallbackFragment; } }));\nObject.defineProperty(exports, \"FunctionFragment\", ({ enumerable: true, get: function () { return index_js_1.FunctionFragment; } }));\nObject.defineProperty(exports, \"NamedFragment\", ({ enumerable: true, get: function () { return index_js_1.NamedFragment; } }));\nObject.defineProperty(exports, \"ParamType\", ({ enumerable: true, get: function () { return index_js_1.ParamType; } }));\nObject.defineProperty(exports, \"StructFragment\", ({ enumerable: true, get: function () { return index_js_1.StructFragment; } }));\nObject.defineProperty(exports, \"checkResultErrors\", ({ enumerable: true, get: function () { return index_js_1.checkResultErrors; } }));\nObject.defineProperty(exports, \"ErrorDescription\", ({ enumerable: true, get: function () { return index_js_1.ErrorDescription; } }));\nObject.defineProperty(exports, \"Indexed\", ({ enumerable: true, get: function () { return index_js_1.Indexed; } }));\nObject.defineProperty(exports, \"Interface\", ({ enumerable: true, get: function () { return index_js_1.Interface; } }));\nObject.defineProperty(exports, \"LogDescription\", ({ enumerable: true, get: function () { return index_js_1.LogDescription; } }));\nObject.defineProperty(exports, \"Result\", ({ enumerable: true, get: function () { return index_js_1.Result; } }));\nObject.defineProperty(exports, \"TransactionDescription\", ({ enumerable: true, get: function () { return index_js_1.TransactionDescription; } }));\nObject.defineProperty(exports, \"Typed\", ({ enumerable: true, get: function () { return index_js_1.Typed; } }));\nvar index_js_2 = __webpack_require__(/*! ./address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nObject.defineProperty(exports, \"getAddress\", ({ enumerable: true, get: function () { return index_js_2.getAddress; } }));\nObject.defineProperty(exports, \"getIcapAddress\", ({ enumerable: true, get: function () { return index_js_2.getIcapAddress; } }));\nObject.defineProperty(exports, \"getCreateAddress\", ({ enumerable: true, get: function () { return index_js_2.getCreateAddress; } }));\nObject.defineProperty(exports, \"getCreate2Address\", ({ enumerable: true, get: function () { return index_js_2.getCreate2Address; } }));\nObject.defineProperty(exports, \"isAddressable\", ({ enumerable: true, get: function () { return index_js_2.isAddressable; } }));\nObject.defineProperty(exports, \"isAddress\", ({ enumerable: true, get: function () { return index_js_2.isAddress; } }));\nObject.defineProperty(exports, \"resolveAddress\", ({ enumerable: true, get: function () { return index_js_2.resolveAddress; } }));\nvar index_js_3 = __webpack_require__(/*! ./constants/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nObject.defineProperty(exports, \"ZeroAddress\", ({ enumerable: true, get: function () { return index_js_3.ZeroAddress; } }));\nObject.defineProperty(exports, \"WeiPerEther\", ({ enumerable: true, get: function () { return index_js_3.WeiPerEther; } }));\nObject.defineProperty(exports, \"MaxUint256\", ({ enumerable: true, get: function () { return index_js_3.MaxUint256; } }));\nObject.defineProperty(exports, \"MinInt256\", ({ enumerable: true, get: function () { return index_js_3.MinInt256; } }));\nObject.defineProperty(exports, \"MaxInt256\", ({ enumerable: true, get: function () { return index_js_3.MaxInt256; } }));\nObject.defineProperty(exports, \"N\", ({ enumerable: true, get: function () { return index_js_3.N; } }));\nObject.defineProperty(exports, \"ZeroHash\", ({ enumerable: true, get: function () { return index_js_3.ZeroHash; } }));\nObject.defineProperty(exports, \"EtherSymbol\", ({ enumerable: true, get: function () { return index_js_3.EtherSymbol; } }));\nObject.defineProperty(exports, \"MessagePrefix\", ({ enumerable: true, get: function () { return index_js_3.MessagePrefix; } }));\nvar index_js_4 = __webpack_require__(/*! ./contract/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/index.js\");\nObject.defineProperty(exports, \"BaseContract\", ({ enumerable: true, get: function () { return index_js_4.BaseContract; } }));\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return index_js_4.Contract; } }));\nObject.defineProperty(exports, \"ContractFactory\", ({ enumerable: true, get: function () { return index_js_4.ContractFactory; } }));\nObject.defineProperty(exports, \"ContractEventPayload\", ({ enumerable: true, get: function () { return index_js_4.ContractEventPayload; } }));\nObject.defineProperty(exports, \"ContractTransactionReceipt\", ({ enumerable: true, get: function () { return index_js_4.ContractTransactionReceipt; } }));\nObject.defineProperty(exports, \"ContractTransactionResponse\", ({ enumerable: true, get: function () { return index_js_4.ContractTransactionResponse; } }));\nObject.defineProperty(exports, \"ContractUnknownEventPayload\", ({ enumerable: true, get: function () { return index_js_4.ContractUnknownEventPayload; } }));\nObject.defineProperty(exports, \"EventLog\", ({ enumerable: true, get: function () { return index_js_4.EventLog; } }));\nObject.defineProperty(exports, \"UndecodedEventLog\", ({ enumerable: true, get: function () { return index_js_4.UndecodedEventLog; } }));\nvar index_js_5 = __webpack_require__(/*! ./crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nObject.defineProperty(exports, \"computeHmac\", ({ enumerable: true, get: function () { return index_js_5.computeHmac; } }));\nObject.defineProperty(exports, \"randomBytes\", ({ enumerable: true, get: function () { return index_js_5.randomBytes; } }));\nObject.defineProperty(exports, \"keccak256\", ({ enumerable: true, get: function () { return index_js_5.keccak256; } }));\nObject.defineProperty(exports, \"ripemd160\", ({ enumerable: true, get: function () { return index_js_5.ripemd160; } }));\nObject.defineProperty(exports, \"sha256\", ({ enumerable: true, get: function () { return index_js_5.sha256; } }));\nObject.defineProperty(exports, \"sha512\", ({ enumerable: true, get: function () { return index_js_5.sha512; } }));\nObject.defineProperty(exports, \"pbkdf2\", ({ enumerable: true, get: function () { return index_js_5.pbkdf2; } }));\nObject.defineProperty(exports, \"scrypt\", ({ enumerable: true, get: function () { return index_js_5.scrypt; } }));\nObject.defineProperty(exports, \"scryptSync\", ({ enumerable: true, get: function () { return index_js_5.scryptSync; } }));\nObject.defineProperty(exports, \"lock\", ({ enumerable: true, get: function () { return index_js_5.lock; } }));\nObject.defineProperty(exports, \"Signature\", ({ enumerable: true, get: function () { return index_js_5.Signature; } }));\nObject.defineProperty(exports, \"SigningKey\", ({ enumerable: true, get: function () { return index_js_5.SigningKey; } }));\nvar index_js_6 = __webpack_require__(/*! ./hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nObject.defineProperty(exports, \"id\", ({ enumerable: true, get: function () { return index_js_6.id; } }));\nObject.defineProperty(exports, \"ensNormalize\", ({ enumerable: true, get: function () { return index_js_6.ensNormalize; } }));\nObject.defineProperty(exports, \"isValidName\", ({ enumerable: true, get: function () { return index_js_6.isValidName; } }));\nObject.defineProperty(exports, \"namehash\", ({ enumerable: true, get: function () { return index_js_6.namehash; } }));\nObject.defineProperty(exports, \"dnsEncode\", ({ enumerable: true, get: function () { return index_js_6.dnsEncode; } }));\nObject.defineProperty(exports, \"hashMessage\", ({ enumerable: true, get: function () { return index_js_6.hashMessage; } }));\nObject.defineProperty(exports, \"verifyMessage\", ({ enumerable: true, get: function () { return index_js_6.verifyMessage; } }));\nObject.defineProperty(exports, \"solidityPacked\", ({ enumerable: true, get: function () { return index_js_6.solidityPacked; } }));\nObject.defineProperty(exports, \"solidityPackedKeccak256\", ({ enumerable: true, get: function () { return index_js_6.solidityPackedKeccak256; } }));\nObject.defineProperty(exports, \"solidityPackedSha256\", ({ enumerable: true, get: function () { return index_js_6.solidityPackedSha256; } }));\nObject.defineProperty(exports, \"TypedDataEncoder\", ({ enumerable: true, get: function () { return index_js_6.TypedDataEncoder; } }));\nObject.defineProperty(exports, \"verifyTypedData\", ({ enumerable: true, get: function () { return index_js_6.verifyTypedData; } }));\nvar index_js_7 = __webpack_require__(/*! ./providers/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/index.js\");\nObject.defineProperty(exports, \"getDefaultProvider\", ({ enumerable: true, get: function () { return index_js_7.getDefaultProvider; } }));\nObject.defineProperty(exports, \"Block\", ({ enumerable: true, get: function () { return index_js_7.Block; } }));\nObject.defineProperty(exports, \"FeeData\", ({ enumerable: true, get: function () { return index_js_7.FeeData; } }));\nObject.defineProperty(exports, \"Log\", ({ enumerable: true, get: function () { return index_js_7.Log; } }));\nObject.defineProperty(exports, \"TransactionReceipt\", ({ enumerable: true, get: function () { return index_js_7.TransactionReceipt; } }));\nObject.defineProperty(exports, \"TransactionResponse\", ({ enumerable: true, get: function () { return index_js_7.TransactionResponse; } }));\nObject.defineProperty(exports, \"AbstractSigner\", ({ enumerable: true, get: function () { return index_js_7.AbstractSigner; } }));\nObject.defineProperty(exports, \"NonceManager\", ({ enumerable: true, get: function () { return index_js_7.NonceManager; } }));\nObject.defineProperty(exports, \"VoidSigner\", ({ enumerable: true, get: function () { return index_js_7.VoidSigner; } }));\nObject.defineProperty(exports, \"AbstractProvider\", ({ enumerable: true, get: function () { return index_js_7.AbstractProvider; } }));\nObject.defineProperty(exports, \"FallbackProvider\", ({ enumerable: true, get: function () { return index_js_7.FallbackProvider; } }));\nObject.defineProperty(exports, \"JsonRpcApiProvider\", ({ enumerable: true, get: function () { return index_js_7.JsonRpcApiProvider; } }));\nObject.defineProperty(exports, \"JsonRpcProvider\", ({ enumerable: true, get: function () { return index_js_7.JsonRpcProvider; } }));\nObject.defineProperty(exports, \"JsonRpcSigner\", ({ enumerable: true, get: function () { return index_js_7.JsonRpcSigner; } }));\nObject.defineProperty(exports, \"BrowserProvider\", ({ enumerable: true, get: function () { return index_js_7.BrowserProvider; } }));\nObject.defineProperty(exports, \"AlchemyProvider\", ({ enumerable: true, get: function () { return index_js_7.AlchemyProvider; } }));\nObject.defineProperty(exports, \"AnkrProvider\", ({ enumerable: true, get: function () { return index_js_7.AnkrProvider; } }));\nObject.defineProperty(exports, \"CloudflareProvider\", ({ enumerable: true, get: function () { return index_js_7.CloudflareProvider; } }));\nObject.defineProperty(exports, \"EtherscanProvider\", ({ enumerable: true, get: function () { return index_js_7.EtherscanProvider; } }));\nObject.defineProperty(exports, \"InfuraProvider\", ({ enumerable: true, get: function () { return index_js_7.InfuraProvider; } }));\nObject.defineProperty(exports, \"InfuraWebSocketProvider\", ({ enumerable: true, get: function () { return index_js_7.InfuraWebSocketProvider; } }));\nObject.defineProperty(exports, \"PocketProvider\", ({ enumerable: true, get: function () { return index_js_7.PocketProvider; } }));\nObject.defineProperty(exports, \"QuickNodeProvider\", ({ enumerable: true, get: function () { return index_js_7.QuickNodeProvider; } }));\nObject.defineProperty(exports, \"IpcSocketProvider\", ({ enumerable: true, get: function () { return index_js_7.IpcSocketProvider; } }));\nObject.defineProperty(exports, \"SocketProvider\", ({ enumerable: true, get: function () { return index_js_7.SocketProvider; } }));\nObject.defineProperty(exports, \"WebSocketProvider\", ({ enumerable: true, get: function () { return index_js_7.WebSocketProvider; } }));\nObject.defineProperty(exports, \"EnsResolver\", ({ enumerable: true, get: function () { return index_js_7.EnsResolver; } }));\nObject.defineProperty(exports, \"Network\", ({ enumerable: true, get: function () { return index_js_7.Network; } }));\nObject.defineProperty(exports, \"EnsPlugin\", ({ enumerable: true, get: function () { return index_js_7.EnsPlugin; } }));\nObject.defineProperty(exports, \"EtherscanPlugin\", ({ enumerable: true, get: function () { return index_js_7.EtherscanPlugin; } }));\nObject.defineProperty(exports, \"FeeDataNetworkPlugin\", ({ enumerable: true, get: function () { return index_js_7.FeeDataNetworkPlugin; } }));\nObject.defineProperty(exports, \"FetchUrlFeeDataNetworkPlugin\", ({ enumerable: true, get: function () { return index_js_7.FetchUrlFeeDataNetworkPlugin; } }));\nObject.defineProperty(exports, \"GasCostPlugin\", ({ enumerable: true, get: function () { return index_js_7.GasCostPlugin; } }));\nObject.defineProperty(exports, \"NetworkPlugin\", ({ enumerable: true, get: function () { return index_js_7.NetworkPlugin; } }));\nObject.defineProperty(exports, \"MulticoinProviderPlugin\", ({ enumerable: true, get: function () { return index_js_7.MulticoinProviderPlugin; } }));\nObject.defineProperty(exports, \"SocketBlockSubscriber\", ({ enumerable: true, get: function () { return index_js_7.SocketBlockSubscriber; } }));\nObject.defineProperty(exports, \"SocketEventSubscriber\", ({ enumerable: true, get: function () { return index_js_7.SocketEventSubscriber; } }));\nObject.defineProperty(exports, \"SocketPendingSubscriber\", ({ enumerable: true, get: function () { return index_js_7.SocketPendingSubscriber; } }));\nObject.defineProperty(exports, \"SocketSubscriber\", ({ enumerable: true, get: function () { return index_js_7.SocketSubscriber; } }));\nObject.defineProperty(exports, \"UnmanagedSubscriber\", ({ enumerable: true, get: function () { return index_js_7.UnmanagedSubscriber; } }));\nObject.defineProperty(exports, \"copyRequest\", ({ enumerable: true, get: function () { return index_js_7.copyRequest; } }));\nObject.defineProperty(exports, \"showThrottleMessage\", ({ enumerable: true, get: function () { return index_js_7.showThrottleMessage; } }));\nvar index_js_8 = __webpack_require__(/*! ./transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nObject.defineProperty(exports, \"accessListify\", ({ enumerable: true, get: function () { return index_js_8.accessListify; } }));\nObject.defineProperty(exports, \"computeAddress\", ({ enumerable: true, get: function () { return index_js_8.computeAddress; } }));\nObject.defineProperty(exports, \"recoverAddress\", ({ enumerable: true, get: function () { return index_js_8.recoverAddress; } }));\nObject.defineProperty(exports, \"Transaction\", ({ enumerable: true, get: function () { return index_js_8.Transaction; } }));\nvar index_js_9 = __webpack_require__(/*! ./utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nObject.defineProperty(exports, \"decodeBase58\", ({ enumerable: true, get: function () { return index_js_9.decodeBase58; } }));\nObject.defineProperty(exports, \"encodeBase58\", ({ enumerable: true, get: function () { return index_js_9.encodeBase58; } }));\nObject.defineProperty(exports, \"decodeBase64\", ({ enumerable: true, get: function () { return index_js_9.decodeBase64; } }));\nObject.defineProperty(exports, \"encodeBase64\", ({ enumerable: true, get: function () { return index_js_9.encodeBase64; } }));\nObject.defineProperty(exports, \"concat\", ({ enumerable: true, get: function () { return index_js_9.concat; } }));\nObject.defineProperty(exports, \"dataLength\", ({ enumerable: true, get: function () { return index_js_9.dataLength; } }));\nObject.defineProperty(exports, \"dataSlice\", ({ enumerable: true, get: function () { return index_js_9.dataSlice; } }));\nObject.defineProperty(exports, \"getBytes\", ({ enumerable: true, get: function () { return index_js_9.getBytes; } }));\nObject.defineProperty(exports, \"getBytesCopy\", ({ enumerable: true, get: function () { return index_js_9.getBytesCopy; } }));\nObject.defineProperty(exports, \"hexlify\", ({ enumerable: true, get: function () { return index_js_9.hexlify; } }));\nObject.defineProperty(exports, \"isHexString\", ({ enumerable: true, get: function () { return index_js_9.isHexString; } }));\nObject.defineProperty(exports, \"isBytesLike\", ({ enumerable: true, get: function () { return index_js_9.isBytesLike; } }));\nObject.defineProperty(exports, \"stripZerosLeft\", ({ enumerable: true, get: function () { return index_js_9.stripZerosLeft; } }));\nObject.defineProperty(exports, \"zeroPadBytes\", ({ enumerable: true, get: function () { return index_js_9.zeroPadBytes; } }));\nObject.defineProperty(exports, \"zeroPadValue\", ({ enumerable: true, get: function () { return index_js_9.zeroPadValue; } }));\nObject.defineProperty(exports, \"defineProperties\", ({ enumerable: true, get: function () { return index_js_9.defineProperties; } }));\nObject.defineProperty(exports, \"resolveProperties\", ({ enumerable: true, get: function () { return index_js_9.resolveProperties; } }));\nObject.defineProperty(exports, \"assert\", ({ enumerable: true, get: function () { return index_js_9.assert; } }));\nObject.defineProperty(exports, \"assertArgument\", ({ enumerable: true, get: function () { return index_js_9.assertArgument; } }));\nObject.defineProperty(exports, \"assertArgumentCount\", ({ enumerable: true, get: function () { return index_js_9.assertArgumentCount; } }));\nObject.defineProperty(exports, \"assertNormalize\", ({ enumerable: true, get: function () { return index_js_9.assertNormalize; } }));\nObject.defineProperty(exports, \"assertPrivate\", ({ enumerable: true, get: function () { return index_js_9.assertPrivate; } }));\nObject.defineProperty(exports, \"makeError\", ({ enumerable: true, get: function () { return index_js_9.makeError; } }));\nObject.defineProperty(exports, \"isCallException\", ({ enumerable: true, get: function () { return index_js_9.isCallException; } }));\nObject.defineProperty(exports, \"isError\", ({ enumerable: true, get: function () { return index_js_9.isError; } }));\nObject.defineProperty(exports, \"EventPayload\", ({ enumerable: true, get: function () { return index_js_9.EventPayload; } }));\nObject.defineProperty(exports, \"FetchRequest\", ({ enumerable: true, get: function () { return index_js_9.FetchRequest; } }));\nObject.defineProperty(exports, \"FetchResponse\", ({ enumerable: true, get: function () { return index_js_9.FetchResponse; } }));\nObject.defineProperty(exports, \"FetchCancelSignal\", ({ enumerable: true, get: function () { return index_js_9.FetchCancelSignal; } }));\nObject.defineProperty(exports, \"FixedNumber\", ({ enumerable: true, get: function () { return index_js_9.FixedNumber; } }));\nObject.defineProperty(exports, \"getBigInt\", ({ enumerable: true, get: function () { return index_js_9.getBigInt; } }));\nObject.defineProperty(exports, \"getNumber\", ({ enumerable: true, get: function () { return index_js_9.getNumber; } }));\nObject.defineProperty(exports, \"getUint\", ({ enumerable: true, get: function () { return index_js_9.getUint; } }));\nObject.defineProperty(exports, \"toBeArray\", ({ enumerable: true, get: function () { return index_js_9.toBeArray; } }));\nObject.defineProperty(exports, \"toBigInt\", ({ enumerable: true, get: function () { return index_js_9.toBigInt; } }));\nObject.defineProperty(exports, \"toBeHex\", ({ enumerable: true, get: function () { return index_js_9.toBeHex; } }));\nObject.defineProperty(exports, \"toNumber\", ({ enumerable: true, get: function () { return index_js_9.toNumber; } }));\nObject.defineProperty(exports, \"toQuantity\", ({ enumerable: true, get: function () { return index_js_9.toQuantity; } }));\nObject.defineProperty(exports, \"fromTwos\", ({ enumerable: true, get: function () { return index_js_9.fromTwos; } }));\nObject.defineProperty(exports, \"toTwos\", ({ enumerable: true, get: function () { return index_js_9.toTwos; } }));\nObject.defineProperty(exports, \"mask\", ({ enumerable: true, get: function () { return index_js_9.mask; } }));\nObject.defineProperty(exports, \"formatEther\", ({ enumerable: true, get: function () { return index_js_9.formatEther; } }));\nObject.defineProperty(exports, \"parseEther\", ({ enumerable: true, get: function () { return index_js_9.parseEther; } }));\nObject.defineProperty(exports, \"formatUnits\", ({ enumerable: true, get: function () { return index_js_9.formatUnits; } }));\nObject.defineProperty(exports, \"parseUnits\", ({ enumerable: true, get: function () { return index_js_9.parseUnits; } }));\nObject.defineProperty(exports, \"toUtf8Bytes\", ({ enumerable: true, get: function () { return index_js_9.toUtf8Bytes; } }));\nObject.defineProperty(exports, \"toUtf8CodePoints\", ({ enumerable: true, get: function () { return index_js_9.toUtf8CodePoints; } }));\nObject.defineProperty(exports, \"toUtf8String\", ({ enumerable: true, get: function () { return index_js_9.toUtf8String; } }));\nObject.defineProperty(exports, \"Utf8ErrorFuncs\", ({ enumerable: true, get: function () { return index_js_9.Utf8ErrorFuncs; } }));\nObject.defineProperty(exports, \"decodeRlp\", ({ enumerable: true, get: function () { return index_js_9.decodeRlp; } }));\nObject.defineProperty(exports, \"encodeRlp\", ({ enumerable: true, get: function () { return index_js_9.encodeRlp; } }));\nObject.defineProperty(exports, \"uuidV4\", ({ enumerable: true, get: function () { return index_js_9.uuidV4; } }));\nvar index_js_10 = __webpack_require__(/*! ./wallet/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/index.js\");\nObject.defineProperty(exports, \"Mnemonic\", ({ enumerable: true, get: function () { return index_js_10.Mnemonic; } }));\nObject.defineProperty(exports, \"BaseWallet\", ({ enumerable: true, get: function () { return index_js_10.BaseWallet; } }));\nObject.defineProperty(exports, \"HDNodeWallet\", ({ enumerable: true, get: function () { return index_js_10.HDNodeWallet; } }));\nObject.defineProperty(exports, \"HDNodeVoidWallet\", ({ enumerable: true, get: function () { return index_js_10.HDNodeVoidWallet; } }));\nObject.defineProperty(exports, \"Wallet\", ({ enumerable: true, get: function () { return index_js_10.Wallet; } }));\nObject.defineProperty(exports, \"defaultPath\", ({ enumerable: true, get: function () { return index_js_10.defaultPath; } }));\nObject.defineProperty(exports, \"getAccountPath\", ({ enumerable: true, get: function () { return index_js_10.getAccountPath; } }));\nObject.defineProperty(exports, \"getIndexedAccountPath\", ({ enumerable: true, get: function () { return index_js_10.getIndexedAccountPath; } }));\nObject.defineProperty(exports, \"isCrowdsaleJson\", ({ enumerable: true, get: function () { return index_js_10.isCrowdsaleJson; } }));\nObject.defineProperty(exports, \"isKeystoreJson\", ({ enumerable: true, get: function () { return index_js_10.isKeystoreJson; } }));\nObject.defineProperty(exports, \"decryptCrowdsaleJson\", ({ enumerable: true, get: function () { return index_js_10.decryptCrowdsaleJson; } }));\nObject.defineProperty(exports, \"decryptKeystoreJsonSync\", ({ enumerable: true, get: function () { return index_js_10.decryptKeystoreJsonSync; } }));\nObject.defineProperty(exports, \"decryptKeystoreJson\", ({ enumerable: true, get: function () { return index_js_10.decryptKeystoreJson; } }));\nObject.defineProperty(exports, \"encryptKeystoreJson\", ({ enumerable: true, get: function () { return index_js_10.encryptKeystoreJson; } }));\nObject.defineProperty(exports, \"encryptKeystoreJsonSync\", ({ enumerable: true, get: function () { return index_js_10.encryptKeystoreJsonSync; } }));\nvar index_js_11 = __webpack_require__(/*! ./wordlists/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/index.js\");\nObject.defineProperty(exports, \"Wordlist\", ({ enumerable: true, get: function () { return index_js_11.Wordlist; } }));\nObject.defineProperty(exports, \"LangEn\", ({ enumerable: true, get: function () { return index_js_11.LangEn; } }));\nObject.defineProperty(exports, \"WordlistOwl\", ({ enumerable: true, get: function () { return index_js_11.WordlistOwl; } }));\nObject.defineProperty(exports, \"WordlistOwlA\", ({ enumerable: true, get: function () { return index_js_11.WordlistOwlA; } }));\nObject.defineProperty(exports, \"wordlists\", ({ enumerable: true, get: function () { return index_js_11.wordlists; } }));\n//# sourceMappingURL=ethers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9ldGhlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLGdCQUFnQixHQUFHLG1DQUFtQyxHQUFHLG1DQUFtQyxHQUFHLGtDQUFrQyxHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLFNBQVMsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcsY0FBYyxHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxnQkFBZ0IsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxlQUFlO0FBQ3pxQyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCLEdBQUcsK0JBQStCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsMEJBQTBCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCLEdBQUcsMkJBQTJCLEdBQUcsMEJBQTBCLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsNEJBQTRCLEdBQUcsK0JBQStCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsVUFBVSxHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLFlBQVksR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ3pwQyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsZUFBZSxHQUFHLHVCQUF1QixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQixHQUFHLGNBQWMsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLG1CQUFtQixHQUFHLDJCQUEyQixHQUFHLHdCQUF3QixHQUFHLCtCQUErQixHQUFHLDZCQUE2QixHQUFHLDZCQUE2QixHQUFHLCtCQUErQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLG9DQUFvQyxHQUFHLDRCQUE0QjtBQUNoc0MsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLCtCQUErQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLDZCQUE2QixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CLEdBQUcsd0JBQXdCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCO0FBQzkxQixvQkFBb0IsbUJBQU8sQ0FBQywyRUFBZTtBQUMzQywyQ0FBMEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDbkgsaUJBQWlCLG1CQUFPLENBQUMsNkVBQWdCO0FBQ3pDLHVEQUFzRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUN4SSx1REFBc0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDeEksNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILHVEQUFzRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUN4SSxpREFBZ0QsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDNUgsaURBQWdELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzVILDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxvREFBbUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDbEksb0RBQW1ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2xJLGlEQUFnRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM1SCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlILHFEQUFvRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNwSSxvREFBbUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDbEksMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsMENBQXlDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzlHLDBEQUF5RCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUM5SSx5Q0FBd0MsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDNUcsaUJBQWlCLG1CQUFPLENBQUMscUZBQW9CO0FBQzdDLDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN0SCxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsb0RBQW1ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2xJLHFEQUFvRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNwSSxpREFBZ0QsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDNUgsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDL0MsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILCtDQUE4QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN4SCw4Q0FBNkMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdEgsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCxxQ0FBb0MsRUFBRSxxQ0FBcUMsd0JBQXdCLEVBQUM7QUFDcEcsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILCtDQUE4QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN4SCxpREFBZ0QsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDNUgsaUJBQWlCLG1CQUFPLENBQUMsdUZBQXFCO0FBQzlDLGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsbURBQWtELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2hJLHdEQUF1RCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUMxSSw4REFBNkQsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDdEosK0RBQThELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQ3hKLCtEQUE4RCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUN4Siw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgscURBQW9ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3BJLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFtQjtBQUM1QywrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsMENBQXlDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzlHLDBDQUF5QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM5RywwQ0FBeUMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDOUcsMENBQXlDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzlHLDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN0SCx3Q0FBdUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDMUcsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN0SCxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBaUI7QUFDMUMsc0NBQXFDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3RHLGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCwrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCwrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsaURBQWdELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzVILGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCwyREFBMEQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDaEosd0RBQXVELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQzFJLG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSxtREFBa0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDaEksaUJBQWlCLG1CQUFPLENBQUMseUZBQXNCO0FBQy9DLHNEQUFxRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUN0SSx5Q0FBd0MsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDNUcsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILHVDQUFzQyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUN4RyxzREFBcUQsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDdEksdURBQXNELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3hJLGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSxvREFBbUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDbEksc0RBQXFELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3RJLG1EQUFrRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNoSSxpREFBZ0QsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDNUgsbURBQWtELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2hJLG1EQUFrRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNoSSxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsc0RBQXFELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3RJLHFEQUFvRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNwSSxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsMkRBQTBELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ2hKLGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCxxREFBb0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDcEkscURBQW9ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3BJLGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCxxREFBb0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDcEksK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsbURBQWtELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2hJLHdEQUF1RCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUMxSSxnRUFBK0QsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDMUosaURBQWdELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzVILGlEQUFnRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM1SCwyREFBMEQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDaEoseURBQXdELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQzVJLHlEQUF3RCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUM1SSwyREFBMEQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDaEosb0RBQW1ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2xJLHVEQUFzRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUN4SSwrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsdURBQXNELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3hJLGlCQUFpQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNqRCxpREFBZ0QsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDNUgsa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlILGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCwrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsaUJBQWlCLG1CQUFPLENBQUMsaUZBQWtCO0FBQzNDLGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsZ0RBQStDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzFILGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDOUcsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsZ0RBQStDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzFILDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCwrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsZ0RBQStDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzFILG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSxxREFBb0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDcEksMENBQXlDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzlHLGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCx1REFBc0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDeEksbURBQWtELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2hJLGlEQUFnRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM1SCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsbURBQWtELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2hJLDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsZ0RBQStDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzFILGlEQUFnRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM1SCxxREFBb0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDcEksK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCw4Q0FBNkMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdEgsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILDBDQUF5QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM5Ryx3Q0FBdUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDMUcsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN0SCwrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILCtDQUE4QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN4SCxvREFBbUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDbEksZ0RBQStDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzFILGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILDBDQUF5QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM5RyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDN0MsNENBQTJDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ25ILDhDQUE2QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN2SCxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsb0RBQW1ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ25JLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRywrQ0FBOEMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDekgsa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILHlEQUF3RCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUM3SSxtREFBa0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDakksa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILHdEQUF1RCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMzSSwyREFBMEQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDakosdURBQXNELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3pJLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSwyREFBMEQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDakosa0JBQWtCLG1CQUFPLENBQUMseUZBQXNCO0FBQ2hELDRDQUEyQyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNuSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9ldGhlcnMuanM/YjAwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLmNvbXB1dGVIbWFjID0gZXhwb3J0cy5VbmRlY29kZWRFdmVudExvZyA9IGV4cG9ydHMuRXZlbnRMb2cgPSBleHBvcnRzLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCA9IGV4cG9ydHMuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuQ29udHJhY3RFdmVudFBheWxvYWQgPSBleHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IGV4cG9ydHMuQ29udHJhY3QgPSBleHBvcnRzLkJhc2VDb250cmFjdCA9IGV4cG9ydHMuTWVzc2FnZVByZWZpeCA9IGV4cG9ydHMuRXRoZXJTeW1ib2wgPSBleHBvcnRzLlplcm9IYXNoID0gZXhwb3J0cy5OID0gZXhwb3J0cy5NYXhJbnQyNTYgPSBleHBvcnRzLk1pbkludDI1NiA9IGV4cG9ydHMuTWF4VWludDI1NiA9IGV4cG9ydHMuV2VpUGVyRXRoZXIgPSBleHBvcnRzLlplcm9BZGRyZXNzID0gZXhwb3J0cy5yZXNvbHZlQWRkcmVzcyA9IGV4cG9ydHMuaXNBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3NhYmxlID0gZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q3JlYXRlQWRkcmVzcyA9IGV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSBleHBvcnRzLlR5cGVkID0gZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5SZXN1bHQgPSBleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gZXhwb3J0cy5JbnRlcmZhY2UgPSBleHBvcnRzLkluZGV4ZWQgPSBleHBvcnRzLkVycm9yRGVzY3JpcHRpb24gPSBleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gZXhwb3J0cy5TdHJ1Y3RGcmFnbWVudCA9IGV4cG9ydHMuUGFyYW1UeXBlID0gZXhwb3J0cy5OYW1lZEZyYWdtZW50ID0gZXhwb3J0cy5GdW5jdGlvbkZyYWdtZW50ID0gZXhwb3J0cy5GYWxsYmFja0ZyYWdtZW50ID0gZXhwb3J0cy5GcmFnbWVudCA9IGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IGV4cG9ydHMuRXJyb3JGcmFnbWVudCA9IGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IGV4cG9ydHMuQWJpQ29kZXIgPSBleHBvcnRzLmVuY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLmRlY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLkV0aGVyc2NhblBsdWdpbiA9IGV4cG9ydHMuRW5zUGx1Z2luID0gZXhwb3J0cy5OZXR3b3JrID0gZXhwb3J0cy5FbnNSZXNvbHZlciA9IGV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JcGNTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuUXVpY2tOb2RlUHJvdmlkZXIgPSBleHBvcnRzLlBvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBleHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gZXhwb3J0cy5DbG91ZGZsYXJlUHJvdmlkZXIgPSBleHBvcnRzLkFua3JQcm92aWRlciA9IGV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gZXhwb3J0cy5Ccm93c2VyUHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNTaWduZXIgPSBleHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY0FwaVByb3ZpZGVyID0gZXhwb3J0cy5GYWxsYmFja1Byb3ZpZGVyID0gZXhwb3J0cy5BYnN0cmFjdFByb3ZpZGVyID0gZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXhwb3J0cy5Ob25jZU1hbmFnZXIgPSBleHBvcnRzLkFic3RyYWN0U2lnbmVyID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlY2VpcHQgPSBleHBvcnRzLkxvZyA9IGV4cG9ydHMuRmVlRGF0YSA9IGV4cG9ydHMuQmxvY2sgPSBleHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGV4cG9ydHMudmVyaWZ5VHlwZWREYXRhID0gZXhwb3J0cy5UeXBlZERhdGFFbmNvZGVyID0gZXhwb3J0cy5zb2xpZGl0eVBhY2tlZFNoYTI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYgPSBleHBvcnRzLnNvbGlkaXR5UGFja2VkID0gZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gZXhwb3J0cy5oYXNoTWVzc2FnZSA9IGV4cG9ydHMuZG5zRW5jb2RlID0gZXhwb3J0cy5uYW1laGFzaCA9IGV4cG9ydHMuaXNWYWxpZE5hbWUgPSBleHBvcnRzLmVuc05vcm1hbGl6ZSA9IGV4cG9ydHMuaWQgPSBleHBvcnRzLlNpZ25pbmdLZXkgPSBleHBvcnRzLlNpZ25hdHVyZSA9IGV4cG9ydHMubG9jayA9IGV4cG9ydHMuc2NyeXB0U3luYyA9IGV4cG9ydHMuc2NyeXB0ID0gZXhwb3J0cy5wYmtkZjIgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjU2ID0gdm9pZCAwO1xuZXhwb3J0cy50b0JlQXJyYXkgPSBleHBvcnRzLmdldFVpbnQgPSBleHBvcnRzLmdldE51bWJlciA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5GaXhlZE51bWJlciA9IGV4cG9ydHMuRmV0Y2hDYW5jZWxTaWduYWwgPSBleHBvcnRzLkZldGNoUmVzcG9uc2UgPSBleHBvcnRzLkZldGNoUmVxdWVzdCA9IGV4cG9ydHMuRXZlbnRQYXlsb2FkID0gZXhwb3J0cy5pc0Vycm9yID0gZXhwb3J0cy5pc0NhbGxFeGNlcHRpb24gPSBleHBvcnRzLm1ha2VFcnJvciA9IGV4cG9ydHMuYXNzZXJ0UHJpdmF0ZSA9IGV4cG9ydHMuYXNzZXJ0Tm9ybWFsaXplID0gZXhwb3J0cy5hc3NlcnRBcmd1bWVudENvdW50ID0gZXhwb3J0cy5hc3NlcnRBcmd1bWVudCA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5yZXNvbHZlUHJvcGVydGllcyA9IGV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGV4cG9ydHMuemVyb1BhZFZhbHVlID0gZXhwb3J0cy56ZXJvUGFkQnl0ZXMgPSBleHBvcnRzLnN0cmlwWmVyb3NMZWZ0ID0gZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmdldEJ5dGVzQ29weSA9IGV4cG9ydHMuZ2V0Qnl0ZXMgPSBleHBvcnRzLmRhdGFTbGljZSA9IGV4cG9ydHMuZGF0YUxlbmd0aCA9IGV4cG9ydHMuY29uY2F0ID0gZXhwb3J0cy5lbmNvZGVCYXNlNjQgPSBleHBvcnRzLmRlY29kZUJhc2U2NCA9IGV4cG9ydHMuZW5jb2RlQmFzZTU4ID0gZXhwb3J0cy5kZWNvZGVCYXNlNTggPSBleHBvcnRzLlRyYW5zYWN0aW9uID0gZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBleHBvcnRzLmFjY2Vzc0xpc3RpZnkgPSBleHBvcnRzLnNob3dUaHJvdHRsZU1lc3NhZ2UgPSBleHBvcnRzLmNvcHlSZXF1ZXN0ID0gZXhwb3J0cy5Vbm1hbmFnZWRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRQZW5kaW5nU3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0RXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRCbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLk11bHRpY29pblByb3ZpZGVyUGx1Z2luID0gZXhwb3J0cy5OZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5HYXNDb3N0UGx1Z2luID0gZXhwb3J0cy5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5GZWVEYXRhTmV0d29ya1BsdWdpbiA9IHZvaWQgMDtcbmV4cG9ydHMud29yZGxpc3RzID0gZXhwb3J0cy5Xb3JkbGlzdE93bEEgPSBleHBvcnRzLldvcmRsaXN0T3dsID0gZXhwb3J0cy5MYW5nRW4gPSBleHBvcnRzLldvcmRsaXN0ID0gZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGV4cG9ydHMuZW5jcnlwdEtleXN0b3JlSnNvbiA9IGV4cG9ydHMuZGVjcnlwdEtleXN0b3JlSnNvbiA9IGV4cG9ydHMuZGVjcnlwdEtleXN0b3JlSnNvblN5bmMgPSBleHBvcnRzLmRlY3J5cHRDcm93ZHNhbGVKc29uID0gZXhwb3J0cy5pc0tleXN0b3JlSnNvbiA9IGV4cG9ydHMuaXNDcm93ZHNhbGVKc29uID0gZXhwb3J0cy5nZXRJbmRleGVkQWNjb3VudFBhdGggPSBleHBvcnRzLmdldEFjY291bnRQYXRoID0gZXhwb3J0cy5kZWZhdWx0UGF0aCA9IGV4cG9ydHMuV2FsbGV0ID0gZXhwb3J0cy5IRE5vZGVWb2lkV2FsbGV0ID0gZXhwb3J0cy5IRE5vZGVXYWxsZXQgPSBleHBvcnRzLkJhc2VXYWxsZXQgPSBleHBvcnRzLk1uZW1vbmljID0gZXhwb3J0cy51dWlkVjQgPSBleHBvcnRzLmVuY29kZVJscCA9IGV4cG9ydHMuZGVjb2RlUmxwID0gZXhwb3J0cy5VdGY4RXJyb3JGdW5jcyA9IGV4cG9ydHMudG9VdGY4U3RyaW5nID0gZXhwb3J0cy50b1V0ZjhDb2RlUG9pbnRzID0gZXhwb3J0cy50b1V0ZjhCeXRlcyA9IGV4cG9ydHMucGFyc2VVbml0cyA9IGV4cG9ydHMuZm9ybWF0VW5pdHMgPSBleHBvcnRzLnBhcnNlRXRoZXIgPSBleHBvcnRzLmZvcm1hdEV0aGVyID0gZXhwb3J0cy5tYXNrID0gZXhwb3J0cy50b1R3b3MgPSBleHBvcnRzLmZyb21Ud29zID0gZXhwb3J0cy50b1F1YW50aXR5ID0gZXhwb3J0cy50b051bWJlciA9IGV4cG9ydHMudG9CZUhleCA9IGV4cG9ydHMudG9CaWdJbnQgPSB2b2lkIDA7XG52YXIgX3ZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3ZlcnNpb25fanNfMS52ZXJzaW9uOyB9IH0pO1xudmFyIGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi9hYmkvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVCeXRlczMyU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLmRlY29kZUJ5dGVzMzJTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVCeXRlczMyU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLmVuY29kZUJ5dGVzMzJTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYmlDb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5BYmlDb2RlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnN0cnVjdG9yRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuQ29uc3RydWN0b3JGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuRXJyb3JGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50RnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuRXZlbnRGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmFsbGJhY2tGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5GYWxsYmFja0ZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25GcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5GdW5jdGlvbkZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZWRGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5OYW1lZEZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFyYW1UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLlBhcmFtVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cnVjdEZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLlN0cnVjdEZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tSZXN1bHRFcnJvcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuY2hlY2tSZXN1bHRFcnJvcnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckRlc2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkVycm9yRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmRleGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkluZGV4ZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmZhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuSW50ZXJmYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuTG9nRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXN1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuUmVzdWx0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25EZXNjcmlwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuVHlwZWQ7IH0gfSk7XG52YXIgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuL2FkZHJlc3MvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLmdldEFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJY2FwQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMi5nZXRJY2FwQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENyZWF0ZUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzIuZ2V0Q3JlYXRlQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENyZWF0ZTJBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLmdldENyZWF0ZTJBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNBZGRyZXNzYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMi5pc0FkZHJlc3NhYmxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLmlzQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzOyB9IH0pO1xudmFyIGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaZXJvQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5aZXJvQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlaVBlckV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18zLldlaVBlckV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWF4VWludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5NYXhVaW50MjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWluSW50MjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18zLk1pbkludDI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1heEludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5NYXhJbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18zLk47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaZXJvSGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5aZXJvSGFzaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyU3ltYm9sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18zLkV0aGVyU3ltYm9sOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVByZWZpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5NZXNzYWdlUHJlZml4OyB9IH0pO1xudmFyIGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi9jb250cmFjdC9pbmRleC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5CYXNlQ29udHJhY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0RmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdEZhY3Rvcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdEV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdEV2ZW50UGF5bG9hZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc180LkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc180LkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdFVua25vd25FdmVudFBheWxvYWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudExvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5FdmVudExvZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZGVjb2RlZEV2ZW50TG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc180LlVuZGVjb2RlZEV2ZW50TG9nOyB9IH0pO1xudmFyIGluZGV4X2pzXzUgPSByZXF1aXJlKFwiLi9jcnlwdG8vaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlSG1hY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5jb21wdXRlSG1hYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJhbmRvbUJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LnJhbmRvbUJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwia2VjY2FrMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LmtlY2NhazI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpcGVtZDE2MFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5yaXBlbWQxNjA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGEyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUuc2hhMjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhNTEyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LnNoYTUxMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBia2RmMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5wYmtkZjI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY3J5cHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUuc2NyeXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NyeXB0U3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5zY3J5cHRTeW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9ja1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5sb2NrOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmF0dXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LlNpZ25hdHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25pbmdLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUuU2lnbmluZ0tleTsgfSB9KTtcbnZhciBpbmRleF9qc182ID0gcmVxdWlyZShcIi4vaGFzaC9pbmRleC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LmlkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5zTm9ybWFsaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LmVuc05vcm1hbGl6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWROYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LmlzVmFsaWROYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmFtZWhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYubmFtZWhhc2g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkbnNFbmNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYuZG5zRW5jb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYuaGFzaE1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LnZlcmlmeU1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb2xpZGl0eVBhY2tlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNi5zb2xpZGl0eVBhY2tlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNvbGlkaXR5UGFja2VkS2VjY2FrMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlQYWNrZWRTaGEyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYuc29saWRpdHlQYWNrZWRTaGEyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlZERhdGFFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LlR5cGVkRGF0YUVuY29kZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlUeXBlZERhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYudmVyaWZ5VHlwZWREYXRhOyB9IH0pO1xudmFyIGluZGV4X2pzXzcgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREZWZhdWx0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuZ2V0RGVmYXVsdFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmxvY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuQmxvY2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZWVEYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkZlZURhdGE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuTG9nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlRyYW5zYWN0aW9uUmVjZWlwdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uUmVzcG9uc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuVHJhbnNhY3Rpb25SZXNwb25zZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0U2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkFic3RyYWN0U2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9uY2VNYW5hZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183Lk5vbmNlTWFuYWdlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZvaWRTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuVm9pZFNpZ25lcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuQWJzdHJhY3RQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZhbGxiYWNrUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuRmFsbGJhY2tQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNBcGlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Kc29uUnBjQXBpUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuSnNvblJwY1Byb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNvblJwY1NpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Kc29uUnBjU2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnJvd3NlclByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkJyb3dzZXJQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFsY2hlbXlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5BbGNoZW15UHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbmtyUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuQW5rclByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xvdWRmbGFyZVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkNsb3VkZmxhcmVQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyc2NhblByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkV0aGVyc2NhblByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5mdXJhUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuSW5mdXJhUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmZ1cmFXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlBvY2tldFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUXVpY2tOb2RlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuUXVpY2tOb2RlUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJcGNTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5JcGNTb2NrZXRQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlNvY2tldFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2ViU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuV2ViU29ja2V0UHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbnNSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5FbnNSZXNvbHZlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5ldHdvcmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuTmV0d29yazsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuc1BsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5FbnNQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcnNjYW5QbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuRXRoZXJzY2FuUGx1Z2luOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVlRGF0YU5ldHdvcmtQbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuRmVlRGF0YU5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHYXNDb3N0UGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183Lkdhc0Nvc3RQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZXR3b3JrUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183Lk5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aWNvaW5Qcm92aWRlclBsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldEJsb2NrU3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Tb2NrZXRCbG9ja1N1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRFdmVudFN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuU29ja2V0RXZlbnRTdWJzY3JpYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0UGVuZGluZ1N1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuU29ja2V0UGVuZGluZ1N1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlNvY2tldFN1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbm1hbmFnZWRTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlVubWFuYWdlZFN1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5UmVxdWVzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5jb3B5UmVxdWVzdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNob3dUaHJvdHRsZU1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuc2hvd1Rocm90dGxlTWVzc2FnZTsgfSB9KTtcbnZhciBpbmRleF9qc184ID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhY2Nlc3NMaXN0aWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc184LmFjY2Vzc0xpc3RpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOC5jb21wdXRlQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlY292ZXJBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc184LnJlY292ZXJBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzguVHJhbnNhY3Rpb247IH0gfSk7XG52YXIgaW5kZXhfanNfOSA9IHJlcXVpcmUoXCIuL3V0aWxzL2luZGV4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQmFzZTU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmRlY29kZUJhc2U1ODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUJhc2U1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5lbmNvZGVCYXNlNTg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVCYXNlNjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGVjb2RlQmFzZTY0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQmFzZTY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmVuY29kZUJhc2U2NDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5jb25jYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkYXRhTGVuZ3RoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmRhdGFMZW5ndGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkYXRhU2xpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGF0YVNsaWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZ2V0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCeXRlc0NvcHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZ2V0Qnl0ZXNDb3B5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4bGlmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5oZXhsaWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuaXNIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0J5dGVzTGlrZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5pc0J5dGVzTGlrZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmlwWmVyb3NMZWZ0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnN0cmlwWmVyb3NMZWZ0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiemVyb1BhZEJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185Lnplcm9QYWRCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInplcm9QYWRWYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS56ZXJvUGFkVmFsdWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZpbmVQcm9wZXJ0aWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmRlZmluZVByb3BlcnRpZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlUHJvcGVydGllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5yZXNvbHZlUHJvcGVydGllczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5hc3NlcnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRBcmd1bWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5hc3NlcnRBcmd1bWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydEFyZ3VtZW50Q291bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuYXNzZXJ0QXJndW1lbnRDb3VudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydE5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5hc3NlcnROb3JtYWxpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRQcml2YXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmFzc2VydFByaXZhdGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkubWFrZUVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNDYWxsRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmlzQ2FsbEV4Y2VwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuaXNFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5FdmVudFBheWxvYWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFJlcXVlc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuRmV0Y2hSZXF1ZXN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hSZXNwb25zZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5GZXRjaFJlc3BvbnNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hDYW5jZWxTaWduYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuRmV0Y2hDYW5jZWxTaWduYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaXhlZE51bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5GaXhlZE51bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJpZ0ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5nZXRCaWdJbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXROdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZ2V0TnVtYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0VWludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5nZXRVaW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CZUFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvQmVBcnJheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmlnSW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvQmlnSW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CZUhleFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS50b0JlSGV4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9OdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9OdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1F1YW50aXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvUXVhbnRpdHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tVHdvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5mcm9tVHdvczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVHdvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS50b1R3b3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185Lm1hc2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5mb3JtYXRFdGhlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRXRoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkucGFyc2VFdGhlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdFVuaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmZvcm1hdFVuaXRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VVbml0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5wYXJzZVVuaXRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9VdGY4Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhDb2RlUG9pbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvVXRmOENvZGVQb2ludHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9VdGY4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRmOEVycm9yRnVuY3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuVXRmOEVycm9yRnVuY3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVSbHBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGVjb2RlUmxwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlUmxwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmVuY29kZVJscDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV1aWRWNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS51dWlkVjQ7IH0gfSk7XG52YXIgaW5kZXhfanNfMTAgPSByZXF1aXJlKFwiLi93YWxsZXQvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNbmVtb25pY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuTW5lbW9uaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5CYXNlV2FsbGV0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSEROb2RlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5IRE5vZGVXYWxsZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIRE5vZGVWb2lkV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5IRE5vZGVWb2lkV2FsbGV0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5XYWxsZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZGVmYXVsdFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBY2NvdW50UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZ2V0QWNjb3VudFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbmRleGVkQWNjb3VudFBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmdldEluZGV4ZWRBY2NvdW50UGF0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQ3Jvd2RzYWxlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuaXNDcm93ZHNhbGVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNLZXlzdG9yZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmlzS2V5c3RvcmVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdENyb3dkc2FsZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmRlY3J5cHRDcm93ZHNhbGVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdEtleXN0b3JlSnNvblN5bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmRlY3J5cHRLZXlzdG9yZUpzb25TeW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdEtleXN0b3JlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZGVjcnlwdEtleXN0b3JlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY3J5cHRLZXlzdG9yZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmVuY3J5cHRLZXlzdG9yZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNyeXB0S2V5c3RvcmVKc29uU3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZW5jcnlwdEtleXN0b3JlSnNvblN5bmM7IH0gfSk7XG52YXIgaW5kZXhfanNfMTEgPSByZXF1aXJlKFwiLi93b3JkbGlzdHMvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JkbGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTEuV29yZGxpc3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMYW5nRW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzExLkxhbmdFbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0T3dsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMS5Xb3JkbGlzdE93bDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0T3dsQVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTEuV29yZGxpc3RPd2xBOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid29yZGxpc3RzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMS53b3JkbGlzdHM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/ethers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/hash/id.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/id.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.id = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */\nfunction id(value) {\n    return (0, index_js_1.keccak256)((0, index_js_2.toUtf8Bytes)(value));\n}\nexports.id = id;\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL2lkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFVBQVU7QUFDVixtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL2lkLmpzPzYwODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlkID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIGlkKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmtlY2NhazI1NikoKDAsIGluZGV4X2pzXzIudG9VdGY4Qnl0ZXMpKHZhbHVlKSk7XG59XG5leHBvcnRzLmlkID0gaWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/hash/id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Utilities for common tasks involving hashing. Also see\n *  [cryptographic hashing](about-crypto-hashing).\n *\n *  @_section: api/hashing:Hashing Utilities  [about-hashing]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = void 0;\nvar id_js_1 = __webpack_require__(/*! ./id.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/id.js\");\nObject.defineProperty(exports, \"id\", ({ enumerable: true, get: function () { return id_js_1.id; } }));\nvar namehash_js_1 = __webpack_require__(/*! ./namehash.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/namehash.js\");\nObject.defineProperty(exports, \"ensNormalize\", ({ enumerable: true, get: function () { return namehash_js_1.ensNormalize; } }));\nObject.defineProperty(exports, \"isValidName\", ({ enumerable: true, get: function () { return namehash_js_1.isValidName; } }));\nObject.defineProperty(exports, \"namehash\", ({ enumerable: true, get: function () { return namehash_js_1.namehash; } }));\nObject.defineProperty(exports, \"dnsEncode\", ({ enumerable: true, get: function () { return namehash_js_1.dnsEncode; } }));\nvar message_js_1 = __webpack_require__(/*! ./message.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/message.js\");\nObject.defineProperty(exports, \"hashMessage\", ({ enumerable: true, get: function () { return message_js_1.hashMessage; } }));\nObject.defineProperty(exports, \"verifyMessage\", ({ enumerable: true, get: function () { return message_js_1.verifyMessage; } }));\nvar solidity_js_1 = __webpack_require__(/*! ./solidity.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/solidity.js\");\nObject.defineProperty(exports, \"solidityPacked\", ({ enumerable: true, get: function () { return solidity_js_1.solidityPacked; } }));\nObject.defineProperty(exports, \"solidityPackedKeccak256\", ({ enumerable: true, get: function () { return solidity_js_1.solidityPackedKeccak256; } }));\nObject.defineProperty(exports, \"solidityPackedSha256\", ({ enumerable: true, get: function () { return solidity_js_1.solidityPackedSha256; } }));\nvar typed_data_js_1 = __webpack_require__(/*! ./typed-data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/typed-data.js\");\nObject.defineProperty(exports, \"TypedDataEncoder\", ({ enumerable: true, get: function () { return typed_data_js_1.TypedDataEncoder; } }));\nObject.defineProperty(exports, \"verifyTypedData\", ({ enumerable: true, get: function () { return typed_data_js_1.verifyTypedData; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLFVBQVU7QUFDM1IsY0FBYyxtQkFBTyxDQUFDLG9FQUFTO0FBQy9CLHNDQUFxQyxFQUFFLHFDQUFxQyxzQkFBc0IsRUFBQztBQUNuRyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUMzQyxnREFBK0MsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDN0gsK0NBQThDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzNILDRDQUEyQyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUNySCw2Q0FBNEMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDdkgsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWM7QUFDekMsK0NBQThDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzFILGlEQUFnRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM5SCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUMzQyxrREFBaUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDakksMkRBQTBELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQ25KLHdEQUF1RCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUM3SSxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDL0Msb0RBQW1ELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3ZJLG1EQUFrRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUNySSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2hhc2gvaW5kZXguanM/NjQ5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFV0aWxpdGllcyBmb3IgY29tbW9uIHRhc2tzIGludm9sdmluZyBoYXNoaW5nLiBBbHNvIHNlZVxuICogIFtjcnlwdG9ncmFwaGljIGhhc2hpbmddKGFib3V0LWNyeXB0by1oYXNoaW5nKS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvaGFzaGluZzpIYXNoaW5nIFV0aWxpdGllcyAgW2Fib3V0LWhhc2hpbmddXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5VHlwZWREYXRhID0gZXhwb3J0cy5UeXBlZERhdGFFbmNvZGVyID0gZXhwb3J0cy5zb2xpZGl0eVBhY2tlZFNoYTI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYgPSBleHBvcnRzLnNvbGlkaXR5UGFja2VkID0gZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gZXhwb3J0cy5oYXNoTWVzc2FnZSA9IGV4cG9ydHMuZG5zRW5jb2RlID0gZXhwb3J0cy5uYW1laGFzaCA9IGV4cG9ydHMuaXNWYWxpZE5hbWUgPSBleHBvcnRzLmVuc05vcm1hbGl6ZSA9IGV4cG9ydHMuaWQgPSB2b2lkIDA7XG52YXIgaWRfanNfMSA9IHJlcXVpcmUoXCIuL2lkLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlkX2pzXzEuaWQ7IH0gfSk7XG52YXIgbmFtZWhhc2hfanNfMSA9IHJlcXVpcmUoXCIuL25hbWVoYXNoLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5zTm9ybWFsaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1laGFzaF9qc18xLmVuc05vcm1hbGl6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWROYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1laGFzaF9qc18xLmlzVmFsaWROYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmFtZWhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWVoYXNoX2pzXzEubmFtZWhhc2g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkbnNFbmNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWVoYXNoX2pzXzEuZG5zRW5jb2RlOyB9IH0pO1xudmFyIG1lc3NhZ2VfanNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2UuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNoTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZV9qc18xLmhhc2hNZXNzYWdlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyaWZ5TWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZV9qc18xLnZlcmlmeU1lc3NhZ2U7IH0gfSk7XG52YXIgc29saWRpdHlfanNfMSA9IHJlcXVpcmUoXCIuL3NvbGlkaXR5LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlQYWNrZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvbGlkaXR5X2pzXzEuc29saWRpdHlQYWNrZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb2xpZGl0eVBhY2tlZEtlY2NhazI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29saWRpdHlfanNfMS5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNvbGlkaXR5UGFja2VkU2hhMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2xpZGl0eV9qc18xLnNvbGlkaXR5UGFja2VkU2hhMjU2OyB9IH0pO1xudmFyIHR5cGVkX2RhdGFfanNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWRhdGEuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlZERhdGFFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlZF9kYXRhX2pzXzEuVHlwZWREYXRhRW5jb2RlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcmlmeVR5cGVkRGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZWRfZGF0YV9qc18xLnZlcmlmeVR5cGVkRGF0YTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/hash/message.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/message.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyMessage = exports.hashMessage = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  Computes the [[link-eip-191]] personal-sign message digest to sign.\n *\n *  This prefixes the message with [[MessagePrefix]] and the decimal length\n *  of %%message%% and computes the [[keccak256]] digest.\n *\n *  If %%message%% is a string, it is converted to its UTF-8 bytes\n *  first. To compute the digest of a [[DataHexString]], it must be converted\n *  to [bytes](getBytes).\n *\n *  @example:\n *    hashMessage(\"Hello World\")\n *    //_result:\n *\n *    // Hashes the SIX (6) string characters, i.e.\n *    // [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\n *    hashMessage(\"0x4243\")\n *    //_result:\n *\n *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\n *    hashMessage(getBytes(\"0x4243\"))\n *    //_result:\n *\n *    // ...which is equal to using data\n *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))\n *    //_result:\n *\n */\nfunction hashMessage(message) {\n    if (typeof (message) === \"string\") {\n        message = (0, index_js_4.toUtf8Bytes)(message);\n    }\n    return (0, index_js_1.keccak256)((0, index_js_4.concat)([\n        (0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix),\n        (0, index_js_4.toUtf8Bytes)(String(message.length)),\n        message\n    ]));\n}\nexports.hashMessage = hashMessage;\n/**\n *  Return the address of the private key that produced\n *  the signature %%sig%% during signing for %%message%%.\n */\nfunction verifyMessage(message, sig) {\n    const digest = hashMessage(message);\n    return (0, index_js_3.recoverAddress)(digest, sig);\n}\nexports.verifyMessage = verifyMessage;\n//# sourceMappingURL=message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsbUJBQW1CO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBdUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsOEZBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL21lc3NhZ2UuanM/YjJlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5TWVzc2FnZSA9IGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vKipcbiAqICBDb21wdXRlcyB0aGUgW1tsaW5rLWVpcC0xOTFdXSBwZXJzb25hbC1zaWduIG1lc3NhZ2UgZGlnZXN0IHRvIHNpZ24uXG4gKlxuICogIFRoaXMgcHJlZml4ZXMgdGhlIG1lc3NhZ2Ugd2l0aCBbW01lc3NhZ2VQcmVmaXhdXSBhbmQgdGhlIGRlY2ltYWwgbGVuZ3RoXG4gKiAgb2YgJSVtZXNzYWdlJSUgYW5kIGNvbXB1dGVzIHRoZSBbW2tlY2NhazI1Nl1dIGRpZ2VzdC5cbiAqXG4gKiAgSWYgJSVtZXNzYWdlJSUgaXMgYSBzdHJpbmcsIGl0IGlzIGNvbnZlcnRlZCB0byBpdHMgVVRGLTggYnl0ZXNcbiAqICBmaXJzdC4gVG8gY29tcHV0ZSB0aGUgZGlnZXN0IG9mIGEgW1tEYXRhSGV4U3RyaW5nXV0sIGl0IG11c3QgYmUgY29udmVydGVkXG4gKiAgdG8gW2J5dGVzXShnZXRCeXRlcykuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgaGFzaE1lc3NhZ2UoXCJIZWxsbyBXb3JsZFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEhhc2hlcyB0aGUgU0lYICg2KSBzdHJpbmcgY2hhcmFjdGVycywgaS5lLlxuICogICAgLy8gWyBcIjBcIiwgXCJ4XCIsIFwiNFwiLCBcIjJcIiwgXCI0XCIsIFwiM1wiIF1cbiAqICAgIGhhc2hNZXNzYWdlKFwiMHg0MjQzXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSGFzaGVzIHRoZSBUV08gKDIpIGJ5dGVzIFsgMHg0MiwgMHg0MyBdLi4uXG4gKiAgICBoYXNoTWVzc2FnZShnZXRCeXRlcyhcIjB4NDI0M1wiKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyAuLi53aGljaCBpcyBlcXVhbCB0byB1c2luZyBkYXRhXG4gKiAgICBoYXNoTWVzc2FnZShuZXcgVWludDhBcnJheShbIDB4NDIsIDB4NDMgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5mdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9ICgwLCBpbmRleF9qc180LnRvVXRmOEJ5dGVzKShtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmtlY2NhazI1NikoKDAsIGluZGV4X2pzXzQuY29uY2F0KShbXG4gICAgICAgICgwLCBpbmRleF9qc180LnRvVXRmOEJ5dGVzKShpbmRleF9qc18yLk1lc3NhZ2VQcmVmaXgpLFxuICAgICAgICAoMCwgaW5kZXhfanNfNC50b1V0ZjhCeXRlcykoU3RyaW5nKG1lc3NhZ2UubGVuZ3RoKSksXG4gICAgICAgIG1lc3NhZ2VcbiAgICBdKSk7XG59XG5leHBvcnRzLmhhc2hNZXNzYWdlID0gaGFzaE1lc3NhZ2U7XG4vKipcbiAqICBSZXR1cm4gdGhlIGFkZHJlc3Mgb2YgdGhlIHByaXZhdGUga2V5IHRoYXQgcHJvZHVjZWRcbiAqICB0aGUgc2lnbmF0dXJlICUlc2lnJSUgZHVyaW5nIHNpZ25pbmcgZm9yICUlbWVzc2FnZSUlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnlNZXNzYWdlKG1lc3NhZ2UsIHNpZykge1xuICAgIGNvbnN0IGRpZ2VzdCA9IGhhc2hNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5yZWNvdmVyQWRkcmVzcykoZGlnZXN0LCBzaWcpO1xufVxuZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gdmVyaWZ5TWVzc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/hash/message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/hash/namehash.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/namehash.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst ens_normalize_1 = __webpack_require__(/*! @adraffy/ens-normalize */ \"(ssr)/./node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs\");\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0, index_js_2.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0, index_js_2.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */\nfunction ensNormalize(name) {\n    try {\n        if (name.length === 0) {\n            throw new Error(\"empty label\");\n        }\n        return (0, ens_normalize_1.ens_normalize)(name);\n    }\n    catch (error) {\n        (0, index_js_2.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\nexports.ensNormalize = ensNormalize;\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */\nfunction isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nexports.isValidName = isValidName;\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */\nfunction namehash(name) {\n    (0, index_js_2.assertArgument)(typeof (name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    (0, index_js_2.assertArgument)(name.length, `invalid ENS name (empty label)`, \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = (0, index_js_1.keccak256)((0, index_js_2.concat)([result, (0, index_js_1.keccak256)((comps.pop()))]));\n    }\n    return (0, index_js_2.hexlify)(result);\n}\nexports.namehash = namehash;\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */\nfunction dnsEncode(name, _maxLength) {\n    const length = (_maxLength != null) ? _maxLength : 63;\n    (0, index_js_2.assertArgument)(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n    return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map((comp) => {\n        (0, index_js_2.assertArgument)(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, \"name\", name);\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\nexports.dnsEncode = dnsEncode;\n//# sourceMappingURL=namehash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL25hbWVoYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQjtBQUNqRixtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLHdCQUF3QixtQkFBTyxDQUFDLDhHQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxjQUFjO0FBQ2pGO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxzQkFBc0IsVUFBVSxRQUFRO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvaGFzaC9uYW1laGFzaC5qcz9jN2UzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kbnNFbmNvZGUgPSBleHBvcnRzLm5hbWVoYXNoID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGV4cG9ydHMuZW5zTm9ybWFsaXplID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgZW5zX25vcm1hbGl6ZV8xID0gcmVxdWlyZShcIkBhZHJhZmZ5L2Vucy1ub3JtYWxpemVcIik7XG5jb25zdCBaZXJvcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcblplcm9zLmZpbGwoMCk7XG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudChjb21wKSB7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzIudG9VdGY4Qnl0ZXMpKGVuc05vcm1hbGl6ZShuYW1lKSk7XG4gICAgY29uc3QgY29tcHMgPSBbXTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XG4gICAgICAgIC8vIEEgc2VwYXJhdG9yIChpLmUuIFwiLlwiKTsgY29weSB0aGlzIGNvbXBvbmVudFxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xuICAgICAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlIHdhcyBhIHN0cmF5IHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGxhc3QgPCBieXRlcy5sZW5ndGgsIFwiaW52YWxpZCBFTlMgbmFtZTsgZW1wdHkgY29tcG9uZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QpKSk7XG4gICAgcmV0dXJuIGNvbXBzO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRU5TICUlbmFtZSUlIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIGVuc05vcm1hbGl6ZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBsYWJlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGVuc19ub3JtYWxpemVfMS5lbnNfbm9ybWFsaXplKShuYW1lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGludmFsaWQgRU5TIG5hbWUgKCR7ZXJyb3IubWVzc2FnZX0pYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5zTm9ybWFsaXplID0gZW5zTm9ybWFsaXplO1xuLyoqXG4gKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJW5hbWUlJSBpcyBhIHZhbGlkIEVOUyBuYW1lLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVmFsaWROYW1lID0gaXNWYWxpZE5hbWU7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShuYW1lLmxlbmd0aCwgYGludmFsaWQgRU5TIG5hbWUgKGVtcHR5IGxhYmVsKWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSAoMCwgaW5kZXhfanNfMS5rZWNjYWsyNTYpKCgwLCBpbmRleF9qc18yLmNvbmNhdCkoW3Jlc3VsdCwgKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoY29tcHMucG9wKCkpKV0pKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmhleGxpZnkpKHJlc3VsdCk7XG59XG5leHBvcnRzLm5hbWVoYXNoID0gbmFtZWhhc2g7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBETlMgZW5jb2RlZCAlJW5hbWUlJS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VkIGZvciB2YXJpb3VzIHBhcnRzIG9mIEVOUyBuYW1lIHJlc29sdXRpb24sIHN1Y2hcbiAqICBhcyB0aGUgd2lsZGNhcmQgcmVzb2x1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUsIF9tYXhMZW5ndGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSAoX21heExlbmd0aCAhPSBudWxsKSA/IF9tYXhMZW5ndGggOiA2MztcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkobGVuZ3RoIDw9IDI1NSwgXCJETlMgZW5jb2RlZCBsYWJlbCBjYW5ub3QgZXhjZWVkIDI1NVwiLCBcImxlbmd0aFwiLCBsZW5ndGgpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMi5jb25jYXQpKGVuc05hbWVTcGxpdChuYW1lKS5tYXAoKGNvbXApID0+IHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGNvbXAubGVuZ3RoIDw9IGxlbmd0aCwgYGxhYmVsICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGV4Y2VlZHMgJHtsZW5ndGh9IGJ5dGVzYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvbXAubGVuZ3RoICsgMSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSkpKSArIFwiMDBcIjtcbn1cbmV4cG9ydHMuZG5zRW5jb2RlID0gZG5zRW5jb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/hash/namehash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/hash/solidity.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/solidity.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nfunction _pack(type, value, isArray) {\n    switch (type) {\n        case \"address\":\n            if (isArray) {\n                return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));\n            }\n            return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));\n        case \"string\":\n            return (0, index_js_3.toUtf8Bytes)(value);\n        case \"bytes\":\n            return (0, index_js_3.getBytes)(value);\n        case \"bool\":\n            value = (!!value ? \"0x01\" : \"0x00\");\n            if (isArray) {\n                return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));\n            }\n            return (0, index_js_3.getBytes)(value);\n    }\n    let match = type.match(regexNumber);\n    if (match) {\n        let signed = (match[1] === \"int\");\n        let size = parseInt(match[2] || \"256\");\n        (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size)) && (size % 8 === 0) && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n        if (isArray) {\n            size = 256;\n        }\n        if (signed) {\n            value = (0, index_js_3.toTwos)(value, size);\n        }\n        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size / 8));\n    }\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n        (0, index_js_3.assertArgument)(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\n        (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === size, `invalid value for ${type}`, \"value\", value);\n        if (isArray) {\n            return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));\n        }\n        return value;\n    }\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        (0, index_js_3.assertArgument)(count === value.length, `invalid array length for ${type}`, \"value\", value);\n        const result = [];\n        value.forEach(function (value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));\n    }\n    (0, index_js_3.assertArgument)(false, \"invalid type\", \"type\", type);\n}\n// @TODO: Array Enum\n/**\n *   Computes the [[link-solc-packed]] representation of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPacked(types, values) {\n    (0, index_js_3.assertArgument)(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n    const tight = [];\n    types.forEach(function (type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));\n}\nexports.solidityPacked = solidityPacked;\n/**\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPackedKeccak256(types, values) {\n    return (0, index_js_2.keccak256)(solidityPacked(types, values));\n}\nexports.solidityPackedKeccak256 = solidityPackedKeccak256;\n/**\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPackedSha256(types, values) {\n    return (0, index_js_2.sha256)(solidityPacked(types, values));\n}\nexports.solidityPackedSha256 = solidityPackedSha256;\n//# sourceMappingURL=solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL3NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLCtCQUErQixHQUFHLHNCQUFzQjtBQUN2RixtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQW9CO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLEtBQUs7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLEtBQUs7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixZQUFZLGNBQWM7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2hhc2gvc29saWRpdHkuanM/NmQxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc29saWRpdHlQYWNrZWRTaGEyNTYgPSBleHBvcnRzLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2ID0gZXhwb3J0cy5zb2xpZGl0eVBhY2tlZCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHJlZ2V4Qnl0ZXMgPSBuZXcgUmVnRXhwKFwiXmJ5dGVzKFswLTldKykkXCIpO1xuY29uc3QgcmVnZXhOdW1iZXIgPSBuZXcgUmVnRXhwKFwiXih1P2ludCkoWzAtOV0qKSRcIik7XG5jb25zdCByZWdleEFycmF5ID0gbmV3IFJlZ0V4cChcIl4oLiopXFxcXFsoWzAtOV0qKVxcXFxdJFwiKTtcbmZ1bmN0aW9uIF9wYWNrKHR5cGUsIHZhbHVlLCBpc0FycmF5KSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKSh2YWx1ZSwgMzIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLnRvVXRmOEJ5dGVzKSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICB2YWx1ZSA9ICghIXZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKSh2YWx1ZSwgMzIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykodmFsdWUpO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4TnVtYmVyKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJpbnRcIik7XG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSgoIW1hdGNoWzJdIHx8IG1hdGNoWzJdID09PSBTdHJpbmcoc2l6ZSkpICYmIChzaXplICUgOCA9PT0gMCkgJiYgc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiwgXCJpbnZhbGlkIG51bWJlciB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIHNpemUgPSAyNTY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgaW5kZXhfanNfMy50b1R3b3MpKHZhbHVlLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18zLnplcm9QYWRWYWx1ZSkoKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KSh2YWx1ZSksIHNpemUgLyA4KSk7XG4gICAgfVxuICAgIG1hdGNoID0gdHlwZS5tYXRjaChyZWdleEJ5dGVzKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKFN0cmluZyhzaXplKSA9PT0gbWF0Y2hbMV0gJiYgc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMy5kYXRhTGVuZ3RoKSh2YWx1ZSkgPT09IHNpemUsIGBpbnZhbGlkIHZhbHVlIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18zLnplcm9QYWRCeXRlcykodmFsdWUsIDMyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheSk7XG4gICAgaWYgKG1hdGNoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGJhc2VUeXBlID0gbWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgU3RyaW5nKHZhbHVlLmxlbmd0aCkpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGludmFsaWQgYXJyYXkgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goX3BhY2soYmFzZVR5cGUsIHZhbHVlLCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18zLmNvbmNhdCkocmVzdWx0KSk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xufVxuLy8gQFRPRE86IEFycmF5IEVudW1cbi8qKlxuICogICBDb21wdXRlcyB0aGUgW1tsaW5rLXNvbGMtcGFja2VkXV0gcmVwcmVzZW50YXRpb24gb2YgJSV2YWx1ZXMlJVxuICogICByZXNwZWN0aXZlbHkgdG8gdGhlaXIgJSV0eXBlcyUlLlxuICpcbiAqICAgQGV4YW1wbGU6XG4gKiAgICAgICBhZGRyID0gXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIlxuICogICAgICAgc29saWRpdHlQYWNrZWQoWyBcImFkZHJlc3NcIiwgXCJ1aW50XCIgXSwgWyBhZGRyLCA0NSBdKTtcbiAqICAgICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gc29saWRpdHlQYWNrZWQodHlwZXMsIHZhbHVlcykge1xuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh0eXBlcy5sZW5ndGggPT09IHZhbHVlcy5sZW5ndGgsIFwid3JvbmcgbnVtYmVyIG9mIHZhbHVlczsgZXhwZWN0ZWQgJHsgdHlwZXMubGVuZ3RoIH1cIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICBjb25zdCB0aWdodCA9IFtdO1xuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgICAgIHRpZ2h0LnB1c2goX3BhY2sodHlwZSwgdmFsdWVzW2luZGV4XSkpO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMy5jb25jYXQpKHRpZ2h0KSk7XG59XG5leHBvcnRzLnNvbGlkaXR5UGFja2VkID0gc29saWRpdHlQYWNrZWQ7XG4vKipcbiAqICAgQ29tcHV0ZXMgdGhlIFtbbGluay1zb2xjLXBhY2tlZF1dIFtba2VjY2FrMjU2XV0gaGFzaCBvZiAlJXZhbHVlcyUlXG4gKiAgIHJlc3BlY3RpdmVseSB0byB0aGVpciAlJXR5cGVzJSUuXG4gKlxuICogICBAZXhhbXBsZTpcbiAqICAgICAgIGFkZHIgPSBcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiXG4gKiAgICAgICBzb2xpZGl0eVBhY2tlZEtlY2NhazI1NihbIFwiYWRkcmVzc1wiLCBcInVpbnRcIiBdLCBbIGFkZHIsIDQ1IF0pO1xuICogICAgICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBzb2xpZGl0eVBhY2tlZEtlY2NhazI1Nih0eXBlcywgdmFsdWVzKSB7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1Nikoc29saWRpdHlQYWNrZWQodHlwZXMsIHZhbHVlcykpO1xufVxuZXhwb3J0cy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NiA9IHNvbGlkaXR5UGFja2VkS2VjY2FrMjU2O1xuLyoqXG4gKiAgIENvbXB1dGVzIHRoZSBbW2xpbmstc29sYy1wYWNrZWRdXSBbW3NoYTI1Nl1dIGhhc2ggb2YgJSV2YWx1ZXMlJVxuICogICByZXNwZWN0aXZlbHkgdG8gdGhlaXIgJSV0eXBlcyUlLlxuICpcbiAqICAgQGV4YW1wbGU6XG4gKiAgICAgICBhZGRyID0gXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIlxuICogICAgICAgc29saWRpdHlQYWNrZWRTaGEyNTYoWyBcImFkZHJlc3NcIiwgXCJ1aW50XCIgXSwgWyBhZGRyLCA0NSBdKTtcbiAqICAgICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gc29saWRpdHlQYWNrZWRTaGEyNTYodHlwZXMsIHZhbHVlcykge1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5zaGEyNTYpKHNvbGlkaXR5UGFja2VkKHR5cGVzLCB2YWx1ZXMpKTtcbn1cbmV4cG9ydHMuc29saWRpdHlQYWNrZWRTaGEyNTYgPSBzb2xpZGl0eVBhY2tlZFNoYTI1Njtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvbGlkaXR5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/hash/solidity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/hash/typed-data.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/typed-data.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyTypedData = exports.TypedDataEncoder = void 0;\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst id_js_1 = __webpack_require__(/*! ./id.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/id.js\");\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0, index_js_4.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0, index_js_4.concat)([bytes, padding.slice(padOffset)]);\n    }\n    return (0, index_js_4.hexlify)(bytes);\n}\nconst hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);\nconst hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        (0, index_js_4.assertArgument)(typeof (value) === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (_value) {\n        const value = (0, index_js_4.getBigInt)(_value, \"domain.chainId\");\n        (0, index_js_4.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0, index_js_4.toQuantity)(value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return (0, index_js_1.getAddress)(value).toLowerCase();\n        }\n        catch (error) { }\n        (0, index_js_4.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        const bytes = (0, index_js_4.getBytes)(value, \"domain.salt\");\n        (0, index_js_4.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return (0, index_js_4.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d+)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2]);\n            (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed ? (width - 1) : width);\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0;\n            return function (_value) {\n                const value = (0, index_js_4.getBigInt)(_value, \"value\");\n                (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return (0, index_js_4.toBeHex)(signed ? (0, index_js_4.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0, index_js_4.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function (value) {\n                const bytes = (0, index_js_4.getBytes)(value);\n                (0, index_js_4.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return (0, index_js_2.keccak256)(value);\n        };\n        case \"string\": return function (value) {\n            return (0, id_js_1.id)(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\nfunction splitArray(type) {\n    const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n        return {\n            base: match[1],\n            index: (match[2] + match[4]),\n            array: {\n                base: match[1],\n                prefix: (match[1] + match[2]),\n                count: (match[5] ? parseInt(match[5]) : -1),\n            }\n        };\n    }\n    return { base: type };\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nclass TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only remaining type with\n     *  no parent nodes.\n     */\n    primaryType;\n    #types;\n    /**\n     *  The types.\n     */\n    get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */\n    constructor(_types) {\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        const types = {};\n        Object.keys(_types).forEach((type) => {\n            types[type] = _types[type].map(({ name, type }) => {\n                // Normalize the base type (unless name conflict)\n                let { base, index } = splitArray(type);\n                if (base === \"int\" && !_types[\"int\"]) {\n                    base = \"int256\";\n                }\n                if (base === \"uint\" && !_types[\"uint\"]) {\n                    base = \"uint256\";\n                }\n                return { name, type: (base + (index || \"\")) };\n            });\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        this.#types = JSON.stringify(types);\n        for (const name in types) {\n            const uniqueNames = new Set();\n            for (const field of types[name]) {\n                // Check each field has a unique name\n                (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", _types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = splitArray(field.type).base;\n                (0, index_js_4.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0, index_js_4.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));\n        (0, index_js_4.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types);\n        (0, index_js_4.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", _types);\n        (0, index_js_4.defineProperties)(this, { primaryType: primaryTypes[0] });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0, index_js_4.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", _types);\n            found.add(type);\n            for (const child of links.get(type)) {\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found) {\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes) {\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */\n    getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            const subtype = array.prefix;\n            const subEncoder = this.getEncoder(subtype);\n            return (value) => {\n                (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(index_js_2.keccak256);\n                }\n                return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0, id_js_1.id)(this.#fullTypes.get(type));\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return (0, index_js_2.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0, index_js_4.concat)(values);\n            };\n        }\n        (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */\n    encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        (0, index_js_4.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */\n    hashStruct(name, value) {\n        return (0, index_js_2.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n            return value.map((v) => this._visit(array.prefix, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0, index_js_4.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static encode(domain, types, value) {\n        return (0, index_js_4.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static hash(domain, types, value) {\n        return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */\n    static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for (const key in domain) {\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value) => {\n            if (type === \"address\" && !(0, index_js_4.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value) => {\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return { domain, value };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        // Get the normalized types\n        types = encoder.types;\n        const typesWithDomain = Object.assign({}, types);\n        (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0, index_js_4.getBigInt)(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0, index_js_4.assertArgument)(typeof (value) === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0, index_js_4.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\nexports.TypedDataEncoder = TypedDataEncoder;\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nfunction verifyTypedData(domain, types, value, signature) {\n    return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n}\nexports.verifyTypedData = verifyTypedData;\n//# sourceMappingURL=typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL3R5cGVkLWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsd0JBQXdCO0FBQ2xELFdBQVcsa0NBQWtDO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsOEZBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csb0JBQW9CLGFBQWEsSUFBSTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILEtBQUs7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLEtBQUs7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLEdBQUcsY0FBYyxZQUFZLG9DQUFvQztBQUNwRjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLDRCQUE0QixLQUFLLHFCQUFxQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0cseUJBQXlCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YseUJBQXlCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsd0RBQXdEO0FBQ3RLLGlEQUFpRCw4QkFBOEI7QUFDL0U7QUFDQTtBQUNBLDJGQUEyRixxQkFBcUI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySCxrQkFBa0IsWUFBWTtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEtBQUs7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHFCQUFxQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxrQkFBa0IsWUFBWTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixxQkFBcUI7QUFDeEcsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZEQUE2RCw0QkFBNEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQ0FBb0M7QUFDbkUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2hhc2gvdHlwZWQtZGF0YS5qcz80YWNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJpZnlUeXBlZERhdGEgPSBleHBvcnRzLlR5cGVkRGF0YUVuY29kZXIgPSB2b2lkIDA7XG4vL2ltcG9ydCB7IFR5cGVkRGF0YURvbWFpbiwgVHlwZWREYXRhRmllbGQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJhYnN0cmFjdC1zaWduZXJcIjtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBpZF9qc18xID0gcmVxdWlyZShcIi4vaWQuanNcIik7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgQk5fXzEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbjtcbjtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykodmFsdWUpO1xuICAgIGNvbnN0IHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmNvbmNhdCkoW2J5dGVzLCBwYWRkaW5nLnNsaWNlKHBhZE9mZnNldCldKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc180LmhleGxpZnkpKGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSAoMCwgaW5kZXhfanNfNC50b0JlSGV4KShCTl8xLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9ICgwLCBpbmRleF9qc180LnRvQmVIZXgpKEJOXzAsIDMyKTtcbmNvbnN0IGRvbWFpbkZpZWxkVHlwZXMgPSB7XG4gICAgbmFtZTogXCJzdHJpbmdcIixcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxuICAgIGNoYWluSWQ6IFwidWludDI1NlwiLFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcImFkZHJlc3NcIixcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxufTtcbmNvbnN0IGRvbWFpbkZpZWxkTmFtZXMgPSBbXG4gICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxuXTtcbmZ1bmN0aW9uIGNoZWNrU3RyaW5nKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzQuZ2V0QmlnSW50KShfdmFsdWUsIFwiZG9tYWluLmNoYWluSWRcIik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSAwLCBcImludmFsaWQgY2hhaW4gSURcIiwgXCJkb21haW4uY2hhaW5JZFwiLCBfdmFsdWUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQudG9RdWFudGl0eSkodmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNhbHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKSh2YWx1ZSwgXCJkb21haW4uc2FsdFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGJ5dGVzLmxlbmd0aCA9PT0gMzIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRCYXNlRW5jb2Rlcih0eXBlKSB7XG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiXCIpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkod2lkdGggJSA4ID09PSAwICYmIHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDI1NiAmJiBtYXRjaFsyXSA9PT0gU3RyaW5nKHdpZHRoKSwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSAoMCwgaW5kZXhfanNfNC5tYXNrKShCTl9NQVhfVUlOVDI1Niwgc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/ICgoYm91bmRzVXBwZXIgKyBCTl8xKSAqIEJOX18xKSA6IEJOXzA7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzQuZ2V0QmlnSW50KShfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC50b0JlSGV4KShzaWduZWQgPyAoMCwgaW5kZXhfanNfNC50b1R3b3MpKHZhbHVlLCAyNTYpIDogdmFsdWUsIDMyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYnl0ZXNYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkod2lkdGggIT09IDAgJiYgd2lkdGggPD0gMzIgJiYgbWF0Y2hbMV0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykodmFsdWUpO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShieXRlcy5sZW5ndGggPT09IHdpZHRoLCBgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4UGFkUmlnaHQodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180Lnplcm9QYWRWYWx1ZSkoKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaWRfanNfMS5pZCkodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG4vLyBmb29bXVszXSA9PiB7IGJhc2U6IFwiZm9vXCIsIGluZGV4OiBcIltdWzNdXCIsIGFycmF5OiB7XG4vLyAgICAgYmFzZTogXCJmb29cIiwgcHJlZml4OiBcImZvb1tdXCIsIGNvdW50OiAzIH0gfVxuZnVuY3Rpb24gc3BsaXRBcnJheSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoKFxceDViXFxkKlxceDVkKSopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICBpbmRleDogKG1hdGNoWzJdICsgbWF0Y2hbNF0pLFxuICAgICAgICAgICAgYXJyYXk6IHtcbiAgICAgICAgICAgICAgICBiYXNlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IChtYXRjaFsxXSArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBjb3VudDogKG1hdGNoWzVdID8gcGFyc2VJbnQobWF0Y2hbNV0pIDogLTEpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBiYXNlOiB0eXBlIH07XG59XG4vKipcbiAqICBBICoqVHlwZWREYXRhRW5jb2RlKiogcHJlcGFyZXMgYW5kIGVuY29kZXMgW1tsaW5rLWVpcC03MTJdXSBwYXlsb2Fkc1xuICogIGZvciBzaWduZWQgdHlwZWQgZGF0YS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHRob3NlIHRoYXQgd2lzaCB0byBjb21wdXRlIHZhcmlvdXMgY29tcG9uZW50cyBvZiBhXG4gKiAgdHlwZWQgZGF0YSBoYXNoLCBwcmltYXJ5IHR5cGVzLCBvciBzdWItY29tcG9uZW50cywgYnV0IGdlbmVyYWxseSB0aGVcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxuICovXG5jbGFzcyBUeXBlZERhdGFFbmNvZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByaW1hcnkgdHlwZSBmb3IgdGhlIHN0cnVjdHVyZWQgW1t0eXBlc11dLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZGVyaXZlZCBhdXRvbWF0aWNhbGx5IGZyb20gdGhlIFtbdHlwZXNdXSwgc2luY2Ugbm9cbiAgICAgKiAgcmVjdXJzaW9uIGlzIHBvc3NpYmxlLCBvbmNlIHRoZSBEQUcgZm9yIHRoZSB0eXBlcyBpcyBjb25zdHVyY3RlZFxuICAgICAqICBpbnRlcm5hbGx5LCB0aGUgcHJpbWFyeSB0eXBlIG11c3QgYmUgdGhlIG9ubHkgcmVtYWluaW5nIHR5cGUgd2l0aFxuICAgICAqICBubyBwYXJlbnQgbm9kZXMuXG4gICAgICovXG4gICAgcHJpbWFyeVR5cGU7XG4gICAgI3R5cGVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGVzKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLiN0eXBlcyk7XG4gICAgfVxuICAgICNmdWxsVHlwZXM7XG4gICAgI2VuY29kZXJDYWNoZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwZXJmb3JtcyBhbGwgbmVjZXNzYXJ5IGNoZWNraW5nIHRoYXQgdHlwZXMgYXJlIHZhbGlkIGFuZFxuICAgICAqICBkbyBub3QgdmlvbGF0ZSB0aGUgW1tsaW5rLWVpcC03MTJdXSBzdHJ1Y3R1cmFsIGNvbnN0cmFpbnRzIGFzXG4gICAgICogIHdlbGwgYXMgY29tcHV0ZXMgdGhlIFtbcHJpbWFyeVR5cGVdXS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfdHlwZXMpIHtcbiAgICAgICAgdGhpcy4jZnVsbFR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXG4gICAgICAgIGNvbnN0IGxpbmtzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuICAgICAgICBjb25zdCBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIGFsbCBzdWJ0eXBlcyB3aXRoaW4gYSBnaXZlbiBzdHJ1Y3RcbiAgICAgICAgY29uc3Qgc3VidHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKF90eXBlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgdHlwZXNbdHlwZV0gPSBfdHlwZXNbdHlwZV0ubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYmFzZSB0eXBlICh1bmxlc3MgbmFtZSBjb25mbGljdClcbiAgICAgICAgICAgICAgICBsZXQgeyBiYXNlLCBpbmRleCB9ID0gc3BsaXRBcnJheSh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCJpbnRcIiAmJiAhX3R5cGVzW1wiaW50XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcImludDI1NlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCJ1aW50XCIgJiYgIV90eXBlc1tcInVpbnRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IFwidWludDI1NlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lLCB0eXBlOiAoYmFzZSArIChpbmRleCB8fCBcIlwiKSkgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlua3Muc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBwYXJlbnRzLnNldCh0eXBlLCBbXSk7XG4gICAgICAgICAgICBzdWJ0eXBlcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI3R5cGVzID0gSlNPTi5zdHJpbmdpZnkodHlwZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoIXVuaXF1ZU5hbWVzLmhhcyhmaWVsZC5uYW1lKSwgYGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lICR7SlNPTi5zdHJpbmdpZnkoZmllbGQubmFtZSl9IGluICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHNwbGl0QXJyYXkoZmllbGQudHlwZSkuYmFzZTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoYmFzZVR5cGUgIT09IG5hbWUsIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBhIGJhc2UgZW5jb2RpbmcgdHlwZT9cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIoYmFzZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkocGFyZW50cy5oYXMoYmFzZVR5cGUpLCBgdW5rbm93biB0eXBlICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxuICAgICAgICAgICAgICAgIHBhcmVudHMuZ2V0KGJhc2VUeXBlKS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmtzLmdldChuYW1lKS5hZGQoYmFzZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlZHVjZSB0aGUgcHJpbWFyeSB0eXBlXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IEFycmF5LmZyb20ocGFyZW50cy5rZXlzKCkpLmZpbHRlcigobikgPT4gKHBhcmVudHMuZ2V0KG4pLmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkocHJpbWFyeVR5cGVzLmxlbmd0aCAhPT0gMCwgXCJtaXNzaW5nIHByaW1hcnkgdHlwZVwiLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAxLCBgYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiAke3ByaW1hcnlUeXBlcy5tYXAoKHQpID0+IChKU09OLnN0cmluZ2lmeSh0KSkpLmpvaW4oXCIsIFwiKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICgwLCBpbmRleF9qc180LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgcHJpbWFyeVR5cGU6IHByaW1hcnlUeXBlc1swXSB9KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NpcmN1bGFyKHR5cGUsIGZvdW5kKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoIWZvdW5kLmhhcyh0eXBlKSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgZm91bmQuYWRkKHR5cGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBsaW5rcy5nZXQodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHMuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2hlY2sgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBjaGVja0NpcmN1bGFyKGNoaWxkLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayBhbGwgYW5jZXN0b3JzIGFzIGhhdmluZyB0aGlzIGRlY2VuZGFudFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3VidHlwZSBvZiBmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlcy5nZXQoc3VidHlwZSkuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZC5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAvLyBDb21wdXRlIGVhY2ggZnVsbHkgZGVzY3JpYmUgdHlwZVxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzZXRdIG9mIHN1YnR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmZyb20oc2V0KTtcbiAgICAgICAgICAgIHN0LnNvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuI2Z1bGxUeXBlcy5zZXQobmFtZSwgZW5jb2RlVHlwZShuYW1lLCB0eXBlc1tuYW1lXSkgKyBzdC5tYXAoKHQpID0+IGVuY29kZVR5cGUodCwgdHlwZXNbdF0pKS5qb2luKFwiXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJudGhlIGVuY29kZXIgZm9yIHRoZSBzcGVjaWZpYyAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLiNlbmNvZGVyQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWVuY29kZXIpIHtcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLiNnZXRFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlLnNldCh0eXBlLCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICB9XG4gICAgI2dldEVuY29kZXIodHlwZSkge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBhcnJheSA9IHNwbGl0QXJyYXkodHlwZSkuYXJyYXk7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IGFycmF5LnByZWZpeDtcbiAgICAgICAgICAgIGNvbnN0IHN1YkVuY29kZXIgPSB0aGlzLmdldEVuY29kZXIoc3VidHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGFycmF5LmNvdW50ID09PSAtMSB8fCBhcnJheS5jb3VudCA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHthcnJheS5jb3VudH1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHN1YnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoaW5kZXhfanNfMi5rZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfNC5jb25jYXQpKHJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFR5cGUgPSAoMCwgaWRfanNfMS5pZCkodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmNvbmNhdCkodmFsdWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsIHR5cGUgZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdWxsVHlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkocmVzdWx0LCBgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgaGFzaCBvZiAlJXZhbHVlJSUgZm9yIHRoZSB0eXBlIG9mICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikodGhpcy5lbmNvZGVEYXRhKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGxlZCBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRGF0YSh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgW1t0eXBlc11dLlxuICAgICAqL1xuICAgIGhhc2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaFN0cnVjdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfdmlzaXQodHlwZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgYXJyYXkgPSBzcGxpdEFycmF5KHR5cGUpLmFycmF5O1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChhcnJheS5wcmVmaXgsIHYsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSwgeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuX3Zpc2l0KHR5cGUsIHZhbHVlW25hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbGwgJSVjYWxiYWNrJSUgZm9yIGVhY2ggdmFsdWUgaW4gJSV2YWx1ZSUlLCBwYXNzaW5nIHRoZSB0eXBlIGFuZFxuICAgICAqICBjb21wb25lbnQgd2l0aGluICUldmFsdWUlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgcmVwbGFjaW5nIGFkZHJlc3NlcyBvciBvdGhlciB0cmFuc2Zvcm1hdGlvbiB0aGF0XG4gICAgICogIG1heSBiZSBkZXNpcmVkIG9uIGVhY2ggY29tcG9uZW50LCBiYXNlZCBvbiBpdHMgdHlwZS5cbiAgICAgKi9cbiAgICB2aXNpdCh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipUeXBlZERhdGFFbmNvZGVyKiogZm9yICUldHlwZXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkRGF0YUVuY29kZXIodHlwZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBwcmltYXJ5IHR5cGUgZm9yICUldHlwZXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJpbWFyeVR5cGUodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykucHJpbWFyeVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2hlZCBzdHJ1Y3QgZm9yICUldmFsdWUlJSB1c2luZyAlJXR5cGVzJSUgYW5kICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoU3RydWN0KG5hbWUsIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoU3RydWN0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZG9tYWluIGhhc2ggZm9yICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hEb21haW4oZG9tYWluKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbkZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkb21haW5GaWVsZFR5cGVzW25hbWVdO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHR5cGUsIGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xuICAgICAgICAgICAgZG9tYWluRmllbGRzLnB1c2goeyBuYW1lLCB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGEubmFtZSkgLSBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBlbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmNvbmNhdCkoW1xuICAgICAgICAgICAgXCIweDE5MDFcIixcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KShUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlcyBhbGwgYWRkcmVzcyB0eXBlcyB3aXRoIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGxvb2tlZCB1cCBhZGRyZXNzXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gdGhlIHZhbHVlIGZyb20gcmVzb2x2aW5nIGFsbCBhZGRyZXNzZXMgaW4gJSV2YWx1ZSUlIGZvclxuICAgICAqICUldHlwZXMlJSBhbmQgdGhlICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgcmVzb2x2ZU5hbWUpIHtcbiAgICAgICAgLy8gTWFrZSBhIGNvcHkgdG8gaXNvbGF0ZSBpdCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIGluXG4gICAgICAgIGRvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIGRvbWFpbik7XG4gICAgICAgIC8vIEFsbG93IHBhc3NpbmcgbnVsbCB0byBpZ25vcmUgdmFsdWVcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkb21haW5ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIGFsbCBFTlMgbmFtZXNcbiAgICAgICAgY29uc3QgZW5zQ2FjaGUgPSB7fTtcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBsb29rIHVwIHRoZSBkb21haW4ncyB2ZXJpZnlpbmdDb250cmFjdD9cbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiAhKDAsIGluZGV4X2pzXzQuaXNIZXhTdHJpbmcpKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCwgMjApKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGVuY29kZXIgdG8gdmlzaXQgYWxsIHRoZSBiYXNlIHZhbHVlc1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgLy8gR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGFkZHJlc3Nlc1xuICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhKDAsIGluZGV4X2pzXzQuaXNIZXhTdHJpbmcpKHZhbHVlLCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBlbnNDYWNoZSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSBhd2FpdCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkb21haW4gdmVyaWZ5aW5nQ29udHJhY3QgaWYgbmVlZGVkXG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgZW5zQ2FjaGVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIEpTT04tZW5jb2RlZCBwYXlsb2FkIGV4cGVjdGVkIGJ5IG5vZGVzIHdoaWNoIGltcGxlbWVudFxuICAgICAqICB0aGUgSlNPTi1SUEMgW1tsaW5rLWVpcC03MTJdXSBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcbiAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxuICAgICAgICBjb25zdCBkb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluVmFsdWVzW25hbWVdID0gZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXplZCB0eXBlc1xuICAgICAgICB0eXBlcyA9IGVuY29kZXIudHlwZXM7XG4gICAgICAgIGNvbnN0IHR5cGVzV2l0aERvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGVzKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPT0gbnVsbCwgXCJ0eXBlcyBtdXN0IG5vdCBjb250YWluIEVJUDcxMkRvbWFpbiB0eXBlXCIsIFwidHlwZXMuRUlQNzEyRG9tYWluXCIsIHR5cGVzKTtcbiAgICAgICAgdHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9IGRvbWFpblR5cGVzO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCB0eXBlc1xuICAgICAgICBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlczogdHlwZXNXaXRoRG9tYWluLFxuICAgICAgICAgICAgZG9tYWluOiBkb21haW5WYWx1ZXMsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogZW5jb2Rlci5wcmltYXJ5VHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL15ieXRlcyhcXGQqKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmdldEJpZ0ludCkodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZWREYXRhRW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXI7XG4vKipcbiAqICBDb21wdXRlIHRoZSBhZGRyZXNzIHVzZWQgdG8gc2lnbiB0aGUgdHlwZWQgZGF0YSBmb3IgdGhlICUlc2lnbmF0dXJlJSUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeVR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18zLnJlY292ZXJBZGRyZXNzKShUeXBlZERhdGFFbmNvZGVyLmhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpLCBzaWduYXR1cmUpO1xufVxuZXhwb3J0cy52ZXJpZnlUeXBlZERhdGEgPSB2ZXJpZnlUeXBlZERhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/hash/typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ethers = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/ethers/node_modules/tslib/tslib.es6.js\");\n/**\n *  The Application Programming Interface (API) is the collection of\n *  functions, classes and types offered by the Ethers library.\n *\n *  @_section: api:Application Programming Interface  [about-api]\n *  @_navTitle: API\n */\nconst ethers = tslib_1.__importStar(__webpack_require__(/*! ./ethers.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/ethers.js\"));\nexports.ethers = ethers;\ntslib_1.__exportStar(__webpack_require__(/*! ./ethers.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/ethers.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQU8sQ0FBQyx1RUFBYTtBQUN6RCxjQUFjO0FBQ2QscUJBQXFCLG1CQUFPLENBQUMsdUVBQWE7QUFDMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9pbmRleC5qcz9hNmIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ldGhlcnMgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyoqXG4gKiAgVGhlIEFwcGxpY2F0aW9uIFByb2dyYW1taW5nIEludGVyZmFjZSAoQVBJKSBpcyB0aGUgY29sbGVjdGlvbiBvZlxuICogIGZ1bmN0aW9ucywgY2xhc3NlcyBhbmQgdHlwZXMgb2ZmZXJlZCBieSB0aGUgRXRoZXJzIGxpYnJhcnkuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpOkFwcGxpY2F0aW9uIFByb2dyYW1taW5nIEludGVyZmFjZSAgW2Fib3V0LWFwaV1cbiAqICBAX25hdlRpdGxlOiBBUElcbiAqL1xuY29uc3QgZXRoZXJzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZXRoZXJzLmpzXCIpKTtcbmV4cG9ydHMuZXRoZXJzID0gZXRoZXJzO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXRoZXJzLmpzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/abstract-provider.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AbstractProvider = exports.UnmanagedSubscriber = void 0;\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_6 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst ens_resolver_js_1 = __webpack_require__(/*! ./ens-resolver.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/ens-resolver.js\");\nconst format_js_1 = __webpack_require__(/*! ./format.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/format.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_js_1 = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nconst subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js\");\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return (value && typeof (value.then) === \"function\");\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof (v) === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof (v) === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof (v) === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key) => {\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nclass UnmanagedSubscriber {\n    /**\n     *  The name fof the event.\n     */\n    name;\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name) { (0, index_js_6.defineProperties)(this, { name }); }\n    start() { }\n    stop() { }\n    pause(dropWhilePaused) { }\n    resume() { }\n}\nexports.UnmanagedSubscriber = UnmanagedSubscriber;\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from((new Set(items)).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = { topics: _event };\n    }\n    if (typeof (_event) === \"string\") {\n        switch (_event) {\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\": {\n                return { type: _event, tag: _event };\n            }\n        }\n    }\n    if ((0, index_js_6.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\n    }\n    if ((_event.address || _event.topics)) {\n        const event = _event;\n        const filter = {\n            topics: ((event.topics || []).map((t) => {\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t) => t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            }))\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr) => {\n                if ((0, index_js_6.isHexString)(addr)) {\n                    addresses.push(addr);\n                }\n                else {\n                    promises.push((async () => {\n                        addresses.push(await (0, index_js_1.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            }\n            else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\n        }\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\n    }\n    (0, index_js_6.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() { return (new Date()).getTime(); }\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nclass AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */\n    constructor(_network, options) {\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        }\n        else if (_network) {\n            const network = network_js_1.Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\n        }\n        else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() { return this.#options.pollingInterval; }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */\n    get provider() { return this; }\n    /**\n     *  Returns all the registered plug-ins.\n     */\n    get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */\n    attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */\n    getPlugin(name) {\n        return (this.#plugins.get(name)) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */\n    get disableCcipRead() { return this.#disableCcipRead; }\n    set disableCcipRead(value) { this.#disableCcipRead = !!value; }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(() => {\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */\n    async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new index_js_6.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = { data, sender };\n            }\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\n            let errorMessage = \"unknown error\";\n            const resp = await request.send();\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\n            }\n            catch (error) { }\n            // 4xx indicates the result is not present; stop\n            (0, index_js_6.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0, index_js_6.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx, info: { urls, errorMessages }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */\n    _wrapBlock(value, network) {\n        return new provider_js_1.Block((0, format_js_1.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */\n    _wrapLog(value, network) {\n        return new provider_js_1.Log((0, format_js_1.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */\n    _wrapTransactionReceipt(value, network) {\n        return new provider_js_1.TransactionReceipt((0, format_js_1.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */\n    _wrapTransactionResponse(tx, network) {\n        return new provider_js_1.TransactionResponse((0, format_js_1.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */\n    _detectNetwork() {\n        (0, index_js_6.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */\n    async _perform(req) {\n        (0, index_js_6.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0, index_js_6.getNumber)(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */\n    _getAddress(address) {\n        return (0, index_js_1.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */\n    _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n        if ((0, index_js_6.isHexString)(blockTag)) {\n            if ((0, index_js_6.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0, index_js_6.toQuantity)(blockTag);\n        }\n        if (typeof (blockTag) === \"bigint\") {\n            blockTag = (0, index_js_6.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof (blockTag) === \"number\") {\n            if (blockTag >= 0) {\n                return (0, index_js_6.toQuantity)(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return (0, index_js_6.toQuantity)(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b) => (0, index_js_6.toQuantity)(b + blockTag));\n        }\n        (0, index_js_6.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */\n    _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t) => {\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t) => t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock) => {\n            let address = undefined;\n            switch (_address.length) {\n                case 0: break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address) {\n                    address.push(this._getAddress(addr));\n                }\n            }\n            else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a) => (typeof (a) !== \"string\")).length ||\n            (fromBlock != null && typeof (fromBlock) !== \"string\") ||\n            (toBlock != null && typeof (toBlock) !== \"string\")) {\n            return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resovles to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */\n    _getTransactionRequest(_request) {\n        const request = (0, provider_js_1.copyRequest)(_request);\n        const promises = [];\n        [\"to\", \"from\"].forEach((key) => {\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0, index_js_1.resolveAddress)(request[key], this);\n            if (isPromise(addr)) {\n                promises.push((async function () { request[key] = await addr; })());\n            }\n            else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push((async function () { request.blockTag = await blockTag; })());\n            }\n            else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return (async function () {\n                await Promise.all(promises);\n                return request;\n            })();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                }\n                catch (error) {\n                    if (this.#networkPromise === detectNetwork) {\n                        this.#networkPromise = null;\n                    }\n                    throw error;\n                }\n            })();\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            }\n            else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0, index_js_6.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await (0, index_js_6.resolveProperties)({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getGasPrice\" });\n                        return (0, index_js_6.getBigInt)(value, \"%response\");\n                    }\n                    catch (error) { }\n                    return null;\n                })()),\n                priorityFee: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getPriorityFee\" });\n                        return (0, index_js_6.getBigInt)(value, \"%response\");\n                    }\n                    catch (error) { }\n                    return null;\n                })())\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee : BigInt(\"1000000000\");\n                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\n            }\n            return new provider_js_1.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new index_js_6.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new provider_js_1.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0, index_js_6.getBigInt)(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        (0, index_js_6.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = (0, provider_js_1.copyRequest)(tx);\n        try {\n            return (0, index_js_6.hexlify)(await this._perform({ method: \"call\", transaction, blockTag }));\n        }\n        catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && (0, index_js_6.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0, index_js_6.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await (0, index_js_1.resolveAddress)(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup((0, index_js_6.dataSlice)(error.data, 4));\n                }\n                catch (error) {\n                    (0, index_js_6.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\", transaction, info: { data }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                (0, index_js_6.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                (0, index_js_6.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs }\n                });\n                const tx = {\n                    to: txSender,\n                    data: (0, index_js_6.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n                };\n                this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({}, tx), result });\n                    return result;\n                }\n                catch (error) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({}, tx), error });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0, index_js_6.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof (address) !== \"string\" || typeof (blockTag) !== \"string\") {\n            [address, blockTag] = await Promise.all([address, blockTag]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\n    }\n    async getBalance(address, blockTag) {\n        return (0, index_js_6.getBigInt)(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0, index_js_6.getNumber)(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0, index_js_6.hexlify)(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0, index_js_6.getBigInt)(_position, \"position\");\n        return (0, index_js_6.hexlify)(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0, index_js_6.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = index_js_5.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if ((0, index_js_6.isHexString)(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof (blockTag) !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\", blockTag, includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0, index_js_6.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getLogs\", filter })\n        });\n        return params.map((p) => this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0, index_js_6.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await ens_resolver_js_1.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0, index_js_1.getAddress)(address);\n        const node = (0, index_js_4.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await ens_resolver_js_1.EnsResolver.getEnsAddress(this);\n            const ensContract = new index_js_3.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === index_js_2.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new index_js_3.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        }\n        catch (error) {\n            // No data was returned from the resolver\n            if ((0, index_js_6.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0, index_js_6.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = (_confirms != null) ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject) => {\n            let timer = null;\n            const listener = (async (blockNumber) => {\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                }\n                catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            });\n            if (timeout != null) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0, index_js_6.makeError)(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0, index_js_6.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */\n    _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */\n    _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\n        }\n        else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, { timer, func, time: getTime() });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */\n    _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */\n    _getSubscriber(sub) {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new subscriber_polling_js_1.PollingBlockSubscriber(this);\n                subscriber.pollingInterval = this.pollingInterval;\n                return subscriber;\n            }\n            case \"safe\":\n            case \"finalized\":\n                return new subscriber_polling_js_1.PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new subscriber_polling_js_1.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new subscriber_polling_js_1.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */\n    _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\n            const payload = new index_js_6.EventPayload(this, (once ? null : listener), event);\n            try {\n                listener.call(this, ...args, payload);\n            }\n            catch (error) { }\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return (count > 0);\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        }\n        else {\n            for (const [tag, { started, subscriber }] of this.#subs) {\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */\n    get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */\n    destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */\n    get paused() { return (this.#pausedState != null); }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        }\n        else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */\n    pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            (0, index_js_6.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()) {\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */\n    resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nexports.AbstractProvider = AbstractProvider;\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0, index_js_6.toUtf8String)(bytes);\n        }\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, start, start + 32));\n        const length = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, offset, offset + 32));\n        return (0, index_js_6.dataSlice)(result, offset + 32, offset + 32 + length);\n    }\n    catch (error) { }\n    return null;\n}\nfunction numPad(value) {\n    const result = (0, index_js_6.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(empty);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = (0, index_js_6.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0, index_js_6.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\", urls: [], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: []\n    };\n    (0, index_js_6.assert)((0, index_js_6.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0, index_js_6.dataSlice)(data, 0, 32);\n    (0, index_js_6.assert)((0, index_js_6.dataSlice)(sender, 0, 12) === (0, index_js_6.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0, index_js_6.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, 32, 64));\n        const urlsLength = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0, index_js_6.dataSlice)(data, urlsOffset + 32);\n        for (let u = 0; u < urlsLength; u++) {\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    }\n    catch (error) {\n        (0, index_js_6.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    }\n    catch (error) {\n        (0, index_js_6.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0, index_js_6.assert)((0, index_js_6.dataSlice)(data, 100, 128) === (0, index_js_6.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0, index_js_6.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    }\n    catch (error) {\n        (0, index_js_6.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => result[k]);\n    return result;\n}\n//# sourceMappingURL=abstract-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXVCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLHdGQUFzQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsOEZBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsaUZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsbUZBQWM7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMscUZBQWU7QUFDN0MsZ0NBQWdDLG1CQUFPLENBQUMseUdBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlDQUF5QyxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlDQUF5QyxNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQ0FBc0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0EsdUNBQXVDLE9BQU8scUJBQXFCLEtBQUs7QUFDeEUsc0JBQXNCLE1BQU0sc0JBQXNCO0FBQ2xELHlEQUF5RCxLQUFLLGtDQUFrQyxjQUFjO0FBQzlHLCtDQUErQyxtQ0FBbUM7QUFDbEY7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDhCQUE4QixLQUFLO0FBQ25DLGlDQUFpQztBQUNqQztBQUNBLGlDQUFpQyw2REFBNkQ7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1REFBdUQ7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBc0Q7QUFDM0Y7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCw2SEFBNkgsYUFBYSx1QkFBdUIseURBQXlELHFCQUFxQjtBQUMvTywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLDhFQUE4RSx1REFBdUQ7QUFDckk7QUFDQSxxQ0FBcUM7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFdBQVc7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsMEJBQTBCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNEJBQTRCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQ0FBb0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtCQUFrQixLQUFLLGdCQUFnQjtBQUN6RztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHVCQUF1QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNERBQTRELDBCQUEwQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRLGdDQUFnQztBQUNqRixTQUFTO0FBQ1QsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSxpRUFBaUUsdUNBQXVDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2Q0FBNkM7QUFDbEY7QUFDQTtBQUNBLHlDQUF5QyxrRUFBa0UsZUFBZTtBQUMxSDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUVBQWlFLGNBQWM7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLG1CQUFtQjtBQUNsRztBQUNBO0FBQ0EsdUVBQXVFLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0EsdUVBQXVFLCtCQUErQjtBQUN0RztBQUNBO0FBQ0EscUVBQXFFLG1CQUFtQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZ0NBQWdDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxvQ0FBb0MsdUNBQXVDO0FBQzNFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0Esb0NBQW9DLHNDQUFzQztBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9ELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxtQkFBbUI7QUFDaEcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBa0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwwQ0FBMEMsc0NBQXNDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQyxvREFBb0QsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlci5qcz9lNTA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgVGhlIGF2YWlsYWJsZSBwcm92aWRlcnMgc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3QgZGV2ZWxvcGVycyBwdXJwb3NlcyxcbiAqICBidXQgdGhlIFtbQWJzdHJhY3RQcm92aWRlcl1dIGNsYXNzIGhhcyBtYW55IGZlYXR1cmVzIHdoaWNoIGVuYWJsZVxuICogIHN1Yi1jbGFzc2luZyBpdCBmb3Igc3BlY2lmaWMgcHVycG9zZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlcjogU3ViY2xhc3NpbmcgUHJvdmlkZXIgIFthYnN0cmFjdC1wcm92aWRlcl1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdFByb3ZpZGVyID0gZXhwb3J0cy5Vbm1hbmFnZWRTdWJzY3JpYmVyID0gdm9pZCAwO1xuLy8gQFRPRE9cbi8vIEV2ZW50IGNvYWxlc2NlbmNlXG4vLyAgIFdoZW4gd2UgcmVnaXN0ZXIgYW4gZXZlbnQgd2l0aCBhbiBhc3luYyB2YWx1ZSAoZS5nLiBhZGRyZXNzIGlzIGEgU2lnbmVyXG4vLyAgIG9yIEVOUyBuYW1lKSwgd2UgbmVlZCB0byBhZGQgaXQgaW1tZWlkYXRlbHkgZm9yIHRoZSBFdmVudCBBUEksIGJ1dCBhbHNvXG4vLyAgIG5lZWQgdGltZSB0byByZXNvbHZlIHRoZSBhZGRyZXNzLiBVcG9uIHJlc29sdmluZyB0aGUgYWRkcmVzcywgd2UgbmVlZCB0b1xuLy8gICBtaWdyYXRlIHRoZSBsaXN0ZW5lciB0byB0aGUgc3RhdGljIGV2ZW50LiBXZSBhbHNvIG5lZWQgdG8gbWFpbnRhaW4gYSBtYXBcbi8vICAgb2YgU2lnbmVyL0VOUyBuYW1lIHRvIGFkZHJlc3Mgc28gd2UgY2FuIHN5bmMgcmVzcG9uZCB0byBsaXN0ZW5lckNvdW50LlxuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzYgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBlbnNfcmVzb2x2ZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Vucy1yZXNvbHZlci5qc1wiKTtcbmNvbnN0IGZvcm1hdF9qc18xID0gcmVxdWlyZShcIi4vZm9ybWF0LmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci5qc1wiKTtcbmNvbnN0IHN1YnNjcmliZXJfcG9sbGluZ19qc18xID0gcmVxdWlyZShcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCIpO1xuLy8gQ29uc3RhbnRzXG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgTUFYX0NDSVBfUkVESVJFQ1RTID0gMTA7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRUYWcocHJlZml4LCB2YWx1ZSkge1xuICAgIHJldHVybiBwcmVmaXggKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoaywgdikgPT4ge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgYmlnaW50OiR7di50b1N0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydCBvYmplY3Qga2V5c1xuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHYpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtrZXldID0gdltrZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9KTtcbn1cbi8qKlxuICogIEFuICoqVW5tYW5hZ2VkU3Vic2NyaWJlcioqIGlzIHVzZWZ1bCBmb3IgZXZlbnRzIHdoaWNoIGRvIG5vdCByZXF1aXJlXG4gKiAgYW55IGFkZGl0aW9uYWwgbWFuYWdlbWVudCwgc3VjaCBhcyBgYFwiZGVidWdcImBgIHdoaWNoIG9ubHkgcmVxdWlyZXNcbiAqICBlbWl0IGluIHN5bmNocm9ub3VzIGV2ZW50IGxvb3AgdHJpZ2dlcmVkIGNhbGxzLlxuICovXG5jbGFzcyBVbm1hbmFnZWRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgZm9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlciB3aXRoICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsgKDAsIGluZGV4X2pzXzYuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBuYW1lIH0pOyB9XG4gICAgc3RhcnQoKSB7IH1cbiAgICBzdG9wKCkgeyB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IH1cbiAgICByZXN1bWUoKSB7IH1cbn1cbmV4cG9ydHMuVW5tYW5hZ2VkU3Vic2NyaWJlciA9IFVubWFuYWdlZFN1YnNjcmliZXI7XG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNvbmNpc2lmeShpdGVtcykge1xuICAgIGl0ZW1zID0gQXJyYXkuZnJvbSgobmV3IFNldChpdGVtcykpLnZhbHVlcygpKTtcbiAgICBpdGVtcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uKF9ldmVudCwgcHJvdmlkZXIpIHtcbiAgICBpZiAoX2V2ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudFwiKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljIGFycmF5IGluZm8gYW4gRXZlbnRGaWx0ZXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZXZlbnQpKSB7XG4gICAgICAgIF9ldmVudCA9IHsgdG9waWNzOiBfZXZlbnQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoX2V2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzd2l0Y2ggKF9ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogX2V2ZW50LCB0YWc6IF9ldmVudCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgoMCwgaW5kZXhfanNfNi5pc0hleFN0cmluZykoX2V2ZW50LCAzMikpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IF9ldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRyYW5zYWN0aW9uXCIsIHRhZzogZ2V0VGFnKFwidHhcIiwgeyBoYXNoIH0pLCBoYXNoIH07XG4gICAgfVxuICAgIGlmIChfZXZlbnQub3JwaGFuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICAvLyBAVE9ETzogU2hvdWxkIGxvd2VyY2FzZSBhbmQgd2hhdG5vdCB0aGluZ3MgaGVyZSBpbnN0ZWFkIG9mIGNvcHkuLi5cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJvcnBoYW5cIiwgdGFnOiBnZXRUYWcoXCJvcnBoYW5cIiwgZXZlbnQpLCBmaWx0ZXI6IGNvcHkoZXZlbnQpIH07XG4gICAgfVxuICAgIGlmICgoX2V2ZW50LmFkZHJlc3MgfHwgX2V2ZW50LnRvcGljcykpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIHRvcGljczogKChldmVudC50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmVudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRBZGRyZXNzID0gKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzYuaXNIZXhTdHJpbmcpKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYXdhaXQgKDAsIGluZGV4X2pzXzEucmVzb2x2ZUFkZHJlc3MpKGFkZHIsIHByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmFkZHJlc3MuZm9yRWFjaChhZGRBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZEFkZHJlc3MoZXZlbnQuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBjb25jaXNpZnkoYWRkcmVzc2VzLm1hcCgoYSkgPT4gYS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyLCB0YWc6IGdldFRhZyhcImV2ZW50XCIsIGZpbHRlciksIHR5cGU6IFwiZXZlbnRcIiB9O1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5rbm93biBQcm92aWRlckV2ZW50XCIsIFwiZXZlbnRcIiwgX2V2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcbn07XG4vKipcbiAqICBBbiAqKkFic3RyYWN0UHJvdmlkZXIqKiBwcm92aWRlcyBhIGJhc2UgY2xhc3MgZm9yIG90aGVyIHN1Yi1jbGFzc2VzIHRvXG4gKiAgaW1wbGVtZW50IHRoZSBbW1Byb3ZpZGVyXV0gQVBJIGJ5IG5vcm1hbGl6aW5nIGlucHV0IGFyZ3VtZW50cyBhbmRcbiAqICBmb3JtYXR0aW5nIG91dHB1dCByZXN1bHRzIGFzIHdlbGwgYXMgdHJhY2tpbmcgZXZlbnRzIGZvciBjb25zaXN0ZW50XG4gKiAgYmVoYXZpb3VyIG9uIGFuIGV2ZW50dWFsbHktY29uc2lzdGVudCBuZXR3b3JrLlxuICovXG5jbGFzcyBBYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAjc3VicztcbiAgICAjcGx1Z2lucztcbiAgICAvLyBudWxsPXVucGF1c2VkLCB0cnVlPXBhdXNlZCtkcm9wV2hpbGVQYXVzZWQsIGZhbHNlPXBhdXNlZFxuICAgICNwYXVzZWRTdGF0ZTtcbiAgICAjZGVzdHJveWVkO1xuICAgICNuZXR3b3JrUHJvbWlzZTtcbiAgICAjYW55TmV0d29yaztcbiAgICAjcGVyZm9ybUNhY2hlO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayBudW1iZXIgaWYgcnVubmluZyBhbiBldmVudCBvciAtMSBpZiBubyBcImJsb2NrXCIgZXZlbnRcbiAgICAjbGFzdEJsb2NrTnVtYmVyO1xuICAgICNuZXh0VGltZXI7XG4gICAgI3RpbWVycztcbiAgICAjZGlzYWJsZUNjaXBSZWFkO1xuICAgICNvcHRpb25zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipBYnN0cmFjdFByb3ZpZGVyKiogY29ubmVjdGVkIHRvICUlbmV0d29yayUlLCBvclxuICAgICAqICB1c2UgdGhlIHZhcmlvdXMgbmV0d29yayBkZXRlY3Rpb24gY2FwYWJpbGl0aWVzIHRvIGRpc2NvdmVyIHRoZVxuICAgICAqICBbW05ldHdvcmtdXSBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09PSBcImFueVwiKSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfbmV0d29yaykge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV0d29yayk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gLTE7XG4gICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV4dFRpbWVyID0gMTtcbiAgICAgICAgdGhpcy4jdGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI29wdGlvbnMucG9sbGluZ0ludGVydmFsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0aGlzYGAsIHRvIGFsbG93IGFuICoqQWJzdHJhY3RQcm92aWRlcioqIHRvIGltcGxlbWVudFxuICAgICAqICB0aGUgW1tDb250cmFjdFJ1bm5lcl1dIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBnZXQgcHJvdmlkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIHBsdWctaW5zLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyBwbHVnLWluLlxuICAgICAqL1xuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY29ubmVjdCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IGEgcGx1Z2luIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByZXZlbnQgYW55IENDSVAtcmVhZCBvcGVyYXRpb24sIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciByZXF1ZXN0ZWRcbiAgICAgKiAgaW4gYSBbW2NhbGxdXSB1c2luZyBgYGVuYWJsZUNjaXBSZWFkYGAuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVDY2lwUmVhZCgpIHsgcmV0dXJuIHRoaXMuI2Rpc2FibGVDY2lwUmVhZDsgfVxuICAgIHNldCBkaXNhYmxlQ2NpcFJlYWQodmFsdWUpIHsgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gISF2YWx1ZTsgfVxuICAgIC8vIFNoYXJlcyBtdWx0aXBsZSBpZGVudGljYWwgcmVxdWVzdHMgbWFkZSBkdXJpbmcgdGhlIHNhbWUgMjUwbXNcbiAgICBhc3luYyAjcGVyZm9ybShyZXEpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuI29wdGlvbnMuY2FjaGVUaW1lb3V0O1xuICAgICAgICAvLyBDYWNoaW5nIGRpc2FibGVkXG4gICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSB0YWdcbiAgICAgICAgY29uc3QgdGFnID0gZ2V0VGFnKHJlcS5tZXRob2QsIHJlcSk7XG4gICAgICAgIGxldCBwZXJmb3JtID0gdGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXBlcmZvcm0pIHtcbiAgICAgICAgICAgIHBlcmZvcm0gPSB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuc2V0KHRhZywgcGVyZm9ybSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpID09PSBwZXJmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5kZWxldGUodGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkYXRhIGZvciBleGVjdXRpbmcgdGhlIENDSVAtcmVhZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGNjaXBSZWFkRmV0Y2godHgsIGNhbGxkYXRhLCB1cmxzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVDY2lwUmVhZCB8fCB1cmxzLmxlbmd0aCA9PT0gMCB8fCB0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gY2FsbGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XG4gICAgICAgICAgICAvLyBVUkwgZXhwYW5zaW9uXG4gICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAvLyBJZiBubyB7ZGF0YX0gaXMgcHJlc2VudCwgdXNlIFBPU1Q7IG90aGVyd2lzZSBHRVRcbiAgICAgICAgICAgIC8vY29uc3QganNvbjogc3RyaW5nIHwgbnVsbCA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGw6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgc2VuZGVyIH0pO1xuICAgICAgICAgICAgLy9jb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgdmFsdWUuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgIC8vICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIC8vfSk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGluZGV4X2pzXzYuRmV0Y2hSZXF1ZXN0KGhyZWYpO1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IHsgZGF0YSwgc2VuZGVyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRGZXRjaFJlcXVlc3RcIiwgcmVxdWVzdCwgaW5kZXg6IGksIHVybHMgfSk7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJ1bmtub3duIGVycm9yXCI7XG4gICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3AuYm9keUpzb247XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoUmVzdWx0XCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoRXJyb3JcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIDR4eCBpbmRpY2F0ZXMgdGhlIHJlc3VsdCBpcyBub3QgcHJlc2VudDsgc3RvcFxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShyZXNwLnN0YXR1c0NvZGUgPCA0MDAgfHwgcmVzcC5zdGF0dXNDb2RlID49IDUwMCwgYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7IHJlYXNvbjogXCI0MDRfTUlTU0lOR19SRVNPVVJDRVwiLCB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJsLCBlcnJvck1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlcy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0pKS5qb2luKFwiLCBcIil9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiNTAwX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybHMsIGVycm9yTWVzc2FnZXMgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGJsb2NrIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgX3dyYXBCbG9jayh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2pzXzEuQmxvY2soKDAsIGZvcm1hdF9qc18xLmZvcm1hdEJsb2NrKSh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgbG9nIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0xvZ11dLlxuICAgICAqL1xuICAgIF93cmFwTG9nKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJfanNfMS5Mb2coKDAsIGZvcm1hdF9qc18xLmZvcm1hdExvZykodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlY2VpcHQgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLlRyYW5zYWN0aW9uUmVjZWlwdCgoMCwgZm9ybWF0X2pzXzEuZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KSh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVzcG9uc2UgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2pzXzEuVHJhbnNhY3Rpb25SZXNwb25zZSgoMCwgZm9ybWF0X2pzXzEuZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSkodHgpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBOZXR3b3JrLCBmb3JjaW5nIGEgbmV0d29yayBkZXRlY3Rpb24gdXNpbmcgd2hhdGV2ZXJcbiAgICAgKiAgdGVjaG5pcXVlIHRoZSBzdWItY2xhc3MgcmVxdWlyZXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgc2hvdWxkIHVzZSB0aGlzIHRvIHBlcmZvcm0gYWxsIGJ1aWx0LWluIG9wZXJhdGlvbnMuIEFsbFxuICAgICAqICBtZXRob2RzIHNhbml0aXplcyBhbmQgbm9ybWFsaXplcyB0aGUgdmFsdWVzIHBhc3NlZCBpbnRvIHRoaXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgYHVuc3VwcG9ydGVkIG1ldGhvZDogJHtyZXEubWV0aG9kfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogcmVxLm1ldGhvZCxcbiAgICAgICAgICAgIGluZm86IHJlcVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU3RhdGVcbiAgICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSAoMCwgaW5kZXhfanNfNi5nZXROdW1iZXIpKGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0QmxvY2tOdW1iZXJcIiB9KSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUsIHJlc29sdmluZyBFTlNcbiAgICAgKiAgbmFtZXMgYW5kIFtbQWRkcmVzc2FibGVdXSBvYmplY3RzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhblxuICAgICAqICBhZGRyZXNzLlxuICAgICAqL1xuICAgIF9nZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKShhZGRyZXNzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSB2YWxpZCBibG9jayB0YWcgZm9yICUlYmxvY2tUYWclJSwgcmVzb2x2aW5nXG4gICAgICogIG5lZ2F0aXZlIHZhbHVlcyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZCBibG9jayB0YWcuXG4gICAgICovXG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGJsb2NrVGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzYuaXNIZXhTdHJpbmcpKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc182LmlzSGV4U3RyaW5nKShibG9ja1RhZywgMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LnRvUXVhbnRpdHkpKGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKShibG9ja1RhZywgXCJibG9ja1RhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RhZyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LnRvUXVhbnRpdHkpKGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi50b1F1YW50aXR5KSh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgKyBibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oKGIpID0+ICgwLCBpbmRleF9qc182LnRvUXVhbnRpdHkpKGIgKyBibG9ja1RhZykpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIGZpbHRlciBmb3IgJSVmaWx0ZXIlJSwgcmVzb2x2aW5nIGFueSBFTlNcbiAgICAgKiAgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIG9iamVjdCBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICBmaWx0ZXIuXG4gICAgICovXG4gICAgX2dldEZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b3BpY3NcbiAgICAgICAgY29uc3QgdG9waWNzID0gKGZpbHRlci50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBibG9ja0hhc2ggPSAoXCJibG9ja0hhc2hcIiBpbiBmaWx0ZXIpID8gZmlsdGVyLmJsb2NrSGFzaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IChfYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN3aXRjaCAoX2FkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX2FkZHJlc3Muc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CbG9jayAhPSBudWxsIHx8IHRvQmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbHRlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcGljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSBmcm9tQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9CbG9jaykge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gdG9CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gYmxvY2tIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkcmVzc2VzIGNvdWxkIGJlIGFzeW5jIChFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzKVxuICAgICAgICBsZXQgYWRkcmVzcyA9IFtdO1xuICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhhZGRyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoZmlsdGVyLmFkZHJlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbUJsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJmcm9tQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci5mcm9tQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b0Jsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJ0b0Jsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICB0b0Jsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzLmZpbHRlcigoYSkgPT4gKHR5cGVvZiAoYSkgIT09IFwic3RyaW5nXCIpKS5sZW5ndGggfHxcbiAgICAgICAgICAgIChmcm9tQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKGZyb21CbG9jaykgIT09IFwic3RyaW5nXCIpIHx8XG4gICAgICAgICAgICAodG9CbG9jayAhPSBudWxsICYmIHR5cGVvZiAodG9CbG9jaykgIT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1Byb21pc2UuYWxsKGFkZHJlc3MpLCBmcm9tQmxvY2ssIHRvQmxvY2tdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGFkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc292bGVzIHRvIGEgdHJhbnNhY3Rpb24gZm9yICUlcmVxdWVzdCUlLCByZXNvbHZpbmdcbiAgICAgKiAgYW55IEVOUyBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfcmVxdWVzdCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gKDAsIHByb3ZpZGVyX2pzXzEuY29weVJlcXVlc3QpKF9yZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgW1widG9cIiwgXCJmcm9tXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Rba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkciA9ICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKShyZXF1ZXN0W2tleV0sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShhZGRyKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdFtrZXldID0gYXdhaXQgYWRkcjsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0W2tleV0gPSBhZGRyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcXVlc3QuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhyZXF1ZXN0LmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0LmJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja1RhZyA9IGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGFzeW5jIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IG5ldHdvcmsgd2FzIHNldCBhbmQgdGhpcyBpcyBvdXIgZmlyc3QgdGltZVxuICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IHRoZSBjdXJyZW50IG5ldHdvcmsgKHNoYXJlZCB3aXRoIGFsbCBjYWxscylcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLl9kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBkZXRlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gZGV0ZWN0TmV0d29yaztcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgZGV0ZWN0TmV0d29yaykuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrUHJvbWlzZSA9IHRoaXMuI25ldHdvcmtQcm9taXNlO1xuICAgICAgICBjb25zdCBbZXhwZWN0ZWQsIGFjdHVhbF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBuZXR3b3JrUHJvbWlzZSxcbiAgICAgICAgICAgIHRoaXMuX2RldGVjdE5ldHdvcmsoKSAvLyBUaGUgYWN0dWFsIGNvbm5lY3RlZCBuZXR3b3JrXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoZXhwZWN0ZWQuY2hhaW5JZCAhPT0gYWN0dWFsLmNoYWluSWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiYW55XCIgbmV0d29yayBjYW4gY2hhbmdlLCBzbyBub3RpZnkgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBhY3R1YWwsIGV4cGVjdGVkKTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5ldHdvcmsgaWYgc29tZXRoaW5nIGVsc2UgaGFzbid0IGFscmVhZHkgY2hhbmdlZCBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gbmV0d29ya1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYWN0dWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGRvIG5vdCBhbGxvdyBjaGFuZ2VzIHRvIHRoZSB1bmRlcmx5aW5nIG5ldHdvcmtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBgbmV0d29yayBjaGFuZ2VkOiAke2V4cGVjdGVkLmNoYWluSWR9ID0+ICR7YWN0dWFsLmNoYWluSWR9IGAsIFwiTkVUV09SS19FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBlY3RlZC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWVEYXRhKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGdldEZlZURhdGFGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBfYmxvY2ssIGdhc1ByaWNlLCBwcmlvcml0eUZlZSB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzYucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICBfYmxvY2s6IHRoaXMuI2dldEJsb2NrKFwibGF0ZXN0XCIsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0R2FzUHJpY2VcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5nZXRCaWdJbnQpKHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eUZlZTogKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0UHJpb3JpdHlGZWVcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5nZXRCaWdJbnQpKHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHJlY29tbWVuZGVkIEVJUC0xNTU5IGhldXJpc3RpY3MgZm9yIGZlZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuX3dyYXBCbG9jayhfYmxvY2ssIG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IChwcmlvcml0eUZlZSAhPSBudWxsKSA/IHByaW9yaXR5RmVlIDogQmlnSW50KFwiMTAwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSAoYmxvY2suYmFzZUZlZVBlckdhcyAqIEJOXzIpICsgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2pzXzEuRmVlRGF0YShnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENoZWNrIGZvciBhIEZlZURhdGFOZXRXb3JrUGx1Z2luXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgaW5kZXhfanNfNi5GZXRjaFJlcXVlc3QocGx1Z2luLnVybCk7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcGx1Z2luLnByb2Nlc3NGdW5jKGdldEZlZURhdGFGdW5jLCB0aGlzLCByZXEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLkZlZURhdGEoZmVlRGF0YS5nYXNQcmljZSwgZmVlRGF0YS5tYXhGZWVQZXJHYXMsIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRGZWVEYXRhRnVuYygpO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyhfdHgpIHtcbiAgICAgICAgbGV0IHR4ID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCk7XG4gICAgICAgIGlmIChpc1Byb21pc2UodHgpKSB7XG4gICAgICAgICAgICB0eCA9IGF3YWl0IHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5nZXRCaWdJbnQpKGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgbWV0aG9kOiBcImVzdGltYXRlR2FzXCIsIHRyYW5zYWN0aW9uOiB0eFxuICAgICAgICB9KSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jICNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGF0dGVtcHQgPCBNQVhfQ0NJUF9SRURJUkVDVFMsIFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIlRPT19NQU5ZX1JFRElSRUNUU1wiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IGJsb2NrVGFnLCBlbmFibGVDY2lwUmVhZDogdHJ1ZSB9KVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBjYW1lIGluIGFzIGEgUGVyZm9ybUFjdGlvblRyYW5zYWN0aW9uLCBzbyB0by9mcm9tIGFyZSBzYWZlOyB3ZSBjYW4gY2FzdFxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9ICgwLCBwcm92aWRlcl9qc18xLmNvcHlSZXF1ZXN0KSh0eCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuaGV4bGlmeSkoYXdhaXQgdGhpcy5fcGVyZm9ybSh7IG1ldGhvZDogXCJjYWxsXCIsIHRyYW5zYWN0aW9uLCBibG9ja1RhZyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBDQ0lQIFJlYWQgT2ZmY2hhaW5Mb29rdXBcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlQ2NpcFJlYWQgJiYgKDAsIGluZGV4X2pzXzYuaXNDYWxsRXhjZXB0aW9uKShlcnJvcikgJiYgZXJyb3IuZGF0YSAmJiBhdHRlbXB0ID49IDAgJiYgYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIgJiYgdHJhbnNhY3Rpb24udG8gIT0gbnVsbCAmJiAoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGVycm9yLmRhdGEsIDAsIDQpID09PSBcIjB4NTU2ZjE4MzBcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gYXdhaXQgKDAsIGluZGV4X2pzXzEucmVzb2x2ZUFkZHJlc3MpKHRyYW5zYWN0aW9uLnRvLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgQ0NJUCBSZWFkIEFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGxldCBjY2lwQXJncztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjY2lwQXJncyA9IHBhcnNlT2ZmY2hhaW5Mb29rdXAoKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShlcnJvci5kYXRhLCA0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBlcnJvci5tZXNzYWdlLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJCQURfREFUQVwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShjY2lwQXJncy5zZW5kZXIudG9Mb3dlckNhc2UoKSA9PT0gdHhTZW5kZXIudG9Mb3dlckNhc2UoKSwgXCJDQ0lQIFJlYWQgc2VuZGVyIG1pc21hdGNoXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGNjaXBBcmdzLmVycm9yQXJnc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2NpcFJlc3VsdCA9IGF3YWl0IHRoaXMuY2NpcFJlYWRGZXRjaCh0cmFuc2FjdGlvbiwgY2NpcEFyZ3MuY2FsbGRhdGEsIGNjaXBBcmdzLnVybHMpO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoY2NpcFJlc3VsdCAhPSBudWxsLCBcIkNDSVAgUmVhZCBmYWlsZWQgdG8gZmV0Y2ggZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkZFVENIX0ZBSUxFRFwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhOiBlcnJvci5kYXRhLCBlcnJvckFyZ3M6IGNjaXBBcmdzLmVycm9yQXJncyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKDAsIGluZGV4X2pzXzYuY29uY2F0KShbY2NpcEFyZ3Muc2VsZWN0b3IsIGVuY29kZUJ5dGVzKFtjY2lwUmVzdWx0LCBjY2lwQXJncy5leHRyYURhdGFdKV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRDYWxsXCIsIHRyYW5zYWN0aW9uOiB0eCB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsUmVzdWx0XCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxFcnJvclwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2NoZWNrTmV0d29yayhwcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHZhbHVlOiBwcm9taXNlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwoX3R4KSB7XG4gICAgICAgIGNvbnN0IHsgdHgsIGJsb2NrVGFnIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgdHg6IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpLFxuICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKF90eC5ibG9ja1RhZylcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIF90eC5lbmFibGVDY2lwUmVhZCA/IDAgOiAtMSkpO1xuICAgIH1cbiAgICAvLyBBY2NvdW50XG4gICAgYXN5bmMgI2dldEFjY291bnRWYWx1ZShyZXF1ZXN0LCBfYWRkcmVzcywgX2Jsb2NrVGFnKSB7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKF9ibG9ja1RhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBbYWRkcmVzcywgYmxvY2tUYWddID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FkZHJlc3MsIGJsb2NrVGFnXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NoZWNrTmV0d29yayh0aGlzLiNwZXJmb3JtKE9iamVjdC5hc3NpZ24ocmVxdWVzdCwgeyBhZGRyZXNzLCBibG9ja1RhZyB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5nZXRCaWdJbnQpKGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRCYWxhbmNlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldENvZGUoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LmhleGxpZnkpKGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRDb2RlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3RvcmFnZShhZGRyZXNzLCBfcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIGluZGV4X2pzXzYuZ2V0QmlnSW50KShfcG9zaXRpb24sIFwicG9zaXRpb25cIik7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5oZXhsaWZ5KShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0U3RvcmFnZVwiLCBwb3NpdGlvbiB9LCBhZGRyZXNzLCBibG9ja1RhZykpO1xuICAgIH1cbiAgICAvLyBXcml0ZVxuICAgIGFzeW5jIGJyb2FkY2FzdFRyYW5zYWN0aW9uKHNpZ25lZFR4KSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGhhc2gsIG5ldHdvcmsgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgaGFzaDogdGhpcy5fcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb246IHNpZ25lZFR4XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGluZGV4X2pzXzUuVHJhbnNhY3Rpb24uZnJvbShzaWduZWRUeCk7XG4gICAgICAgIGlmICh0eC5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ETzogdGhlIHJldHVybmVkIGhhc2ggZGlkIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIG5ldHdvcmspLnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oYmxvY2tOdW1iZXIpO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0QmxvY2soYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgLy8gQFRPRE86IEFkZCBDdXN0b21CbG9ja1BsdWdpbiBjaGVja1xuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzYuaXNIZXhTdHJpbmcpKGJsb2NrLCAzMikpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmxvY2tcIiwgYmxvY2tIYXNoOiBibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2spO1xuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0QmxvY2soYmxvY2ssIHByZWZldGNoVHhzKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI2dldEJsb2NrKGJsb2NrLCAhIXByZWZldGNoVHhzKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcEJsb2NrKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZShwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzYucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgYmFja2VuZHMgZGlkIG5vdCBiYWNrZmlsbCB0aGUgZWZmZWN0aXZlR2FzUHJpY2UgaW50byBvbGQgdHJhbnNhY3Rpb25zXG4gICAgICAgIC8vIGluIHRoZSByZWNlaXB0LCBzbyB3ZSBsb29rIGl0IHVwIG1hbnVhbGx5IGFuZCBpbmplY3QgaXQuXG4gICAgICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgPT0gbnVsbCAmJiBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSk7XG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcG9ydCB0aGlzOyBjb3VsZCBub3QgZmluZCB0eCBvciBlZmZlY3RpdmVHYXNQcmljZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVzdWx0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5oZXhsaWZ5KShyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBCbG9vbS1maWx0ZXIgUXVlcmllc1xuICAgIGFzeW5jIGdldExvZ3MoX2ZpbHRlcikge1xuICAgICAgICBsZXQgZmlsdGVyID0gdGhpcy5fZ2V0RmlsdGVyKF9maWx0ZXIpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKGZpbHRlcikpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IGF3YWl0IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzYucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldExvZ3NcIiwgZmlsdGVyIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcCgocCkgPT4gdGhpcy5fd3JhcExvZyhwLCBuZXR3b3JrKSk7XG4gICAgfVxuICAgIC8vIEVOU1xuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoZmFsc2UsIFwicHJvdmlkZXIgY2Fubm90IGNvbm5lY3QgdG8gdGFyZ2V0IG5ldHdvcmtcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9nZXRQcm92aWRlcigpXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlc29sdmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVuc19yZXNvbHZlcl9qc18xLkVuc1Jlc29sdmVyLmZyb21OYW1lKHRoaXMsIG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdmF0YXIobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9ICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBub2RlID0gKDAsIGluZGV4X2pzXzQubmFtZWhhc2gpKGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgZW5zX3Jlc29sdmVyX2pzXzEuRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuc0NvbnRyYWN0ID0gbmV3IGluZGV4X2pzXzMuQ29udHJhY3QoZW5zQWRkciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZXIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgZW5zQ29udHJhY3QucmVzb2x2ZXIobm9kZSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT0gbnVsbCB8fCByZXNvbHZlciA9PT0gaW5kZXhfanNfMi5aZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJDb250cmFjdCA9IG5ldyBpbmRleF9qc18zLkNvbnRyYWN0KHJlc29sdmVyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBuYW1lKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCByZXNvbHZlckNvbnRyYWN0Lm5hbWUobm9kZSk7XG4gICAgICAgICAgICAvLyBGYWlsZWQgZm9yd2FyZCByZXNvbHV0aW9uXG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IGF3YWl0IHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gZGF0YSB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNi5pc0Vycm9yKShlcnJvciwgXCJCQURfREFUQVwiKSAmJiBlcnJvci52YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgcmVlcnRlZFxuICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc182LmlzRXJyb3IpKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKGhhc2gsIF9jb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb25maXJtcyA9IChfY29uZmlybXMgIT0gbnVsbCkgPyBfY29uZmlybXMgOiAxO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGFzeW5jIChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlciArIDEgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVFRVwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCgwLCBpbmRleF9qc182Lm1ha2VFcnJvcikoXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7IHJlYXNvbjogXCJ0aW1lb3V0XCIgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIoYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JCbG9jayhibG9ja1RhZykge1xuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIiwgXCJOT1RfSU1QTEVNRU5URURcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIndhaXRGb3JCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYSB0aW1lciBjcmVhdGVkIHVzaW5nIHRoZSBbW19zZXRUaW1lb3V0XV0gbWV0aG9kLlxuICAgICAqL1xuICAgIF9jbGVhclRpbWVvdXQodGltZXJJZCkge1xuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuI3RpbWVycy5nZXQodGltZXJJZCk7XG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIHRpbWVyIHRoYXQgd2lsbCBleGVjdXRlICUlZnVuYyUlIGFmdGVyIGF0IGxlYXN0ICUldGltZW91dCUlXG4gICAgICogIChpbiBtcykuIElmICUldGltZW91dCUlIGlzIHVuc3BlY2lmaWVkLCB0aGVuICUlZnVuYyUlIHdpbGwgZXhlY3V0ZVxuICAgICAqICBpbiB0aGUgbmV4dCBldmVudCBsb29wLlxuICAgICAqXG4gICAgICogIFtQYXVzaW5nXShBYnN0cmFjdFByb3ZpZGVyLXBhdXNlZCkgdGhlIHByb3ZpZGVyIHdpbGwgcGF1c2UgYW55XG4gICAgICogIGFzc29jaWF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIF9zZXRUaW1lb3V0KF9mdW5jLCB0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSB0aGlzLiNuZXh0VGltZXIrKztcbiAgICAgICAgY29uc3QgZnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgICAgICAgICBfZnVuYygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lcjogbnVsbCwgZnVuYywgdGltZTogdGltZW91dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChmdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lciwgZnVuYywgdGltZTogZ2V0VGltZSgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGVyZm9ybSAlJWZ1bmMlJSBvbiBlYWNoIHN1YnNjcmliZXIuXG4gICAgICovXG4gICAgX2ZvckVhY2hTdWJzY3JpYmVyKGZ1bmMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZnVuYyhzdWIuc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIGN1c3RvbWl6ZSBzdWJzY3JpcHRpb25cbiAgICAgKiAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoc3ViLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gbmV3IHN1YnNjcmliZXJfcG9sbGluZ19qc18xLlBvbGxpbmdCbG9ja1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdWJzY3JpYmVyX3BvbGxpbmdfanNfMS5Qb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyKHRoaXMsIHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcih0aGlzLCBzdWIuaGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwib3JwaGFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdWJzY3JpYmVyX3BvbGxpbmdfanNfMS5Qb2xsaW5nT3JwaGFuU3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV2ZW50OiAke3N1Yi50eXBlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSBbW1N1YnNjcmliZXJdXSBmYWlscyBhbmQgbmVlZHMgdG8gcmVwbGFjZSBpdHNlbGYsIHRoaXNcbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCB0aGlzIGlzIHVzZWQgZm9yIHByb3ZpZGVycyB3aGVuIHVzaW5nIHRoZVxuICAgICAqICBgYGV0aF9nZXRGaWx0ZXJDaGFuZ2VzYGAgbWV0aG9kLCB3aGljaCBjYW4gcmV0dXJuIG51bGwgaWYgc3RhdGVcbiAgICAgKiAgZmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCwgYWxsb3dpbmcgdGhlIFN1YnNjcmliZXJcbiAgICAgKiAgdG8gc3dhcCBpbiBhIFtbUG9sbGluZ0V2ZW50U3Vic2NyaWJlcl1dLlxuICAgICAqL1xuICAgIF9yZWNvdmVyU3Vic2NyaWJlcihvbGRTdWIsIG5ld1N1Yikge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZXIgPT09IG9sZFN1Yikge1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyID0gbmV3U3ViO1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2hhc1N1YihldmVudCwgZW1pdEFyZ3MpIHtcbiAgICAgICAgbGV0IHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsb2cgdGhhdCBpcyByZW1vdmluZyBhbiBleGlzdGluZyBsb2c7IHdlIGFjdHVhbGx5IHdhbnRcbiAgICAgICAgLy8gdG8gZW1pdCBhbiBvcnBoYW4gZXZlbnQgZm9yIHRoZSByZW1vdmVkIGxvZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIiAmJiBlbWl0QXJncyAmJiBlbWl0QXJncy5sZW5ndGggPiAwICYmIGVtaXRBcmdzWzBdLnJlbW92ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbih7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IGVtaXRBcmdzWzBdIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNzdWJzLmdldChzdWIudGFnKSB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0U3ViKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFByZXZlbnQgdGFtcGVyaW5nIHdpdGggb3VyIHRhZyBpbiBhbnkgc3ViY2xhc3MnIF9nZXRTdWJzY3JpYmVyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN1YnNjcmlwdGlvbi50YWc7XG4gICAgICAgIGxldCBzdWIgPSB0aGlzLiNzdWJzLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuX2dldFN1YnNjcmliZXIoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NhYmxlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBzdWIgPSB7IHN1YnNjcmliZXIsIHRhZywgYWRkcmVzc2FibGVNYXAsIG5hbWVNYXAsIHN0YXJ0ZWQ6IGZhbHNlLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgICAgICB0aGlzLiNzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCwgYXJncyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBzdWJzY3JpcHRpb24gb3IgaWYgYSByZWNlbnQgZW1pdCByZW1vdmVkXG4gICAgICAgIC8vIHRoZSBsYXN0IG9mIHRoZW0gKHdoaWNoIGFsc28gZGVsZXRlZCB0aGUgc3ViKSBkbyBub3RoaW5nXG4gICAgICAgIGlmICghc3ViIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG5ldyBpbmRleF9qc182LkV2ZW50UGF5bG9hZCh0aGlzLCAob25jZSA/IG51bGwgOiBsaXN0ZW5lciksIGV2ZW50KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY291bnQgPiAwKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaXN0ZW5lciB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGFnLCBzdGFydGVkLCBzdWJzY3JpYmVyIH0gPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0YWcsIHsgc3RhcnRlZCwgc3Vic2NyaWJlciB9XSBvZiB0aGlzLiNzdWJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGlzIHByb3ZpZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCB1c2luZyB0aGUgW1tkZXN0cm95XV0gbWV0aG9kLlxuICAgICAqXG4gICAgICogIE9uY2UgZGVzdHJveWVkLCBhbGwgcmVzb3VyY2VzIGFyZSByZWNsYWltZWQsIGludGVybmFsIGV2ZW50IGxvb3BzXG4gICAgICogIGFuZCB0aW1lcnMgYXJlIGNsZWFuZWQgdXAgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgbWF5IGJlIHNlbnQgdG9cbiAgICAgKiAgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkZXN0cm95ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgdXNlIHRoaXMgdG8gc2h1dGRvd24gYW55IHNvY2tldHMgb3IgcmVsZWFzZSB0aGVpclxuICAgICAqICByZXNvdXJjZXMgYW5kIHJlamVjdCBhbnkgcGVuZGluZyByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBjYWxsIGBgc3VwZXIuZGVzdHJveSgpYGAuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBhbGwgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIFNodXQgZG93biBhbGwgdGllbXJzXG4gICAgICAgIGZvciAoY29uc3QgdGltZXJJZCBvZiB0aGlzLiN0aW1lcnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIHByb3ZpZGVyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAgICpcbiAgICAgKiAgQSBwYXVzZWQgcHJvdmlkZXIgd2lsbCBub3QgZW1pdCBhbnkgZXZlbnRzLCBhbmQgZ2VuZXJhbGx5IHNob3VsZFxuICAgICAqICBub3QgbWFrZSBhbnkgcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmssIGJ1dCB0aGF0IGlzIHVwIHRvIHN1Yi1jbGFzc2VzXG4gICAgICogIHRvIG1hbmFnZS5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIGBgcGF1c2VkID0gdHJ1ZWBgIGlzIGlkZW50aWNhbCB0byBjYWxsaW5nIGBgLnBhdXNlKGZhbHNlKWBgLFxuICAgICAqICB3aGljaCB3aWxsIGJ1ZmZlciBhbnkgZXZlbnRzIHRoYXQgb2NjdXIgd2hpbGUgcGF1c2VkIHVudGlsIHRoZVxuICAgICAqICBwcm92aWRlciBpcyB1bnBhdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkgeyByZXR1cm4gKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpOyB9XG4gICAgc2V0IHBhdXNlZChwYXVzZSkge1xuICAgICAgICBpZiAoISFwYXVzZSA9PT0gdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGF1c2UgdGhlIHByb3ZpZGVyLiBJZiAlJWRyb3BXaGlsZVBhdXNlZCUlLCBhbnkgZXZlbnRzIHRoYXQgb2NjdXJcbiAgICAgKiAgd2hpbGUgcGF1c2VkIGFyZSBkcm9wcGVkLCBvdGhlcndpc2UgYWxsIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgb25jZVxuICAgICAqICB0aGUgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09ICEhZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJjYW5ub3QgY2hhbmdlIHBhdXNlIHR5cGU7IHJlc3VtZSBmaXJzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdXNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyXG4gICAgICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgbmVlZGVkIGZvciB3aGVuIHdlIGJlY29tZSB1bnBhdXNlZFxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKSAtIHRpbWVyLnRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc3VtZSB0aGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnJlc3VtZSgpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgd2hlbiB3ZSB3ZXJlIHBhdXNlZFxuICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSB0aW1lci50aW1lO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCB0aW1lIChpbiBjYXVzZSBwYXVzZWQsIHNvIHdlIGNvbiBjb21wdXRlIHJlbWFpbmluZiB0aW1lKVxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lci5mdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RQcm92aWRlciA9IEFic3RyYWN0UHJvdmlkZXI7XG5mdW5jdGlvbiBfcGFyc2VTdHJpbmcocmVzdWx0LCBzdGFydCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCk7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LnRvVXRmOFN0cmluZykoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoMCwgaW5kZXhfanNfNi5nZXROdW1iZXIpKCgwLCBpbmRleF9qc182LmRhdGFTbGljZSkocmVzdWx0LCBzdGFydCwgc3RhcnQgKyAzMikpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAoMCwgaW5kZXhfanNfNi5nZXROdW1iZXIpKCgwLCBpbmRleF9qc182LmRhdGFTbGljZSkocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSk7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG51bVBhZCh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBpbmRleF9qc182LnRvQmVBcnJheSkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZDtcbn1cbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZS5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8vIEFCSSBFbmNvZGVzIGEgc2VyaWVzIG9mIChieXRlcywgYnl0ZXMsIC4uLilcbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKGRhdGFzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgLy8gQWRkIHBsYWNlLWhvbGRlcnMgZm9yIHBvaW50ZXJzIGFzIHdlIGFkZCBpdGVtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW1wdHkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc182LmdldEJ5dGVzKShkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc182LmNvbmNhdCkocmVzdWx0KTtcbn1cbmNvbnN0IHplcm9zID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbmZ1bmN0aW9uIHBhcnNlT2ZmY2hhaW5Mb29rdXAoZGF0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2VuZGVyOiBcIlwiLCB1cmxzOiBbXSwgY2FsbGRhdGE6IFwiXCIsIHNlbGVjdG9yOiBcIlwiLCBleHRyYURhdGE6IFwiXCIsIGVycm9yQXJnczogW11cbiAgICB9O1xuICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoKDAsIGluZGV4X2pzXzYuZGF0YUxlbmd0aCkoZGF0YSkgPj0gNSAqIDMyLCBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIlxuICAgIH0pO1xuICAgIGNvbnN0IHNlbmRlciA9ICgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoZGF0YSwgMCwgMzIpO1xuICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShzZW5kZXIsIDAsIDEyKSA9PT0gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKSh6ZXJvcywgMCwgMTIpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIlxuICAgIH0pO1xuICAgIHJlc3VsdC5zZW5kZXIgPSAoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKHNlbmRlciwgMTIpO1xuICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmxzID0gW107XG4gICAgICAgIGNvbnN0IHVybHNPZmZzZXQgPSAoMCwgaW5kZXhfanNfNi5nZXROdW1iZXIpKCgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoZGF0YSwgMzIsIDY0KSk7XG4gICAgICAgIGNvbnN0IHVybHNMZW5ndGggPSAoMCwgaW5kZXhfanNfNi5nZXROdW1iZXIpKCgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSk7XG4gICAgICAgIGNvbnN0IHVybHNEYXRhID0gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShkYXRhLCB1cmxzT2Zmc2V0ICsgMzIpO1xuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVybHNMZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gX3BhcnNlU3RyaW5nKHVybHNEYXRhLCB1ICogMzIpO1xuICAgICAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmxzLnB1c2godXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudXJscyA9IHVybHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgdXJsc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDY0KTtcbiAgICAgICAgaWYgKGNhbGxkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5jYWxsZGF0YSA9IGNhbGxkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBjYWxsYmFja1NlbGVjdG9yIChieXRlczQpXG4gICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGRhdGEsIDEwMCwgMTI4KSA9PT0gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKSh6ZXJvcywgMCwgMjgpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VsZWN0b3IgPSAoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGRhdGEsIDk2LCAxMDApO1xuICAgIC8vIEdldCB0aGUgZXh0cmEgZGF0YSB0byBzZW5kIGJhY2sgdG8gdGhlIGNvbnRyYWN0IGFzIGNvbnRleHRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBleHRyYURhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCAxMjgpO1xuICAgICAgICBpZiAoZXh0cmFEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5leHRyYURhdGEgPSBleHRyYURhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VsdC5lcnJvckFyZ3MgPSBcInNlbmRlcix1cmxzLGNhbGxkYXRhLHNlbGVjdG9yLGV4dHJhRGF0YVwiLnNwbGl0KC8sLykubWFwKChrKSA9PiByZXN1bHRba10pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/abstract-signer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VoidSigner = exports.AbstractSigner = void 0;\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst provider_js_1 = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0, index_js_3.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", { operation });\n}\nasync function populate(signer, tx) {\n    let pop = (0, provider_js_1.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0, index_js_1.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0, index_js_1.resolveAddress)(from, signer)\n        ]).then(([address, from]) => {\n            (0, index_js_3.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    }\n    else {\n        pop.from = signer.getAddress();\n    }\n    return await (0, index_js_3.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nclass AbstractSigner {\n    /**\n     *  The provider this signer is connected to.\n     */\n    provider;\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider) {\n        (0, index_js_3.defineProperties)(this, { provider: (provider || null) });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await (this.provider).getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0, index_js_3.getBigInt)(pop.chainId);\n            (0, index_js_3.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        }\n        else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0, index_js_3.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        }\n        else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0, index_js_3.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        }\n        else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0, index_js_3.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        }\n        else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    pop.type = 2;\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    }\n                    else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                }\n                else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0, index_js_3.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                }\n                else {\n                    // getFeeData has failed us.\n                    (0, index_js_3.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            }\n            else if (pop.type === 2) {\n                // Explicitly using EIP-1559\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0, index_js_3.resolveProperties)(pop);\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = index_js_2.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n}\nexports.AbstractSigner = AbstractSigner;\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nclass VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    address;\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address, provider) {\n        super(provider);\n        (0, index_js_3.defineProperties)(this, { address });\n    }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        (0, index_js_3.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", { operation });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n}\nexports.VoidSigner = VoidSigner;\n//# sourceMappingURL=abstract-signer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLHNCQUFzQixtQkFBTyxDQUFDLHFGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFdBQVc7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU8sOEJBQThCLFdBQVc7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9hYnN0cmFjdC1zaWduZXIuanM/OWVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVm9pZFNpZ25lciA9IGV4cG9ydHMuQWJzdHJhY3RTaWduZXIgPSB2b2lkIDA7XG4vKipcbiAqICBHZW5lcmFsbHkgdGhlIFtbV2FsbGV0XV0gYW5kIFtbSnNvblJwY1NpZ25lcl1dIGFuZCB0aGVpciBzdWItY2xhc3Nlc1xuICogIGFyZSBzdWZmaWNlbnQgZm9yIG1vc3QgZGV2ZWxvcGVycywgYnV0IHRoaXMgaXMgcHJvdmlkZWQgdG9cbiAqICBmYXNjaWxpdGF0ZSBtb3JlIGNvbXBsZXggU2lnbmVycy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lcjogU3ViY2xhc3NpbmcgU2lnbmVyIFthYnN0cmFjdC1zaWduZXJdXG4gKi9cbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLmpzXCIpO1xuZnVuY3Rpb24gY2hlY2tQcm92aWRlcihzaWduZXIsIG9wZXJhdGlvbikge1xuICAgIGlmIChzaWduZXIucHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25lci5wcm92aWRlcjtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoc2lnbmVyLCB0eCkge1xuICAgIGxldCBwb3AgPSAoMCwgcHJvdmlkZXJfanNfMS5jb3B5UmVxdWVzdCkodHgpO1xuICAgIGlmIChwb3AudG8gIT0gbnVsbCkge1xuICAgICAgICBwb3AudG8gPSAoMCwgaW5kZXhfanNfMS5yZXNvbHZlQWRkcmVzcykocG9wLnRvLCBzaWduZXIpO1xuICAgIH1cbiAgICBpZiAocG9wLmZyb20gIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBmcm9tID0gcG9wLmZyb207XG4gICAgICAgIHBvcC5mcm9tID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgc2lnbmVyLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKShmcm9tLCBzaWduZXIpXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gZnJvbS50b0xvd2VyQ2FzZSgpLCBcInRyYW5zYWN0aW9uIGZyb20gbWlzbWF0Y2hcIiwgXCJ0eC5mcm9tXCIsIGZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9wLmZyb20gPSBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgKDAsIGluZGV4X2pzXzMucmVzb2x2ZVByb3BlcnRpZXMpKHBvcCk7XG59XG4vKipcbiAqICBBbiAqKkFic3RyYWN0U2lnbmVyKiogaW5jbHVkZXMgbW9zdCBvZiB0ZWggZnVuY3Rpb25hbGl0eSByZXF1aXJlZFxuICogIHRvIGdldCBhIFtbU2lnbmVyXV0gd29ya2luZyBhcyBleHBlY3RlZCwgYnV0IHJlcXVpcmVzIGEgZmV3XG4gKiAgU2lnbmVyLXNwZWNpZmljIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbi5cbiAqXG4gKi9cbmNsYXNzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgc2lnbmVyIGlzIGNvbm5lY3RlZCB0by5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBTaWduZXIgY29ubmVjdGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHByb3ZpZGVyOiAocHJvdmlkZXIgfHwgbnVsbCkgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5vbmNlKGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKS5nZXRUcmFuc2FjdGlvbkNvdW50KGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgfVxuICAgIGFzeW5jIHBvcHVsYXRlQ2FsbCh0eCkge1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XG4gICAgICAgIHJldHVybiBwb3A7XG4gICAgfVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwicG9wdWxhdGVUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICBpZiAocG9wLm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5ub25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3AuZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9wLmdhc0xpbWl0ID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUdhcyhwb3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBjaGFpbiBJRFxuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgKHRoaXMucHJvdmlkZXIpLmdldE5ldHdvcmsoKTtcbiAgICAgICAgaWYgKHBvcC5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSAoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKHBvcC5jaGFpbklkKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShjaGFpbklkID09PSBuZXR3b3JrLmNoYWluSWQsIFwidHJhbnNhY3Rpb24gY2hhaW5JZCBtaXNtYXRjaFwiLCBcInR4LmNoYWluSWRcIiwgdHguY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3AuY2hhaW5JZCA9IG5ldHdvcmsuY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgbWl4aW5nIHByZS1laXAtMTU1OSBhbmQgZWlwLTE1NTkgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgIT0gbnVsbCAmJiAocG9wLnR5cGUgPT09IDIgfHwgaGFzRWlwMTU1OSkpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocG9wLnR5cGUgPT09IDAgfHwgcG9wLnR5cGUgPT09IDEpICYmIGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJwcmUtZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBMZWdhY3kgb3IgRUlQLTI5MzAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRHYXNQcmljZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgaWYgKHBvcC50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cbiAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTkhXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoIWhhc0VpcDE1NTksIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHVudHlwZWQgdHJhbnNhY3Rpb24gdG8gbGVnYWN5XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBNYXliZSB0aGlzIHNob2xkIGFsbG93IHR5cGUgMT9cbiAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RmVlRGF0YSBoYXMgZmFpbGVkIHVzLlxuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZhbHNlLCBcImZhaWxlZCB0byBnZXQgY29uc2lzdGVudCBmZWUgZGF0YVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmdldEZlZURhdGFcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3AudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNpbmcgRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0BUT09EOiBEb24ndCBhd2FpdCBhbGwgb3ZlciB0aGUgcGxhY2U7IHNhdmUgdGhlbSB1cCBmb3JcbiAgICAgICAgLy8gdGhlIGVuZCBmb3IgYmV0dGVyIGJhdGNoaW5nXG4gICAgICAgIHJldHVybiBhd2FpdCAoMCwgaW5kZXhfanNfMy5yZXNvbHZlUHJvcGVydGllcykocG9wKTtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVHYXModHgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJlc3RpbWF0ZUdhc1wiKS5lc3RpbWF0ZUdhcyhhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiY2FsbFwiKS5jYWxsKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgZGVsZXRlIHBvcC5mcm9tO1xuICAgICAgICBjb25zdCB0eE9iaiA9IGluZGV4X2pzXzIuVHJhbnNhY3Rpb24uZnJvbShwb3ApO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuYnJvYWRjYXN0VHJhbnNhY3Rpb24oYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHhPYmopKTtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0U2lnbmVyID0gQWJzdHJhY3RTaWduZXI7XG4vKipcbiAqICBBICoqVm9pZFNpZ25lcioqIGlzIGEgY2xhc3MgZGVpc2duZWQgdG8gYWxsb3cgYW4gYWRkcmVzcyB0byBiZSB1c2VkXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xuICogIGNyZWRlbnRpYWxzIGF2YWlsYWJsZSB0byBwZXJmb3JtIGFueSBhY3R1YWwgc2lnbmluZy5cbiAqXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXG4gKiAgc3RhdGljIGNhbGxzIG9yIGVzdGltYXRpbmcgZ2FzLCBidXQgZG9lcyBub3QgYWxsb3cgc2VuZGluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmNsYXNzIFZvaWRTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduZXIgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqVm9pZFNpZ25lcioqIHdpdGggJSVhZGRyZXNzJSUgYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxuICAgICN0aHJvd1Vuc3VwcG9ydGVkKHN1ZmZpeCwgb3BlcmF0aW9uKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmFsc2UsIGBWb2lkU2lnbmVyIGNhbm5vdCBzaWduICR7c3VmZml4fWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcInRyYW5zYWN0aW9uc1wiLCBcInNpZ25UcmFuc2FjdGlvblwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwibWVzc2FnZXNcIiwgXCJzaWduTWVzc2FnZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHlwZWQtZGF0YVwiLCBcInNpZ25UeXBlZERhdGFcIik7XG4gICAgfVxufVxuZXhwb3J0cy5Wb2lkU2lnbmVyID0gVm9pZFNpZ25lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LXNpZ25lci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/community.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n *  There are many awesome community services that provide Ethereum\n *  nodes both for developers just starting out and for large-scale\n *  communities.\n *\n *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.showThrottleMessage = void 0;\n// Show the throttle message only once per service\nconst shown = new Set();\n/**\n *  Displays a warning in tht console when the community resource is\n *  being used too heavily by the app, recommending the developer\n *  acquire their own credentials instead of using the community\n *  credentials.\n *\n *  The notification will only occur once per service.\n */\nfunction showThrottleMessage(service) {\n    if (shown.has(service)) {\n        return;\n    }\n    shown.add(service);\n    console.log(\"========= NOTICE =========\");\n    console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.org/api-keys/\");\n    console.log(\"==========================\");\n}\nexports.showThrottleMessage = showThrottleMessage;\n//# sourceMappingURL=community.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvY29tbXVuaXR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9jb21tdW5pdHkuanM/YTVmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZXJlIGFyZSBtYW55IGF3ZXNvbWUgY29tbXVuaXR5IHNlcnZpY2VzIHRoYXQgcHJvdmlkZSBFdGhlcmV1bVxuICogIG5vZGVzIGJvdGggZm9yIGRldmVsb3BlcnMganVzdCBzdGFydGluZyBvdXQgYW5kIGZvciBsYXJnZS1zY2FsZVxuICogIGNvbW11bml0aWVzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTogQ29tbXVuaXR5IFByb3ZpZGVycyAgW3RoaXJkcGFydHldXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hvd1Rocm90dGxlTWVzc2FnZSA9IHZvaWQgMDtcbi8vIFNob3cgdGhlIHRocm90dGxlIG1lc3NhZ2Ugb25seSBvbmNlIHBlciBzZXJ2aWNlXG5jb25zdCBzaG93biA9IG5ldyBTZXQoKTtcbi8qKlxuICogIERpc3BsYXlzIGEgd2FybmluZyBpbiB0aHQgY29uc29sZSB3aGVuIHRoZSBjb21tdW5pdHkgcmVzb3VyY2UgaXNcbiAqICBiZWluZyB1c2VkIHRvbyBoZWF2aWx5IGJ5IHRoZSBhcHAsIHJlY29tbWVuZGluZyB0aGUgZGV2ZWxvcGVyXG4gKiAgYWNxdWlyZSB0aGVpciBvd24gY3JlZGVudGlhbHMgaW5zdGVhZCBvZiB1c2luZyB0aGUgY29tbXVuaXR5XG4gKiAgY3JlZGVudGlhbHMuXG4gKlxuICogIFRoZSBub3RpZmljYXRpb24gd2lsbCBvbmx5IG9jY3VyIG9uY2UgcGVyIHNlcnZpY2UuXG4gKi9cbmZ1bmN0aW9uIHNob3dUaHJvdHRsZU1lc3NhZ2Uoc2VydmljZSkge1xuICAgIGlmIChzaG93bi5oYXMoc2VydmljZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzaG93bi5hZGQoc2VydmljZSk7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT0gTk9USUNFID09PT09PT09PVwiKTtcbiAgICBjb25zb2xlLmxvZyhgUmVxdWVzdC1SYXRlIEV4Y2VlZGVkIGZvciAke3NlcnZpY2V9ICh0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcmVwZWF0ZWQpYCk7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJUaGUgZGVmYXVsdCBBUEkga2V5cyBmb3IgZWFjaCBzZXJ2aWNlIGFyZSBwcm92aWRlZCBhcyBhIGhpZ2hseS10aHJvdHRsZWQsXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiY29tbXVuaXR5IHJlc291cmNlIGZvciBsb3ctdHJhZmZpYyBwcm9qZWN0cyBhbmQgZWFybHkgcHJvdG90eXBpbmcuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiV2hpbGUgeW91ciBhcHBsaWNhdGlvbiB3aWxsIGNvbnRpbnVlIHRvIGZ1bmN0aW9uLCB3ZSBoaWdobHkgcmVjb21tZW5kZWRcIik7XG4gICAgY29uc29sZS5sb2coXCJzaWduaW5nIHVwIGZvciB5b3VyIG93biBBUEkga2V5cyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBpbmNyZWFzZSB5b3VyXCIpO1xuICAgIGNvbnNvbGUubG9nKFwicmVxdWVzdCByYXRlL2xpbWl0IGFuZCBlbmFibGUgb3RoZXIgcGVya3MsIHN1Y2ggYXMgbWV0cmljcyBhbmQgYWR2YW5jZWQgQVBJcy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJGb3IgbW9yZSBkZXRhaWxzOiBodHRwczovXFwvZG9jcy5ldGhlcnMub3JnL2FwaS1rZXlzL1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xufVxuZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gc2hvd1Rocm90dGxlTWVzc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW11bml0eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/default-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/default-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDefaultProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst provider_ankr_js_1 = __webpack_require__(/*! ./provider-ankr.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-ankr.js\");\nconst provider_alchemy_js_1 = __webpack_require__(/*! ./provider-alchemy.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js\");\nconst provider_cloudflare_js_1 = __webpack_require__(/*! ./provider-cloudflare.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js\");\nconst provider_etherscan_js_1 = __webpack_require__(/*! ./provider-etherscan.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js\");\nconst provider_infura_js_1 = __webpack_require__(/*! ./provider-infura.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-infura.js\");\n//import { PocketProvider } from \"./provider-pocket.js\";\nconst provider_quicknode_js_1 = __webpack_require__(/*! ./provider-quicknode.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js\");\nconst provider_fallback_js_1 = __webpack_require__(/*! ./provider-fallback.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-fallback.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js\");\nfunction isWebSocketLike(value) {\n    return (value && typeof (value.send) === \"function\" &&\n        typeof (value.close) === \"function\");\n}\nconst Testnets = \"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\" \");\n/**\n *  Returns a default provider for %%network%%.\n *\n *  If %%network%% is a [[WebSocketLike]] or string that begins with\n *  ``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\n *  by that WebSocket or URL.\n *\n *  If %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\n *  a [[JsonRpcProvider]] is returned connected to that URL.\n *\n *  Otherwise, a default provider is created backed by well-known public\n *  Web3 backends (such as [[link-infura]]) using community-provided API\n *  keys.\n *\n *  The %%options%% allows specifying custom API keys per backend (setting\n *  an API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\n *  can be set to either a backend name or and array of backend names, which\n *  will whitelist **only** those backends.\n *\n *  Current backend strings supported are:\n *  - ``\"alchemy\"``\n *  - ``\"ankr\"``\n *  - ``\"cloudflare\"``\n *  - ``\"etherscan\"``\n *  - ``\"infura\"``\n *  - ``\"publicPolygon\"``\n *  - ``\"quicknode\"``\n *\n *  @example:\n *    // Connect to a local Geth node\n *    provider = getDefaultProvider(\"http://localhost:8545/\");\n *\n *    // Connect to Ethereum mainnet with any current and future\n *    // third-party services available\n *    provider = getDefaultProvider(\"mainnet\");\n *\n *    // Connect to Polygon, but only allow Etherscan and\n *    // INFURA and use \"MY_API_KEY\" in calls to Etherscan.\n *    provider = getDefaultProvider(\"matic\", {\n *      etherscan: \"MY_API_KEY\",\n *      exclusive: [ \"etherscan\", \"infura\" ]\n *    });\n */\nfunction getDefaultProvider(network, options) {\n    if (options == null) {\n        options = {};\n    }\n    const allowService = (name) => {\n        if (options[name] === \"-\") {\n            return false;\n        }\n        if (typeof (options.exclusive) === \"string\") {\n            return (name === options.exclusive);\n        }\n        if (Array.isArray(options.exclusive)) {\n            return (options.exclusive.indexOf(name) !== -1);\n        }\n        return true;\n    };\n    if (typeof (network) === \"string\" && network.match(/^https?:/)) {\n        return new provider_jsonrpc_js_1.JsonRpcProvider(network);\n    }\n    if (typeof (network) === \"string\" && network.match(/^wss?:/) || isWebSocketLike(network)) {\n        return new provider_websocket_js_1.WebSocketProvider(network);\n    }\n    // Get the network and name, if possible\n    let staticNetwork = null;\n    try {\n        staticNetwork = network_js_1.Network.from(network);\n    }\n    catch (error) { }\n    const providers = [];\n    if (allowService(\"publicPolygon\") && staticNetwork) {\n        if (staticNetwork.name === \"matic\") {\n            providers.push(new provider_jsonrpc_js_1.JsonRpcProvider(\"https:/\\/polygon-rpc.com/\", staticNetwork, { staticNetwork }));\n        }\n    }\n    if (allowService(\"alchemy\")) {\n        try {\n            providers.push(new provider_alchemy_js_1.AlchemyProvider(network, options.alchemy));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"ankr\") && options.ankr != null) {\n        try {\n            providers.push(new provider_ankr_js_1.AnkrProvider(network, options.ankr));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"cloudflare\")) {\n        try {\n            providers.push(new provider_cloudflare_js_1.CloudflareProvider(network));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"etherscan\")) {\n        try {\n            providers.push(new provider_etherscan_js_1.EtherscanProvider(network, options.etherscan));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"infura\")) {\n        try {\n            let projectId = options.infura;\n            let projectSecret = undefined;\n            if (typeof (projectId) === \"object\") {\n                projectSecret = projectId.projectSecret;\n                projectId = projectId.projectId;\n            }\n            providers.push(new provider_infura_js_1.InfuraProvider(network, projectId, projectSecret));\n        }\n        catch (error) { }\n    }\n    /*\n        if (options.pocket !== \"-\") {\n            try {\n                let appId = options.pocket;\n                let secretKey: undefined | string = undefined;\n                let loadBalancer: undefined | boolean = undefined;\n                if (typeof(appId) === \"object\") {\n                    loadBalancer = !!appId.loadBalancer;\n                    secretKey = appId.secretKey;\n                    appId = appId.appId;\n                }\n                providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));\n            } catch (error) { console.log(error); }\n        }\n    */\n    if (allowService(\"quicknode\")) {\n        try {\n            let token = options.quicknode;\n            providers.push(new provider_quicknode_js_1.QuickNodeProvider(network, token));\n        }\n        catch (error) { }\n    }\n    (0, index_js_1.assert)(providers.length, \"unsupported default network\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getDefaultProvider\"\n    });\n    // No need for a FallbackProvider\n    if (providers.length === 1) {\n        return providers[0];\n    }\n    // We use the floor because public third-party providers can be unreliable,\n    // so a low number of providers with a large quorum will fail too often\n    let quorum = Math.floor(providers.length / 2);\n    if (quorum > 2) {\n        quorum = 2;\n    }\n    // Testnets don't need as strong a security gaurantee and speed is\n    // more useful during testing\n    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {\n        quorum = 1;\n    }\n    // Provided override qorum takes priority\n    if (options && options.quorum) {\n        quorum = options.quorum;\n    }\n    return new provider_fallback_js_1.FallbackProvider(providers, undefined, { quorum });\n}\nexports.getDefaultProvider = getDefaultProvider;\n//# sourceMappingURL=default-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZGVmYXVsdC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLDJCQUEyQixtQkFBTyxDQUFDLCtGQUFvQjtBQUN2RCw4QkFBOEIsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsMkdBQTBCO0FBQ25FLGdDQUFnQyxtQkFBTyxDQUFDLHlHQUF5QjtBQUNqRSw2QkFBNkIsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDM0QsV0FBVyxpQkFBaUI7QUFDNUIsZ0NBQWdDLG1CQUFPLENBQUMseUdBQXlCO0FBQ2pFLCtCQUErQixtQkFBTyxDQUFDLHVHQUF3QjtBQUMvRCw4QkFBOEIsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsbUZBQWM7QUFDM0MsZ0NBQWdDLG1CQUFPLENBQUMseUdBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsZUFBZTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxRQUFRO0FBQ3ZGO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL2RlZmF1bHQtcHJvdmlkZXIuanM/NWEyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2Fua3JfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWFua3IuanNcIik7XG5jb25zdCBwcm92aWRlcl9hbGNoZW15X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1hbGNoZW15LmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfY2xvdWRmbGFyZV9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItY2xvdWRmbGFyZS5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2V0aGVyc2Nhbl9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItZXRoZXJzY2FuLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfaW5mdXJhX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1pbmZ1cmEuanNcIik7XG4vL2ltcG9ydCB7IFBvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItcG9ja2V0LmpzXCI7XG5jb25zdCBwcm92aWRlcl9xdWlja25vZGVfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLXF1aWNrbm9kZS5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2ZhbGxiYWNrX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1mYWxsYmFjay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfd2Vic29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci13ZWJzb2NrZXQuanNcIik7XG5mdW5jdGlvbiBpc1dlYlNvY2tldExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgKHZhbHVlLmNsb3NlKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmNvbnN0IFRlc3RuZXRzID0gXCJnb2VybGkga292YW4gc2Vwb2xpYSBjbGFzc2ljS290dGkgb3B0aW1pc20tZ29lcmxpIGFyYml0cnVtLWdvZXJsaSBtYXRpYy1tdW1iYWkgYm5idFwiLnNwbGl0KFwiIFwiKTtcbi8qKlxuICogIFJldHVybnMgYSBkZWZhdWx0IHByb3ZpZGVyIGZvciAlJW5ldHdvcmslJS5cbiAqXG4gKiAgSWYgJSVuZXR3b3JrJSUgaXMgYSBbW1dlYlNvY2tldExpa2VdXSBvciBzdHJpbmcgdGhhdCBiZWdpbnMgd2l0aFxuICogIGBgXCJ3czpcImBgIG9yIGBgXCJ3c3M6XCJgYCwgYSBbW1dlYlNvY2tldFByb3ZpZGVyXV0gaXMgcmV0dXJuZWQgYmFja2VkXG4gKiAgYnkgdGhhdCBXZWJTb2NrZXQgb3IgVVJMLlxuICpcbiAqICBJZiAlJW5ldHdvcmslJSBpcyBhIHN0cmluZyB0aGF0IGJlZ2lucyB3aXRoIGBgXCJIVFRQOlwiYGAgb3IgYGBcIkhUVFBTOlwiYGAsXG4gKiAgYSBbW0pzb25ScGNQcm92aWRlcl1dIGlzIHJldHVybmVkIGNvbm5lY3RlZCB0byB0aGF0IFVSTC5cbiAqXG4gKiAgT3RoZXJ3aXNlLCBhIGRlZmF1bHQgcHJvdmlkZXIgaXMgY3JlYXRlZCBiYWNrZWQgYnkgd2VsbC1rbm93biBwdWJsaWNcbiAqICBXZWIzIGJhY2tlbmRzIChzdWNoIGFzIFtbbGluay1pbmZ1cmFdXSkgdXNpbmcgY29tbXVuaXR5LXByb3ZpZGVkIEFQSVxuICogIGtleXMuXG4gKlxuICogIFRoZSAlJW9wdGlvbnMlJSBhbGxvd3Mgc3BlY2lmeWluZyBjdXN0b20gQVBJIGtleXMgcGVyIGJhY2tlbmQgKHNldHRpbmdcbiAqICBhbiBBUEkga2V5IHRvIGBgXCItXCJgYCB3aWxsIG9taXQgdGhhdCBwcm92aWRlcikgYW5kIGBgb3B0aW9ucy5leGNsdXNpdmVgYFxuICogIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGEgYmFja2VuZCBuYW1lIG9yIGFuZCBhcnJheSBvZiBiYWNrZW5kIG5hbWVzLCB3aGljaFxuICogIHdpbGwgd2hpdGVsaXN0ICoqb25seSoqIHRob3NlIGJhY2tlbmRzLlxuICpcbiAqICBDdXJyZW50IGJhY2tlbmQgc3RyaW5ncyBzdXBwb3J0ZWQgYXJlOlxuICogIC0gYGBcImFsY2hlbXlcImBgXG4gKiAgLSBgYFwiYW5rclwiYGBcbiAqICAtIGBgXCJjbG91ZGZsYXJlXCJgYFxuICogIC0gYGBcImV0aGVyc2NhblwiYGBcbiAqICAtIGBgXCJpbmZ1cmFcImBgXG4gKiAgLSBgYFwicHVibGljUG9seWdvblwiYGBcbiAqICAtIGBgXCJxdWlja25vZGVcImBgXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gQ29ubmVjdCB0byBhIGxvY2FsIEdldGggbm9kZVxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJodHRwOi8vbG9jYWxob3N0Ojg1NDUvXCIpO1xuICpcbiAqICAgIC8vIENvbm5lY3QgdG8gRXRoZXJldW0gbWFpbm5ldCB3aXRoIGFueSBjdXJyZW50IGFuZCBmdXR1cmVcbiAqICAgIC8vIHRoaXJkLXBhcnR5IHNlcnZpY2VzIGF2YWlsYWJsZVxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJtYWlubmV0XCIpO1xuICpcbiAqICAgIC8vIENvbm5lY3QgdG8gUG9seWdvbiwgYnV0IG9ubHkgYWxsb3cgRXRoZXJzY2FuIGFuZFxuICogICAgLy8gSU5GVVJBIGFuZCB1c2UgXCJNWV9BUElfS0VZXCIgaW4gY2FsbHMgdG8gRXRoZXJzY2FuLlxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJtYXRpY1wiLCB7XG4gKiAgICAgIGV0aGVyc2NhbjogXCJNWV9BUElfS0VZXCIsXG4gKiAgICAgIGV4Y2x1c2l2ZTogWyBcImV0aGVyc2NhblwiLCBcImluZnVyYVwiIF1cbiAqICAgIH0pO1xuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0UHJvdmlkZXIobmV0d29yaywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBhbGxvd1NlcnZpY2UgPSAobmFtZSkgPT4ge1xuICAgICAgICBpZiAob3B0aW9uc1tuYW1lXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLmV4Y2x1c2l2ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAobmFtZSA9PT0gb3B0aW9ucy5leGNsdXNpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuZXhjbHVzaXZlKSkge1xuICAgICAgICAgICAgcmV0dXJuIChvcHRpb25zLmV4Y2x1c2l2ZS5pbmRleE9mKG5hbWUpICE9PSAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIiAmJiBuZXR3b3JrLm1hdGNoKC9eaHR0cHM/Oi8pKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgJiYgbmV0d29yay5tYXRjaCgvXndzcz86LykgfHwgaXNXZWJTb2NrZXRMaWtlKG5ldHdvcmspKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJfd2Vic29ja2V0X2pzXzEuV2ViU29ja2V0UHJvdmlkZXIobmV0d29yayk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgbmV0d29yayBhbmQgbmFtZSwgaWYgcG9zc2libGVcbiAgICBsZXQgc3RhdGljTmV0d29yayA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RhdGljTmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20obmV0d29yayk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgY29uc3QgcHJvdmlkZXJzID0gW107XG4gICAgaWYgKGFsbG93U2VydmljZShcInB1YmxpY1BvbHlnb25cIikgJiYgc3RhdGljTmV0d29yaykge1xuICAgICAgICBpZiAoc3RhdGljTmV0d29yay5uYW1lID09PSBcIm1hdGljXCIpIHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY1Byb3ZpZGVyKFwiaHR0cHM6L1xcL3BvbHlnb24tcnBjLmNvbS9cIiwgc3RhdGljTmV0d29yaywgeyBzdGF0aWNOZXR3b3JrIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiYWxjaGVteVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IHByb3ZpZGVyX2FsY2hlbXlfanNfMS5BbGNoZW15UHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbGNoZW15KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImFua3JcIikgJiYgb3B0aW9ucy5hbmtyICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBwcm92aWRlcl9hbmtyX2pzXzEuQW5rclByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuYW5rcikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJjbG91ZGZsYXJlXCIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfY2xvdWRmbGFyZV9qc18xLkNsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImV0aGVyc2NhblwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IHByb3ZpZGVyX2V0aGVyc2Nhbl9qc18xLkV0aGVyc2NhblByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuZXRoZXJzY2FuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImluZnVyYVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb2plY3RJZCA9IG9wdGlvbnMuaW5mdXJhO1xuICAgICAgICAgICAgbGV0IHByb2plY3RTZWNyZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChwcm9qZWN0SWQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdFNlY3JldCA9IHByb2plY3RJZC5wcm9qZWN0U2VjcmV0O1xuICAgICAgICAgICAgICAgIHByb2plY3RJZCA9IHByb2plY3RJZC5wcm9qZWN0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfaW5mdXJhX2pzXzEuSW5mdXJhUHJvdmlkZXIobmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgLypcbiAgICAgICAgaWYgKG9wdGlvbnMucG9ja2V0ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYXBwSWQgPSBvcHRpb25zLnBvY2tldDtcbiAgICAgICAgICAgICAgICBsZXQgc2VjcmV0S2V5OiB1bmRlZmluZWQgfCBzdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IGxvYWRCYWxhbmNlcjogdW5kZWZpbmVkIHwgYm9vbGVhbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGFwcElkKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2FkQmFsYW5jZXIgPSAhIWFwcElkLmxvYWRCYWxhbmNlcjtcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0S2V5ID0gYXBwSWQuc2VjcmV0S2V5O1xuICAgICAgICAgICAgICAgICAgICBhcHBJZCA9IGFwcElkLmFwcElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgUG9ja2V0UHJvdmlkZXIobmV0d29yaywgYXBwSWQsIHNlY3JldEtleSwgbG9hZEJhbGFuY2VyKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgeyBjb25zb2xlLmxvZyhlcnJvcik7IH1cbiAgICAgICAgfVxuICAgICovXG4gICAgaWYgKGFsbG93U2VydmljZShcInF1aWNrbm9kZVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gb3B0aW9ucy5xdWlja25vZGU7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfcXVpY2tub2RlX2pzXzEuUXVpY2tOb2RlUHJvdmlkZXIobmV0d29yaywgdG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHByb3ZpZGVycy5sZW5ndGgsIFwidW5zdXBwb3J0ZWQgZGVmYXVsdCBuZXR3b3JrXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldERlZmF1bHRQcm92aWRlclwiXG4gICAgfSk7XG4gICAgLy8gTm8gbmVlZCBmb3IgYSBGYWxsYmFja1Byb3ZpZGVyXG4gICAgaWYgKHByb3ZpZGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1swXTtcbiAgICB9XG4gICAgLy8gV2UgdXNlIHRoZSBmbG9vciBiZWNhdXNlIHB1YmxpYyB0aGlyZC1wYXJ0eSBwcm92aWRlcnMgY2FuIGJlIHVucmVsaWFibGUsXG4gICAgLy8gc28gYSBsb3cgbnVtYmVyIG9mIHByb3ZpZGVycyB3aXRoIGEgbGFyZ2UgcXVvcnVtIHdpbGwgZmFpbCB0b28gb2Z0ZW5cbiAgICBsZXQgcXVvcnVtID0gTWF0aC5mbG9vcihwcm92aWRlcnMubGVuZ3RoIC8gMik7XG4gICAgaWYgKHF1b3J1bSA+IDIpIHtcbiAgICAgICAgcXVvcnVtID0gMjtcbiAgICB9XG4gICAgLy8gVGVzdG5ldHMgZG9uJ3QgbmVlZCBhcyBzdHJvbmcgYSBzZWN1cml0eSBnYXVyYW50ZWUgYW5kIHNwZWVkIGlzXG4gICAgLy8gbW9yZSB1c2VmdWwgZHVyaW5nIHRlc3RpbmdcbiAgICBpZiAoc3RhdGljTmV0d29yayAmJiBUZXN0bmV0cy5pbmRleE9mKHN0YXRpY05ldHdvcmsubmFtZSkgIT09IC0xKSB7XG4gICAgICAgIHF1b3J1bSA9IDE7XG4gICAgfVxuICAgIC8vIFByb3ZpZGVkIG92ZXJyaWRlIHFvcnVtIHRha2VzIHByaW9yaXR5XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdW9ydW0pIHtcbiAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG4gICAgfVxuICAgIHJldHVybiBuZXcgcHJvdmlkZXJfZmFsbGJhY2tfanNfMS5GYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVycywgdW5kZWZpbmVkLCB7IHF1b3J1bSB9KTtcbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gZ2V0RGVmYXVsdFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/default-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/ens-resolver.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/ens-resolver.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EnsResolver = exports.BasicMulticoinProviderPlugin = exports.MulticoinProviderPlugin = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        (0, index_js_5.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nclass MulticoinProviderPlugin {\n    /**\n     *  The name.\n     */\n    name;\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name) {\n        (0, index_js_5.defineProperties)(this, { name });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */\n    supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resovles to the encoded %%address%% for %%coinType%%.\n     */\n    async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resovles to the decoded %%data%% for %%coinType%%.\n     */\n    async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nexports.MulticoinProviderPlugin = MulticoinProviderPlugin;\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */\nclass BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */\n    constructor() {\n        super(BasicMulticoinPluginId);\n    }\n}\nexports.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nclass EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider;\n    /**\n     *  The address of the resolver.\n     */\n    address;\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name;\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name) {\n        (0, index_js_5.defineProperties)(this, { provider, address, name });\n        this.#supports2544 = null;\n        this.#resolver = new index_js_3.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\",\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */\n    async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async () => {\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                }\n                catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0, index_js_5.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift((0, index_js_4.namehash)(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            (0, index_js_5.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: { funcName }\n            });\n            params = [\n                (0, index_js_4.dnsEncode)(this.name, 255),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        }\n        catch (error) {\n            if (!(0, index_js_5.isError)(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */\n    async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === index_js_2.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            }\n            catch (error) {\n                if ((0, index_js_5.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [ethCoinType]);\n            if ((0, index_js_5.isHexString)(data, 20)) {\n                return (0, index_js_1.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins) {\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [coinType]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0, index_js_5.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: { coinType, data }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */\n    async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [key]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */\n    async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = (ipfs[1] === \"e3010170\") ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${(0, index_js_5.encodeBase58)(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        (0, index_js_5.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: { data }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */\n    async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */\n    async _getAvatar() {\n        const linkage = [{ type: \"name\", value: this.name }];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({ type: \"!avatar\", value: \"\" });\n                return { url: null, linkage };\n            }\n            linkage.push({ type: \"avatar\", value: avatar });\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch (scheme) {\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({ type: \"url\", value: avatar });\n                        return { linkage, url: avatar };\n                    case \"ipfs\": {\n                        const url = getIpfsLink(avatar);\n                        linkage.push({ type: \"ipfs\", value: avatar });\n                        linkage.push({ type: \"url\", value: url });\n                        return { linkage, url };\n                    }\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                        linkage.push({ type: scheme, value: avatar });\n                        // The owner of this name\n                        const owner = await this.getAddress();\n                        if (owner == null) {\n                            linkage.push({ type: \"!owner\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            linkage.push({ type: `!${scheme}caip`, value: (match[2] || \"\") });\n                            return { url: null, linkage };\n                        }\n                        const tokenId = comps[1];\n                        const contract = new index_js_3.Contract(comps[0], [\n                            // ERC-721\n                            \"function tokenURI(uint) view returns (string)\",\n                            \"function ownerOf(uint) view returns (address)\",\n                            // ERC-1155\n                            \"function uri(uint) view returns (string)\",\n                            \"function balanceOf(address, uint256) view returns (uint)\"\n                        ], this.provider);\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            const tokenOwner = await contract.ownerOf(tokenId);\n                            if (owner !== tokenOwner) {\n                                linkage.push({ type: \"!owner\", value: tokenOwner });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"owner\", value: tokenOwner });\n                        }\n                        else if (scheme === \"erc1155\") {\n                            const balance = await contract.balanceOf(owner, tokenId);\n                            if (!balance) {\n                                linkage.push({ type: \"!balance\", value: \"0\" });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"balance\", value: balance.toString() });\n                        }\n                        // Call the token contract for the metadata URL\n                        let metadataUrl = await contract[selector](tokenId);\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\n                            linkage.push({ type: \"!metadata-url\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        linkage.push({ type: \"metadata-url-base\", value: metadataUrl });\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", (0, index_js_5.toBeHex)(tokenId, 32).substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", value: metadataUrl });\n                        }\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n                        linkage.push({ type: \"metadata-url\", value: metadataUrl });\n                        // Get the token metadata\n                        let metadata = {};\n                        const response = await (new index_js_5.FetchRequest(metadataUrl)).send();\n                        response.assertOk();\n                        try {\n                            metadata = response.bodyJson;\n                        }\n                        catch (error) {\n                            try {\n                                linkage.push({ type: \"!metadata\", value: response.bodyText });\n                            }\n                            catch (error) {\n                                const bytes = response.body;\n                                if (bytes) {\n                                    linkage.push({ type: \"!metadata\", value: (0, index_js_5.hexlify)(bytes) });\n                                }\n                                return { url: null, linkage };\n                            }\n                            return { url: null, linkage };\n                        }\n                        if (!metadata) {\n                            linkage.push({ type: \"!metadata\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        linkage.push({ type: \"metadata\", value: JSON.stringify(metadata) });\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof (imageUrl) !== \"string\") {\n                            linkage.push({ type: \"!imageUrl\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        }\n                        else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                linkage.push({ type: \"!imageUrl-ipfs\", value: imageUrl });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"imageUrl-ipfs\", value: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n                        linkage.push({ type: \"url\", value: imageUrl });\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        }\n        catch (error) { }\n        return { linkage, url: null };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0, index_js_5.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\", info: { network }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new index_js_3.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver((0, index_js_4.namehash)(name), {\n                enableCcipRead: true\n            });\n            if (addr === index_js_2.ZeroAddress) {\n                return null;\n            }\n            return addr;\n        }\n        catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */\n    static async fromName(provider, name) {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n}\nexports.EnsResolver = EnsResolver;\n//# sourceMappingURL=ens-resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG9DQUFvQyxHQUFHLCtCQUErQjtBQUM1RixtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXVCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLHdGQUFzQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTyxNQUFNLDZDQUE2QztBQUNwRjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRCx5QkFBeUI7QUFDekI7QUFDQSwyQkFBMkIsK0JBQStCO0FBQzFELDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkUsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQTZCO0FBQ3BFLHVDQUF1Qyx5QkFBeUI7QUFDaEUsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQkFBMkI7QUFDdEUscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVLE9BQU8sZ0NBQWdDO0FBQzVGLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRix5Q0FBeUM7QUFDekM7QUFDQSwyQ0FBMkMsa0NBQWtDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDhCQUE4QjtBQUM3RSx5Q0FBeUM7QUFDekM7QUFDQSwyQ0FBMkMsNENBQTRDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGtDQUFrQztBQUM3RSxxQ0FBcUM7QUFDckM7QUFDQSx1Q0FBdUMsK0NBQStDO0FBQ3RGLHNEQUFzRCxJQUFJO0FBQzFEO0FBQ0EsZ0VBQWdFLEdBQUc7QUFDbkUsMkNBQTJDLG1EQUFtRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBDQUEwQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBEQUEwRDtBQUM3RztBQUNBLHlDQUF5QztBQUN6QztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RSxxQ0FBcUM7QUFDckM7QUFDQSx1Q0FBdUMsbURBQW1EO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4QkFBOEI7QUFDekUscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUNBQXlDO0FBQ3hGLHlDQUF5QztBQUN6QztBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckUsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXIuanM/ZGNkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEVOUyBpcyBhIHNlcnZpY2Ugd2hpY2ggYWxsb3dzIGVhc3ktdG8tcmVtZW1iZXIgbmFtZXMgdG8gbWFwIHRvXG4gKiAgbmV0d29yayBhZGRyZXNzZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXI6RU5TIFJlc29sdmVyICBbYWJvdXQtZW5zLXJzb2x2ZXJdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW5zUmVzb2x2ZXIgPSBleHBvcnRzLkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4gPSBleHBvcnRzLk11bHRpY29pblByb3ZpZGVyUGx1Z2luID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbi8vIEBUT0RPOiBUaGlzIHNob3VsZCB1c2UgdGhlIGZldGNoLWRhdGE6aXBmcyBnYXRld2F5XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbjtcbjtcbi8qKlxuICogIEEgcHJvdmlkZXIgcGx1Z2luIHN1cGVyLWNsYXNzIGZvciBwcm9jZXNzaW5nIG11bHRpY29pbiBhZGRyZXNzIHR5cGVzLlxuICovXG5jbGFzcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipNdWx0aWNvaW5Qcm92aWRlclBsdWluZyoqIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgICgwLCBpbmRleF9qc181LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm9pdmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSVjb2luVHlwZSUlIGlzIHN1cHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBzdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc292bGVzIHRvIHRoZSBlbmNvZGVkICUlYWRkcmVzcyUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZW5jb2RlQWRkcmVzcyhjb2luVHlwZSwgYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb3ZsZXMgdG8gdGhlIGRlY29kZWQgJSVkYXRhJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxufVxuZXhwb3J0cy5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbiA9IE11bHRpY29pblByb3ZpZGVyUGx1Z2luO1xuY29uc3QgQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCA9IFwib3JnLmV0aGVycy5wbHVnaW5zLnByb3ZpZGVyLkJhc2ljTXVsdGljb2luXCI7XG4vKipcbiAqICBBICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqIHByb3ZpZGVzIHNlcnZpY2UgZm9yIGNvbW1vblxuICogIGNvaW4gdHlwZXMsIHdoaWNoIGRvIG5vdCByZXF1aXJlIGFkZGl0aW9uYWwgbGlicmFyaWVzIHRvIGVuY29kZSBvclxuICogIGRlY29kZS5cbiAqL1xuY2xhc3MgQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiBleHRlbmRzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luID0gQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbjtcbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbi8qKlxuICogIEEgY29ubmVjdGVkIG9iamVjdCB0byBhIHJlc29sdmVkIEVOUyBuYW1lIHJlc29sdmVyLCB3aGljaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGFkZGl0aW9uYWwgZGV0YWlscy5cbiAqL1xuY2xhc3MgRW5zUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgcmVzb2x2ZXIuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgdGhpcyByZXNvbHZlciB3YXMgcmVzb2x2ZWQgYWdhaW5zdC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8vIEZvciBFSVAtMjU0NCBuYW1lcywgdGhlIGFuY2VzdG9yIHRoYXQgcHJvdmlkZWQgdGhlIHJlc29sdmVyXG4gICAgI3N1cHBvcnRzMjU0NDtcbiAgICAjcmVzb2x2ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzUuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwcm92aWRlciwgYWRkcmVzcywgbmFtZSB9KTtcbiAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZXIgPSBuZXcgaW5kZXhfanNfMy5Db250cmFjdChhZGRyZXNzLCBbXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCkgdmlldyByZXR1cm5zIChib29sKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlKGJ5dGVzLCBieXRlcykgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMiwgdWludCkgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gdGV4dChieXRlczMyLCBzdHJpbmcpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBjb250ZW50aGFzaChieXRlczMyKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0cnVlIGlmIHRoZSByZXNvbHZlciBzdXBwb3J0cyB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNzdXBwb3J0czI1NDQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmVzb2x2ZXIuc3VwcG9ydHNJbnRlcmZhY2UoXCIweDkwNjFiOTIzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2lsZGNhcmQgcmVzb2x2ZXJzIG11c3QgdW5kZXJzdGFuZCBzdXBwb3J0c0ludGVyZmFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNS5pc0Vycm9yKShlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCBmdXR1cmUgYXR0ZW1wdHMgdHJ5IGFnYWluLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3N1cHBvcnRzMjU0NDtcbiAgICB9XG4gICAgYXN5bmMgI2ZldGNoKGZ1bmNOYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSB0aGlzLiNyZXNvbHZlci5pbnRlcmZhY2U7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXJzIGlzIGFsd2F5cyB0aGUgbm9kZWhhc2hcbiAgICAgICAgcGFyYW1zLnVuc2hpZnQoKDAsIGluZGV4X2pzXzQubmFtZWhhc2gpKHRoaXMubmFtZSkpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gaWZhY2UuZ2V0RnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KShmcmFnbWVudCwgXCJtaXNzaW5nIGZyYWdtZW50XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgaW5mbzogeyBmdW5jTmFtZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5kbnNFbmNvZGUpKHRoaXMubmFtZSwgMjU1KSxcbiAgICAgICAgICAgICAgICBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHBhcmFtcylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmdW5jTmFtZSA9IFwicmVzb2x2ZShieXRlcyxieXRlcylcIjtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Jlc29sdmVyW2Z1bmNOYW1lXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKDAsIGluZGV4X2pzXzUuaXNFcnJvcikoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWNvaW5UeXBlJSUgb3IgbnVsbCBpZiB0aGVcbiAgICAgKiAgcHJvdmlkZWQgJSVjb2luVHlwZSUlIGhhcyBub3QgYmVlbiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvaW5UeXBlID0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMilcIik7XG4gICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IGluZGV4X2pzXzIuWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzUuaXNFcnJvcikoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBkZWNvZGluZyBpdHMgRVZNIGNhbm9uaWNhbCBjaGFpbiBhcyBhbiBFVk0gY2hhaW4gYWRkcmVzcyBmaXJzdFxuICAgICAgICBpZiAoY29pblR5cGUgPj0gMCAmJiBjb2luVHlwZSA8IDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgIGxldCBldGhDb2luVHlwZSA9IGNvaW5UeXBlICsgMHg4MDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbZXRoQ29pblR5cGVdKTtcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNS5pc0hleFN0cmluZykoZGF0YSwgMjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2luUGx1Z2luID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wcm92aWRlci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoIShwbHVnaW4gaW5zdGFuY2VvZiBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbHVnaW4uc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb2luUGx1Z2luID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luUGx1Z2luID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2XCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbY29pblR5cGVdKTtcbiAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYWRkcmVzc1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgY29pblBsdWdpbi5kZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKTtcbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KShmYWxzZSwgYGludmFsaWQgY29pbiBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgaW5mbzogeyBjb2luVHlwZSwgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEVJUC02MzQgdGV4dCByZWNvcmQgZm9yICUla2V5JSUsIG9yIGBgbnVsbGBgXG4gICAgICogIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUZXh0KGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJ0ZXh0KGJ5dGVzMzIsc3RyaW5nKVwiLCBba2V5XSk7XG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJzb2x2ZXMgdG8gdGhlIGNvbnRlbnQtaGFzaCBvciBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiY29udGVudGhhc2goYnl0ZXMzMilcIik7XG4gICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IDcwPURBRy1QQiwgNzI9bGlicDJwLWtleSlcbiAgICAgICAgY29uc3QgaXBmcyA9IGRhdGEubWF0Y2goL14weChlMzAxMDE3MHxlNTAxMDE3MikoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gKGlwZnNbMV0gPT09IFwiZTMwMTAxNzBcIikgPyBcImlwZnNcIiA6IFwiaXBuc1wiO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1s0XSwgMTYpO1xuICAgICAgICAgICAgaWYgKGlwZnNbNV0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NjaGVtZX06L1xcLyR7KDAsIGluZGV4X2pzXzUuZW5jb2RlQmFzZTU4KShcIjB4XCIgKyBpcGZzWzJdKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN3YXJtIChDSUQ6IDEsIFR5cGU6IHN3YXJtLW1hbmlmZXN0OyBoYXNoL2xlbmd0aCBoYXJkLWNvZGVkIHRvIGtlY2NhazI1Ni8zMilcbiAgICAgICAgY29uc3Qgc3dhcm0gPSBkYXRhLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICBpZiAoc3dhcm0gJiYgc3dhcm1bMV0ubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgcmV0dXJuIGBieno6L1xcLyR7c3dhcm1bMV19YDtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnQpKGZhbHNlLCBgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICBpbmZvOiB7IGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhdmF0YXIgdXJsIG9yIGBgbnVsbGBgIGlmIHRoZSBhdmF0YXIgaXMgZWl0aGVyXG4gICAgICogIHVuY29uZmlndXJlZCBvciBpbmNvcnJlY3RseSBjb25maWd1cmVkIChlLmcuIHJlZmVyZW5jZXMgYW4gTkZUXG4gICAgICogIG5vdCBvd25lZCBieSB0aGUgYWRkcmVzcykuXG4gICAgICpcbiAgICAgKiAgSWYgZGlhZ25vc2luZyBpc3N1ZXMgd2l0aCBjb25maWd1cmF0aW9ucywgdGhlIFtbX2dldEF2YXRhcl1dXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZnVsLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5fZ2V0QXZhdGFyKCk7XG4gICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2hlbiByZXNvbHZpbmcgYW4gYXZhdGFyLCB0aGVyZSBhcmUgbWFueSBzdGVwcyBpbnZvbHZlZCwgc3VjaFxuICAgICAqICBmZXRjaGluZyBtZXRhZGF0YSBhbmQgcG9zc2libHkgdmFsaWRhdGluZyBvd25lcnNoaXAgb2YgYW5cbiAgICAgKiAgTkZULlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGV4YW1pbmUgZWFjaCBzdGVwIGFuZCB0aGUgdmFsdWUgaXRcbiAgICAgKiAgd2FzIHdvcmtpbmcgZnJvbS5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0aGlzLm5hbWUgfV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0ZXN0IGRhdGEgZm9yIHJpY21vby5ldGhcbiAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XG4gICAgICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLmdldFRleHQoXCJhdmF0YXJcIik7XG4gICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFhdmF0YXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImF2YXRhclwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXZhdGFyLm1hdGNoKG1hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBnZXRJcGZzTGluayhhdmF0YXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpcGZzXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogdXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIEVSQyB0eXBlLCB1c2UgdG9rZW5VUkkodWludDI1Nikgb3IgdXJsKHVpbnQyNTYpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCJ0b2tlblVSSSh1aW50MjU2KVwiIDogXCJ1cmkodWludDI1NilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IHNjaGVtZSwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvd25lciBvZiB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IGAhJHtzY2hlbWV9Y2FpcGAsIHZhbHVlOiAobWF0Y2hbMl0gfHwgXCJcIikgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gY29tcHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBpbmRleF9qc18zLkNvbnRyYWN0KGNvbXBzWzBdLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTcyMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdG9rZW5VUkkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBvd25lck9mKHVpbnQpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdXJpKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MsIHVpbnQyNTYpIHZpZXcgcmV0dXJucyAodWludClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSBhd2FpdCBjb250cmFjdC5vd25lck9mKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbnRyYWN0LmJhbGFuY2VPZihvd25lciwgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWJhbGFuY2VcIiwgdmFsdWU6IFwiMFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIHZhbHVlOiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSB0b2tlbiBjb250cmFjdCBmb3IgdGhlIG1ldGFkYXRhIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gYXdhaXQgY29udHJhY3Rbc2VsZWN0b3JdKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwgfHwgbWV0YWRhdGFVcmwgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhLXVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCAoMCwgaW5kZXhfanNfNS50b0JlSGV4KSh0b2tlbklkLCAzMikuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1leHBhbmRlZFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBtZXRhZGF0YSBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsLm1hdGNoKC9eaXBmczovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IGdldElwZnNMaW5rKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAobmV3IGluZGV4X2pzXzUuRmV0Y2hSZXF1ZXN0KG1ldGFkYXRhVXJsKSkuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiByZXNwb25zZS5ib2R5VGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogKDAsIGluZGV4X2pzXzUuaGV4bGlmeSkoYnl0ZXMpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGFcIiwgdmFsdWU6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBsaW5rIHRvIGdhdGV3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogbnVsbCB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZ2V0RW5zQWRkcmVzcyhwcm92aWRlcikge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBlbnNQbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgLy8gTm8gRU5TLi4uXG4gICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydCkoZW5zUGx1Z2luLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEVuc0FkZHJlc3NcIiwgaW5mbzogeyBuZXR3b3JrIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbnNQbHVnaW4uYWRkcmVzcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jICNnZXRSZXNvbHZlcihwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyhwcm92aWRlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBpbmRleF9qc18zLkNvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IGNvbnRyYWN0LnJlc29sdmVyKCgwLCBpbmRleF9qc180Lm5hbWVoYXNoKShuYW1lKSwge1xuICAgICAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhZGRyID09PSBpbmRleF9qc18yLlplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEVOUyByZWdpc3RyeSBjYW5ub3QgdGhyb3cgZXJyb3JzIG9uIHJlc29sdmVyKGJ5dGVzMzIpLFxuICAgICAgICAgICAgLy8gc28gcHJvYmFibHkgYSBsaW5rIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhlIEVOUyByZXNvbHZlciBmb3IgJSVuYW1lJSUgdXNpbmcgJSVwcm92aWRlciUlIG9yXG4gICAgICogIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbU5hbWUocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gXCJcIiB8fCBjdXJyZW50TmFtZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiBzaW5jZSB0aGUgZXRoIG5vZGUgY2Fubm90IGNoYW5nZSBhbmQgZG9lc1xuICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiZXRoXCIgJiYgY3VycmVudE5hbWUgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IG5vZGUgZm9yIGEgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci4jZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIGN1cnJlbnROYW1lKTtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXG4gICAgICAgICAgICBpZiAoYWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgRW5zUmVzb2x2ZXIocHJvdmlkZXIsIGFkZHIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgIT09IG5hbWUgJiYgIShhd2FpdCByZXNvbHZlci5zdXBwb3J0c1dpbGRjYXJkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW5zUmVzb2x2ZXIgPSBFbnNSZXNvbHZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVucy1yZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/ens-resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/format.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/format.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatTransactionResponse = exports.formatTransactionReceipt = exports.formatReceiptLog = exports.formatBlock = exports.formatLog = exports.formatUint256 = exports.formatHash = exports.formatData = exports.formatBoolean = exports.object = exports.arrayOf = exports.allowNull = void 0;\n/**\n *  @_ignore\n */\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return (function (value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    });\n}\nexports.allowNull = allowNull;\nfunction arrayOf(format, allowNull) {\n    return ((array) => {\n        if (allowNull && array == null) {\n            return null;\n        }\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i) => format(i));\n    });\n}\nexports.arrayOf = arrayOf;\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return ((value) => {\n        const result = {};\n        for (const key in format) {\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]) {\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            }\n            catch (error) {\n                const message = (error instanceof Error) ? error.message : \"not-an-error\";\n                (0, index_js_4.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", { value });\n            }\n        }\n        return result;\n    });\n}\nexports.object = object;\nfunction formatBoolean(value) {\n    switch (value) {\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0, index_js_4.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\n}\nexports.formatBoolean = formatBoolean;\nfunction formatData(value) {\n    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nexports.formatData = formatData;\nfunction formatHash(value) {\n    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nexports.formatHash = formatHash;\nfunction formatUint256(value) {\n    if (!(0, index_js_4.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0, index_js_4.zeroPadValue)(value, 32);\n}\nexports.formatUint256 = formatUint256;\nconst _formatLog = object({\n    address: index_js_1.getAddress,\n    blockHash: formatHash,\n    blockNumber: index_js_4.getNumber,\n    data: formatData,\n    index: index_js_4.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: index_js_4.getNumber,\n}, {\n    index: [\"logIndex\"]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nexports.formatLog = formatLog;\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    parentBeaconBlockRoot: allowNull(formatHash, null),\n    number: index_js_4.getNumber,\n    timestamp: index_js_4.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: index_js_4.getBigInt,\n    gasLimit: index_js_4.getBigInt,\n    gasUsed: index_js_4.getBigInt,\n    stateRoot: allowNull(formatHash, null),\n    receiptsRoot: allowNull(formatHash, null),\n    blobGasUsed: allowNull(index_js_4.getBigInt, null),\n    excessBlobGas: allowNull(index_js_4.getBigInt, null),\n    miner: allowNull(index_js_1.getAddress),\n    extraData: formatData,\n    baseFeePerGas: allowNull(index_js_4.getBigInt)\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx) => {\n        if (typeof (tx) === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nexports.formatBlock = formatBlock;\nconst _formatReceiptLog = object({\n    transactionIndex: index_js_4.getNumber,\n    blockNumber: index_js_4.getNumber,\n    transactionHash: formatHash,\n    address: index_js_1.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: index_js_4.getNumber,\n    blockHash: formatHash,\n}, {\n    index: [\"logIndex\"]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nexports.formatReceiptLog = formatReceiptLog;\nconst _formatTransactionReceipt = object({\n    to: allowNull(index_js_1.getAddress, null),\n    from: allowNull(index_js_1.getAddress, null),\n    contractAddress: allowNull(index_js_1.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: index_js_4.getNumber,\n    root: allowNull(index_js_4.hexlify),\n    gasUsed: index_js_4.getBigInt,\n    blobGasUsed: allowNull(index_js_4.getBigInt, null),\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: index_js_4.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: index_js_4.getBigInt,\n    effectiveGasPrice: allowNull(index_js_4.getBigInt),\n    blobGasPrice: allowNull(index_js_4.getBigInt, null),\n    status: allowNull(index_js_4.getNumber),\n    type: allowNull(index_js_4.getNumber, 0)\n}, {\n    effectiveGasPrice: [\"gasPrice\"],\n    hash: [\"transactionHash\"],\n    index: [\"transactionIndex\"],\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nexports.formatTransactionReceipt = formatTransactionReceipt;\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0, index_js_4.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        // Some nodes do not return this, usually test nodes (like Ganache)\n        index: allowNull(index_js_4.getNumber, undefined),\n        type: (value) => {\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0, index_js_4.getNumber)(value);\n        },\n        accessList: allowNull(index_js_3.accessListify, null),\n        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(index_js_4.getNumber, null),\n        transactionIndex: allowNull(index_js_4.getNumber, null),\n        from: index_js_1.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(index_js_4.getBigInt),\n        maxPriorityFeePerGas: allowNull(index_js_4.getBigInt),\n        maxFeePerGas: allowNull(index_js_4.getBigInt),\n        maxFeePerBlobGas: allowNull(index_js_4.getBigInt, null),\n        gasLimit: index_js_4.getBigInt,\n        to: allowNull(index_js_1.getAddress, null),\n        value: index_js_4.getBigInt,\n        nonce: index_js_4.getNumber,\n        data: formatData,\n        creates: allowNull(index_js_1.getAddress, null),\n        chainId: allowNull(index_js_4.getBigInt, null)\n    }, {\n        data: [\"input\"],\n        gasLimit: [\"gas\"],\n        index: [\"transactionIndex\"]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0, index_js_1.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = index_js_2.Signature.from(value.signature);\n    }\n    else {\n        result.signature = index_js_2.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */\n    // 0x0000... should actually be null\n    if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n}\nexports.formatTransactionResponse = formatTransactionResponse;\n//# sourceMappingURL=format.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZm9ybWF0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxHQUFHLGdDQUFnQyxHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsaUJBQWlCO0FBQzFSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsOEZBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLEtBQUssR0FBRyxRQUFRLGtCQUFrQixPQUFPO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsRUFBRSxzQkFBc0I7QUFDcEY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL2Zvcm1hdC5qcz8wZjdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQgPSBleHBvcnRzLmZvcm1hdFJlY2VpcHRMb2cgPSBleHBvcnRzLmZvcm1hdEJsb2NrID0gZXhwb3J0cy5mb3JtYXRMb2cgPSBleHBvcnRzLmZvcm1hdFVpbnQyNTYgPSBleHBvcnRzLmZvcm1hdEhhc2ggPSBleHBvcnRzLmZvcm1hdERhdGEgPSBleHBvcnRzLmZvcm1hdEJvb2xlYW4gPSBleHBvcnRzLm9iamVjdCA9IGV4cG9ydHMuYXJyYXlPZiA9IGV4cG9ydHMuYWxsb3dOdWxsID0gdm9pZCAwO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5mdW5jdGlvbiBhbGxvd051bGwoZm9ybWF0LCBudWxsVmFsdWUpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYWxsb3dOdWxsID0gYWxsb3dOdWxsO1xuZnVuY3Rpb24gYXJyYXlPZihmb3JtYXQsIGFsbG93TnVsbCkge1xuICAgIHJldHVybiAoKGFycmF5KSA9PiB7XG4gICAgICAgIGlmIChhbGxvd051bGwgJiYgYXJyYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGkpID0+IGZvcm1hdChpKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmFycmF5T2YgPSBhcnJheU9mO1xuLy8gUmVxdWlyZXMgYW4gb2JqZWN0IHdoaWNoIG1hdGNoZXMgYSBmbGVldCBvZiBvdGhlciBmb3JtYXR0ZXJzXG4vLyBBbnkgRm9ybWF0RnVuYyBtYXkgcmV0dXJuIGB1bmRlZmluZWRgIHRvIGhhdmUgdGhlIHZhbHVlIG9taXR0ZWRcbi8vIGZyb20gdGhlIHJlc3VsdCBvYmplY3QuIENhbGxzIHByZXNlcnZlIGB0aGlzYC5cbmZ1bmN0aW9uIG9iamVjdChmb3JtYXQsIGFsdE5hbWVzKSB7XG4gICAgcmV0dXJuICgodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgbGV0IHNyY0tleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChhbHROYW1lcyAmJiBrZXkgaW4gYWx0TmFtZXMgJiYgIShzcmNLZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbHRLZXkgb2YgYWx0TmFtZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNLZXkgPSBhbHRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnYgPSBmb3JtYXRba2V5XSh2YWx1ZVtzcmNLZXldKTtcbiAgICAgICAgICAgICAgICBpZiAobnYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG52O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgPyBlcnJvci5tZXNzYWdlIDogXCJub3QtYW4tZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBgaW52YWxpZCB2YWx1ZSBmb3IgdmFsdWUuJHtrZXl9ICgke21lc3NhZ2V9KWAsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG5mdW5jdGlvbiBmb3JtYXRCb29sZWFuKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGludmFsaWQgYm9vbGVhbjsgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnRzLmZvcm1hdEJvb2xlYW4gPSBmb3JtYXRCb29sZWFuO1xuZnVuY3Rpb24gZm9ybWF0RGF0YSh2YWx1ZSkge1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfNC5pc0hleFN0cmluZykodmFsdWUsIHRydWUpLCBcImludmFsaWQgZGF0YVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLmZvcm1hdERhdGEgPSBmb3JtYXREYXRhO1xuZnVuY3Rpb24gZm9ybWF0SGFzaCh2YWx1ZSkge1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfNC5pc0hleFN0cmluZykodmFsdWUsIDMyKSwgXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5mb3JtYXRIYXNoID0gZm9ybWF0SGFzaDtcbmZ1bmN0aW9uIGZvcm1hdFVpbnQyNTYodmFsdWUpIHtcbiAgICBpZiAoISgwLCBpbmRleF9qc180LmlzSGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuemVyb1BhZFZhbHVlKSh2YWx1ZSwgMzIpO1xufVxuZXhwb3J0cy5mb3JtYXRVaW50MjU2ID0gZm9ybWF0VWludDI1NjtcbmNvbnN0IF9mb3JtYXRMb2cgPSBvYmplY3Qoe1xuICAgIGFkZHJlc3M6IGluZGV4X2pzXzEuZ2V0QWRkcmVzcyxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgYmxvY2tOdW1iZXI6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIHJlbW92ZWQ6IGFsbG93TnVsbChmb3JtYXRCb29sZWFuLCBmYWxzZSksXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBpbmRleF9qc180LmdldE51bWJlcixcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZnVuY3Rpb24gZm9ybWF0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRMb2codmFsdWUpO1xufVxuZXhwb3J0cy5mb3JtYXRMb2cgPSBmb3JtYXRMb2c7XG5jb25zdCBfZm9ybWF0QmxvY2sgPSBvYmplY3Qoe1xuICAgIGhhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoKSxcbiAgICBwYXJlbnRIYXNoOiBmb3JtYXRIYXNoLFxuICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIG51bWJlcjogaW5kZXhfanNfNC5nZXROdW1iZXIsXG4gICAgdGltZXN0YW1wOiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICBub25jZTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGRpZmZpY3VsdHk6IGluZGV4X2pzXzQuZ2V0QmlnSW50LFxuICAgIGdhc0xpbWl0OiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICBnYXNVc2VkOiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICBzdGF0ZVJvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICByZWNlaXB0c1Jvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKSxcbiAgICBleGNlc3NCbG9iR2FzOiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXRCaWdJbnQsIG51bGwpLFxuICAgIG1pbmVyOiBhbGxvd051bGwoaW5kZXhfanNfMS5nZXRBZGRyZXNzKSxcbiAgICBleHRyYURhdGE6IGZvcm1hdERhdGEsXG4gICAgYmFzZUZlZVBlckdhczogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KVxufSk7XG5mdW5jdGlvbiBmb3JtYXRCbG9jayh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IF9mb3JtYXRCbG9jayh2YWx1ZSk7XG4gICAgcmVzdWx0LnRyYW5zYWN0aW9ucyA9IHZhbHVlLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5mb3JtYXRCbG9jayA9IGZvcm1hdEJsb2NrO1xuY29uc3QgX2Zvcm1hdFJlY2VpcHRMb2cgPSBvYmplY3Qoe1xuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIGJsb2NrTnVtYmVyOiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgYWRkcmVzczogaW5kZXhfanNfMS5nZXRBZGRyZXNzLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmZ1bmN0aW9uIGZvcm1hdFJlY2VpcHRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFJlY2VpcHRMb2codmFsdWUpO1xufVxuZXhwb3J0cy5mb3JtYXRSZWNlaXB0TG9nID0gZm9ybWF0UmVjZWlwdExvZztcbmNvbnN0IF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQgPSBvYmplY3Qoe1xuICAgIHRvOiBhbGxvd051bGwoaW5kZXhfanNfMS5nZXRBZGRyZXNzLCBudWxsKSxcbiAgICBmcm9tOiBhbGxvd051bGwoaW5kZXhfanNfMS5nZXRBZGRyZXNzLCBudWxsKSxcbiAgICBjb250cmFjdEFkZHJlc3M6IGFsbG93TnVsbChpbmRleF9qc18xLmdldEFkZHJlc3MsIG51bGwpLFxuICAgIC8vIHNob3VsZCBiZSBhbGxvd051bGwoaGFzaCksIGJ1dCBicm9rZW4tRUlQLTY1OCBzdXBwb3J0IGlzIGhhbmRsZWQgaW4gcmVjZWlwdFxuICAgIGluZGV4OiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICByb290OiBhbGxvd051bGwoaW5kZXhfanNfNC5oZXhsaWZ5KSxcbiAgICBnYXNVc2VkOiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKSxcbiAgICBsb2dzQmxvb206IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICBsb2dzOiBhcnJheU9mKGZvcm1hdFJlY2VpcHRMb2cpLFxuICAgIGJsb2NrTnVtYmVyOiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICAvL2NvbmZpcm1hdGlvbnM6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgIGN1bXVsYXRpdmVHYXNVc2VkOiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KSxcbiAgICBibG9iR2FzUHJpY2U6IGFsbG93TnVsbChpbmRleF9qc180LmdldEJpZ0ludCwgbnVsbCksXG4gICAgc3RhdHVzOiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXROdW1iZXIpLFxuICAgIHR5cGU6IGFsbG93TnVsbChpbmRleF9qc180LmdldE51bWJlciwgMClcbn0sIHtcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogW1wiZ2FzUHJpY2VcIl0sXG4gICAgaGFzaDogW1widHJhbnNhY3Rpb25IYXNoXCJdLFxuICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdLFxufSk7XG5mdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSk7XG59XG5leHBvcnRzLmZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdDtcbmZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodmFsdWUpIHtcbiAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICBpZiAodmFsdWUudG8gJiYgKDAsIGluZGV4X2pzXzQuZ2V0QmlnSW50KSh2YWx1ZS50bykgPT09IEJOXzApIHtcbiAgICAgICAgdmFsdWUudG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBvYmplY3Qoe1xuICAgICAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgICAgICAvLyBTb21lIG5vZGVzIGRvIG5vdCByZXR1cm4gdGhpcywgdXN1YWxseSB0ZXN0IG5vZGVzIChsaWtlIEdhbmFjaGUpXG4gICAgICAgIGluZGV4OiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXROdW1iZXIsIHVuZGVmaW5lZCksXG4gICAgICAgIHR5cGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmdldE51bWJlcikodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3NMaXN0OiBhbGxvd051bGwoaW5kZXhfanNfMy5hY2Nlc3NMaXN0aWZ5LCBudWxsKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogYWxsb3dOdWxsKGFycmF5T2YoZm9ybWF0SGFzaCwgdHJ1ZSksIG51bGwpLFxuICAgICAgICBibG9ja0hhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICAgICAgYmxvY2tOdW1iZXI6IGFsbG93TnVsbChpbmRleF9qc180LmdldE51bWJlciwgbnVsbCksXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGFsbG93TnVsbChpbmRleF9qc180LmdldE51bWJlciwgbnVsbCksXG4gICAgICAgIGZyb206IGluZGV4X2pzXzEuZ2V0QWRkcmVzcyxcbiAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKSBtdXN0IGJlIHNldFxuICAgICAgICBnYXNQcmljZTogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGFsbG93TnVsbChpbmRleF9qc180LmdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckdhczogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKSxcbiAgICAgICAgZ2FzTGltaXQ6IGluZGV4X2pzXzQuZ2V0QmlnSW50LFxuICAgICAgICB0bzogYWxsb3dOdWxsKGluZGV4X2pzXzEuZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIHZhbHVlOiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICAgICAgbm9uY2U6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgICAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgICAgICBjcmVhdGVzOiBhbGxvd051bGwoaW5kZXhfanNfMS5nZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgY2hhaW5JZDogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKVxuICAgIH0sIHtcbiAgICAgICAgZGF0YTogW1wiaW5wdXRcIl0sXG4gICAgICAgIGdhc0xpbWl0OiBbXCJnYXNcIl0sXG4gICAgICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdXG4gICAgfSkodmFsdWUpO1xuICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdmFsdWVcbiAgICBpZiAocmVzdWx0LnRvID09IG51bGwgJiYgcmVzdWx0LmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY3JlYXRlcyA9ICgwLCBpbmRleF9qc18xLmdldENyZWF0ZUFkZHJlc3MpKHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayBmZWUgZGF0YVxuICAgIC8vIEFkZCBhbiBhY2Nlc3MgbGlzdCB0byBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZXNcbiAgICBpZiAoKHZhbHVlLnR5cGUgPT09IDEgfHwgdmFsdWUudHlwZSA9PT0gMikgJiYgdmFsdWUuYWNjZXNzTGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gW107XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIHNpZ25hdHVyZVxuICAgIGlmICh2YWx1ZS5zaWduYXR1cmUpIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IGluZGV4X2pzXzIuU2lnbmF0dXJlLmZyb20odmFsdWUuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBpbmRleF9qc18yLlNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU29tZSBiYWNrZW5kcyBvbWl0IENoYWluSWQgb24gbGVnYWN5IHRyYW5zYWN0aW9ucywgYnV0IHdlIGNhbiBjb21wdXRlIGl0XG4gICAgaWYgKHJlc3VsdC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHJlc3VsdC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBjaGVjayBjaGFpbklEXG4gICAgLypcbiAgICBpZiAodmFsdWUuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5uZXR3b3JrSWQ7XG5cbiAgICAgICAgLy8gZ2V0aC1ldGMgcmV0dXJucyBjaGFpbklkXG4gICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkgeyBjaGFpbklkID0gMDsgfVxuICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIikgeyBjaGFpbklkID0gMDsgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB9XG4gICAgKi9cbiAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiAoMCwgaW5kZXhfanNfNC5nZXRCaWdJbnQpKHJlc3VsdC5ibG9ja0hhc2gpID09PSBCTl8wKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5mb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlID0gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A **Provider** provides a connection to the blockchain, whch can be\n *  used to query its current state, simulate execution and send transactions\n *  to update the state.\n *\n *  It is one of the most fundamental components of interacting with a\n *  blockchain application, and there are many ways to connect, such as over\n *  HTTP, WebSockets or injected providers such as [MetaMask](link-metamask).\n *\n *  @_section: api/providers:Providers  [about-providers]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanPlugin = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.copyRequest = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = exports.NonceManager = exports.Network = exports.MulticoinProviderPlugin = exports.EnsResolver = exports.getDefaultProvider = exports.showThrottleMessage = exports.VoidSigner = exports.AbstractSigner = exports.UnmanagedSubscriber = exports.AbstractProvider = void 0;\nvar abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nObject.defineProperty(exports, \"AbstractProvider\", ({ enumerable: true, get: function () { return abstract_provider_js_1.AbstractProvider; } }));\nObject.defineProperty(exports, \"UnmanagedSubscriber\", ({ enumerable: true, get: function () { return abstract_provider_js_1.UnmanagedSubscriber; } }));\nvar abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js\");\nObject.defineProperty(exports, \"AbstractSigner\", ({ enumerable: true, get: function () { return abstract_signer_js_1.AbstractSigner; } }));\nObject.defineProperty(exports, \"VoidSigner\", ({ enumerable: true, get: function () { return abstract_signer_js_1.VoidSigner; } }));\nvar community_js_1 = __webpack_require__(/*! ./community.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nObject.defineProperty(exports, \"showThrottleMessage\", ({ enumerable: true, get: function () { return community_js_1.showThrottleMessage; } }));\nvar default_provider_js_1 = __webpack_require__(/*! ./default-provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/default-provider.js\");\nObject.defineProperty(exports, \"getDefaultProvider\", ({ enumerable: true, get: function () { return default_provider_js_1.getDefaultProvider; } }));\nvar ens_resolver_js_1 = __webpack_require__(/*! ./ens-resolver.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/ens-resolver.js\");\nObject.defineProperty(exports, \"EnsResolver\", ({ enumerable: true, get: function () { return ens_resolver_js_1.EnsResolver; } }));\nObject.defineProperty(exports, \"MulticoinProviderPlugin\", ({ enumerable: true, get: function () { return ens_resolver_js_1.MulticoinProviderPlugin; } }));\nvar network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nObject.defineProperty(exports, \"Network\", ({ enumerable: true, get: function () { return network_js_1.Network; } }));\nvar signer_noncemanager_js_1 = __webpack_require__(/*! ./signer-noncemanager.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js\");\nObject.defineProperty(exports, \"NonceManager\", ({ enumerable: true, get: function () { return signer_noncemanager_js_1.NonceManager; } }));\nvar plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js\");\nObject.defineProperty(exports, \"NetworkPlugin\", ({ enumerable: true, get: function () { return plugins_network_js_1.NetworkPlugin; } }));\nObject.defineProperty(exports, \"GasCostPlugin\", ({ enumerable: true, get: function () { return plugins_network_js_1.GasCostPlugin; } }));\nObject.defineProperty(exports, \"EnsPlugin\", ({ enumerable: true, get: function () { return plugins_network_js_1.EnsPlugin; } }));\nObject.defineProperty(exports, \"FeeDataNetworkPlugin\", ({ enumerable: true, get: function () { return plugins_network_js_1.FeeDataNetworkPlugin; } }));\nObject.defineProperty(exports, \"FetchUrlFeeDataNetworkPlugin\", ({ enumerable: true, get: function () { return plugins_network_js_1.FetchUrlFeeDataNetworkPlugin; } }));\nvar provider_js_1 = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nObject.defineProperty(exports, \"Block\", ({ enumerable: true, get: function () { return provider_js_1.Block; } }));\nObject.defineProperty(exports, \"FeeData\", ({ enumerable: true, get: function () { return provider_js_1.FeeData; } }));\nObject.defineProperty(exports, \"Log\", ({ enumerable: true, get: function () { return provider_js_1.Log; } }));\nObject.defineProperty(exports, \"TransactionReceipt\", ({ enumerable: true, get: function () { return provider_js_1.TransactionReceipt; } }));\nObject.defineProperty(exports, \"TransactionResponse\", ({ enumerable: true, get: function () { return provider_js_1.TransactionResponse; } }));\nObject.defineProperty(exports, \"copyRequest\", ({ enumerable: true, get: function () { return provider_js_1.copyRequest; } }));\nvar provider_fallback_js_1 = __webpack_require__(/*! ./provider-fallback.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-fallback.js\");\nObject.defineProperty(exports, \"FallbackProvider\", ({ enumerable: true, get: function () { return provider_fallback_js_1.FallbackProvider; } }));\nvar provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nObject.defineProperty(exports, \"JsonRpcApiProvider\", ({ enumerable: true, get: function () { return provider_jsonrpc_js_1.JsonRpcApiProvider; } }));\nObject.defineProperty(exports, \"JsonRpcProvider\", ({ enumerable: true, get: function () { return provider_jsonrpc_js_1.JsonRpcProvider; } }));\nObject.defineProperty(exports, \"JsonRpcSigner\", ({ enumerable: true, get: function () { return provider_jsonrpc_js_1.JsonRpcSigner; } }));\nvar provider_browser_js_1 = __webpack_require__(/*! ./provider-browser.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-browser.js\");\nObject.defineProperty(exports, \"BrowserProvider\", ({ enumerable: true, get: function () { return provider_browser_js_1.BrowserProvider; } }));\nvar provider_alchemy_js_1 = __webpack_require__(/*! ./provider-alchemy.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js\");\nObject.defineProperty(exports, \"AlchemyProvider\", ({ enumerable: true, get: function () { return provider_alchemy_js_1.AlchemyProvider; } }));\nvar provider_ankr_js_1 = __webpack_require__(/*! ./provider-ankr.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-ankr.js\");\nObject.defineProperty(exports, \"AnkrProvider\", ({ enumerable: true, get: function () { return provider_ankr_js_1.AnkrProvider; } }));\nvar provider_cloudflare_js_1 = __webpack_require__(/*! ./provider-cloudflare.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js\");\nObject.defineProperty(exports, \"CloudflareProvider\", ({ enumerable: true, get: function () { return provider_cloudflare_js_1.CloudflareProvider; } }));\nvar provider_etherscan_js_1 = __webpack_require__(/*! ./provider-etherscan.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js\");\nObject.defineProperty(exports, \"EtherscanProvider\", ({ enumerable: true, get: function () { return provider_etherscan_js_1.EtherscanProvider; } }));\nObject.defineProperty(exports, \"EtherscanPlugin\", ({ enumerable: true, get: function () { return provider_etherscan_js_1.EtherscanPlugin; } }));\nvar provider_infura_js_1 = __webpack_require__(/*! ./provider-infura.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-infura.js\");\nObject.defineProperty(exports, \"InfuraProvider\", ({ enumerable: true, get: function () { return provider_infura_js_1.InfuraProvider; } }));\nObject.defineProperty(exports, \"InfuraWebSocketProvider\", ({ enumerable: true, get: function () { return provider_infura_js_1.InfuraWebSocketProvider; } }));\nvar provider_pocket_js_1 = __webpack_require__(/*! ./provider-pocket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-pocket.js\");\nObject.defineProperty(exports, \"PocketProvider\", ({ enumerable: true, get: function () { return provider_pocket_js_1.PocketProvider; } }));\nvar provider_quicknode_js_1 = __webpack_require__(/*! ./provider-quicknode.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js\");\nObject.defineProperty(exports, \"QuickNodeProvider\", ({ enumerable: true, get: function () { return provider_quicknode_js_1.QuickNodeProvider; } }));\nconst provider_ipcsocket_js_1 = __webpack_require__(/*! ./provider-ipcsocket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js\"); /*-browser*/\nObject.defineProperty(exports, \"IpcSocketProvider\", ({ enumerable: true, get: function () { return provider_ipcsocket_js_1.IpcSocketProvider; } }));\nvar provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\");\nObject.defineProperty(exports, \"SocketProvider\", ({ enumerable: true, get: function () { return provider_socket_js_1.SocketProvider; } }));\nvar provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js\");\nObject.defineProperty(exports, \"WebSocketProvider\", ({ enumerable: true, get: function () { return provider_websocket_js_1.WebSocketProvider; } }));\nvar provider_socket_js_2 = __webpack_require__(/*! ./provider-socket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\");\nObject.defineProperty(exports, \"SocketSubscriber\", ({ enumerable: true, get: function () { return provider_socket_js_2.SocketSubscriber; } }));\nObject.defineProperty(exports, \"SocketBlockSubscriber\", ({ enumerable: true, get: function () { return provider_socket_js_2.SocketBlockSubscriber; } }));\nObject.defineProperty(exports, \"SocketPendingSubscriber\", ({ enumerable: true, get: function () { return provider_socket_js_2.SocketPendingSubscriber; } }));\nObject.defineProperty(exports, \"SocketEventSubscriber\", ({ enumerable: true, get: function () { return provider_socket_js_2.SocketEventSubscriber; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLCtCQUErQixHQUFHLDZCQUE2QixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLCtCQUErQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLG9CQUFvQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQixHQUFHLFdBQVcsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLG9DQUFvQyxHQUFHLDRCQUE0QixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLGVBQWUsR0FBRywrQkFBK0IsR0FBRyxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyxrQkFBa0IsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0I7QUFDamxDLDZCQUE2QixtQkFBTyxDQUFDLHVHQUF3QjtBQUM3RCxvREFBbUQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDOUksdURBQXNELEVBQUUscUNBQXFDLHNEQUFzRCxFQUFDO0FBQ3BKLDJCQUEyQixtQkFBTyxDQUFDLG1HQUFzQjtBQUN6RCxrREFBaUQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDeEksOENBQTZDLEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ2hJLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM3Qyx1REFBc0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDNUksNEJBQTRCLG1CQUFPLENBQUMscUdBQXVCO0FBQzNELHNEQUFxRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNqSix3QkFBd0IsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDbkQsK0NBQThDLEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQy9ILDJEQUEwRCxFQUFFLHFDQUFxQyxxREFBcUQsRUFBQztBQUN2SixtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBYztBQUN6QywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgsK0JBQStCLG1CQUFPLENBQUMsMkdBQTBCO0FBQ2pFLGdEQUErQyxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUN4SSwyQkFBMkIsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDekQsaURBQWdELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ3RJLGlEQUFnRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUN0SSw2Q0FBNEMsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDOUgsd0RBQXVELEVBQUUscUNBQXFDLHFEQUFxRCxFQUFDO0FBQ3BKLGdFQUErRCxFQUFFLHFDQUFxQyw2REFBNkQsRUFBQztBQUNwSyxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUMzQyx5Q0FBd0MsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDL0csMkNBQTBDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ25ILHVDQUFzQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMzRyxzREFBcUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDekksdURBQXNELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQzNJLCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCw2QkFBNkIsbUJBQU8sQ0FBQyx1R0FBd0I7QUFDN0Qsb0RBQW1ELEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQzlJLDRCQUE0QixtQkFBTyxDQUFDLHFHQUF1QjtBQUMzRCxzREFBcUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDakosbURBQWtELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQzNJLGlEQUFnRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUN2SSw0QkFBNEIsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDM0QsbURBQWtELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQzNJLDRCQUE0QixtQkFBTyxDQUFDLHFHQUF1QjtBQUMzRCxtREFBa0QsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDM0kseUJBQXlCLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3JELGdEQUErQyxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUNsSSwrQkFBK0IsbUJBQU8sQ0FBQywyR0FBMEI7QUFDakUsc0RBQXFELEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQ3BKLDhCQUE4QixtQkFBTyxDQUFDLHlHQUF5QjtBQUMvRCxxREFBb0QsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDakosbURBQWtELEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQzdJLDJCQUEyQixtQkFBTyxDQUFDLG1HQUFzQjtBQUN6RCxrREFBaUQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDeEksMkRBQTBELEVBQUUscUNBQXFDLHdEQUF3RCxFQUFDO0FBQzFKLDJCQUEyQixtQkFBTyxDQUFDLG1HQUFzQjtBQUN6RCxrREFBaUQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDeEksOEJBQThCLG1CQUFPLENBQUMseUdBQXlCO0FBQy9ELHFEQUFvRCxFQUFFLHFDQUFxQyxxREFBcUQsRUFBQztBQUNqSixnQ0FBZ0MsbUJBQU8sQ0FBQyx5R0FBeUIsR0FBRztBQUNwRSxxREFBb0QsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDakosMkJBQTJCLG1CQUFPLENBQUMsbUdBQXNCO0FBQ3pELGtEQUFpRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUN4SSw4QkFBOEIsbUJBQU8sQ0FBQyx5R0FBeUI7QUFDL0QscURBQW9ELEVBQUUscUNBQXFDLHFEQUFxRCxFQUFDO0FBQ2pKLDJCQUEyQixtQkFBTyxDQUFDLG1HQUFzQjtBQUN6RCxvREFBbUQsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDNUkseURBQXdELEVBQUUscUNBQXFDLHNEQUFzRCxFQUFDO0FBQ3RKLDJEQUEwRCxFQUFFLHFDQUFxQyx3REFBd0QsRUFBQztBQUMxSix5REFBd0QsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDdEoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvaW5kZXguanM/M2U1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgKipQcm92aWRlcioqIHByb3ZpZGVzIGEgY29ubmVjdGlvbiB0byB0aGUgYmxvY2tjaGFpbiwgd2hjaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGl0cyBjdXJyZW50IHN0YXRlLCBzaW11bGF0ZSBleGVjdXRpb24gYW5kIHNlbmQgdHJhbnNhY3Rpb25zXG4gKiAgdG8gdXBkYXRlIHRoZSBzdGF0ZS5cbiAqXG4gKiAgSXQgaXMgb25lIG9mIHRoZSBtb3N0IGZ1bmRhbWVudGFsIGNvbXBvbmVudHMgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhXG4gKiAgYmxvY2tjaGFpbiBhcHBsaWNhdGlvbiwgYW5kIHRoZXJlIGFyZSBtYW55IHdheXMgdG8gY29ubmVjdCwgc3VjaCBhcyBvdmVyXG4gKiAgSFRUUCwgV2ViU29ja2V0cyBvciBpbmplY3RlZCBwcm92aWRlcnMgc3VjaCBhcyBbTWV0YU1hc2tdKGxpbmstbWV0YW1hc2spLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnM6UHJvdmlkZXJzICBbYWJvdXQtcHJvdmlkZXJzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldEV2ZW50U3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0UGVuZGluZ1N1YnNjcmliZXIgPSBleHBvcnRzLlNvY2tldEJsb2NrU3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0U3Vic2NyaWJlciA9IGV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JcGNTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuUXVpY2tOb2RlUHJvdmlkZXIgPSBleHBvcnRzLlBvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBleHBvcnRzLkV0aGVyc2NhblBsdWdpbiA9IGV4cG9ydHMuRXRoZXJzY2FuUHJvdmlkZXIgPSBleHBvcnRzLkNsb3VkZmxhcmVQcm92aWRlciA9IGV4cG9ydHMuQW5rclByb3ZpZGVyID0gZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBleHBvcnRzLkJyb3dzZXJQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY1NpZ25lciA9IGV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gZXhwb3J0cy5Kc29uUnBjQXBpUHJvdmlkZXIgPSBleHBvcnRzLkZhbGxiYWNrUHJvdmlkZXIgPSBleHBvcnRzLmNvcHlSZXF1ZXN0ID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlY2VpcHQgPSBleHBvcnRzLkxvZyA9IGV4cG9ydHMuRmVlRGF0YSA9IGV4cG9ydHMuQmxvY2sgPSBleHBvcnRzLkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4gPSBleHBvcnRzLkZlZURhdGFOZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5FbnNQbHVnaW4gPSBleHBvcnRzLkdhc0Nvc3RQbHVnaW4gPSBleHBvcnRzLk5ldHdvcmtQbHVnaW4gPSBleHBvcnRzLk5vbmNlTWFuYWdlciA9IGV4cG9ydHMuTmV0d29yayA9IGV4cG9ydHMuTXVsdGljb2luUHJvdmlkZXJQbHVnaW4gPSBleHBvcnRzLkVuc1Jlc29sdmVyID0gZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBleHBvcnRzLnNob3dUaHJvdHRsZU1lc3NhZ2UgPSBleHBvcnRzLlZvaWRTaWduZXIgPSBleHBvcnRzLkFic3RyYWN0U2lnbmVyID0gZXhwb3J0cy5Vbm1hbmFnZWRTdWJzY3JpYmVyID0gZXhwb3J0cy5BYnN0cmFjdFByb3ZpZGVyID0gdm9pZCAwO1xudmFyIGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuQWJzdHJhY3RQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVubWFuYWdlZFN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuVW5tYW5hZ2VkU3Vic2NyaWJlcjsgfSB9KTtcbnZhciBhYnN0cmFjdF9zaWduZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXNpZ25lci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0U2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF9zaWduZXJfanNfMS5BYnN0cmFjdFNpZ25lcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZvaWRTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFic3RyYWN0X3NpZ25lcl9qc18xLlZvaWRTaWduZXI7IH0gfSk7XG52YXIgY29tbXVuaXR5X2pzXzEgPSByZXF1aXJlKFwiLi9jb21tdW5pdHkuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaG93VGhyb3R0bGVNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tdW5pdHlfanNfMS5zaG93VGhyb3R0bGVNZXNzYWdlOyB9IH0pO1xudmFyIGRlZmF1bHRfcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHQtcHJvdmlkZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREZWZhdWx0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlZmF1bHRfcHJvdmlkZXJfanNfMS5nZXREZWZhdWx0UHJvdmlkZXI7IH0gfSk7XG52YXIgZW5zX3Jlc29sdmVyX2pzXzEgPSByZXF1aXJlKFwiLi9lbnMtcmVzb2x2ZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbnNSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5zX3Jlc29sdmVyX2pzXzEuRW5zUmVzb2x2ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aWNvaW5Qcm92aWRlclBsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5zX3Jlc29sdmVyX2pzXzEuTXVsdGljb2luUHJvdmlkZXJQbHVnaW47IH0gfSk7XG52YXIgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5ldHdvcmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldHdvcmtfanNfMS5OZXR3b3JrOyB9IH0pO1xudmFyIHNpZ25lcl9ub25jZW1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuL3NpZ25lci1ub25jZW1hbmFnZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb25jZU1hbmFnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25lcl9ub25jZW1hbmFnZXJfanNfMS5Ob25jZU1hbmFnZXI7IH0gfSk7XG52YXIgcGx1Z2luc19uZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZXR3b3JrUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5zX25ldHdvcmtfanNfMS5OZXR3b3JrUGx1Z2luOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2FzQ29zdFBsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2luc19uZXR3b3JrX2pzXzEuR2FzQ29zdFBsdWdpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuc1BsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2luc19uZXR3b3JrX2pzXzEuRW5zUGx1Z2luOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVlRGF0YU5ldHdvcmtQbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBsdWdpbnNfbmV0d29ya19qc18xLkZlZURhdGFOZXR3b3JrUGx1Z2luOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2luc19uZXR3b3JrX2pzXzEuRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbjsgfSB9KTtcbnZhciBwcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCbG9ja1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5CbG9jazsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZlZURhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2pzXzEuRmVlRGF0YTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5Mb2c7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblJlY2VpcHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2pzXzEuVHJhbnNhY3Rpb25SZWNlaXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25SZXNwb25zZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlc3BvbnNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29weVJlcXVlc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2pzXzEuY29weVJlcXVlc3Q7IH0gfSk7XG52YXIgcHJvdmlkZXJfZmFsbGJhY2tfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWZhbGxiYWNrLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmFsbGJhY2tQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfZmFsbGJhY2tfanNfMS5GYWxsYmFja1Byb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjQXBpUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjQXBpUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY1NpZ25lcjsgfSB9KTtcbnZhciBwcm92aWRlcl9icm93c2VyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1icm93c2VyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnJvd3NlclByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9icm93c2VyX2pzXzEuQnJvd3NlclByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX2FsY2hlbXlfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWFsY2hlbXkuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbGNoZW15UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2FsY2hlbXlfanNfMS5BbGNoZW15UHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfYW5rcl9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItYW5rci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFua3JQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfYW5rcl9qc18xLkFua3JQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl9jbG91ZGZsYXJlX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1jbG91ZGZsYXJlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xvdWRmbGFyZVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9jbG91ZGZsYXJlX2pzXzEuQ2xvdWRmbGFyZVByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX2V0aGVyc2Nhbl9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItZXRoZXJzY2FuLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJzY2FuUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2V0aGVyc2Nhbl9qc18xLkV0aGVyc2NhblByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJzY2FuUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9ldGhlcnNjYW5fanNfMS5FdGhlcnNjYW5QbHVnaW47IH0gfSk7XG52YXIgcHJvdmlkZXJfaW5mdXJhX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1pbmZ1cmEuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmZ1cmFQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfaW5mdXJhX2pzXzEuSW5mdXJhUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmZ1cmFXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfaW5mdXJhX2pzXzEuSW5mdXJhV2ViU29ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfcG9ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1wb2NrZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfcG9ja2V0X2pzXzEuUG9ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfcXVpY2tub2RlX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1xdWlja25vZGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWlja05vZGVQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfcXVpY2tub2RlX2pzXzEuUXVpY2tOb2RlUHJvdmlkZXI7IH0gfSk7XG5jb25zdCBwcm92aWRlcl9pcGNzb2NrZXRfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWlwY3NvY2tldC5qc1wiKTsgLyotYnJvd3NlciovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJcGNTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfaXBjc29ja2V0X2pzXzEuSXBjU29ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfc29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1zb2NrZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfc29ja2V0X2pzXzEuU29ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfd2Vic29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci13ZWJzb2NrZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfd2Vic29ja2V0X2pzXzEuV2ViU29ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfc29ja2V0X2pzXzIgPSByZXF1aXJlKFwiLi9wcm92aWRlci1zb2NrZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9zb2NrZXRfanNfMi5Tb2NrZXRTdWJzY3JpYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0QmxvY2tTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9zb2NrZXRfanNfMi5Tb2NrZXRCbG9ja1N1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRQZW5kaW5nU3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfc29ja2V0X2pzXzIuU29ja2V0UGVuZGluZ1N1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRFdmVudFN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX3NvY2tldF9qc18yLlNvY2tldEV2ZW50U3Vic2NyaWJlcjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/network.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Network = void 0;\nconst index_js_1 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js\");\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/\nconst Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */\nclass Network {\n    #name;\n    #chainId;\n    #plugins;\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */\n    constructor(name, chainId) {\n        this.#name = name;\n        this.#chainId = (0, index_js_2.getBigInt)(chainId);\n        this.#plugins = new Map();\n    }\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */\n    toJSON() {\n        return { name: this.name, chainId: String(this.chainId) };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */\n    get name() { return this.#name; }\n    set name(value) { this.#name = value; }\n    /**\n     *  The network chain ID.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = (0, index_js_2.getBigInt)(value, \"chainId\"); }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */\n    matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof (other) === \"string\") {\n            try {\n                return (this.chainId === (0, index_js_2.getBigInt)(other));\n            }\n            catch (error) { }\n            return (this.name === other);\n        }\n        if (typeof (other) === \"number\" || typeof (other) === \"bigint\") {\n            try {\n                return (this.chainId === (0, index_js_2.getBigInt)(other));\n            }\n            catch (error) { }\n            return false;\n        }\n        if (typeof (other) === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return (this.chainId === (0, index_js_2.getBigInt)(other.chainId));\n                }\n                catch (error) { }\n                return false;\n            }\n            if (other.name != null) {\n                return (this.name === other.name);\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */\n    get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */\n    attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */\n    getPlugin(name) {\n        return (this.#plugins.get(name)) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */\n    getPlugins(basename) {\n        return (this.plugins.filter((p) => (p.name.split(\"#\")[0] === basename)));\n    }\n    /**\n     *  Create a copy of this Network.\n     */\n    clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin) => {\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */\n    computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || (new plugins_network_js_1.GasCostPlugin());\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for (let i = 2; i < tx.data.length; i += 2) {\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                }\n                else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0, index_js_1.accessListify)(tx.accessList);\n            for (const addr in accessList) {\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */\n    static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof (network) === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof (network) === \"string\" || typeof (network) === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof (network) === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0, index_js_2.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof (network.clone) === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof (network) === \"object\") {\n            (0, index_js_2.assertArgument)(typeof (network.name) === \"string\" && typeof (network.chainId) === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network((network.name), (network.chainId));\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new plugins_network_js_1.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0, index_js_2.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */\n    static register(nameOrChainId, networkFunc) {\n        if (typeof (nameOrChainId) === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0, index_js_2.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\nexports.Network = Network;\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Pad the fraction to 9 decimalplaces\n    while (comps[1].length < decimals) {\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(), fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),\n            };\n            return feeData;\n        }\n        catch (error) {\n            (0, index_js_2.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", { request, response, error });\n        }\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function () {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new plugins_network_js_1.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new plugins_network_js_1.GasCostPlugin());\n            (options.plugins || []).forEach((plugin) => {\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name) => {\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, { ensNetwork: 1, altNames: [\"homestead\"] });\n    registerEth(\"ropsten\", 3, { ensNetwork: 3 });\n    registerEth(\"rinkeby\", 4, { ensNetwork: 4 });\n    registerEth(\"goerli\", 5, { ensNetwork: 5 });\n    registerEth(\"kovan\", 42, { ensNetwork: 42 });\n    registerEth(\"sepolia\", 11155111, { ensNetwork: 11155111 });\n    registerEth(\"holesky\", 17000, { ensNetwork: 17000 });\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1,\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"arbitrum-sepolia\", 421614, {});\n    registerEth(\"base\", 8453, { ensNetwork: 1 });\n    registerEth(\"base-goerli\", 84531, {});\n    registerEth(\"base-sepolia\", 84532, {});\n    registerEth(\"bnb\", 56, { ensNetwork: 1 });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"linea\", 59144, { ensNetwork: 1 });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https:/\\/gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\"maticMumbai\", \"maticmum\"],\n        plugins: [\n            getGasStationPlugin(\"https:/\\/gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: []\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"optimism-sepolia\", 11155420, {});\n    registerEth(\"xdai\", 100, { ensNetwork: 1 });\n}\n//# sourceMappingURL=network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsbUJBQW1CLG1CQUFPLENBQUMsOEZBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyw2QkFBNkIsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSw4QkFBOEI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5Riw0QkFBNEIsc0JBQXNCLDBCQUEwQjtBQUNySztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFLGdDQUFnQyxlQUFlO0FBQy9DLGdDQUFnQyxlQUFlO0FBQy9DLCtCQUErQixlQUFlO0FBQzlDLCtCQUErQixnQkFBZ0I7QUFDL0MsdUNBQXVDLHNCQUFzQjtBQUM3RCxvQ0FBb0MsbUJBQW1CO0FBQ3ZELGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTCw2Q0FBNkM7QUFDN0MsOENBQThDO0FBQzlDLGdDQUFnQyxlQUFlO0FBQy9DLHdDQUF3QztBQUN4Qyx5Q0FBeUM7QUFDekMsNkJBQTZCLGVBQWU7QUFDNUMsOEJBQThCO0FBQzlCLGtDQUFrQyxlQUFlO0FBQ2pELHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBDQUEwQztBQUMxQyxnREFBZ0Q7QUFDaEQsK0JBQStCLGVBQWU7QUFDOUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9uZXR3b3JrLmpzPzNjMDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBBICoqTmV0d29yayoqIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvXG4gKiAgaW50ZXJhY3Qgd2l0aCBhIHNwZWNpZmljIGNoYWluLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnM6TmV0d29ya3MgIFtuZXR3b3Jrc11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXR3b3JrID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBwbHVnaW5zX25ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiKTtcbi8qICogKiAqXG4vLyBOZXR3b3JrcyB3aGljaCBvcGVyYXRpb24gYWdhaW5zdCBhbiBMMiBjYW4gdXNlIHRoaXMgcGx1Z2luIHRvXG4vLyBzcGVjaWZ5IGhvdyB0byBhY2Nlc3MgTDEsIGZvciB0aGUgcHVycG9zZSBvZiByZXNvbHZpbmcgRU5TLFxuLy8gZm9yIGV4YW1wbGUuXG5leHBvcnQgY2xhc3MgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgcHJvdmlkZXIhOiBQcm92aWRlcjtcbi8vIEBUT0RPOiBSZW5hbWUgdG8gQ2hhaW5BY2Nlc3MgYW5kIGFsbG93IGZvciBjb25uZWN0aW5nIHRvIGFueSBjaGFpblxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyOiBQcm92aWRlcikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5sYXllci1vbmUtY29ubmVjdGlvblwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllczxMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4+KHRoaXMsIHsgcHJvdmlkZXIgfSk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4odGhpcy5wcm92aWRlcik7XG4gICAgfVxufVxuKi9cbmNvbnN0IE5ldHdvcmtzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBwcm92aWRlcyBhY2Nlc3MgdG8gYSBjaGFpbidzIHByb3BlcnRpZXMgYW5kIGFsbG93c1xuICogIGZvciBwbHVnLWlucyB0byBleHRlbmQgZnVuY3Rpb25hbGl0eS5cbiAqL1xuY2xhc3MgTmV0d29yayB7XG4gICAgI25hbWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3BsdWdpbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrKiogZm9yICUlbmFtZSUlIGFuZCAlJWNoYWluSWQlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjaGFpbklkKSB7XG4gICAgICAgIHRoaXMuI25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KShjaGFpbklkKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgYSBOZXR3b3JrLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogdGhpcy5uYW1lLCBjaGFpbklkOiBTdHJpbmcodGhpcy5jaGFpbklkKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY29tbW9uIG5hbWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB0aGUgY2Fub25pY2FsIG5hbWUsIGFzIG5ldHdvcmtzIG1pZ2ggaGF2ZSBtdWx0aXBsZVxuICAgICAqICBuYW1lcy5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuI25hbWU7IH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkgeyB0aGlzLiNuYW1lID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY2hhaW4gSUQuXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9ICgwLCBpbmRleF9qc18yLmdldEJpZ0ludCkodmFsdWUsIFwiY2hhaW5JZFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIG1hdGNoZXMgdGhpcyBuZXR3b3JrLiBBbnkgY2hhaW4gSURcbiAgICAgKiAgbXVzdCBtYXRjaCwgYW5kIGlmIG5vIGNoYWluIElEIGlzIHByZXNlbnQsIHRoZSBuYW1lIG11c3QgbWF0Y2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgZG9lcyBub3QgY3VycmVudGx5IGNoZWNrIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXMsXG4gICAgICogIHN1Y2ggYXMgRU5TIGFkZHJlc3Mgb3IgcGx1Zy1pbiBjb21wYXRpYmlsaXR5LlxuICAgICAqL1xuICAgIG1hdGNoZXMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09ICgwLCBpbmRleF9qc18yLmdldEJpZ0ludCkob3RoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKG90aGVyKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KShvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KShvdGhlci5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlci5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHBsdWdpbnMgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgTmV0d29yay5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgJSVwbHVnaW4lJSB0byB0aGlzIE5ldHdvcmsuIFRoZSBuZXR3b3JrIG5hbWVcbiAgICAgKiAgbXVzdCBiZSB1bmlxdWUsIGV4Y2x1ZGluZyBhbnkgZnJhZ21lbnQuXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHBsdWdpbiwgaWYgYW55LCBtYXRjaGluZyAlJW5hbWUlJSBleGFjdGx5LiBQbHVnaW5zXG4gICAgICogIHdpdGggZnJhZ21lbnRzIHdpbGwgbm90IGJlIHJldHVybmVkIHVubGVzcyAlJW5hbWUlJSBpbmNsdWRlc1xuICAgICAqICBhIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXRzIGEgbGlzdCBvZiBhbGwgcGx1Z2lucyB0aGF0IG1hdGNoICUlbmFtZSUlLCB3aXRoIG90ciB3aXRob3V0XG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2lucyhiYXNlbmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMucGx1Z2lucy5maWx0ZXIoKHApID0+IChwLm5hbWUuc3BsaXQoXCIjXCIpWzBdID09PSBiYXNlbmFtZSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBOZXR3b3JrKHRoaXMubmFtZSwgdGhpcy5jaGFpbklkKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgY2xvbmUuYXR0YWNoUGx1Z2luKHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQSBHYXNDb3N0UGx1Z2luIGNhbiBiZSBhdHRhY2hlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdFxuICAgICAqICB2YWx1ZXMuXG4gICAgICovXG4gICAgY29tcHV0ZUludHJpbnNpY0dhcyh0eCkge1xuICAgICAgICBjb25zdCBjb3N0cyA9IHRoaXMuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuR2FzQ29zdFwiKSB8fCAobmV3IHBsdWdpbnNfbmV0d29ya19qc18xLkdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgIGxldCBnYXMgPSBjb3N0cy50eEJhc2U7XG4gICAgICAgIGlmICh0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICBnYXMgKz0gY29zdHMudHhDcmVhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdHguZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhLnN1YnN0cmluZyhpLCBpICsgMikgPT09IFwiMDBcIikge1xuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhWmVybztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFOb256ZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzTGlzdCA9ICgwLCBpbmRleF9qc18xLmFjY2Vzc0xpc3RpZnkpKHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIGluIGFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhBY2Nlc3NMaXN0QWRkcmVzcyArIGNvc3RzLnR4QWNjZXNzTGlzdFN0b3JhZ2VLZXkgKiBhY2Nlc3NMaXN0W2FkZHJdLnN0b3JhZ2VLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBOZXR3b3JrIGZvciB0aGUgJSVuZXR3b3JrJSUgbmFtZSBvciBjaGFpbklkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG5ldHdvcmspIHtcbiAgICAgICAgaW5qZWN0Q29tbW9uTmV0d29ya3MoKTtcbiAgICAgICAgLy8gRGVmYXVsdCBuZXR3b3JrXG4gICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oXCJtYWlubmV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbm9uaWNhbCBuYW1lIG9yIGNoYWluIElEXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gQmlnSW50KG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtGdW5jID0gTmV0d29ya3MuZ2V0KG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmtGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtGdW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29yayhcInVua25vd25cIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5rbm93biBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9uYWJsZSB3aXRoIG5ldHdvcmstbGlrZSBhYmlsaXRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jbG9uZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBuZXR3b3JrLmNsb25lKCk7XG4gICAgICAgICAgICAvL2lmICh0eXBlb2YobmV0d29yay5uYW1lKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV0d29ya2lzaFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAobmV0d29yay5uYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBuZXR3b3JrIG9iamVjdCBuYW1lIG9yIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tID0gbmV3IE5ldHdvcmsoKG5ldHdvcmsubmFtZSksIChuZXR3b3JrLmNoYWluSWQpKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgbmV0d29yay5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBwbHVnaW5zX25ldHdvcmtfanNfMS5FbnNQbHVnaW4obmV0d29yay5lbnNBZGRyZXNzLCBuZXR3b3JrLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgLy8gICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikpO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVnaXN0ZXIgJSVuYW1lT3JDaGFpbklkJSUgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnNcbiAgICAgKiAgYW4gaW5zdGFuY2Ugb2YgYSBOZXR3b3JrIHJlcHJlc2VudGluZyB0aGF0IGNoYWluLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlcihuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIChuYW1lT3JDaGFpbklkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmFtZU9yQ2hhaW5JZCA9IEJpZ0ludChuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZyA9IE5ldHdvcmtzLmdldChuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBjb25mbGljdGluZyBuZXR3b3JrIGZvciAke0pTT04uc3RyaW5naWZ5KGV4aXN0aW5nLm5hbWUpfWAsIFwibmFtZU9yQ2hhaW5JZFwiLCBuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBOZXR3b3Jrcy5zZXQobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV0d29yayA9IE5ldHdvcms7XG4vLyBXZSBkb24ndCB3YW50IHRvIGJyaW5nIGluIGZvcm1hdFVuaXRzIGJlY2F1c2UgaXQgaXMgYmFja2VkIGJ5XG4vLyBGaXhlZE51bWJlciBhbmQgd2Ugd2FudCB0byBrZWVwIE5ldHdvcmtzIHRpbnkuIFRoZSB2YWx1ZXNcbi8vIGluY2x1ZGVkIGJ5IHRoZSBHYXMgU3RhdGlvbnMgYXJlIGFsc28gSUVFRSA3NTQgd2l0aCBsb3RzIG9mXG4vLyByb3VuZGluZyBpc3N1ZXMgYW5kIGV4Y2VlZCB0aGUgc3RyaWN0IGNoZWNrcyBmb3JtYXRVbml0cyBoYXMuXG5mdW5jdGlvbiBwYXJzZVVuaXRzKF92YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFN0cmluZyhfdmFsdWUpO1xuICAgIGlmICghdmFsdWUubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gQnJlYWsgaW50byBbIHdob2xlLCBmcmFjdGlvbiBdXG4gICAgY29uc3QgY29tcHMgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb21wcy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICAvLyBNb3JlIHRoYW4gMSBkZWNpbWFsIHBvaW50IG9yIHRvbyBtYW55IGZyYWN0aW9uYWwgcG9zaXRpb25zXG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XG4gICAgfVxuICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gdG8gOSBkZWNpbWFscGxhY2VzXG4gICAgd2hpbGUgKGNvbXBzWzFdLmxlbmd0aCA8IGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbXBzWzFdICs9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBUb28gbWFueSBkZWNpbWFscyBhbmQgc29tZSBub24temVybyBlbmRpbmcsIHRha2UgdGhlIGNlaWxpbmdcbiAgICBpZiAoY29tcHNbMV0ubGVuZ3RoID4gOSkge1xuICAgICAgICBsZXQgZnJhYyA9IEJpZ0ludChjb21wc1sxXS5zdWJzdHJpbmcoMCwgOSkpO1xuICAgICAgICBpZiAoIWNvbXBzWzFdLnN1YnN0cmluZyg5KS5tYXRjaCgvXjArJC8pKSB7XG4gICAgICAgICAgICBmcmFjKys7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHNbMV0gPSBmcmFjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoY29tcHNbMF0gKyBjb21wc1sxXSk7XG59XG4vLyBVc2VkIGJ5IFBvbHlnb24gdG8gdXNlIGEgZ2FzIHN0YXRpb24gZm9yIGZlZSBkYXRhXG5mdW5jdGlvbiBnZXRHYXNTdGF0aW9uUGx1Z2luKHVybCkge1xuICAgIHJldHVybiBuZXcgcGx1Z2luc19uZXR3b3JrX2pzXzEuRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbih1cmwsIGFzeW5jIChmZXRjaEZlZURhdGEsIHByb3ZpZGVyLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgIC8vIFByZXZlbnQgQ2xvdWRmbGFyZSBmcm9tIGJsb2NraW5nIG91ciByZXF1ZXN0IGluIG5vZGUuanNcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJVc2VyLUFnZW50XCIsIFwiZXRoZXJzXCIpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbX3Jlc3BvbnNlLCBfZmVlRGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCksIGZldGNoRmVlRGF0YSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX3Jlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHJlc3BvbnNlLmJvZHlKc29uLnN0YW5kYXJkO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogX2ZlZURhdGEuZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4RmVlLCA5KSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heFByaW9yaXR5RmVlLCA5KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZmVlRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydCkoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCB3aXRoIHBvbHlnb24gZ2FzIHN0YXRpb24gKCR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdC51cmwpfSlgLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gU2VlOiBodHRwczovL2NoYWlubGlzdC5vcmdcbmxldCBpbmplY3RlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5qZWN0Q29tbW9uTmV0d29ya3MoKSB7XG4gICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIC8vLyBSZWdpc3RlciBwb3B1bGFyIEV0aGVyZXVtIG5ldHdvcmtzXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdGgobmFtZSwgY2hhaW5JZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldyBOZXR3b3JrKG5hbWUsIGNoYWluSWQpO1xuICAgICAgICAgICAgLy8gV2UgdXNlIDAgdG8gZGlzYWJsZSBFTlNcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBwbHVnaW5zX25ldHdvcmtfanNfMS5FbnNQbHVnaW4obnVsbCwgb3B0aW9ucy5lbnNOZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgcGx1Z2luc19uZXR3b3JrX2pzXzEuR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgICAgIChvcHRpb25zLnBsdWdpbnMgfHwgW10pLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV0d29yayBieSBuYW1lIGFuZCBjaGFpbiBJRFxuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKGNoYWluSWQsIGZ1bmMpO1xuICAgICAgICBpZiAob3B0aW9ucy5hbHROYW1lcykge1xuICAgICAgICAgICAgb3B0aW9ucy5hbHROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyRXRoKFwibWFpbm5ldFwiLCAxLCB7IGVuc05ldHdvcms6IDEsIGFsdE5hbWVzOiBbXCJob21lc3RlYWRcIl0gfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJyb3BzdGVuXCIsIDMsIHsgZW5zTmV0d29yazogMyB9KTtcbiAgICByZWdpc3RlckV0aChcInJpbmtlYnlcIiwgNCwgeyBlbnNOZXR3b3JrOiA0IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiZ29lcmxpXCIsIDUsIHsgZW5zTmV0d29yazogNSB9KTtcbiAgICByZWdpc3RlckV0aChcImtvdmFuXCIsIDQyLCB7IGVuc05ldHdvcms6IDQyIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwic2Vwb2xpYVwiLCAxMTE1NTExMSwgeyBlbnNOZXR3b3JrOiAxMTE1NTExMSB9KTtcbiAgICByZWdpc3RlckV0aChcImhvbGVza3lcIiwgMTcwMDAsIHsgZW5zTmV0d29yazogMTcwMDAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJjbGFzc2ljXCIsIDYxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJjbGFzc2ljS290dGlcIiwgNiwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW1cIiwgNDIxNjEsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtLWdvZXJsaVwiLCA0MjE2MTMsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtLXNlcG9saWFcIiwgNDIxNjE0LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlXCIsIDg0NTMsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2UtZ29lcmxpXCIsIDg0NTMxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlLXNlcG9saWFcIiwgODQ1MzIsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJuYlwiLCA1NiwgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYm5idFwiLCA5Nywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwibGluZWFcIiwgNTkxNDQsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhLWdvZXJsaVwiLCA1OTE0MCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwibWF0aWNcIiwgMTM3LCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldEdhc1N0YXRpb25QbHVnaW4oXCJodHRwczovXFwvZ2Fzc3RhdGlvbi5wb2x5Z29uLnRlY2hub2xvZ3kvdjJcIilcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwibWF0aWMtbXVtYmFpXCIsIDgwMDAxLCB7XG4gICAgICAgIGFsdE5hbWVzOiBbXCJtYXRpY011bWJhaVwiLCBcIm1hdGljbXVtXCJdLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24tdGVzdG5ldC5wb2x5Z29uLnRlY2hub2xvZ3kvdjJcIilcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc21cIiwgMTAsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICAgICAgcGx1Z2luczogW11cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtLWdvZXJsaVwiLCA0MjAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtLXNlcG9saWFcIiwgMTExNTU0MjAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcInhkYWlcIiwgMTAwLCB7IGVuc05ldHdvcms6IDEgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/plugins-network.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = void 0;\nconst properties_js_1 = __webpack_require__(/*! ../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */\nclass NetworkPlugin {\n    /**\n     *  The name of the plugin.\n     *\n     *  It is recommended to use reverse-domain-notation, which permits\n     *  unique names with a known authority as well as hierarchal entries.\n     */\n    name;\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */\n    constructor(name) {\n        (0, properties_js_1.defineProperties)(this, { name });\n    }\n    /**\n     *  Creates a copy of this plugin.\n     */\n    clone() {\n        return new NetworkPlugin(this.name);\n    }\n}\nexports.NetworkPlugin = NetworkPlugin;\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */\nclass GasCostPlugin extends NetworkPlugin {\n    /**\n     *  The block number to treat these values as valid from.\n     *\n     *  This allows a hardfork to have updated values included as well as\n     *  mulutiple hardforks to be supported.\n     */\n    effectiveBlock;\n    /**\n     *  The transactions base fee.\n     */\n    txBase;\n    /**\n     *  The fee for creating a new account.\n     */\n    txCreate;\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    txDataZero;\n    /**\n     *  The fee per non-zero-byte in the data.\n     */\n    txDataNonzero;\n    /**\n     *  The fee per storage key in the [[link-eip-2930]] access list.\n     */\n    txAccessListStorageKey;\n    /**\n     *  The fee per address in the [[link-eip-2930]] access list.\n     */\n    txAccessListAddress;\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */\n    constructor(effectiveBlock, costs) {\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(`org.ethers.network.plugins.GasCost#${(effectiveBlock || 0)}`);\n        const props = { effectiveBlock };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0, index_js_1.assertArgument)(typeof (value) === \"number\", `invalud value for ${name}`, \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0, properties_js_1.defineProperties)(this, props);\n    }\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\nexports.GasCostPlugin = GasCostPlugin;\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */\nclass EnsPlugin extends NetworkPlugin {\n    /**\n     *  The ENS Registrty Contract address.\n     */\n    address;\n    /**\n     *  The chain ID that the ENS contract lives on.\n     */\n    targetNetwork;\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */\n    constructor(address, targetNetwork) {\n        super(\"org.ethers.plugins.network.Ens\");\n        (0, properties_js_1.defineProperties)(this, {\n            address: (address || EnsAddress),\n            targetNetwork: ((targetNetwork == null) ? 1 : targetNetwork)\n        });\n    }\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\nexports.EnsPlugin = EnsPlugin;\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */\nclass FeeDataNetworkPlugin extends NetworkPlugin {\n    #feeDataFunc;\n    /**\n     *  The fee data function provided to the constructor.\n     */\n    get feeDataFunc() {\n        return this.#feeDataFunc;\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */\n    constructor(feeDataFunc) {\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n    /**\n     *  Resolves to the fee data.\n     */\n    async getFeeData(provider) {\n        return await this.#feeDataFunc(provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\nexports.FeeDataNetworkPlugin = FeeDataNetworkPlugin;\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    #url;\n    #processFunc;\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */\n    get url() { return this.#url; }\n    /**\n     *  The callback to use when computing the FeeData.\n     */\n    get processFunc() { return this.#processFunc; }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */\n    constructor(url, processFunc) {\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() { return this; }\n}\nexports.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin;\n/*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/\n//# sourceMappingURL=plugins-network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxHQUFHLDRCQUE0QixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQjtBQUN2SSx3QkFBd0IsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsc0JBQXNCO0FBQzFFLHdCQUF3QjtBQUN4QjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsS0FBSztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzPzBhMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4gPSBleHBvcnRzLkZlZURhdGFOZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5FbnNQbHVnaW4gPSBleHBvcnRzLkdhc0Nvc3RQbHVnaW4gPSBleHBvcnRzLk5ldHdvcmtQbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBwcm9wZXJ0aWVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBFbnNBZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIjtcbi8qKlxuICogIEEgKipOZXR3b3JrUGx1Z2luKiogcHJvdmlkZXMgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IG9uIGEgW1tOZXR3b3JrXV0uXG4gKi9cbmNsYXNzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSByZXZlcnNlLWRvbWFpbi1ub3RhdGlvbiwgd2hpY2ggcGVybWl0c1xuICAgICAqICB1bmlxdWUgbmFtZXMgd2l0aCBhIGtub3duIGF1dGhvcml0eSBhcyB3ZWxsIGFzIGhpZXJhcmNoYWwgZW50cmllcy5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrUGx1Z2luKHRoaXMubmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3JrUGx1Z2luID0gTmV0d29ya1BsdWdpbjtcbi8qKlxuICogIEEgKipHYXNDb3N0UGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFsdGVybmF0aXZlIHZhbHVlcyB3aGVuXG4gKiAgY29tcHV0aW5nIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICovXG5jbGFzcyBHYXNDb3N0UGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgdG8gdHJlYXQgdGhlc2UgdmFsdWVzIGFzIHZhbGlkIGZyb20uXG4gICAgICpcbiAgICAgKiAgVGhpcyBhbGxvd3MgYSBoYXJkZm9yayB0byBoYXZlIHVwZGF0ZWQgdmFsdWVzIGluY2x1ZGVkIGFzIHdlbGwgYXNcbiAgICAgKiAgbXVsdXRpcGxlIGhhcmRmb3JrcyB0byBiZSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgZWZmZWN0aXZlQmxvY2s7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbnMgYmFzZSBmZWUuXG4gICAgICovXG4gICAgdHhCYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGZvciBjcmVhdGluZyBhIG5ldyBhY2NvdW50LlxuICAgICAqL1xuICAgIHR4Q3JlYXRlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciB6ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhWmVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgbm9uLXplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFOb256ZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBzdG9yYWdlIGtleSBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0U3RvcmFnZUtleTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgYWRkcmVzcyBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBHYXNDb3N0UGx1Z2luIGZyb20gJSVlZmZlY3RpdmVCbG9jayUlIHVudGlsIHRoZVxuICAgICAqICBsYXRlc3QgYmxvY2sgb3IgYW5vdGhlciBHYXNDb3N0UGx1Z2luIHN1cGVyY2VkZXMgdGhhdCBibG9jayBudW1iZXIsXG4gICAgICogIHdpdGggdGhlIGFzc29jaWF0ZWQgJSVjb3N0cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVmZmVjdGl2ZUJsb2NrLCBjb3N0cykge1xuICAgICAgICBpZiAoZWZmZWN0aXZlQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWZmZWN0aXZlQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGBvcmcuZXRoZXJzLm5ldHdvcmsucGx1Z2lucy5HYXNDb3N0IyR7KGVmZmVjdGl2ZUJsb2NrIHx8IDApfWApO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHsgZWZmZWN0aXZlQmxvY2sgfTtcbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIG51bGxpc2gpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IChjb3N0cyB8fCB7fSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbGlzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiwgYGludmFsdWQgdmFsdWUgZm9yICR7bmFtZX1gLCBcImNvc3RzXCIsIGNvc3RzKTtcbiAgICAgICAgICAgIHByb3BzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KFwidHhCYXNlXCIsIDIxMDAwKTtcbiAgICAgICAgc2V0KFwidHhDcmVhdGVcIiwgMzIwMDApO1xuICAgICAgICBzZXQoXCJ0eERhdGFaZXJvXCIsIDQpO1xuICAgICAgICBzZXQoXCJ0eERhdGFOb256ZXJvXCIsIDE2KTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0U3RvcmFnZUtleVwiLCAxOTAwKTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0QWRkcmVzc1wiLCAyNDAwKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCBwcm9wcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdhc0Nvc3RQbHVnaW4odGhpcy5lZmZlY3RpdmVCbG9jaywgdGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5HYXNDb3N0UGx1Z2luID0gR2FzQ29zdFBsdWdpbjtcbi8qKlxuICogIEFuICoqRW5zUGx1Z2luKiogYWxsb3dzIGEgW1tOZXR3b3JrXV0gdG8gc3BlY2lmeSB0aGUgRU5TIFJlZ2lzdHJ5XG4gKiAgQ29udHJhY3QgYWRkcmVzcyBhbmQgdGhlIHRhcmdldCBuZXR3b3JrIHRvIHVzZSB3aGVuIHVzaW5nIHRoYXRcbiAqICBjb250cmFjdC5cbiAqXG4gKiAgVmFyaW91cyB0ZXN0bmV0cyBoYXZlIHRoZWlyIG93biBpbnN0YW5jZSBvZiB0aGUgY29udHJhY3QgdG8gdXNlLCBidXRcbiAqICBpbiBnZW5lcmFsLCB0aGUgbWFpbm5ldCBpbnN0YW5jZSBzdXBwb3J0cyBtdWx0aS1jaGFpbiBhZGRyZXNzZXMgYW5kXG4gKiAgc2hvdWxkIGJlIHVzZWQuXG4gKi9cbmNsYXNzIEVuc1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgRU5TIFJlZ2lzdHJ0eSBDb250cmFjdCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGF0IHRoZSBFTlMgY29udHJhY3QgbGl2ZXMgb24uXG4gICAgICovXG4gICAgdGFyZ2V0TmV0d29yaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkVuc1BsdWdpbioqIGNvbm5lY3RlZCB0byAlJWFkZHJlc3MlJSBvbiB0aGVcbiAgICAgKiAgJSV0YXJnZXROZXR3b3JrJSUuIFRoZSBkZWZhdWx0IEVOUyBhZGRyZXNzIGFuZCBtYWlubmV0IGlzIHVzZWRcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgdGFyZ2V0TmV0d29yaykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoYWRkcmVzcyB8fCBFbnNBZGRyZXNzKSxcbiAgICAgICAgICAgIHRhcmdldE5ldHdvcms6ICgodGFyZ2V0TmV0d29yayA9PSBudWxsKSA/IDEgOiB0YXJnZXROZXR3b3JrKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW5zUGx1Z2luKHRoaXMuYWRkcmVzcywgdGhpcy50YXJnZXROZXR3b3JrKTtcbiAgICB9XG59XG5leHBvcnRzLkVuc1BsdWdpbiA9IEVuc1BsdWdpbjtcbi8qKlxuICogIEEgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbmQgYWx0ZXJuYXRlXG4gKiAgbWVhbnMgdG8gc3BlY2lmeSBpdHMgZmVlIGRhdGEuXG4gKlxuICogIEZvciBleGFtcGxlLCBhIG5ldHdvcmsgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBbW2xpbmstZWlwLTE1NTldXSBtYXlcbiAqICBjaG9vc2UgdG8gdXNlIGEgR2FzIFN0YXRpb24gc2l0ZSB0byBhcHByb3hpbWF0ZSB0aGUgZ2FzIHByaWNlLlxuICovXG5jbGFzcyBGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICNmZWVEYXRhRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBkYXRhIGZ1bmN0aW9uIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBnZXQgZmVlRGF0YUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZlZURhdGFGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmVlRGF0YVwiKTtcbiAgICAgICAgdGhpcy4jZmVlRGF0YUZ1bmMgPSBmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBmZWUgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGZWVEYXRhKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZWVEYXRhRnVuYyhwcm92aWRlcik7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZlZURhdGFOZXR3b3JrUGx1Z2luKHRoaXMuI2ZlZURhdGFGdW5jKTtcbiAgICB9XG59XG5leHBvcnRzLkZlZURhdGFOZXR3b3JrUGx1Z2luID0gRmVlRGF0YU5ldHdvcmtQbHVnaW47XG5jbGFzcyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI3VybDtcbiAgICAjcHJvY2Vzc0Z1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBVUkwgdG8gaW5pdGlhbGl6ZSB0aGUgRmV0Y2hSZXF1ZXN0IHdpdGggaW4gJSVwcm9jZXNzRnVuYyUlLlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNhbGxiYWNrIHRvIHVzZSB3aGVuIGNvbXB1dGluZyB0aGUgRmVlRGF0YS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7IHJldHVybiB0aGlzLiNwcm9jZXNzRnVuYzsgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbioqIHdoaWNoIHdpbGxcbiAgICAgKiAgYmUgdXNlZCB3aGVuIGNvbXB1dGluZyB0aGUgZmVlIGRhdGEgZm9yIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZXRjaFVybEZlZURhdGFQbHVnaW5cIik7XG4gICAgICAgIHRoaXMuI3VybCA9IHVybDtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0Z1bmMgPSBwcm9jZXNzRnVuYztcbiAgICB9XG4gICAgLy8gV2UgYXJlIGltbXV0YWJsZSwgc28gd2UgY2FuIHNlcnZlIGFzIG91ciBvd24gY2xvbmVcbiAgICBjbG9uZSgpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbmV4cG9ydHMuRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiA9IEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW47XG4vKlxuZXhwb3J0IGNsYXNzIEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5ICNibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+O1xuICAgIHJlYWRvbmx5ICNibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuXG4gICAgY29uc3RydWN0b3IoYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPiwgYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMubmV0d29yay1wbHVnaW5zLmN1c3RvbS1ibG9ja1wiKTtcbiAgICAgICAgdGhpcy4jYmxvY2tGdW5jID0gYmxvY2tGdW5jO1xuICAgICAgICB0aGlzLiNibG9ja1dpdGhUeHNGdW5jID0gYmxvY2tXaXRoVHhzRnVuYztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9jayhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KTogUHJvbWlzZTxCbG9jazxzdHJpbmc+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9ja2lvbnMocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pOiBQcm9taXNlPEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4odGhpcy4jYmxvY2tGdW5jLCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKTtcbiAgICB9XG59XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy1uZXR3b3JrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  [[link-alchemy]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\n *  - Base (``base``)\n *  - Base Goerlia Testnet (``base-goerli``)\n *  - Base Sepolia Testnet (``base-sepolia``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:Alchemy  [providers-alchemy]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlchemyProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"eth-mainnet.alchemyapi.io\";\n        case \"goerli\":\n            return \"eth-goerli.g.alchemy.com\";\n        case \"sepolia\":\n            return \"eth-sepolia.g.alchemy.com\";\n        case \"arbitrum\":\n            return \"arb-mainnet.g.alchemy.com\";\n        case \"arbitrum-goerli\":\n            return \"arb-goerli.g.alchemy.com\";\n        case \"arbitrum-sepolia\":\n            return \"arb-sepolia.g.alchemy.com\";\n        case \"base\":\n            return \"base-mainnet.g.alchemy.com\";\n        case \"base-goerli\":\n            return \"base-goerli.g.alchemy.com\";\n        case \"base-sepolia\":\n            return \"base-sepolia.g.alchemy.com\";\n        case \"matic\":\n            return \"polygon-mainnet.g.alchemy.com\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai.g.alchemy.com\";\n        case \"optimism\":\n            return \"opt-mainnet.g.alchemy.com\";\n        case \"optimism-goerli\":\n            return \"opt-goerli.g.alchemy.com\";\n        case \"optimism-sepolia\":\n            return \"opt-sepolia.g.alchemy.com\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **AlchemyProvider** connects to the [[link-alchemy]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-alchemy-signup).\n *\n *  @_docloc: api/providers/thirdparty\n */\nclass AlchemyProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    apiKey;\n    constructor(_network, apiKey) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = AlchemyProvider.getRequest(network, apiKey);\n        super(request, network, { staticNetwork: network });\n        (0, index_js_1.defineProperties)(this, { apiKey });\n    }\n    _getProvider(chainId) {\n        try {\n            return new AlchemyProvider(chainId, this.apiKey);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    async _perform(req) {\n        // https://docs.alchemy.com/reference/trace-transaction\n        if (req.method === \"getTransactionResult\") {\n            const { trace, tx } = await (0, index_js_1.resolveProperties)({\n                trace: this.send(\"trace_transaction\", [req.hash]),\n                tx: this.getTransaction(req.hash)\n            });\n            if (trace == null || tx == null) {\n                return null;\n            }\n            let data;\n            let error = false;\n            try {\n                data = trace[0].result.output;\n                error = (trace[0].error === \"Reverted\");\n            }\n            catch (error) { }\n            if (data) {\n                (0, index_js_1.assert)(!error, \"an error occurred during transaction executions\", \"CALL_EXCEPTION\", {\n                    action: \"getTransactionResult\",\n                    data,\n                    reason: null,\n                    transaction: tx,\n                    invocation: null,\n                    revert: null // @TODO\n                });\n                return data;\n            }\n            (0, index_js_1.assert)(false, \"could not parse trace result\", \"BAD_DATA\", { value: trace });\n        }\n        return await super._perform(req);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n    static getRequest(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/v2/${apiKey}`);\n        request.allowGzip = true;\n        if (apiKey === defaultApiKey) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0, community_js_1.showThrottleMessage)(\"alchemy\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\nexports.AlchemyProvider = AlchemyProvider;\n//# sourceMappingURL=provider-alchemy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYWxjaGVteS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsbUZBQWM7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMscUdBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFELGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0ZBQXdGLGNBQWM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCLE1BQU0sT0FBTztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci1hbGNoZW15LmpzPzUxNmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBbW2xpbmstYWxjaGVteV1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqICAtIEFyYml0cnVtIEdvZXJsaSBUZXN0bmV0IChgYGFyYml0cnVtLWdvZXJsaWBgKVxuICogIC0gQXJiaXRydW0gU2Vwb2xpYSBUZXN0bmV0IChgYGFyYml0cnVtLXNlcG9saWFgYClcbiAqICAtIEJhc2UgKGBgYmFzZWBgKVxuICogIC0gQmFzZSBHb2VybGlhIFRlc3RuZXQgKGBgYmFzZS1nb2VybGlgYClcbiAqICAtIEJhc2UgU2Vwb2xpYSBUZXN0bmV0IChgYGJhc2Utc2Vwb2xpYWBgKVxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxuICogIC0gT3B0aW1pc20gU2Vwb2xpYSBUZXN0bmV0IChgYG9wdGltaXNtLXNlcG9saWFgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIFBvbHlnb24gTXVtYmFpIFRlc3RuZXQgKGBgbWF0aWMtbXVtYmFpYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkFsY2hlbXkgIFtwcm92aWRlcnMtYWxjaGVteV1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgY29tbXVuaXR5X2pzXzEgPSByZXF1aXJlKFwiLi9jb21tdW5pdHkuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbmNvbnN0IGRlZmF1bHRBcGlLZXkgPSBcIl9nZzd3U1NpMEtNQnNkS25HVmZIRHVlcTZ4TUI5RWtDXCI7XG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aC1tYWlubmV0LmFsY2hlbXlhcGkuaW9cIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoLWdvZXJsaS5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJzZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGgtc2Vwb2xpYS5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJiLW1haW5uZXQuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW0tZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmItZ29lcmxpLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLXNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYi1zZXBvbGlhLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgIHJldHVybiBcImJhc2UtbWFpbm5ldC5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmFzZS1nb2VybGkuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwiYmFzZS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLXNlcG9saWEuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbWFpbm5ldC5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpYy1tdW1iYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbXVtYmFpLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJvcHQtbWFpbm5ldC5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm9wdC1nb2VybGkuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc20tc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0LXNlcG9saWEuZy5hbGNoZW15LmNvbVwiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKipcbiAqICBUaGUgKipBbGNoZW15UHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLWFsY2hlbXldXVxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWFsY2hlbXktc2lnbnVwKS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eVxuICovXG5jbGFzcyBBbGNoZW15UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBhcGlLZXk7XG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gQWxjaGVteVByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFwaUtleSB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxjaGVteVByb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmFsY2hlbXkuY29tL3JlZmVyZW5jZS90cmFjZS10cmFuc2FjdGlvblxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNlLCB0eCB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICB0cmFjZTogdGhpcy5zZW5kKFwidHJhY2VfdHJhbnNhY3Rpb25cIiwgW3JlcS5oYXNoXSksXG4gICAgICAgICAgICAgICAgdHg6IHRoaXMuZ2V0VHJhbnNhY3Rpb24ocmVxLmhhc2gpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PSBudWxsIHx8IHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0cmFjZVswXS5yZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgICAgIGVycm9yID0gKHRyYWNlWzBdLmVycm9yID09PSBcIlJldmVydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSghZXJyb3IsIFwiYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbnNcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBudWxsIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcImNvdWxkIG5vdCBwYXJzZSB0cmFjZSByZXN1bHRcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0cmFjZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleSA9IGRlZmF1bHRBcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc18xLkZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS92Mi8ke2FwaUtleX1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBjb21tdW5pdHlfanNfMS5zaG93VGhyb3R0bGVNZXNzYWdlKShcImFsY2hlbXlcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gQWxjaGVteVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItYWxjaGVteS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-ankr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-ankr.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnkrProvider = void 0;\n/**\n *  [[link-ankr]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Base (``base``)\n *  - Base Goerlia Testnet (``base-goerli``)\n *  - Base Sepolia Testnet (``base-sepolia``)\n *  - BNB (``bnb``)\n *  - BNB Testnet (``bnbt``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:Ankr  [providers-ankr]\n */\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"rpc.ankr.com/eth\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli\";\n        case \"sepolia\":\n            return \"rpc.ankr.com/eth_sepolia\";\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum\";\n        case \"base\":\n            return \"rpc.ankr.com/base\";\n        case \"base-goerli\":\n            return \"rpc.ankr.com/base_goerli\";\n        case \"base-sepolia\":\n            return \"rpc.ankr.com/base_sepolia\";\n        case \"bnb\":\n            return \"rpc.ankr.com/bsc\";\n        case \"bnbt\":\n            return \"rpc.ankr.com/bsc_testnet_chapel\";\n        case \"matic\":\n            return \"rpc.ankr.com/polygon\";\n        case \"matic-mumbai\":\n            return \"rpc.ankr.com/polygon_mumbai\";\n        case \"optimism\":\n            return \"rpc.ankr.com/optimism\";\n        case \"optimism-goerli\":\n            return \"rpc.ankr.com/optimism_testnet\";\n        case \"optimism-sepolia\":\n            return \"rpc.ankr.com/optimism_sepolia\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **AnkrProvider** connects to the [[link-ankr]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-ankr-signup).\n */\nclass AnkrProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    /**\n     *  The API key for the Ankr connection.\n     */\n    apiKey;\n    /**\n     *  Create a new **AnkrProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n     *  API key.\n     */\n    constructor(_network, apiKey) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        // Ankr does not support filterId, so we force polling\n        const options = { polling: true, staticNetwork: network };\n        const request = AnkrProvider.getRequest(network, apiKey);\n        super(request, network, options);\n        (0, index_js_1.defineProperties)(this, { apiKey });\n    }\n    _getProvider(chainId) {\n        try {\n            return new AnkrProvider(chainId, this.apiKey);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%% with\n     *  %%apiKey%%.\n     */\n    static getRequest(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/${apiKey}`);\n        request.allowGzip = true;\n        if (apiKey === defaultApiKey) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0, community_js_1.showThrottleMessage)(\"AnkrProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n    getRpcError(payload, error) {\n        if (payload.method === \"eth_sendRawTransaction\") {\n            if (error && error.error && error.error.message === \"INTERNAL_ERROR: could not replace existing tx\") {\n                error.error.message = \"replacement transaction underpriced\";\n            }\n        }\n        return super.getRpcError(payload, error);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\nexports.AnkrProvider = AnkrProvider;\n//# sourceMappingURL=provider-ankr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYW5rci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsbUZBQWM7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMscUdBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCLEdBQUcsT0FBTztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYW5rci5qcz84MmJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbmtyUHJvdmlkZXIgPSB2b2lkIDA7XG4vKipcbiAqICBbW2xpbmstYW5rcl1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqICAtIEJhc2UgKGBgYmFzZWBgKVxuICogIC0gQmFzZSBHb2VybGlhIFRlc3RuZXQgKGBgYmFzZS1nb2VybGlgYClcbiAqICAtIEJhc2UgU2Vwb2xpYSBUZXN0bmV0IChgYGJhc2Utc2Vwb2xpYWBgKVxuICogIC0gQk5CIChgYGJuYmBgKVxuICogIC0gQk5CIFRlc3RuZXQgKGBgYm5idGBgKVxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxuICogIC0gT3B0aW1pc20gU2Vwb2xpYSBUZXN0bmV0IChgYG9wdGltaXNtLXNlcG9saWFgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIFBvbHlnb24gTXVtYmFpIFRlc3RuZXQgKGBgbWF0aWMtbXVtYmFpYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkFua3IgIFtwcm92aWRlcnMtYW5rcl1cbiAqL1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGNvbW11bml0eV9qc18xID0gcmVxdWlyZShcIi4vY29tbXVuaXR5LmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG5jb25zdCBkZWZhdWx0QXBpS2V5ID0gXCI5ZjdkOTI5YjAxOGNkZmZiMzM4NTE3ZWZhMDZmNTgzNTllODZmZjFmZmQzNTBiYzg4OTczODUyMzY1OWU3OTcyXCI7XG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhcIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2V0aF9nb2VybGlcIjtcbiAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhfc2Vwb2xpYVwiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9hcmJpdHJ1bVwiO1xuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2Jhc2VcIjtcbiAgICAgICAgY2FzZSBcImJhc2UtZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYmFzZV9nb2VybGlcIjtcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2Jhc2Vfc2Vwb2xpYVwiO1xuICAgICAgICBjYXNlIFwiYm5iXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYnNjXCI7XG4gICAgICAgIGNhc2UgXCJibmJ0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYnNjX3Rlc3RuZXRfY2hhcGVsXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL3BvbHlnb25cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL3BvbHlnb25fbXVtYmFpXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL29wdGltaXNtXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9vcHRpbWlzbV90ZXN0bmV0XCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vb3B0aW1pc21fc2Vwb2xpYVwiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKipcbiAqICBUaGUgKipBbmtyUHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLWFua3JdXVxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWFua3Itc2lnbnVwKS5cbiAqL1xuY2xhc3MgQW5rclByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkga2V5IGZvciB0aGUgQW5rciBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFwaUtleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQW5rclByb3ZpZGVyKiouXG4gICAgICpcbiAgICAgKiAgQnkgZGVmYXVsdCBjb25uZWN0aW5nIHRvIGBgbWFpbm5ldGBgIHdpdGggYSBoaWdobHkgdGhyb3R0bGVkXG4gICAgICogIEFQSSBrZXkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbmtyIGRvZXMgbm90IHN1cHBvcnQgZmlsdGVySWQsIHNvIHdlIGZvcmNlIHBvbGxpbmdcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgcG9sbGluZzogdHJ1ZSwgc3RhdGljTmV0d29yazogbmV0d29yayB9O1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gQW5rclByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYXBpS2V5IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmtyUHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcHJlcGFyZWQgcmVxdWVzdCBmb3IgY29ubmVjdGluZyB0byAlJW5ldHdvcmslJSB3aXRoXG4gICAgICogICUlYXBpS2V5JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGluZGV4X2pzXzEuRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9LyR7YXBpS2V5fWApO1xuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIGlmIChhcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKFwiQW5rclByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpIHtcbiAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmVycm9yICYmIGVycm9yLmVycm9yLm1lc3NhZ2UgPT09IFwiSU5URVJOQUxfRVJST1I6IGNvdWxkIG5vdCByZXBsYWNlIGV4aXN0aW5nIHR4XCIpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcik7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQW5rclByb3ZpZGVyID0gQW5rclByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItYW5rci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-ankr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-browser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */\nclass BrowserProvider extends provider_jsonrpc_js_1.JsonRpcApiPollingProvider {\n    #request;\n    /**\n     *  Connnect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */\n    constructor(ethereum, network) {\n        (0, index_js_1.assertArgument)(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n        super(network, { batchMaxCount: 1 });\n        this.#request = async (method, params) => {\n            const payload = { method, params };\n            this.emit(\"debug\", { action: \"sendEip1193Request\", payload });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", { action: \"receiveEip1193Result\", result });\n                return result;\n            }\n            catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", { action: \"receiveEip1193Error\", error });\n                throw error;\n            }\n        };\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        (0, index_js_1.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await this.#request(payload.method, payload.params || []);\n            return [{ id: payload.id, result }];\n        }\n        catch (e) {\n            return [{\n                    id: payload.id,\n                    error: { code: e.code, data: e.data, message: e.message }\n                }];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into \n        switch (error.error.code || -1) {\n            case 4001:\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */\n    async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof (address) === \"number\") {\n            return (accounts.length > address);\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a) => (a.toLowerCase() === address)).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!(await this.hasSigner(address))) {\n            try {\n                //const resp = \n                await this.#request(\"eth_requestAccounts\", []);\n                //console.log(\"RESP\", resp);\n            }\n            catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, { id: payload.id, error });\n            }\n        }\n        return await super.getSigner(address);\n    }\n}\nexports.BrowserProvider = BrowserProvider;\n//# sourceMappingURL=provider-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLDhCQUE4QixtQkFBTyxDQUFDLHFHQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBLDhCQUE4QjtBQUM5QixpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNDQUFzQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcz9iM2U0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2VyUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbjtcbi8qKlxuICogIEEgKipCcm93c2VyUHJvdmlkZXIqKiBpcyBpbnRlbmRlZCB0byB3cmFwIGFuIGluamVjdGVkIHByb3ZpZGVyIHdoaWNoXG4gKiAgYWRoZXJlcyB0byB0aGUgW1tsaW5rLWVpcC0xMTkzXV0gc3RhbmRhcmQsIHdoaWNoIG1vc3QgKGlmIG5vdCBhbGwpXG4gKiAgY3VycmVudGx5IGRvLlxuICovXG5jbGFzcyBCcm93c2VyUHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB7XG4gICAgI3JlcXVlc3Q7XG4gICAgLyoqXG4gICAgICogIENvbm5uZWN0IHRvIHRoZSAlJWV0aGVyZXVtJSUgcHJvdmlkZXIsIG9wdGlvbmFsbHkgZm9yY2luZyB0aGVcbiAgICAgKiAgJSVuZXR3b3JrJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXRoZXJldW0sIG5ldHdvcmspIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGV0aGVyZXVtICYmIGV0aGVyZXVtLnJlcXVlc3QsIFwiaW52YWxpZCBFSVAtMTE5MyBwcm92aWRlclwiLCBcImV0aGVyZXVtXCIsIGV0aGVyZXVtKTtcbiAgICAgICAgc3VwZXIobmV0d29yaywgeyBiYXRjaE1heENvdW50OiAxIH0pO1xuICAgICAgICB0aGlzLiNyZXF1ZXN0ID0gYXN5bmMgKG1ldGhvZCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyBtZXRob2QsIHBhcmFtcyB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZEVpcDExOTNSZXF1ZXN0XCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVpcDExOTNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGUuY29kZTtcbiAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgIGVycm9yLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFaXAxMTkzRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSghQXJyYXkuaXNBcnJheShwYXlsb2FkKSwgXCJFSVAtMTE5MyBkb2VzIG5vdCBzdXBwb3J0IGJhdGNoIHJlcXVlc3RcIiwgXCJwYXlsb2FkXCIsIHBheWxvYWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcmVxdWVzdChwYXlsb2FkLm1ldGhvZCwgcGF5bG9hZC5wYXJhbXMgfHwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIFt7IGlkOiBwYXlsb2FkLmlkLCByZXN1bHQgfV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGF5bG9hZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHsgY29kZTogZS5jb2RlLCBkYXRhOiBlLmRhdGEsIG1lc3NhZ2U6IGUubWVzc2FnZSB9XG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICAgIC8vIEVJUC0xMTkzIGdpdmVzIHVzIHNvbWUgbWFjaGluZS1yZWFkYWJsZSBlcnJvciBjb2Rlcywgc28gcmV3cml0ZVxuICAgICAgICAvLyB0aGVtIGludG8gXG4gICAgICAgIHN3aXRjaCAoZXJyb3IuZXJyb3IuY29kZSB8fCAtMSkge1xuICAgICAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVzZXItZGVuaWVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDIwMDpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11bnN1cHBvcnRlZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIHRoZSBwcm92aWRlciBtYW5hZ2VzIHRoZSAlJWFkZHJlc3MlJS5cbiAgICAgKi9cbiAgICBhc3luYyBoYXNTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFjY291bnRzLmxlbmd0aCA+IGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5maWx0ZXIoKGEpID0+IChhLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MpKS5sZW5ndGggIT09IDA7XG4gICAgfVxuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuaGFzU2lnbmVyKGFkZHJlc3MpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvL2NvbnN0IHJlc3AgPSBcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNyZXF1ZXN0KFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLCBbXSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJFU1BcIiwgcmVzcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZXJyb3IucGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHsgaWQ6IHBheWxvYWQuaWQsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5nZXRTaWduZXIoYWRkcmVzcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyUHJvdmlkZXIgPSBCcm93c2VyUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-browser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  About Cloudflare\n *\n *  @_subsection: api/providers/thirdparty:Cloudflare  [providers-cloudflare]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CloudflareProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\n/**\n *  About Cloudflare...\n */\nclass CloudflareProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    constructor(_network) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        (0, index_js_1.assertArgument)(network.name === \"mainnet\", \"unsupported network\", \"network\", _network);\n        super(\"https:/\\/cloudflare-eth.com/\", network, { staticNetwork: network });\n    }\n}\nexports.CloudflareProvider = CloudflareProvider;\n//# sourceMappingURL=provider-cloudflare.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItY2xvdWRmbGFyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItY2xvdWRmbGFyZS5qcz9iNjc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQWJvdXQgQ2xvdWRmbGFyZVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpDbG91ZGZsYXJlICBbcHJvdmlkZXJzLWNsb3VkZmxhcmVdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl9qc29ucnBjX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCIpO1xuLyoqXG4gKiAgQWJvdXQgQ2xvdWRmbGFyZS4uLlxuICovXG5jbGFzcyBDbG91ZGZsYXJlUHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaykge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShuZXR3b3JrLm5hbWUgPT09IFwibWFpbm5ldFwiLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIF9uZXR3b3JrKTtcbiAgICAgICAgc3VwZXIoXCJodHRwczovXFwvY2xvdWRmbGFyZS1ldGguY29tL1wiLCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5DbG91ZGZsYXJlUHJvdmlkZXIgPSBDbG91ZGZsYXJlUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1jbG91ZGZsYXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  [[link-etherscan]] provides a third-party service for connecting to\n *  various blockchains over a combination of JSON-RPC and custom API\n *  endpoints.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Sepolia Testnet (``holesky``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - BNB Smart Chain Mainnet (``bnb``)\n *  - BNB Smart Chain Testnet (``bnbt``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EtherscanProvider = exports.EtherscanPlugin = void 0;\nconst index_js_1 = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/contract/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst THROTTLE = 2000;\nfunction isPromise(value) {\n    return (value && typeof (value.then) === \"function\");\n}\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\";\n/**\n *  A Network can include an **EtherscanPlugin** to provide\n *  a custom base URL.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */\nclass EtherscanPlugin extends plugins_network_js_1.NetworkPlugin {\n    /**\n     *  The Etherscan API base URL.\n     */\n    baseUrl;\n    /**\n     *  Creates a new **EtherscanProvider** which will use\n     *  %%baseUrl%%.\n     */\n    constructor(baseUrl) {\n        super(EtherscanPluginId);\n        (0, index_js_4.defineProperties)(this, { baseUrl });\n    }\n    clone() {\n        return new EtherscanPlugin(this.baseUrl);\n    }\n}\nexports.EtherscanPlugin = EtherscanPlugin;\nconst skipKeys = [\"enableCcipRead\"];\nlet nextId = 1;\n/**\n *  The **EtherscanBaseProvider** is the super-class of\n *  [[EtherscanProvider]], which should generally be used instead.\n *\n *  Since the **EtherscanProvider** includes additional code for\n *  [[Contract]] access, in //rare cases// that contracts are not\n *  used, this class can reduce code size.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */\nclass EtherscanProvider extends abstract_provider_js_1.AbstractProvider {\n    /**\n     *  The connected network.\n     */\n    network;\n    /**\n     *  The API key or null if using the community provided bandwidth.\n     */\n    apiKey;\n    #plugin;\n    /**\n     *  Creates a new **EtherscanBaseProvider**.\n     */\n    constructor(_network, _apiKey) {\n        const apiKey = (_apiKey != null) ? _apiKey : null;\n        super();\n        const network = network_js_1.Network.from(_network);\n        this.#plugin = network.getPlugin(EtherscanPluginId);\n        (0, index_js_4.defineProperties)(this, { apiKey, network });\n        // Test that the network is supported by Etherscan\n        this.getBaseUrl();\n    }\n    /**\n     *  Returns the base URL.\n     *\n     *  If an [[EtherscanPlugin]] is configured on the\n     *  [[EtherscanBaseProvider_network]], returns the plugin's\n     *  baseUrl.\n     */\n    getBaseUrl() {\n        if (this.#plugin) {\n            return this.#plugin.baseUrl;\n        }\n        switch (this.network.name) {\n            case \"mainnet\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"sepolia\":\n                return \"https:/\\/api-sepolia.etherscan.io\";\n            case \"holesky\":\n                return \"https:/\\/api-holesky.etherscan.io\";\n            case \"arbitrum\":\n                return \"https:/\\/api.arbiscan.io\";\n            case \"arbitrum-goerli\":\n                return \"https:/\\/api-goerli.arbiscan.io\";\n            case \"bnb\":\n                return \"https:/\\/api.bscscan.com\";\n            case \"bnbt\":\n                return \"https:/\\/api-testnet.bscscan.com\";\n            case \"matic\":\n                return \"https:/\\/api.polygonscan.com\";\n            case \"matic-mumbai\":\n                return \"https:/\\/api-testnet.polygonscan.com\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            case \"optimism-goerli\":\n                return \"https:/\\/api-goerli-optimistic.etherscan.io\";\n            default:\n        }\n        (0, index_js_4.assertArgument)(false, \"unsupported network\", \"network\", this.network);\n    }\n    /**\n     *  Returns the URL for the %%module%% and %%params%%.\n     */\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;\n    }\n    /**\n     *  Returns the URL for using POST requests.\n     */\n    getPostUrl() {\n        return `${this.getBaseUrl()}/api`;\n    }\n    /**\n     *  Returns the parameters for using POST requests.\n     */\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    async detectNetwork() {\n        return this.network;\n    }\n    /**\n     *  Resolves to the result of calling %%module%% with %%params%%.\n     *\n     *  If %%post%%, the request is made as a POST request.\n     */\n    async fetch(module, params, post) {\n        const id = nextId++;\n        const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params) : null);\n        this.emit(\"debug\", { action: \"sendRequest\", id, url, payload: payload });\n        const request = new index_js_4.FetchRequest(url);\n        request.setThrottleParams({ slotInterval: 1000 });\n        request.retryFunc = (req, resp, attempt) => {\n            if (this.isCommunityResource()) {\n                (0, community_js_1.showThrottleMessage)(\"Etherscan\");\n            }\n            return Promise.resolve(true);\n        };\n        request.processFunc = async (request, response) => {\n            const result = response.hasBody() ? JSON.parse((0, index_js_4.toUtf8String)(response.body)) : {};\n            const throttle = ((typeof (result.result) === \"string\") ? result.result : \"\").toLowerCase().indexOf(\"rate limit\") >= 0;\n            if (module === \"proxy\") {\n                // This JSON response indicates we are being throttled\n                if (result && result.status == 0 && result.message == \"NOTOK\" && throttle) {\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"proxy-NOTOK\", error: result });\n                    response.throwThrottleError(result.result, THROTTLE);\n                }\n            }\n            else {\n                if (throttle) {\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"null result\", error: result.result });\n                    response.throwThrottleError(result.result, THROTTLE);\n                }\n            }\n            return response;\n        };\n        if (payload) {\n            request.setHeader(\"content-type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n            request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join(\"&\");\n        }\n        const response = await request.send();\n        try {\n            response.assertOk();\n        }\n        catch (error) {\n            this.emit(\"debug\", { action: \"receiveError\", id, error, reason: \"assertOk\" });\n            (0, index_js_4.assert)(false, \"response error\", \"SERVER_ERROR\", { request, response });\n        }\n        if (!response.hasBody()) {\n            this.emit(\"debug\", { action: \"receiveError\", id, error: \"missing body\", reason: \"null body\" });\n            (0, index_js_4.assert)(false, \"missing response\", \"SERVER_ERROR\", { request, response });\n        }\n        const result = JSON.parse((0, index_js_4.toUtf8String)(response.body));\n        if (module === \"proxy\") {\n            if (result.jsonrpc != \"2.0\") {\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"invalid JSON-RPC\" });\n                (0, index_js_4.assert)(false, \"invalid JSON-RPC response (missing jsonrpc='2.0')\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            if (result.error) {\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"JSON-RPC error\" });\n                (0, index_js_4.assert)(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n            return result.result;\n        }\n        else {\n            // getLogs, getHistory have weird success responses\n            if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n                this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n                return result.result;\n            }\n            if (result.status != 1 || (typeof (result.message) === \"string\" && !result.message.match(/^OK/))) {\n                this.emit(\"debug\", { action: \"receiveError\", id, result });\n                (0, index_js_4.assert)(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n            return result.result;\n        }\n    }\n    /**\n     *  Returns %%transaction%% normalized for the Etherscan API.\n     */\n    _getTransactionPostData(transaction) {\n        const result = {};\n        for (let key in transaction) {\n            if (skipKeys.indexOf(key) >= 0) {\n                continue;\n            }\n            if (transaction[key] == null) {\n                continue;\n            }\n            let value = transaction[key];\n            if (key === \"type\" && value === 0) {\n                continue;\n            }\n            if (key === \"blockTag\" && value === \"latest\") {\n                continue;\n            }\n            // Quantity-types require no leading zero, unless 0\n            if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n                value = (0, index_js_4.toQuantity)(value);\n            }\n            else if (key === \"accessList\") {\n                value = \"[\" + (0, index_js_3.accessListify)(value).map((set) => {\n                    return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n                }).join(\",\") + \"]\";\n            }\n            else {\n                value = (0, index_js_4.hexlify)(value);\n            }\n            result[key] = value;\n        }\n        return result;\n    }\n    /**\n     *  Throws the normalized Etherscan error.\n     */\n    _checkError(req, error, transaction) {\n        // Pull any message out if, possible\n        let message = \"\";\n        if ((0, index_js_4.isError)(error, \"SERVER_ERROR\")) {\n            // Check for an error emitted by a proxy call\n            try {\n                message = error.info.result.error.message;\n            }\n            catch (e) { }\n            if (!message) {\n                try {\n                    message = error.info.message;\n                }\n                catch (e) { }\n            }\n        }\n        if (req.method === \"estimateGas\") {\n            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {\n                (0, index_js_4.assert)(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: req.transaction\n                });\n            }\n        }\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            if (message.match(/execution reverted/i)) {\n                let data = \"\";\n                try {\n                    data = error.info.result.error.data;\n                }\n                catch (error) { }\n                const e = index_js_1.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);\n                e.info = { request: req, error };\n                throw e;\n            }\n        }\n        if (message) {\n            if (req.method === \"broadcastTransaction\") {\n                const transaction = index_js_3.Transaction.from(req.signedTransaction);\n                if (message.match(/replacement/i) && message.match(/underpriced/i)) {\n                    (0, index_js_4.assert)(false, \"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                        transaction\n                    });\n                }\n                if (message.match(/insufficient funds/)) {\n                    (0, index_js_4.assert)(false, \"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                        transaction\n                    });\n                }\n                if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n                    (0, index_js_4.assert)(false, \"nonce has already been used\", \"NONCE_EXPIRED\", {\n                        transaction\n                    });\n                }\n            }\n        }\n        // Something we could not process\n        throw error;\n    }\n    async _detectNetwork() {\n        return this.network;\n    }\n    async _perform(req) {\n        switch (req.method) {\n            case \"chainId\":\n                return this.network.chainId;\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n            case \"getPriorityFee\":\n                // This is temporary until Etherscan completes support\n                if (this.network.name === \"mainnet\") {\n                    return \"1000000000\";\n                }\n                else if (this.network.name === \"optimism\") {\n                    return \"1000000\";\n                }\n                else {\n                    throw new Error(\"fallback onto the AbstractProvider default\");\n                }\n            /* Working with Etherscan to get this added:\n            try {\n                const test = await this.fetch(\"proxy\", {\n                    action: \"eth_maxPriorityFeePerGas\"\n                });\n                console.log(test);\n                return test;\n            } catch (e) {\n                console.log(\"DEBUG\", e);\n                throw e;\n            }\n            */\n            /* This might be safe; but due to rounding neither myself\n               or Etherscan are necessarily comfortable with this. :)\n            try {\n                const result = await this.fetch(\"gastracker\", { action: \"gasoracle\" });\n                console.log(result);\n                const gasPrice = parseUnits(result.SafeGasPrice, \"gwei\");\n                const baseFee = parseUnits(result.suggestBaseFee, \"gwei\");\n                const priorityFee = gasPrice - baseFee;\n                if (priorityFee < 0) { throw new Error(\"negative priority fee; defer to abstract provider default\"); }\n                return priorityFee;\n            } catch (error) {\n                console.log(\"DEBUG\", error);\n                throw error;\n            }\n            */\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getStorage\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: req.address,\n                    position: req.position,\n                    tag: req.blockTag\n                });\n            case \"broadcastTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: req.signedTransaction\n                }, true).catch((error) => {\n                    return this._checkError(req, error, req.signedTransaction);\n                });\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: req.blockTag,\n                        boolean: (req.includeTransactions ? \"true\" : \"false\")\n                    });\n                }\n                (0, index_js_4.assert)(false, \"getBlock by blockHash not supported by Etherscan\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"getBlock(blockHash)\"\n                });\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: req.hash\n                });\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: req.hash\n                });\n            case \"call\": {\n                if (req.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n                const postData = this._getTransactionPostData(req.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                }\n                catch (error) {\n                    return this._checkError(req, error, req.transaction);\n                }\n            }\n            case \"estimateGas\": {\n                const postData = this._getTransactionPostData(req.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                }\n                catch (error) {\n                    return this._checkError(req, error, req.transaction);\n                }\n            }\n            /*\n                        case \"getLogs\": {\n                            // Needs to complain if more than one address is passed in\n                            const args: Record<string, any> = { action: \"getLogs\" }\n            \n                            if (params.filter.fromBlock) {\n                                args.fromBlock = checkLogTag(params.filter.fromBlock);\n                            }\n            \n                            if (params.filter.toBlock) {\n                                args.toBlock = checkLogTag(params.filter.toBlock);\n                            }\n            \n                            if (params.filter.address) {\n                                args.address = params.filter.address;\n                            }\n            \n                            // @TODO: We can handle slightly more complicated logs using the logs API\n                            if (params.filter.topics && params.filter.topics.length > 0) {\n                                if (params.filter.topics.length > 1) {\n                                    logger.throwError(\"unsupported topic count\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                                }\n                                if (params.filter.topics.length === 1) {\n                                    const topic0 = params.filter.topics[0];\n                                    if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                                        logger.throwError(\"unsupported topic format\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                                    }\n                                    args.topic0 = topic0;\n                                }\n                            }\n            \n                            const logs: Array<any> = await this.fetch(\"logs\", args);\n            \n                            // Cache txHash => blockHash\n                            let blocks: { [tag: string]: string } = {};\n            \n                            // Add any missing blockHash to the logs\n                            for (let i = 0; i < logs.length; i++) {\n                                const log = logs[i];\n                                if (log.blockHash != null) { continue; }\n                                if (blocks[log.blockNumber] == null) {\n                                    const block = await this.getBlock(log.blockNumber);\n                                    if (block) {\n                                        blocks[log.blockNumber] = block.hash;\n                                    }\n                                }\n            \n                                log.blockHash = blocks[log.blockNumber];\n                            }\n            \n                            return logs;\n                        }\n            */\n            default:\n                break;\n        }\n        return super._perform(req);\n    }\n    async getNetwork() {\n        return this.network;\n    }\n    /**\n     *  Resolves to the current price of ether.\n     *\n     *  This returns ``0`` on any network other than ``mainnet``.\n     */\n    async getEtherPrice() {\n        if (this.network.name !== \"mainnet\") {\n            return 0.0;\n        }\n        return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n    }\n    /**\n     *  Resolves to a [Contract]] for %%address%%, using the\n     *  Etherscan API to retreive the Contract ABI.\n     */\n    async getContract(_address) {\n        let address = this._getAddress(_address);\n        if (isPromise(address)) {\n            address = await address;\n        }\n        try {\n            const resp = await this.fetch(\"contract\", {\n                action: \"getabi\", address\n            });\n            const abi = JSON.parse(resp);\n            return new index_js_2.Contract(address, abi, this);\n        }\n        catch (error) {\n            return null;\n        }\n    }\n    isCommunityResource() {\n        return (this.apiKey == null);\n    }\n}\nexports.EtherscanProvider = EtherscanProvider;\n//# sourceMappingURL=provider-etherscan.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItZXRoZXJzY2FuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsdUJBQXVCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsOEZBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QywrQkFBK0IsbUJBQU8sQ0FBQyx1R0FBd0I7QUFDL0QscUJBQXFCLG1CQUFPLENBQUMsbUZBQWM7QUFDM0MsNkJBQTZCLG1CQUFPLENBQUMsbUdBQXNCO0FBQzNELHVCQUF1QixtQkFBTyxDQUFDLHVGQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUksR0FBRyxNQUFNO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbURBQW1ELFlBQVk7QUFDL0Qsa0JBQWtCLGtCQUFrQixjQUFjLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQWtEO0FBQy9FO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0VBQWtFO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUVBQXlFO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRiw4REFBOEQsRUFBRSxHQUFHLFdBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVEQUF1RDtBQUN4Riw4RUFBOEUsbUJBQW1CO0FBQ2pHO0FBQ0E7QUFDQSxpQ0FBaUMsd0VBQXdFO0FBQ3pHLGdGQUFnRixtQkFBbUI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0VBQWdFO0FBQ3JHLHFIQUFxSCwyQkFBMkIsVUFBVTtBQUMxSjtBQUNBO0FBQ0EscUNBQXFDLDhEQUE4RDtBQUNuRyxrRkFBa0YsMkJBQTJCLFVBQVU7QUFDdkg7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQ0FBb0M7QUFDekUsa0ZBQWtGLDJCQUEyQixVQUFVO0FBQ3ZIO0FBQ0EsaUNBQWlDLHNDQUFzQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFIQUFxSDtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXLFlBQVksa0JBQWtCLDRCQUE0QixHQUFHO0FBQ3JHLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQkFBMkI7QUFDeEU7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxnRUFBZ0UscUJBQXFCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdDQUF3QztBQUMvRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0gsOEJBQThCO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILGdCQUFnQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsb0JBQW9CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItZXRoZXJzY2FuLmpzPzRlN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBbW2xpbmstZXRoZXJzY2FuXV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXG4gKiAgdmFyaW91cyBibG9ja2NoYWlucyBvdmVyIGEgY29tYmluYXRpb24gb2YgSlNPTi1SUEMgYW5kIGN1c3RvbSBBUElcbiAqICBlbmRwb2ludHMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcbiAqICAtIFNlcG9saWEgVGVzdG5ldCAoYGBob2xlc2t5YGApXG4gKiAgLSBBcmJpdHJ1bSAoYGBhcmJpdHJ1bWBgKVxuICogIC0gQXJiaXRydW0gR29lcmxpIFRlc3RuZXQgKGBgYXJiaXRydW0tZ29lcmxpYGApXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gTWFpbm5ldCAoYGBibmJgYClcbiAqICAtIEJOQiBTbWFydCBDaGFpbiBUZXN0bmV0IChgYGJuYnRgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIFBvbHlnb24gTXVtYmFpIFRlc3RuZXQgKGBgbWF0aWMtbXVtYmFpYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6RXRoZXJzY2FuICBbcHJvdmlkZXJzLWV0aGVyc2Nhbl1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IGV4cG9ydHMuRXRoZXJzY2FuUGx1Z2luID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hYmkvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBhYnN0cmFjdF9wcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcGx1Z2luc19uZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIik7XG5jb25zdCBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbmNvbnN0IFRIUk9UVExFID0gMjAwMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmNvbnN0IEV0aGVyc2NhblBsdWdpbklkID0gXCJvcmcuZXRoZXJzLnBsdWdpbnMucHJvdmlkZXIuRXRoZXJzY2FuXCI7XG4vKipcbiAqICBBIE5ldHdvcmsgY2FuIGluY2x1ZGUgYW4gKipFdGhlcnNjYW5QbHVnaW4qKiB0byBwcm92aWRlXG4gKiAgYSBjdXN0b20gYmFzZSBVUkwuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6RXRoZXJzY2FuXG4gKi9cbmNsYXNzIEV0aGVyc2NhblBsdWdpbiBleHRlbmRzIHBsdWdpbnNfbmV0d29ya19qc18xLk5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgRXRoZXJzY2FuIEFQSSBiYXNlIFVSTC5cbiAgICAgKi9cbiAgICBiYXNlVXJsO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRXRoZXJzY2FuUHJvdmlkZXIqKiB3aGljaCB3aWxsIHVzZVxuICAgICAqICAlJWJhc2VVcmwlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihiYXNlVXJsKSB7XG4gICAgICAgIHN1cGVyKEV0aGVyc2NhblBsdWdpbklkKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBiYXNlVXJsIH0pO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFdGhlcnNjYW5QbHVnaW4odGhpcy5iYXNlVXJsKTtcbiAgICB9XG59XG5leHBvcnRzLkV0aGVyc2NhblBsdWdpbiA9IEV0aGVyc2NhblBsdWdpbjtcbmNvbnN0IHNraXBLZXlzID0gW1wiZW5hYmxlQ2NpcFJlYWRcIl07XG5sZXQgbmV4dElkID0gMTtcbi8qKlxuICogIFRoZSAqKkV0aGVyc2NhbkJhc2VQcm92aWRlcioqIGlzIHRoZSBzdXBlci1jbGFzcyBvZlxuICogIFtbRXRoZXJzY2FuUHJvdmlkZXJdXSwgd2hpY2ggc2hvdWxkIGdlbmVyYWxseSBiZSB1c2VkIGluc3RlYWQuXG4gKlxuICogIFNpbmNlIHRoZSAqKkV0aGVyc2NhblByb3ZpZGVyKiogaW5jbHVkZXMgYWRkaXRpb25hbCBjb2RlIGZvclxuICogIFtbQ29udHJhY3RdXSBhY2Nlc3MsIGluIC8vcmFyZSBjYXNlcy8vIHRoYXQgY29udHJhY3RzIGFyZSBub3RcbiAqICB1c2VkLCB0aGlzIGNsYXNzIGNhbiByZWR1Y2UgY29kZSBzaXplLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkV0aGVyc2NhblxuICovXG5jbGFzcyBFdGhlcnNjYW5Qcm92aWRlciBleHRlbmRzIGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuQWJzdHJhY3RQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgbmV0d29yay5cbiAgICAgKi9cbiAgICBuZXR3b3JrO1xuICAgIC8qKlxuICAgICAqICBUaGUgQVBJIGtleSBvciBudWxsIGlmIHVzaW5nIHRoZSBjb21tdW5pdHkgcHJvdmlkZWQgYmFuZHdpZHRoLlxuICAgICAqL1xuICAgIGFwaUtleTtcbiAgICAjcGx1Z2luO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRXRoZXJzY2FuQmFzZVByb3ZpZGVyKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIF9hcGlLZXkpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gKF9hcGlLZXkgIT0gbnVsbCkgPyBfYXBpS2V5IDogbnVsbDtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICB0aGlzLiNwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihFdGhlcnNjYW5QbHVnaW5JZCk7XG4gICAgICAgICgwLCBpbmRleF9qc180LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYXBpS2V5LCBuZXR3b3JrIH0pO1xuICAgICAgICAvLyBUZXN0IHRoYXQgdGhlIG5ldHdvcmsgaXMgc3VwcG9ydGVkIGJ5IEV0aGVyc2NhblxuICAgICAgICB0aGlzLmdldEJhc2VVcmwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGJhc2UgVVJMLlxuICAgICAqXG4gICAgICogIElmIGFuIFtbRXRoZXJzY2FuUGx1Z2luXV0gaXMgY29uZmlndXJlZCBvbiB0aGVcbiAgICAgKiAgW1tFdGhlcnNjYW5CYXNlUHJvdmlkZXJfbmV0d29ya11dLCByZXR1cm5zIHRoZSBwbHVnaW4nc1xuICAgICAqICBiYXNlVXJsLlxuICAgICAqL1xuICAgIGdldEJhc2VVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwbHVnaW4uYmFzZVVybDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMubmV0d29yay5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1nb2VybGkuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktc2Vwb2xpYS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJob2xlc2t5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1ob2xlc2t5LmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5hcmJpc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktZ29lcmxpLmFyYmlzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwiYm5iXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5ic2NzY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcImJuYnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLXRlc3RuZXQuYnNjc2Nhbi5jb21cIjtcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkucG9seWdvbnNjYW4uY29tXCI7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWMtbXVtYmFpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS10ZXN0bmV0LnBvbHlnb25zY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1vcHRpbWlzdGljLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktZ29lcmxpLW9wdGltaXN0aWMuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCB0aGlzLm5ldHdvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgVVJMIGZvciB0aGUgJSVtb2R1bGUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBnZXRVcmwobW9kdWxlLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBPYmplY3Qua2V5cyhwYXJhbXMpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gYCYke2tleX09JHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gKCh0aGlzLmFwaUtleSkgPyBgJmFwaWtleT0ke3RoaXMuYXBpS2V5fWAgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0QmFzZVVybCgpfS9hcGk/bW9kdWxlPSR7bW9kdWxlfSR7cXVlcnl9JHthcGlLZXl9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFVSTCBmb3IgdXNpbmcgUE9TVCByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBnZXRQb3N0VXJsKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRCYXNlVXJsKCl9L2FwaWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIGZvciB1c2luZyBQT1NUIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHBhcmFtcy5hcGlrZXkgPSB0aGlzLmFwaUtleTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgYXN5bmMgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyAlJW1vZHVsZSUlIHdpdGggJSVwYXJhbXMlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXBvc3QlJSwgdGhlIHJlcXVlc3QgaXMgbWFkZSBhcyBhIFBPU1QgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaChtb2R1bGUsIHBhcmFtcywgcG9zdCkge1xuICAgICAgICBjb25zdCBpZCA9IG5leHRJZCsrO1xuICAgICAgICBjb25zdCB1cmwgPSAocG9zdCA/IHRoaXMuZ2V0UG9zdFVybCgpIDogdGhpcy5nZXRVcmwobW9kdWxlLCBwYXJhbXMpKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChwb3N0ID8gdGhpcy5nZXRQb3N0RGF0YShtb2R1bGUsIHBhcmFtcykgOiBudWxsKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJlcXVlc3RcIiwgaWQsIHVybCwgcGF5bG9hZDogcGF5bG9hZCB9KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc180LkZldGNoUmVxdWVzdCh1cmwpO1xuICAgICAgICByZXF1ZXN0LnNldFRocm90dGxlUGFyYW1zKHsgc2xvdEludGVydmFsOiAxMDAwIH0pO1xuICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IChyZXEsIHJlc3AsIGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tbXVuaXR5UmVzb3VyY2UoKSkge1xuICAgICAgICAgICAgICAgICgwLCBjb21tdW5pdHlfanNfMS5zaG93VGhyb3R0bGVNZXNzYWdlKShcIkV0aGVyc2NhblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3QucHJvY2Vzc0Z1bmMgPSBhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLmhhc0JvZHkoKSA/IEpTT04ucGFyc2UoKDAsIGluZGV4X2pzXzQudG9VdGY4U3RyaW5nKShyZXNwb25zZS5ib2R5KSkgOiB7fTtcbiAgICAgICAgICAgIGNvbnN0IHRocm90dGxlID0gKCh0eXBlb2YgKHJlc3VsdC5yZXN1bHQpID09PSBcInN0cmluZ1wiKSA/IHJlc3VsdC5yZXN1bHQgOiBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpID49IDA7XG4gICAgICAgICAgICBpZiAobW9kdWxlID09PSBcInByb3h5XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIEpTT04gcmVzcG9uc2UgaW5kaWNhdGVzIHdlIGFyZSBiZWluZyB0aHJvdHRsZWRcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdGF0dXMgPT0gMCAmJiByZXN1bHQubWVzc2FnZSA9PSBcIk5PVE9LXCIgJiYgdGhyb3R0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCByZWFzb246IFwicHJveHktTk9UT0tcIiwgZXJyb3I6IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UudGhyb3dUaHJvdHRsZUVycm9yKHJlc3VsdC5yZXN1bHQsIFRIUk9UVExFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3R0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCByZWFzb246IFwibnVsbCByZXN1bHRcIiwgZXJyb3I6IHJlc3VsdC5yZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcihyZXN1bHQucmVzdWx0LCBUSFJPVFRMRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIik7XG4gICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSBPYmplY3Qua2V5cyhwYXlsb2FkKS5tYXAoKGspID0+IGAke2t9PSR7cGF5bG9hZFtrXX1gKS5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgZXJyb3IsIHJlYXNvbjogXCJhc3NlcnRPa1wiIH0pO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJyZXNwb25zZSBlcnJvclwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UuaGFzQm9keSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRXJyb3JcIiwgaWQsIGVycm9yOiBcIm1pc3NpbmcgYm9keVwiLCByZWFzb246IFwibnVsbCBib2R5XCIgfSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcIm1pc3NpbmcgcmVzcG9uc2VcIiwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKCgwLCBpbmRleF9qc180LnRvVXRmOFN0cmluZykocmVzcG9uc2UuYm9keSkpO1xuICAgICAgICBpZiAobW9kdWxlID09PSBcInByb3h5XCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuanNvbnJwYyAhPSBcIjIuMFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCByZXN1bHQsIHJlYXNvbjogXCJpbnZhbGlkIEpTT04tUlBDXCIgfSk7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJpbnZhbGlkIEpTT04tUlBDIHJlc3BvbnNlIChtaXNzaW5nIGpzb25ycGM9JzIuMCcpXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGluZm86IHsgcmVzdWx0IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCByZXN1bHQsIHJlYXNvbjogXCJKU09OLVJQQyBlcnJvclwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwiZXJyb3IgcmVzcG9uc2VcIiwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSwgaW5mbzogeyByZXN1bHQgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVSZXF1ZXN0XCIsIGlkLCByZXN1bHQgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldExvZ3MsIGdldEhpc3RvcnkgaGF2ZSB3ZWlyZCBzdWNjZXNzIHJlc3BvbnNlc1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT0gMCAmJiAocmVzdWx0Lm1lc3NhZ2UgPT09IFwiTm8gcmVjb3JkcyBmb3VuZFwiIHx8IHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHRyYW5zYWN0aW9ucyBmb3VuZFwiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVSZXF1ZXN0XCIsIGlkLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSAxIHx8ICh0eXBlb2YgKHJlc3VsdC5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiAhcmVzdWx0Lm1lc3NhZ2UubWF0Y2goL15PSy8pKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwiZXJyb3IgcmVzcG9uc2VcIiwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSwgaW5mbzogeyByZXN1bHQgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVSZXF1ZXN0XCIsIGlkLCByZXN1bHQgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyAlJXRyYW5zYWN0aW9uJSUgbm9ybWFsaXplZCBmb3IgdGhlIEV0aGVyc2NhbiBBUEkuXG4gICAgICovXG4gICAgX2dldFRyYW5zYWN0aW9uUG9zdERhdGEodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgaWYgKHNraXBLZXlzLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0cmFuc2FjdGlvbltrZXldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYmxvY2tUYWdcIiAmJiB2YWx1ZSA9PT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUXVhbnRpdHktdHlwZXMgcmVxdWlyZSBubyBsZWFkaW5nIHplcm8sIHVubGVzcyAwXG4gICAgICAgICAgICBpZiAoeyB0eXBlOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG1heEZlZVBlckdzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZSwgbm9uY2U6IHRydWUsIHZhbHVlOiB0cnVlIH1ba2V5XSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzQudG9RdWFudGl0eSkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImFjY2Vzc0xpc3RcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCJbXCIgKyAoMCwgaW5kZXhfanNfMy5hY2Nlc3NMaXN0aWZ5KSh2YWx1ZSkubWFwKChzZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB7YWRkcmVzczpcIiR7c2V0LmFkZHJlc3N9XCIsc3RvcmFnZUtleXM6W1wiJHtzZXQuc3RvcmFnZUtleXMuam9pbignXCIsXCInKX1cIl19YDtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgdGhlIG5vcm1hbGl6ZWQgRXRoZXJzY2FuIGVycm9yLlxuICAgICAqL1xuICAgIF9jaGVja0Vycm9yKHJlcSwgZXJyb3IsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIFB1bGwgYW55IG1lc3NhZ2Ugb3V0IGlmLCBwb3NzaWJsZVxuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIGlmICgoMCwgaW5kZXhfanNfNC5pc0Vycm9yKShlcnJvciwgXCJTRVJWRVJfRVJST1JcIikpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbiBlcnJvciBlbWl0dGVkIGJ5IGEgcHJveHkgY2FsbFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuaW5mby5yZXN1bHQuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5pbmZvLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UubWF0Y2goL3JldmVydC9pKSAmJiBtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvaSkpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcImluc3VmZmljaWVudCBmdW5kc1wiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiByZXEudHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgcmVxLm1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvZXhlY3V0aW9uIHJldmVydGVkL2kpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBlcnJvci5pbmZvLnJlc3VsdC5lcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBpbmRleF9qc18xLkFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKHJlcS5tZXRob2QsIHJlcS50cmFuc2FjdGlvbiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgZS5pbmZvID0geyByZXF1ZXN0OiByZXEsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gaW5kZXhfanNfMy5UcmFuc2FjdGlvbi5mcm9tKHJlcS5zaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50L2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy8pKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3NhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZHx0cmFuc2FjdGlvbiBub25jZSBpcyB0b28gbG93fG5vbmNlIHRvbyBsb3cvKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBcIk5PTkNFX0VYUElSRURcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZSBjb3VsZCBub3QgcHJvY2Vzc1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgYXN5bmMgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcms7XG4gICAgfVxuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGFpbklkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV0d29yay5jaGFpbklkO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfYmxvY2tOdW1iZXJcIiB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwgeyBhY3Rpb246IFwiZXRoX2dhc1ByaWNlXCIgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0UHJpb3JpdHlGZWVcIjpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyeSB1bnRpbCBFdGhlcnNjYW4gY29tcGxldGVzIHN1cHBvcnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrLm5hbWUgPT09IFwibWFpbm5ldFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjEwMDAwMDAwMDBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXR3b3JrLm5hbWUgPT09IFwib3B0aW1pc21cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIxMDAwMDAwXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWxsYmFjayBvbnRvIHRoZSBBYnN0cmFjdFByb3ZpZGVyIGRlZmF1bHRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogV29ya2luZyB3aXRoIEV0aGVyc2NhbiB0byBnZXQgdGhpcyBhZGRlZDpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdCA9IGF3YWl0IHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfbWF4UHJpb3JpdHlGZWVQZXJHYXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUdcIiwgZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKiBUaGlzIG1pZ2h0IGJlIHNhZmU7IGJ1dCBkdWUgdG8gcm91bmRpbmcgbmVpdGhlciBteXNlbGZcbiAgICAgICAgICAgICAgIG9yIEV0aGVyc2NhbiBhcmUgbmVjZXNzYXJpbHkgY29tZm9ydGFibGUgd2l0aCB0aGlzLiA6KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKFwiZ2FzdHJhY2tlclwiLCB7IGFjdGlvbjogXCJnYXNvcmFjbGVcIiB9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gcGFyc2VVbml0cyhyZXN1bHQuU2FmZUdhc1ByaWNlLCBcImd3ZWlcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUZlZSA9IHBhcnNlVW5pdHMocmVzdWx0LnN1Z2dlc3RCYXNlRmVlLCBcImd3ZWlcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlGZWUgPSBnYXNQcmljZSAtIGJhc2VGZWU7XG4gICAgICAgICAgICAgICAgaWYgKHByaW9yaXR5RmVlIDwgMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSBwcmlvcml0eSBmZWU7IGRlZmVyIHRvIGFic3RyYWN0IHByb3ZpZGVyIGRlZmF1bHRcIik7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpb3JpdHlGZWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUdcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyBiYXNlLTEwIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiYWNjb3VudFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJiYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlcS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlcS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlcS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVxLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZXEucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRhZzogcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgaGV4OiByZXEuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB9LCB0cnVlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrRXJyb3IocmVxLCBlcnJvciwgcmVxLnNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IChyZXEuaW5jbHVkZVRyYW5zYWN0aW9ucyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJnZXRCbG9jayBieSBibG9ja0hhc2ggbm90IHN1cHBvcnRlZCBieSBFdGhlcnNjYW5cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QmxvY2soYmxvY2tIYXNoKVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICB0eGhhc2g6IHJlcS5oYXNoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcmVxLmhhc2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLmJsb2NrVGFnICE9PSBcImxhdGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyc2NhblByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYmxvY2tUYWcgZm9yIGNhbGxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3REYXRhID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShyZXEudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcbiAgICAgICAgICAgICAgICBwb3N0RGF0YS5hY3Rpb24gPSBcImV0aF9jYWxsXCI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2goXCJwcm94eVwiLCBwb3N0RGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tFcnJvcihyZXEsIGVycm9yLCByZXEudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdERhdGEgPSB0aGlzLl9nZXRUcmFuc2FjdGlvblBvc3REYXRhKHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zdERhdGEubW9kdWxlID0gXCJwcm94eVwiO1xuICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2VzdGltYXRlR2FzXCI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2goXCJwcm94eVwiLCBwb3N0RGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tFcnJvcihyZXEsIGVycm9yLCByZXEudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZHMgdG8gY29tcGxhaW4gaWYgbW9yZSB0aGFuIG9uZSBhZGRyZXNzIGlzIHBhc3NlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3M6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7IGFjdGlvbjogXCJnZXRMb2dzXCIgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuZnJvbUJsb2NrID0gY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy50b0Jsb2NrID0gY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci50b0Jsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuYWRkcmVzcyA9IHBhcmFtcy5maWx0ZXIuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2UgY2FuIGhhbmRsZSBzbGlnaHRseSBtb3JlIGNvbXBsaWNhdGVkIGxvZ3MgdXNpbmcgdGhlIGxvZ3MgQVBJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzICYmIHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgY291bnRcIiwgTG9nZ2VyLkVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgdG9waWNzOiBwYXJhbXMuZmlsdGVyLnRvcGljcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3BpYzAgPSBwYXJhbXMuZmlsdGVyLnRvcGljc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YodG9waWMwKSAhPT0gXCJzdHJpbmdcIiB8fCB0b3BpYzAubGVuZ3RoICE9PSA2Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgZm9ybWF0XCIsIExvZ2dlci5FcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljMDogdG9waWMwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy50b3BpYzAgPSB0b3BpYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzOiBBcnJheTxhbnk+ID0gYXdhaXQgdGhpcy5mZXRjaChcImxvZ3NcIiwgYXJncyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0eEhhc2ggPT4gYmxvY2tIYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrczogeyBbdGFnOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFueSBtaXNzaW5nIGJsb2NrSGFzaCB0byB0aGUgbG9nc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2cgPSBsb2dzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nLmJsb2NrSGFzaCAhPSBudWxsKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0QmxvY2sobG9nLmJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdID0gYmxvY2suaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5ibG9ja0hhc2ggPSBibG9ja3NbbG9nLmJsb2NrTnVtYmVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9ncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fcGVyZm9ybShyZXEpO1xuICAgIH1cbiAgICBhc3luYyBnZXROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGN1cnJlbnQgcHJpY2Ugb2YgZXRoZXIuXG4gICAgICpcbiAgICAgKiAgVGhpcyByZXR1cm5zIGBgMGBgIG9uIGFueSBuZXR3b3JrIG90aGVyIHRoYW4gYGBtYWlubmV0YGAuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RXRoZXJQcmljZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV0d29yay5uYW1lICE9PSBcIm1haW5uZXRcIikge1xuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgoYXdhaXQgdGhpcy5mZXRjaChcInN0YXRzXCIsIHsgYWN0aW9uOiBcImV0aHByaWNlXCIgfSkpLmV0aHVzZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBhIFtDb250cmFjdF1dIGZvciAlJWFkZHJlc3MlJSwgdXNpbmcgdGhlXG4gICAgICogIEV0aGVyc2NhbiBBUEkgdG8gcmV0cmVpdmUgdGhlIENvbnRyYWN0IEFCSS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb250cmFjdChfYWRkcmVzcykge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gYXdhaXQgYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZmV0Y2goXCJjb250cmFjdFwiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImdldGFiaVwiLCBhZGRyZXNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFiaSA9IEpTT04ucGFyc2UocmVzcCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuQ29udHJhY3QoYWRkcmVzcywgYWJpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT0gbnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IEV0aGVyc2NhblByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItZXRoZXJzY2FuLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-fallback.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-fallback.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FallbackProvider = void 0;\n/**\n *  A **FallbackProvider** provides resilience, security and performance\n *  in a way that is customizable and configurable.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\nfunction getTime() { return (new Date()).getTime(); }\nfunction stringify(value) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof (value) === \"bigint\") {\n            return { type: \"bigint\", value: value.toString() };\n        }\n        return value;\n    });\n}\n;\nconst defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };\nconst defaultState = {\n    blockNumber: -2, requests: 0, lateResponses: 0, errorResponses: 0,\n    outOfSync: -1, unsupportedEvents: 0, rollingDuration: 0, score: 0,\n    _network: null, _updateNumber: null, _totalTime: 0,\n    _lastFatalError: null, _lastFatalErrorTimestamp: 0\n};\nasync function waitForSync(config, blockNumber) {\n    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n        if (!config._updateNumber) {\n            config._updateNumber = (async () => {\n                try {\n                    const blockNumber = await config.provider.getBlockNumber();\n                    if (blockNumber > config.blockNumber) {\n                        config.blockNumber = blockNumber;\n                    }\n                }\n                catch (error) {\n                    config.blockNumber = -2;\n                    config._lastFatalError = error;\n                    config._lastFatalErrorTimestamp = getTime();\n                }\n                config._updateNumber = null;\n            })();\n        }\n        await config._updateNumber;\n        config.outOfSync++;\n        if (config._lastFatalError) {\n            break;\n        }\n    }\n}\nfunction _normalize(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[\" + (value.map(_normalize)).join(\",\") + \"]\";\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return _normalize(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n        case \"number\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{\" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\") + \"}\";\n        }\n    }\n    console.log(\"Could not serialize\", value);\n    throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(value) {\n    if (\"error\" in value) {\n        const error = value.error;\n        return { tag: _normalize(error), value: error };\n    }\n    const result = value.result;\n    return { tag: _normalize(result), value: result };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n    const tally = new Map();\n    for (const { value, tag, weight } of results) {\n        const t = tally.get(tag) || { value, weight: 0 };\n        t.weight += weight;\n        tally.set(tag, t);\n    }\n    let best = null;\n    for (const r of tally.values()) {\n        if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n            best = r;\n        }\n    }\n    if (best) {\n        return best.value;\n    }\n    return undefined;\n}\nfunction getMedian(quorum, results) {\n    let resultWeight = 0;\n    const errorMap = new Map();\n    let bestError = null;\n    const values = [];\n    for (const { value, tag, weight } of results) {\n        if (value instanceof Error) {\n            const e = errorMap.get(tag) || { value, weight: 0 };\n            e.weight += weight;\n            errorMap.set(tag, e);\n            if (bestError == null || e.weight > bestError.weight) {\n                bestError = e;\n            }\n        }\n        else {\n            values.push(BigInt(value));\n            resultWeight += weight;\n        }\n    }\n    if (resultWeight < quorum) {\n        // We have quorum for an error\n        if (bestError && bestError.weight >= quorum) {\n            return bestError.value;\n        }\n        // We do not have quorum for a result\n        return undefined;\n    }\n    // Get the sorted values\n    values.sort((a, b) => ((a < b) ? -1 : (b > a) ? 1 : 0));\n    const mid = Math.floor(values.length / 2);\n    // Odd-length; take the middle value\n    if (values.length % 2) {\n        return values[mid];\n    }\n    // Even length; take the ceiling of the mean of the center two values\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n    // If any value or error meets quorum, that is our preferred result\n    const result = checkQuorum(quorum, results);\n    if (result !== undefined) {\n        return result;\n    }\n    // Otherwise, do we have any result?\n    for (const r of results) {\n        if (r.value) {\n            return r.value;\n        }\n    }\n    // Nope!\n    return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n    if (quorum === 1) {\n        return (0, index_js_1.getNumber)(getMedian(quorum, results), \"%internal\");\n    }\n    const tally = new Map();\n    const add = (result, weight) => {\n        const t = tally.get(result) || { result, weight: 0 };\n        t.weight += weight;\n        tally.set(result, t);\n    };\n    for (const { weight, value } of results) {\n        const r = (0, index_js_1.getNumber)(value);\n        add(r - 1, weight);\n        add(r, weight);\n        add(r + 1, weight);\n    }\n    let bestWeight = 0;\n    let bestResult = undefined;\n    for (const { weight, result } of tally.values()) {\n        // Use this result, if this result meets quorum and has either:\n        // - a better weight\n        // - or equal weight, but the result is larger\n        if (weight >= quorum && (weight > bestWeight || (bestResult != null && weight === bestWeight && result > bestResult))) {\n            bestWeight = weight;\n            bestResult = result;\n        }\n    }\n    return bestResult;\n}\n/**\n *  A **FallbackProvider** manages several [[Providers]] providing\n *  resilience by switching between slow or misbehaving nodes, security\n *  by requiring multiple backends to aggree and performance by allowing\n *  faster backends to respond earlier.\n *\n */\nclass FallbackProvider extends abstract_provider_js_1.AbstractProvider {\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    quorum;\n    /**\n     *  @_ignore:\n     */\n    eventQuorum;\n    /**\n     *  @_ignore:\n     */\n    eventWorkers;\n    #configs;\n    #height;\n    #initialSyncPromise;\n    /**\n     *  Creates a new **FallbackProvider** with %%providers%% connected to\n     *  %%network%%.\n     *\n     *  If a [[Provider]] is included in %%providers%%, defaults are used\n     *  for the configuration.\n     */\n    constructor(providers, network, options) {\n        super(network, options);\n        this.#configs = providers.map((p) => {\n            if (p instanceof abstract_provider_js_1.AbstractProvider) {\n                return Object.assign({ provider: p }, defaultConfig, defaultState);\n            }\n            else {\n                return Object.assign({}, defaultConfig, p, defaultState);\n            }\n        });\n        this.#height = -2;\n        this.#initialSyncPromise = null;\n        if (options && options.quorum != null) {\n            this.quorum = options.quorum;\n        }\n        else {\n            this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {\n                accum += config.weight;\n                return accum;\n            }, 0) / 2);\n        }\n        this.eventQuorum = 1;\n        this.eventWorkers = 1;\n        (0, index_js_1.assertArgument)(this.quorum <= this.#configs.reduce((a, c) => (a + c.weight), 0), \"quorum exceed provider wieght\", \"quorum\", this.quorum);\n    }\n    get providerConfigs() {\n        return this.#configs.map((c) => {\n            const result = Object.assign({}, c);\n            for (const key in result) {\n                if (key[0] === \"_\") {\n                    delete result[key];\n                }\n            }\n            return result;\n        });\n    }\n    async _detectNetwork() {\n        return network_js_1.Network.from((0, index_js_1.getBigInt)(await this._perform({ method: \"chainId\" })));\n    }\n    // @TODO: Add support to select providers to be the event subscriber\n    //_getSubscriber(sub: Subscription): Subscriber {\n    //    throw new Error(\"@TODO\");\n    //}\n    /**\n     *  Transforms a %%req%% into the correct method call on %%provider%%.\n     */\n    async _translatePerform(provider, req) {\n        switch (req.method) {\n            case \"broadcastTransaction\":\n                return await provider.broadcastTransaction(req.signedTransaction);\n            case \"call\":\n                return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));\n            case \"chainId\":\n                return (await provider.getNetwork()).chainId;\n            case \"estimateGas\":\n                return await provider.estimateGas(req.transaction);\n            case \"getBalance\":\n                return await provider.getBalance(req.address, req.blockTag);\n            case \"getBlock\": {\n                const block = (\"blockHash\" in req) ? req.blockHash : req.blockTag;\n                return await provider.getBlock(block, req.includeTransactions);\n            }\n            case \"getBlockNumber\":\n                return await provider.getBlockNumber();\n            case \"getCode\":\n                return await provider.getCode(req.address, req.blockTag);\n            case \"getGasPrice\":\n                return (await provider.getFeeData()).gasPrice;\n            case \"getPriorityFee\":\n                return (await provider.getFeeData()).maxPriorityFeePerGas;\n            case \"getLogs\":\n                return await provider.getLogs(req.filter);\n            case \"getStorage\":\n                return await provider.getStorage(req.address, req.position, req.blockTag);\n            case \"getTransaction\":\n                return await provider.getTransaction(req.hash);\n            case \"getTransactionCount\":\n                return await provider.getTransactionCount(req.address, req.blockTag);\n            case \"getTransactionReceipt\":\n                return await provider.getTransactionReceipt(req.hash);\n            case \"getTransactionResult\":\n                return await provider.getTransactionResult(req.hash);\n        }\n    }\n    // Grab the next (random) config that is not already part of\n    // the running set\n    #getNextConfig(running) {\n        // @TODO: Maybe do a check here to favour (heavily) providers that\n        //        do not require waitForSync and disfavour providers that\n        //        seem down-ish or are behaving slowly\n        const configs = Array.from(running).map((r) => r.config);\n        // Shuffle the states, sorted by priority\n        const allConfigs = this.#configs.slice();\n        shuffle(allConfigs);\n        allConfigs.sort((a, b) => (a.priority - b.priority));\n        for (const config of allConfigs) {\n            if (config._lastFatalError) {\n                continue;\n            }\n            if (configs.indexOf(config) === -1) {\n                return config;\n            }\n        }\n        return null;\n    }\n    // Adds a new runner (if available) to running.\n    #addRunner(running, req) {\n        const config = this.#getNextConfig(running);\n        // No runners available\n        if (config == null) {\n            return null;\n        }\n        // Create a new runner\n        const runner = {\n            config, result: null, didBump: false,\n            perform: null, staller: null\n        };\n        const now = getTime();\n        // Start performing this operation\n        runner.perform = (async () => {\n            try {\n                config.requests++;\n                const result = await this._translatePerform(config.provider, req);\n                runner.result = { result };\n            }\n            catch (error) {\n                config.errorResponses++;\n                runner.result = { error };\n            }\n            const dt = (getTime() - now);\n            config._totalTime += dt;\n            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n            runner.perform = null;\n        })();\n        // Start a staller; when this times out, it's time to force\n        // kicking off another runner because we are taking too long\n        runner.staller = (async () => {\n            await stall(config.stallTimeout);\n            runner.staller = null;\n        })();\n        running.add(runner);\n        return runner;\n    }\n    // Initializes the blockNumber and network for each runner and\n    // blocks until initialized\n    async #initialSync() {\n        let initialSync = this.#initialSyncPromise;\n        if (!initialSync) {\n            const promises = [];\n            this.#configs.forEach((config) => {\n                promises.push((async () => {\n                    await waitForSync(config, 0);\n                    if (!config._lastFatalError) {\n                        config._network = await config.provider.getNetwork();\n                    }\n                })());\n            });\n            this.#initialSyncPromise = initialSync = (async () => {\n                // Wait for all providers to have a block number and network\n                await Promise.all(promises);\n                // Check all the networks match\n                let chainId = null;\n                for (const config of this.#configs) {\n                    if (config._lastFatalError) {\n                        continue;\n                    }\n                    const network = (config._network);\n                    if (chainId == null) {\n                        chainId = network.chainId;\n                    }\n                    else if (network.chainId !== chainId) {\n                        (0, index_js_1.assert)(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n                            operation: \"new FallbackProvider\"\n                        });\n                    }\n                }\n            })();\n        }\n        await initialSync;\n    }\n    async #checkQuorum(running, req) {\n        // Get all the result objects\n        const results = [];\n        for (const runner of running) {\n            if (runner.result != null) {\n                const { tag, value } = normalizeResult(runner.result);\n                results.push({ tag, value, weight: runner.config.weight });\n            }\n        }\n        // Are there enough results to event meet quorum?\n        if (results.reduce((a, r) => (a + r.weight), 0) < this.quorum) {\n            return undefined;\n        }\n        switch (req.method) {\n            case \"getBlockNumber\": {\n                // We need to get the bootstrap block height\n                if (this.#height === -2) {\n                    this.#height = Math.ceil((0, index_js_1.getNumber)(getMedian(this.quorum, this.#configs.filter((c) => (!c._lastFatalError)).map((c) => ({\n                        value: c.blockNumber,\n                        tag: (0, index_js_1.getNumber)(c.blockNumber).toString(),\n                        weight: c.weight\n                    })))));\n                }\n                // Find the mode across all the providers, allowing for\n                // a little drift between block heights\n                const mode = getFuzzyMode(this.quorum, results);\n                if (mode === undefined) {\n                    return undefined;\n                }\n                if (mode > this.#height) {\n                    this.#height = mode;\n                }\n                return this.#height;\n            }\n            case \"getGasPrice\":\n            case \"getPriorityFee\":\n            case \"estimateGas\":\n                return getMedian(this.quorum, results);\n            case \"getBlock\":\n                // Pending blocks are in the mempool and already\n                // quite untrustworthy; just grab anything\n                if (\"blockTag\" in req && req.blockTag === \"pending\") {\n                    return getAnyResult(this.quorum, results);\n                }\n                return checkQuorum(this.quorum, results);\n            case \"call\":\n            case \"chainId\":\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n            case \"getStorage\":\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n            case \"getLogs\":\n                return checkQuorum(this.quorum, results);\n            case \"broadcastTransaction\":\n                return getAnyResult(this.quorum, results);\n        }\n        (0, index_js_1.assert)(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n            operation: `_perform(${stringify(req.method)})`\n        });\n    }\n    async #waitForQuorum(running, req) {\n        if (running.size === 0) {\n            throw new Error(\"no runners?!\");\n        }\n        // Any promises that are interesting to watch for; an expired stall\n        // or a successful perform\n        const interesting = [];\n        let newRunners = 0;\n        for (const runner of running) {\n            // No responses, yet; keep an eye on it\n            if (runner.perform) {\n                interesting.push(runner.perform);\n            }\n            // Still stalling...\n            if (runner.staller) {\n                interesting.push(runner.staller);\n                continue;\n            }\n            // This runner has already triggered another runner\n            if (runner.didBump) {\n                continue;\n            }\n            // Got a response (result or error) or stalled; kick off another runner\n            runner.didBump = true;\n            newRunners++;\n        }\n        // Check if we have reached quorum on a result (or error)\n        const value = await this.#checkQuorum(running, req);\n        if (value !== undefined) {\n            if (value instanceof Error) {\n                throw value;\n            }\n            return value;\n        }\n        // Add any new runners, because a staller timed out or a result\n        // or error response came in.\n        for (let i = 0; i < newRunners; i++) {\n            this.#addRunner(running, req);\n        }\n        // All providers have returned, and we have no result\n        (0, index_js_1.assert)(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n            request: \"%sub-requests\",\n            info: { request: req, results: Array.from(running).map((r) => stringify(r.result)) }\n        });\n        // Wait for someone to either complete its perform or stall out\n        await Promise.race(interesting);\n        // This is recursive, but at worst case the depth is 2x the\n        // number of providers (each has a perform and a staller)\n        return await this.#waitForQuorum(running, req);\n    }\n    async _perform(req) {\n        // Broadcasting a transaction is rare (ish) and already incurs\n        // a cost on the user, so spamming is safe-ish. Just send it to\n        // every backend.\n        if (req.method === \"broadcastTransaction\") {\n            // Once any broadcast provides a positive result, use it. No\n            // need to wait for anyone else\n            const results = this.#configs.map((c) => null);\n            const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {\n                try {\n                    const result = await provider._perform(req);\n                    results[index] = Object.assign(normalizeResult({ result }), { weight });\n                }\n                catch (error) {\n                    results[index] = Object.assign(normalizeResult({ error }), { weight });\n                }\n            });\n            // As each promise finishes...\n            while (true) {\n                // Check for a valid broadcast result\n                const done = results.filter((r) => (r != null));\n                for (const { value } of done) {\n                    if (!(value instanceof Error)) {\n                        return value;\n                    }\n                }\n                // Check for a legit broadcast error (one which we cannot\n                // recover from; some nodes may return the following red\n                // herring events:\n                // - alredy seend (UNKNOWN_ERROR)\n                // - NONCE_EXPIRED\n                // - REPLACEMENT_UNDERPRICED\n                const result = checkQuorum(this.quorum, results.filter((r) => (r != null)));\n                if ((0, index_js_1.isError)(result, \"INSUFFICIENT_FUNDS\")) {\n                    throw result;\n                }\n                // Kick off the next provider (if any)\n                const waiting = broadcasts.filter((b, i) => (results[i] == null));\n                if (waiting.length === 0) {\n                    break;\n                }\n                await Promise.race(waiting);\n            }\n            // Use standard quorum results; any result was returned above,\n            // so this will find any error that met quorum if any\n            const result = getAnyResult(this.quorum, results);\n            (0, index_js_1.assert)(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n                request: \"%sub-requests\",\n                info: { request: req, results: results.map(stringify) }\n            });\n            if (result instanceof Error) {\n                throw result;\n            }\n            return result;\n        }\n        await this.#initialSync();\n        // Bootstrap enough runners to meet quorum\n        const running = new Set();\n        let inflightQuorum = 0;\n        while (true) {\n            const runner = this.#addRunner(running, req);\n            if (runner == null) {\n                break;\n            }\n            inflightQuorum += runner.config.weight;\n            if (inflightQuorum >= this.quorum) {\n                break;\n            }\n        }\n        const result = await this.#waitForQuorum(running, req);\n        // Track requests sent to a provider that are still\n        // outstanding after quorum has been otherwise found\n        for (const runner of running) {\n            if (runner.perform && runner.result == null) {\n                runner.config.lateResponses++;\n            }\n        }\n        return result;\n    }\n    async destroy() {\n        for (const { provider } of this.#configs) {\n            provider.destroy();\n        }\n        super.destroy();\n    }\n}\nexports.FallbackProvider = FallbackProvider;\n//# sourceMappingURL=provider-fallback.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItZmFsbGJhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QywrQkFBK0IsbUJBQU8sQ0FBQyx1R0FBd0I7QUFDL0QscUJBQXFCLG1CQUFPLENBQUMsbUZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QixrQkFBa0IsR0FBRyxxQkFBcUIsaUJBQWlCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUZBQXlGLG1CQUFtQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUIsd0JBQXdCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckMsK0JBQStCLDBDQUEwQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCO0FBQ3pELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBLHFFQUFxRSxRQUFRLEtBQUssUUFBUTtBQUMxRjtBQUNBO0FBQ0EscUVBQXFFLE9BQU8sS0FBSyxRQUFRO0FBQ3pGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItZmFsbGJhY2suanM/M2ZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IHZvaWQgMDtcbi8qKlxuICogIEEgKipGYWxsYmFja1Byb3ZpZGVyKiogcHJvdmlkZXMgcmVzaWxpZW5jZSwgc2VjdXJpdHkgYW5kIHBlcmZvcm1hbmNlXG4gKiAgaW4gYSB3YXkgdGhhdCBpcyBjdXN0b21pemFibGUgYW5kIGNvbmZpZ3VyYWJsZS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2ZhbGxiYWNrLXByb3ZpZGVyOkZhbGxiYWNrIFByb3ZpZGVyIFthYm91dC1mYWxsYmFjay1wcm92aWRlcl1cbiAqL1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBCTl8xID0gQmlnSW50KFwiMVwiKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoXCIyXCIpO1xuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgY29uc3QgdG1wID0gYXJyYXlbaV07XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgICAgIGFycmF5W2pdID0gdG1wO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pOyB9KTtcbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaWdpbnRcIiwgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG47XG5jb25zdCBkZWZhdWx0Q29uZmlnID0geyBzdGFsbFRpbWVvdXQ6IDQwMCwgcHJpb3JpdHk6IDEsIHdlaWdodDogMSB9O1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIGJsb2NrTnVtYmVyOiAtMiwgcmVxdWVzdHM6IDAsIGxhdGVSZXNwb25zZXM6IDAsIGVycm9yUmVzcG9uc2VzOiAwLFxuICAgIG91dE9mU3luYzogLTEsIHVuc3VwcG9ydGVkRXZlbnRzOiAwLCByb2xsaW5nRHVyYXRpb246IDAsIHNjb3JlOiAwLFxuICAgIF9uZXR3b3JrOiBudWxsLCBfdXBkYXRlTnVtYmVyOiBudWxsLCBfdG90YWxUaW1lOiAwLFxuICAgIF9sYXN0RmF0YWxFcnJvcjogbnVsbCwgX2xhc3RGYXRhbEVycm9yVGltZXN0YW1wOiAwXG59O1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN5bmMoY29uZmlnLCBibG9ja051bWJlcikge1xuICAgIHdoaWxlIChjb25maWcuYmxvY2tOdW1iZXIgPCAwIHx8IGNvbmZpZy5ibG9ja051bWJlciA8IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGlmICghY29uZmlnLl91cGRhdGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdXBkYXRlTnVtYmVyID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IGNvbmZpZy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiBjb25maWcuYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9sYXN0RmF0YWxFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2xhc3RGYXRhbEVycm9yVGltZXN0YW1wID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcuX3VwZGF0ZU51bWJlciA9IG51bGw7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNvbmZpZy5fdXBkYXRlTnVtYmVyO1xuICAgICAgICBjb25maWcub3V0T2ZTeW5jKys7XG4gICAgICAgIGlmIChjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbXCIgKyAodmFsdWUubWFwKF9ub3JtYWxpemUpKS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIF9ub3JtYWxpemUodmFsdWUudG9KU09OKCkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwie1wiICsga2V5cy5tYXAoKGspID0+IGAke0pTT04uc3RyaW5naWZ5KGspfToke19ub3JtYWxpemUodmFsdWVba10pfWApLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJDb3VsZCBub3Qgc2VyaWFsaXplXCIsIHZhbHVlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIbW0uLi5cIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZXN1bHQodmFsdWUpIHtcbiAgICBpZiAoXCJlcnJvclwiIGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICAgIHJldHVybiB7IHRhZzogX25vcm1hbGl6ZShlcnJvciksIHZhbHVlOiBlcnJvciB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgcmV0dXJuIHsgdGFnOiBfbm9ybWFsaXplKHJlc3VsdCksIHZhbHVlOiByZXN1bHQgfTtcbn1cbi8vIFRoaXMgc3RyYXRlZ3kgcGlja3MgdGhlIGhpZ2hlc3Qgd2VpZ2h0IHJlc3VsdCwgYXMgbG9uZyBhcyB0aGUgd2VpZ2h0IGlzXG4vLyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gcXVvcnVtXG5mdW5jdGlvbiBjaGVja1F1b3J1bShxdW9ydW0sIHJlc3VsdHMpIHtcbiAgICBjb25zdCB0YWxseSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWUsIHRhZywgd2VpZ2h0IH0gb2YgcmVzdWx0cykge1xuICAgICAgICBjb25zdCB0ID0gdGFsbHkuZ2V0KHRhZykgfHwgeyB2YWx1ZSwgd2VpZ2h0OiAwIH07XG4gICAgICAgIHQud2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgICAgdGFsbHkuc2V0KHRhZywgdCk7XG4gICAgfVxuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGFsbHkudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHIud2VpZ2h0ID49IHF1b3J1bSAmJiAoIWJlc3QgfHwgci53ZWlnaHQgPiBiZXN0LndlaWdodCkpIHtcbiAgICAgICAgICAgIGJlc3QgPSByO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0KSB7XG4gICAgICAgIHJldHVybiBiZXN0LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0TWVkaWFuKHF1b3J1bSwgcmVzdWx0cykge1xuICAgIGxldCByZXN1bHRXZWlnaHQgPSAwO1xuICAgIGNvbnN0IGVycm9yTWFwID0gbmV3IE1hcCgpO1xuICAgIGxldCBiZXN0RXJyb3IgPSBudWxsO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgdGFnLCB3ZWlnaHQgfSBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gZXJyb3JNYXAuZ2V0KHRhZykgfHwgeyB2YWx1ZSwgd2VpZ2h0OiAwIH07XG4gICAgICAgICAgICBlLndlaWdodCArPSB3ZWlnaHQ7XG4gICAgICAgICAgICBlcnJvck1hcC5zZXQodGFnLCBlKTtcbiAgICAgICAgICAgIGlmIChiZXN0RXJyb3IgPT0gbnVsbCB8fCBlLndlaWdodCA+IGJlc3RFcnJvci53ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBiZXN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goQmlnSW50KHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHRXZWlnaHQgKz0gd2VpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHRXZWlnaHQgPCBxdW9ydW0pIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBxdW9ydW0gZm9yIGFuIGVycm9yXG4gICAgICAgIGlmIChiZXN0RXJyb3IgJiYgYmVzdEVycm9yLndlaWdodCA+PSBxdW9ydW0pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0RXJyb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZG8gbm90IGhhdmUgcXVvcnVtIGZvciBhIHJlc3VsdFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHNvcnRlZCB2YWx1ZXNcbiAgICB2YWx1ZXMuc29ydCgoYSwgYikgPT4gKChhIDwgYikgPyAtMSA6IChiID4gYSkgPyAxIDogMCkpO1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuICAgIC8vIE9kZC1sZW5ndGg7IHRha2UgdGhlIG1pZGRsZSB2YWx1ZVxuICAgIGlmICh2YWx1ZXMubGVuZ3RoICUgMikge1xuICAgICAgICByZXR1cm4gdmFsdWVzW21pZF07XG4gICAgfVxuICAgIC8vIEV2ZW4gbGVuZ3RoOyB0YWtlIHRoZSBjZWlsaW5nIG9mIHRoZSBtZWFuIG9mIHRoZSBjZW50ZXIgdHdvIHZhbHVlc1xuICAgIHJldHVybiAodmFsdWVzW21pZCAtIDFdICsgdmFsdWVzW21pZF0gKyBCTl8xKSAvIEJOXzI7XG59XG5mdW5jdGlvbiBnZXRBbnlSZXN1bHQocXVvcnVtLCByZXN1bHRzKSB7XG4gICAgLy8gSWYgYW55IHZhbHVlIG9yIGVycm9yIG1lZXRzIHF1b3J1bSwgdGhhdCBpcyBvdXIgcHJlZmVycmVkIHJlc3VsdFxuICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrUXVvcnVtKHF1b3J1bSwgcmVzdWx0cyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgZG8gd2UgaGF2ZSBhbnkgcmVzdWx0P1xuICAgIGZvciAoY29uc3QgciBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmIChyLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3BlIVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRGdXp6eU1vZGUocXVvcnVtLCByZXN1bHRzKSB7XG4gICAgaWYgKHF1b3J1bSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0TnVtYmVyKShnZXRNZWRpYW4ocXVvcnVtLCByZXN1bHRzKSwgXCIlaW50ZXJuYWxcIik7XG4gICAgfVxuICAgIGNvbnN0IHRhbGx5ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFkZCA9IChyZXN1bHQsIHdlaWdodCkgPT4ge1xuICAgICAgICBjb25zdCB0ID0gdGFsbHkuZ2V0KHJlc3VsdCkgfHwgeyByZXN1bHQsIHdlaWdodDogMCB9O1xuICAgICAgICB0LndlaWdodCArPSB3ZWlnaHQ7XG4gICAgICAgIHRhbGx5LnNldChyZXN1bHQsIHQpO1xuICAgIH07XG4gICAgZm9yIChjb25zdCB7IHdlaWdodCwgdmFsdWUgfSBvZiByZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IHIgPSAoMCwgaW5kZXhfanNfMS5nZXROdW1iZXIpKHZhbHVlKTtcbiAgICAgICAgYWRkKHIgLSAxLCB3ZWlnaHQpO1xuICAgICAgICBhZGQociwgd2VpZ2h0KTtcbiAgICAgICAgYWRkKHIgKyAxLCB3ZWlnaHQpO1xuICAgIH1cbiAgICBsZXQgYmVzdFdlaWdodCA9IDA7XG4gICAgbGV0IGJlc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCB7IHdlaWdodCwgcmVzdWx0IH0gb2YgdGFsbHkudmFsdWVzKCkpIHtcbiAgICAgICAgLy8gVXNlIHRoaXMgcmVzdWx0LCBpZiB0aGlzIHJlc3VsdCBtZWV0cyBxdW9ydW0gYW5kIGhhcyBlaXRoZXI6XG4gICAgICAgIC8vIC0gYSBiZXR0ZXIgd2VpZ2h0XG4gICAgICAgIC8vIC0gb3IgZXF1YWwgd2VpZ2h0LCBidXQgdGhlIHJlc3VsdCBpcyBsYXJnZXJcbiAgICAgICAgaWYgKHdlaWdodCA+PSBxdW9ydW0gJiYgKHdlaWdodCA+IGJlc3RXZWlnaHQgfHwgKGJlc3RSZXN1bHQgIT0gbnVsbCAmJiB3ZWlnaHQgPT09IGJlc3RXZWlnaHQgJiYgcmVzdWx0ID4gYmVzdFJlc3VsdCkpKSB7XG4gICAgICAgICAgICBiZXN0V2VpZ2h0ID0gd2VpZ2h0O1xuICAgICAgICAgICAgYmVzdFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdFJlc3VsdDtcbn1cbi8qKlxuICogIEEgKipGYWxsYmFja1Byb3ZpZGVyKiogbWFuYWdlcyBzZXZlcmFsIFtbUHJvdmlkZXJzXV0gcHJvdmlkaW5nXG4gKiAgcmVzaWxpZW5jZSBieSBzd2l0Y2hpbmcgYmV0d2VlbiBzbG93IG9yIG1pc2JlaGF2aW5nIG5vZGVzLCBzZWN1cml0eVxuICogIGJ5IHJlcXVpcmluZyBtdWx0aXBsZSBiYWNrZW5kcyB0byBhZ2dyZWUgYW5kIHBlcmZvcm1hbmNlIGJ5IGFsbG93aW5nXG4gKiAgZmFzdGVyIGJhY2tlbmRzIHRvIHJlc3BvbmQgZWFybGllci5cbiAqXG4gKi9cbmNsYXNzIEZhbGxiYWNrUHJvdmlkZXIgZXh0ZW5kcyBhYnN0cmFjdF9wcm92aWRlcl9qc18xLkFic3RyYWN0UHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJhY2tlbmRzIHRoYXQgbXVzdCBhZ3JlZSBvbiBhIHZhbHVlIGJlZm9yZSBpdCBpc1xuICAgICAqICBhY2NwZXRlZC5cbiAgICAgKi9cbiAgICBxdW9ydW07XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGV2ZW50UXVvcnVtO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBldmVudFdvcmtlcnM7XG4gICAgI2NvbmZpZ3M7XG4gICAgI2hlaWdodDtcbiAgICAjaW5pdGlhbFN5bmNQcm9taXNlO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmFsbGJhY2tQcm92aWRlcioqIHdpdGggJSVwcm92aWRlcnMlJSBjb25uZWN0ZWQgdG9cbiAgICAgKiAgJSVuZXR3b3JrJSUuXG4gICAgICpcbiAgICAgKiAgSWYgYSBbW1Byb3ZpZGVyXV0gaXMgaW5jbHVkZWQgaW4gJSVwcm92aWRlcnMlJSwgZGVmYXVsdHMgYXJlIHVzZWRcbiAgICAgKiAgZm9yIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVycywgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jY29uZmlncyA9IHByb3ZpZGVycy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5BYnN0cmFjdFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBwcm92aWRlcjogcCB9LCBkZWZhdWx0Q29uZmlnLCBkZWZhdWx0U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcsIHAsIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNoZWlnaHQgPSAtMjtcbiAgICAgICAgdGhpcy4jaW5pdGlhbFN5bmNQcm9taXNlID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdW9ydW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5xdW9ydW0gPSBvcHRpb25zLnF1b3J1bTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVvcnVtID0gTWF0aC5jZWlsKHRoaXMuI2NvbmZpZ3MucmVkdWNlKChhY2N1bSwgY29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gY29uZmlnLndlaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCAwKSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRRdW9ydW0gPSAxO1xuICAgICAgICB0aGlzLmV2ZW50V29ya2VycyA9IDE7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSh0aGlzLnF1b3J1bSA8PSB0aGlzLiNjb25maWdzLnJlZHVjZSgoYSwgYykgPT4gKGEgKyBjLndlaWdodCksIDApLCBcInF1b3J1bSBleGNlZWQgcHJvdmlkZXIgd2llZ2h0XCIsIFwicXVvcnVtXCIsIHRoaXMucXVvcnVtKTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVyQ29uZmlncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NvbmZpZ3MubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBjKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gPT09IFwiX1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKCgwLCBpbmRleF9qc18xLmdldEJpZ0ludCkoYXdhaXQgdGhpcy5fcGVyZm9ybSh7IG1ldGhvZDogXCJjaGFpbklkXCIgfSkpKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEFkZCBzdXBwb3J0IHRvIHNlbGVjdCBwcm92aWRlcnMgdG8gYmUgdGhlIGV2ZW50IHN1YnNjcmliZXJcbiAgICAvL19nZXRTdWJzY3JpYmVyKHN1YjogU3Vic2NyaXB0aW9uKTogU3Vic2NyaWJlciB7XG4gICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgLy99XG4gICAgLyoqXG4gICAgICogIFRyYW5zZm9ybXMgYSAlJXJlcSUlIGludG8gdGhlIGNvcnJlY3QgbWV0aG9kIGNhbGwgb24gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGFzeW5jIF90cmFuc2xhdGVQZXJmb3JtKHByb3ZpZGVyLCByZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuYnJvYWRjYXN0VHJhbnNhY3Rpb24ocmVxLnNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmNhbGwoT2JqZWN0LmFzc2lnbih7fSwgcmVxLnRyYW5zYWN0aW9uLCB7IGJsb2NrVGFnOiByZXEuYmxvY2tUYWcgfSkpO1xuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5lc3RpbWF0ZUdhcyhyZXEudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZShyZXEuYWRkcmVzcywgcmVxLmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSAoXCJibG9ja0hhc2hcIiBpbiByZXEpID8gcmVxLmJsb2NrSGFzaCA6IHJlcS5ibG9ja1RhZztcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2soYmxvY2ssIHJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0Q29kZShyZXEuYWRkcmVzcywgcmVxLmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpKS5nYXNQcmljZTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRQcmlvcml0eUZlZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpKS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldExvZ3MocmVxLmZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRTdG9yYWdlKHJlcS5hZGRyZXNzLCByZXEucG9zaXRpb24sIHJlcS5ibG9ja1RhZyk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVxLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudChyZXEuYWRkcmVzcywgcmVxLmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHJlcS5oYXNoKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdChyZXEuaGFzaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR3JhYiB0aGUgbmV4dCAocmFuZG9tKSBjb25maWcgdGhhdCBpcyBub3QgYWxyZWFkeSBwYXJ0IG9mXG4gICAgLy8gdGhlIHJ1bm5pbmcgc2V0XG4gICAgI2dldE5leHRDb25maWcocnVubmluZykge1xuICAgICAgICAvLyBAVE9ETzogTWF5YmUgZG8gYSBjaGVjayBoZXJlIHRvIGZhdm91ciAoaGVhdmlseSkgcHJvdmlkZXJzIHRoYXRcbiAgICAgICAgLy8gICAgICAgIGRvIG5vdCByZXF1aXJlIHdhaXRGb3JTeW5jIGFuZCBkaXNmYXZvdXIgcHJvdmlkZXJzIHRoYXRcbiAgICAgICAgLy8gICAgICAgIHNlZW0gZG93bi1pc2ggb3IgYXJlIGJlaGF2aW5nIHNsb3dseVxuICAgICAgICBjb25zdCBjb25maWdzID0gQXJyYXkuZnJvbShydW5uaW5nKS5tYXAoKHIpID0+IHIuY29uZmlnKTtcbiAgICAgICAgLy8gU2h1ZmZsZSB0aGUgc3RhdGVzLCBzb3J0ZWQgYnkgcHJpb3JpdHlcbiAgICAgICAgY29uc3QgYWxsQ29uZmlncyA9IHRoaXMuI2NvbmZpZ3Muc2xpY2UoKTtcbiAgICAgICAgc2h1ZmZsZShhbGxDb25maWdzKTtcbiAgICAgICAgYWxsQ29uZmlncy5zb3J0KChhLCBiKSA9PiAoYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpKTtcbiAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgYWxsQ29uZmlncykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fbGFzdEZhdGFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWdzLmluZGV4T2YoY29uZmlnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBBZGRzIGEgbmV3IHJ1bm5lciAoaWYgYXZhaWxhYmxlKSB0byBydW5uaW5nLlxuICAgICNhZGRSdW5uZXIocnVubmluZywgcmVxKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuI2dldE5leHRDb25maWcocnVubmluZyk7XG4gICAgICAgIC8vIE5vIHJ1bm5lcnMgYXZhaWxhYmxlXG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHJ1bm5lclxuICAgICAgICBjb25zdCBydW5uZXIgPSB7XG4gICAgICAgICAgICBjb25maWcsIHJlc3VsdDogbnVsbCwgZGlkQnVtcDogZmFsc2UsXG4gICAgICAgICAgICBwZXJmb3JtOiBudWxsLCBzdGFsbGVyOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vdyA9IGdldFRpbWUoKTtcbiAgICAgICAgLy8gU3RhcnQgcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvblxuICAgICAgICBydW5uZXIucGVyZm9ybSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5yZXF1ZXN0cysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3RyYW5zbGF0ZVBlcmZvcm0oY29uZmlnLnByb3ZpZGVyLCByZXEpO1xuICAgICAgICAgICAgICAgIHJ1bm5lci5yZXN1bHQgPSB7IHJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmVycm9yUmVzcG9uc2VzKys7XG4gICAgICAgICAgICAgICAgcnVubmVyLnJlc3VsdCA9IHsgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR0ID0gKGdldFRpbWUoKSAtIG5vdyk7XG4gICAgICAgICAgICBjb25maWcuX3RvdGFsVGltZSArPSBkdDtcbiAgICAgICAgICAgIGNvbmZpZy5yb2xsaW5nRHVyYXRpb24gPSAwLjk1ICogY29uZmlnLnJvbGxpbmdEdXJhdGlvbiArIDAuMDUgKiBkdDtcbiAgICAgICAgICAgIHJ1bm5lci5wZXJmb3JtID0gbnVsbDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgLy8gU3RhcnQgYSBzdGFsbGVyOyB3aGVuIHRoaXMgdGltZXMgb3V0LCBpdCdzIHRpbWUgdG8gZm9yY2VcbiAgICAgICAgLy8ga2lja2luZyBvZmYgYW5vdGhlciBydW5uZXIgYmVjYXVzZSB3ZSBhcmUgdGFraW5nIHRvbyBsb25nXG4gICAgICAgIHJ1bm5lci5zdGFsbGVyID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHN0YWxsKGNvbmZpZy5zdGFsbFRpbWVvdXQpO1xuICAgICAgICAgICAgcnVubmVyLnN0YWxsZXIgPSBudWxsO1xuICAgICAgICB9KSgpO1xuICAgICAgICBydW5uaW5nLmFkZChydW5uZXIpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbiAgICAvLyBJbml0aWFsaXplcyB0aGUgYmxvY2tOdW1iZXIgYW5kIG5ldHdvcmsgZm9yIGVhY2ggcnVubmVyIGFuZFxuICAgIC8vIGJsb2NrcyB1bnRpbCBpbml0aWFsaXplZFxuICAgIGFzeW5jICNpbml0aWFsU3luYygpIHtcbiAgICAgICAgbGV0IGluaXRpYWxTeW5jID0gdGhpcy4jaW5pdGlhbFN5bmNQcm9taXNlO1xuICAgICAgICBpZiAoIWluaXRpYWxTeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy4jY29uZmlncy5mb3JFYWNoKChjb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JTeW5jKGNvbmZpZywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLl9sYXN0RmF0YWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9uZXR3b3JrID0gYXdhaXQgY29uZmlnLnByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNpbml0aWFsU3luY1Byb21pc2UgPSBpbml0aWFsU3luYyA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgYWxsIHByb3ZpZGVycyB0byBoYXZlIGEgYmxvY2sgbnVtYmVyIGFuZCBuZXR3b3JrXG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGFsbCB0aGUgbmV0d29ya3MgbWF0Y2hcbiAgICAgICAgICAgICAgICBsZXQgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgdGhpcy4jY29uZmlncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLl9sYXN0RmF0YWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IChjb25maWcuX25ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ldHdvcmsuY2hhaW5JZCAhPT0gY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShmYWxzZSwgXCJjYW5ub3QgbWl4IHByb3ZpZGVycyBvbiBkaWZmZXJlbnQgbmV0d29ya3NcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRmFsbGJhY2tQcm92aWRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaW5pdGlhbFN5bmM7XG4gICAgfVxuICAgIGFzeW5jICNjaGVja1F1b3J1bShydW5uaW5nLCByZXEpIHtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgcmVzdWx0IG9iamVjdHNcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5lciBvZiBydW5uaW5nKSB7XG4gICAgICAgICAgICBpZiAocnVubmVyLnJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0YWcsIHZhbHVlIH0gPSBub3JtYWxpemVSZXN1bHQocnVubmVyLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgdGFnLCB2YWx1ZSwgd2VpZ2h0OiBydW5uZXIuY29uZmlnLndlaWdodCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcmUgdGhlcmUgZW5vdWdoIHJlc3VsdHMgdG8gZXZlbnQgbWVldCBxdW9ydW0/XG4gICAgICAgIGlmIChyZXN1bHRzLnJlZHVjZSgoYSwgcikgPT4gKGEgKyByLndlaWdodCksIDApIDwgdGhpcy5xdW9ydW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjoge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IHRoZSBib290c3RyYXAgYmxvY2sgaGVpZ2h0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hlaWdodCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVpZ2h0ID0gTWF0aC5jZWlsKCgwLCBpbmRleF9qc18xLmdldE51bWJlcikoZ2V0TWVkaWFuKHRoaXMucXVvcnVtLCB0aGlzLiNjb25maWdzLmZpbHRlcigoYykgPT4gKCFjLl9sYXN0RmF0YWxFcnJvcikpLm1hcCgoYykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAoMCwgaW5kZXhfanNfMS5nZXROdW1iZXIpKGMuYmxvY2tOdW1iZXIpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IGMud2VpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pKSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbW9kZSBhY3Jvc3MgYWxsIHRoZSBwcm92aWRlcnMsIGFsbG93aW5nIGZvclxuICAgICAgICAgICAgICAgIC8vIGEgbGl0dGxlIGRyaWZ0IGJldHdlZW4gYmxvY2sgaGVpZ2h0c1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBnZXRGdXp6eU1vZGUodGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPiB0aGlzLiNoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVpZ2h0ID0gbW9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVkaWFuKHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIC8vIFBlbmRpbmcgYmxvY2tzIGFyZSBpbiB0aGUgbWVtcG9vbCBhbmQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIHF1aXRlIHVudHJ1c3R3b3J0aHk7IGp1c3QgZ3JhYiBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxICYmIHJlcS5ibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEFueVJlc3VsdCh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1F1b3J1bSh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUXVvcnVtKHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBbnlSZXN1bHQodGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbWV0aG9kXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYF9wZXJmb3JtKCR7c3RyaW5naWZ5KHJlcS5tZXRob2QpfSlgXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyAjd2FpdEZvclF1b3J1bShydW5uaW5nLCByZXEpIHtcbiAgICAgICAgaWYgKHJ1bm5pbmcuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gcnVubmVycz8hXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFueSBwcm9taXNlcyB0aGF0IGFyZSBpbnRlcmVzdGluZyB0byB3YXRjaCBmb3I7IGFuIGV4cGlyZWQgc3RhbGxcbiAgICAgICAgLy8gb3IgYSBzdWNjZXNzZnVsIHBlcmZvcm1cbiAgICAgICAgY29uc3QgaW50ZXJlc3RpbmcgPSBbXTtcbiAgICAgICAgbGV0IG5ld1J1bm5lcnMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5lciBvZiBydW5uaW5nKSB7XG4gICAgICAgICAgICAvLyBObyByZXNwb25zZXMsIHlldDsga2VlcCBhbiBleWUgb24gaXRcbiAgICAgICAgICAgIGlmIChydW5uZXIucGVyZm9ybSkge1xuICAgICAgICAgICAgICAgIGludGVyZXN0aW5nLnB1c2gocnVubmVyLnBlcmZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RpbGwgc3RhbGxpbmcuLi5cbiAgICAgICAgICAgIGlmIChydW5uZXIuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgIGludGVyZXN0aW5nLnB1c2gocnVubmVyLnN0YWxsZXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBydW5uZXIgaGFzIGFscmVhZHkgdHJpZ2dlcmVkIGFub3RoZXIgcnVubmVyXG4gICAgICAgICAgICBpZiAocnVubmVyLmRpZEJ1bXApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdvdCBhIHJlc3BvbnNlIChyZXN1bHQgb3IgZXJyb3IpIG9yIHN0YWxsZWQ7IGtpY2sgb2ZmIGFub3RoZXIgcnVubmVyXG4gICAgICAgICAgICBydW5uZXIuZGlkQnVtcCA9IHRydWU7XG4gICAgICAgICAgICBuZXdSdW5uZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSByZWFjaGVkIHF1b3J1bSBvbiBhIHJlc3VsdCAob3IgZXJyb3IpXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jY2hlY2tRdW9ydW0ocnVubmluZywgcmVxKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGFueSBuZXcgcnVubmVycywgYmVjYXVzZSBhIHN0YWxsZXIgdGltZWQgb3V0IG9yIGEgcmVzdWx0XG4gICAgICAgIC8vIG9yIGVycm9yIHJlc3BvbnNlIGNhbWUgaW4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3UnVubmVyczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLiNhZGRSdW5uZXIocnVubmluZywgcmVxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgcHJvdmlkZXJzIGhhdmUgcmV0dXJuZWQsIGFuZCB3ZSBoYXZlIG5vIHJlc3VsdFxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGludGVyZXN0aW5nLmxlbmd0aCA+IDAsIFwicXVvcnVtIG5vdCBtZXRcIiwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogXCIlc3ViLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICBpbmZvOiB7IHJlcXVlc3Q6IHJlcSwgcmVzdWx0czogQXJyYXkuZnJvbShydW5uaW5nKS5tYXAoKHIpID0+IHN0cmluZ2lmeShyLnJlc3VsdCkpIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHNvbWVvbmUgdG8gZWl0aGVyIGNvbXBsZXRlIGl0cyBwZXJmb3JtIG9yIHN0YWxsIG91dFxuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoaW50ZXJlc3RpbmcpO1xuICAgICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZSwgYnV0IGF0IHdvcnN0IGNhc2UgdGhlIGRlcHRoIGlzIDJ4IHRoZVxuICAgICAgICAvLyBudW1iZXIgb2YgcHJvdmlkZXJzIChlYWNoIGhhcyBhIHBlcmZvcm0gYW5kIGEgc3RhbGxlcilcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3dhaXRGb3JRdW9ydW0ocnVubmluZywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIEJyb2FkY2FzdGluZyBhIHRyYW5zYWN0aW9uIGlzIHJhcmUgKGlzaCkgYW5kIGFscmVhZHkgaW5jdXJzXG4gICAgICAgIC8vIGEgY29zdCBvbiB0aGUgdXNlciwgc28gc3BhbW1pbmcgaXMgc2FmZS1pc2guIEp1c3Qgc2VuZCBpdCB0b1xuICAgICAgICAvLyBldmVyeSBiYWNrZW5kLlxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBPbmNlIGFueSBicm9hZGNhc3QgcHJvdmlkZXMgYSBwb3NpdGl2ZSByZXN1bHQsIHVzZSBpdC4gTm9cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gd2FpdCBmb3IgYW55b25lIGVsc2VcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLiNjb25maWdzLm1hcCgoYykgPT4gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBicm9hZGNhc3RzID0gdGhpcy4jY29uZmlncy5tYXAoYXN5bmMgKHsgcHJvdmlkZXIsIHdlaWdodCB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gT2JqZWN0LmFzc2lnbihub3JtYWxpemVSZXN1bHQoeyByZXN1bHQgfSksIHsgd2VpZ2h0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBPYmplY3QuYXNzaWduKG5vcm1hbGl6ZVJlc3VsdCh7IGVycm9yIH0pLCB7IHdlaWdodCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFzIGVhY2ggcHJvbWlzZSBmaW5pc2hlcy4uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSB2YWxpZCBicm9hZGNhc3QgcmVzdWx0XG4gICAgICAgICAgICAgICAgY29uc3QgZG9uZSA9IHJlc3VsdHMuZmlsdGVyKChyKSA9PiAociAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlIH0gb2YgZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIGxlZ2l0IGJyb2FkY2FzdCBlcnJvciAob25lIHdoaWNoIHdlIGNhbm5vdFxuICAgICAgICAgICAgICAgIC8vIHJlY292ZXIgZnJvbTsgc29tZSBub2RlcyBtYXkgcmV0dXJuIHRoZSBmb2xsb3dpbmcgcmVkXG4gICAgICAgICAgICAgICAgLy8gaGVycmluZyBldmVudHM6XG4gICAgICAgICAgICAgICAgLy8gLSBhbHJlZHkgc2VlbmQgKFVOS05PV05fRVJST1IpXG4gICAgICAgICAgICAgICAgLy8gLSBOT05DRV9FWFBJUkVEXG4gICAgICAgICAgICAgICAgLy8gLSBSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrUXVvcnVtKHRoaXMucXVvcnVtLCByZXN1bHRzLmZpbHRlcigocikgPT4gKHIgIT0gbnVsbCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNFcnJvcikocmVzdWx0LCBcIklOU1VGRklDSUVOVF9GVU5EU1wiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEtpY2sgb2ZmIHRoZSBuZXh0IHByb3ZpZGVyIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgY29uc3Qgd2FpdGluZyA9IGJyb2FkY2FzdHMuZmlsdGVyKChiLCBpKSA9PiAocmVzdWx0c1tpXSA9PSBudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKHdhaXRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2Uod2FpdGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2Ugc3RhbmRhcmQgcXVvcnVtIHJlc3VsdHM7IGFueSByZXN1bHQgd2FzIHJldHVybmVkIGFib3ZlLFxuICAgICAgICAgICAgLy8gc28gdGhpcyB3aWxsIGZpbmQgYW55IGVycm9yIHRoYXQgbWV0IHF1b3J1bSBpZiBhbnlcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldEFueVJlc3VsdCh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHJlc3VsdCAhPT0gdW5kZWZpbmVkLCBcInByb2JsZW0gbXVsdGktYnJvYWRjYXN0aW5nXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBcIiVzdWItcmVxdWVzdHNcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IHJlcXVlc3Q6IHJlcSwgcmVzdWx0czogcmVzdWx0cy5tYXAoc3RyaW5naWZ5KSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy4jaW5pdGlhbFN5bmMoKTtcbiAgICAgICAgLy8gQm9vdHN0cmFwIGVub3VnaCBydW5uZXJzIHRvIG1lZXQgcXVvcnVtXG4gICAgICAgIGNvbnN0IHJ1bm5pbmcgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBpbmZsaWdodFF1b3J1bSA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBydW5uZXIgPSB0aGlzLiNhZGRSdW5uZXIocnVubmluZywgcmVxKTtcbiAgICAgICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mbGlnaHRRdW9ydW0gKz0gcnVubmVyLmNvbmZpZy53ZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaW5mbGlnaHRRdW9ydW0gPj0gdGhpcy5xdW9ydW0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiN3YWl0Rm9yUXVvcnVtKHJ1bm5pbmcsIHJlcSk7XG4gICAgICAgIC8vIFRyYWNrIHJlcXVlc3RzIHNlbnQgdG8gYSBwcm92aWRlciB0aGF0IGFyZSBzdGlsbFxuICAgICAgICAvLyBvdXRzdGFuZGluZyBhZnRlciBxdW9ydW0gaGFzIGJlZW4gb3RoZXJ3aXNlIGZvdW5kXG4gICAgICAgIGZvciAoY29uc3QgcnVubmVyIG9mIHJ1bm5pbmcpIHtcbiAgICAgICAgICAgIGlmIChydW5uZXIucGVyZm9ybSAmJiBydW5uZXIucmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuY29uZmlnLmxhdGVSZXNwb25zZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHsgcHJvdmlkZXIgfSBvZiB0aGlzLiNjb25maWdzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IEZhbGxiYWNrUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1mYWxsYmFjay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-fallback.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-infura.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-infura.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;\n/**\n *  [[link-infura]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\n *  - Base (``base``)\n *  - Base Goerlia Testnet (``base-goerli``)\n *  - Base Sepolia Testnet (``base-sepolia``)\n *  - BNB Smart Chain Mainnet (``bnb``)\n *  - BNB Smart Chain Testnet (``bnbt``)\n *  - Linea (``linea``)\n *  - Linea Goerlia Testnet (``linea-goerli``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:INFURA  [providers-infura]\n */\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js\");\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"mainnet.infura.io\";\n        case \"goerli\":\n            return \"goerli.infura.io\";\n        case \"sepolia\":\n            return \"sepolia.infura.io\";\n        case \"arbitrum\":\n            return \"arbitrum-mainnet.infura.io\";\n        case \"arbitrum-goerli\":\n            return \"arbitrum-goerli.infura.io\";\n        case \"arbitrum-sepolia\":\n            return \"arbitrum-sepolia.infura.io\";\n        case \"base\":\n            return \"base-mainnet.infura.io\";\n        case \"base-goerlia\":\n            return \"base-goerli.infura.io\";\n        case \"base-sepolia\":\n            return \"base-sepolia.infura.io\";\n        case \"bnb\":\n            return \"bnbsmartchain-mainnet.infura.io\";\n        case \"bnbt\":\n            return \"bnbsmartchain-testnet.infura.io\";\n        case \"linea\":\n            return \"linea-mainnet.infura.io\";\n        case \"linea-goerli\":\n            return \"linea-goerli.infura.io\";\n        case \"matic\":\n            return \"polygon-mainnet.infura.io\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai.infura.io\";\n        case \"optimism\":\n            return \"optimism-mainnet.infura.io\";\n        case \"optimism-goerli\":\n            return \"optimism-goerli.infura.io\";\n        case \"optimism-sepolia\":\n            return \"optimism-sepolia.infura.io\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **InfuraWebSocketProvider** connects to the [[link-infura]]\n *  WebSocket end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-infura-signup).\n */\nclass InfuraWebSocketProvider extends provider_websocket_js_1.WebSocketProvider {\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    projectId;\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This should not\n     *  be used outside of private contexts.\n     */\n    projectSecret;\n    /**\n     *  Creates a new **InfuraWebSocketProvider**.\n     */\n    constructor(network, projectId) {\n        const provider = new InfuraProvider(network, projectId);\n        const req = provider._getConnection();\n        (0, index_js_1.assert)(!req.credentials, \"INFURA WebSocket project secrets unsupported\", \"UNSUPPORTED_OPERATION\", { operation: \"InfuraProvider.getWebSocketProvider()\" });\n        const url = req.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        (0, index_js_1.defineProperties)(this, {\n            projectId: provider.projectId,\n            projectSecret: provider.projectSecret\n        });\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\nexports.InfuraWebSocketProvider = InfuraWebSocketProvider;\n/**\n *  The **InfuraProvider** connects to the [[link-infura]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-infura-signup).\n */\nclass InfuraProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    projectId;\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This should not\n     *  be used outside of private contexts.\n     */\n    projectSecret;\n    /**\n     *  Creates a new **InfuraProvider**.\n     */\n    constructor(_network, projectId, projectSecret) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (projectId == null) {\n            projectId = defaultProjectId;\n        }\n        if (projectSecret == null) {\n            projectSecret = null;\n        }\n        const request = InfuraProvider.getRequest(network, projectId, projectSecret);\n        super(request, network, { staticNetwork: network });\n        (0, index_js_1.defineProperties)(this, { projectId, projectSecret });\n    }\n    _getProvider(chainId) {\n        try {\n            return new InfuraProvider(chainId, this.projectId, this.projectSecret);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n    /**\n     *  Creates a new **InfuraWebSocketProvider**.\n     */\n    static getWebSocketProvider(network, projectId) {\n        return new InfuraWebSocketProvider(network, projectId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%%\n     *  with %%projectId%% and %%projectSecret%%.\n     */\n    static getRequest(network, projectId, projectSecret) {\n        if (projectId == null) {\n            projectId = defaultProjectId;\n        }\n        if (projectSecret == null) {\n            projectSecret = null;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/v3/${projectId}`);\n        request.allowGzip = true;\n        if (projectSecret) {\n            request.setCredentials(\"\", projectSecret);\n        }\n        if (projectId === defaultProjectId) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0, community_js_1.showThrottleMessage)(\"InfuraProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\nexports.InfuraProvider = InfuraProvider;\n//# sourceMappingURL=provider-infura.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItaW5mdXJhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMsdUZBQWdCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLG1GQUFjO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLHFHQUF1QjtBQUM3RCxnQ0FBZ0MsbUJBQU8sQ0FBQyx5R0FBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILG9EQUFvRDtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRCxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixNQUFNLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItaW5mdXJhLmpzPzllODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluZnVyYVByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IHZvaWQgMDtcbi8qKlxuICogIFtbbGluay1pbmZ1cmFdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBBcmJpdHJ1bSBHb2VybGkgVGVzdG5ldCAoYGBhcmJpdHJ1bS1nb2VybGlgYClcbiAqICAtIEFyYml0cnVtIFNlcG9saWEgVGVzdG5ldCAoYGBhcmJpdHJ1bS1zZXBvbGlhYGApXG4gKiAgLSBCYXNlIChgYGJhc2VgYClcbiAqICAtIEJhc2UgR29lcmxpYSBUZXN0bmV0IChgYGJhc2UtZ29lcmxpYGApXG4gKiAgLSBCYXNlIFNlcG9saWEgVGVzdG5ldCAoYGBiYXNlLXNlcG9saWFgYClcbiAqICAtIEJOQiBTbWFydCBDaGFpbiBNYWlubmV0IChgYGJuYmBgKVxuICogIC0gQk5CIFNtYXJ0IENoYWluIFRlc3RuZXQgKGBgYm5idGBgKVxuICogIC0gTGluZWEgKGBgbGluZWFgYClcbiAqICAtIExpbmVhIEdvZXJsaWEgVGVzdG5ldCAoYGBsaW5lYS1nb2VybGlgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpJTkZVUkEgIFtwcm92aWRlcnMtaW5mdXJhXVxuICovXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgY29tbXVuaXR5X2pzXzEgPSByZXF1aXJlKFwiLi9jb21tdW5pdHkuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX3dlYnNvY2tldF9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItd2Vic29ja2V0LmpzXCIpO1xuY29uc3QgZGVmYXVsdFByb2plY3RJZCA9IFwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtcbmZ1bmN0aW9uIGdldEhvc3QobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwic2Vwb2xpYS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmJpdHJ1bS1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW0tZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmJpdHJ1bS1nb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmJpdHJ1bS1zZXBvbGlhLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmFzZS1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYmFzZS1nb2VybGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLWdvZXJsaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmFzZS1zZXBvbGlhLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYm5iXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJibmJzbWFydGNoYWluLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJibmJ0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJibmJzbWFydGNoYWluLXRlc3RuZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJsaW5lYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibGluZWEtbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImxpbmVhLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibGluZWEtZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1tdW1iYWkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc20tc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tc2Vwb2xpYS5pbmZ1cmEuaW9cIjtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuLyoqXG4gKiAgVGhlICoqSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLWluZnVyYV1dXG4gKiAgV2ViU29ja2V0IGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWluZnVyYS1zaWdudXApLlxuICovXG5jbGFzcyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX3dlYnNvY2tldF9qc18xLldlYlNvY2tldFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIFByb2plY3QgSUQgZm9yIHRoZSBJTkZVUkEgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBwcm9qZWN0SWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBQcm9qZWN0IFNlY3JldC5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCBubyBhdXRoZW50aWNhdGVkIHJlcXVlc3RzIGFyZSBtYWRlLiBUaGlzIHNob3VsZCBub3RcbiAgICAgKiAgYmUgdXNlZCBvdXRzaWRlIG9mIHByaXZhdGUgY29udGV4dHMuXG4gICAgICovXG4gICAgcHJvamVjdFNlY3JldDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkluZnVyYVdlYlNvY2tldFByb3ZpZGVyKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmV0d29yaywgcHJvamVjdElkKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIHByb2plY3RJZCk7XG4gICAgICAgIGNvbnN0IHJlcSA9IHByb3ZpZGVyLl9nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoIXJlcS5jcmVkZW50aWFscywgXCJJTkZVUkEgV2ViU29ja2V0IHByb2plY3Qgc2VjcmV0cyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJJbmZ1cmFQcm92aWRlci5nZXRXZWJTb2NrZXRQcm92aWRlcigpXCIgfSk7XG4gICAgICAgIGNvbnN0IHVybCA9IHJlcS51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG4gICAgICAgIHN1cGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIHByb2plY3RJZDogcHJvdmlkZXIucHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdFNlY3JldDogcHJvdmlkZXIucHJvamVjdFNlY3JldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCk7XG4gICAgfVxufVxuZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IEluZnVyYVdlYlNvY2tldFByb3ZpZGVyO1xuLyoqXG4gKiAgVGhlICoqSW5mdXJhUHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLWluZnVyYV1dXG4gKiAgSlNPTi1SUEMgZW5kLXBvaW50cy5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSBrZXkgaXMgdXNlZCwgd2hpY2ggaXNcbiAqICBhcHByb3ByaWF0ZSBmb3IgcXVpY2sgcHJvdG90eXBlcyBhbmQgc2ltcGxlIHNjcmlwdHMuIFRvXG4gKiAgZ2FpbiBhY2Nlc3MgdG8gYW4gaW5jcmVhc2VkIHJhdGUtbGltaXQsIGl0IGlzIGhpZ2hseVxuICogIHJlY29tbWVuZGVkIHRvIFtzaWduIHVwIGhlcmVdKGxpbmstaW5mdXJhLXNpZ251cCkuXG4gKi9cbmNsYXNzIEluZnVyYVByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBQcm9qZWN0IElEIGZvciB0aGUgSU5GVVJBIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgcHJvamVjdElkO1xuICAgIC8qKlxuICAgICAqICBUaGUgUHJvamVjdCBTZWNyZXQuXG4gICAgICpcbiAgICAgKiAgSWYgbnVsbCwgbm8gYXV0aGVudGljYXRlZCByZXF1ZXN0cyBhcmUgbWFkZS4gVGhpcyBzaG91bGQgbm90XG4gICAgICogIGJlIHVzZWQgb3V0c2lkZSBvZiBwcml2YXRlIGNvbnRleHRzLlxuICAgICAqL1xuICAgIHByb2plY3RTZWNyZXQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipJbmZ1cmFQcm92aWRlcioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBwcm9qZWN0SWQsIHByb2plY3RTZWNyZXQpIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICBpZiAocHJvamVjdElkID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2plY3RJZCA9IGRlZmF1bHRQcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3RTZWNyZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvamVjdFNlY3JldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IEluZnVyYVByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KTtcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHByb2plY3RJZCwgcHJvamVjdFNlY3JldCB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5mdXJhUHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5wcm9qZWN0SWQsIHRoaXMucHJvamVjdFNlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRQcm92aWRlcihjaGFpbklkKTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0V2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgcHJvamVjdElkKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgcHJvamVjdElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBwcmVwYXJlZCByZXF1ZXN0IGZvciBjb25uZWN0aW5nIHRvICUlbmV0d29yayUlXG4gICAgICogIHdpdGggJSVwcm9qZWN0SWQlJSBhbmQgJSVwcm9qZWN0U2VjcmV0JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KSB7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvamVjdElkID0gZGVmYXVsdFByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdFNlY3JldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9qZWN0U2VjcmV0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGluZGV4X2pzXzEuRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9L3YzLyR7cHJvamVjdElkfWApO1xuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIGlmIChwcm9qZWN0U2VjcmV0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNldENyZWRlbnRpYWxzKFwiXCIsIHByb2plY3RTZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKFwiSW5mdXJhUHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBJbmZ1cmFQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWluZnVyYS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-infura.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IpcSocketProvider = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\");\n// @TODO: Is this sufficient? Is this robust? Will newlines occur between\n// all payloads and only between payloads?\nfunction splitBuffer(data) {\n    const messages = [];\n    let lastStart = 0;\n    while (true) {\n        const nl = data.indexOf(10, lastStart);\n        if (nl === -1) {\n            break;\n        }\n        messages.push(data.subarray(lastStart, nl).toString().trim());\n        lastStart = nl + 1;\n    }\n    return { messages, remaining: data.subarray(lastStart) };\n}\n/**\n *  An **IpcSocketProvider** connects over an IPC socket on the host\n *  which provides fast access to the node, but requires the node and\n *  the script run on the same machine.\n */\nclass IpcSocketProvider extends provider_socket_js_1.SocketProvider {\n    #socket;\n    /**\n     *  The connected socket.\n     */\n    get socket() { return this.#socket; }\n    constructor(path, network, options) {\n        super(network, options);\n        this.#socket = (0, net_1.connect)(path);\n        this.socket.on(\"ready\", async () => {\n            try {\n                await this._start();\n            }\n            catch (error) {\n                console.log(\"failed to start IpcSocketProvider\", error);\n                // @TODO: Now what? Restart?\n            }\n        });\n        let response = Buffer.alloc(0);\n        this.socket.on(\"data\", (data) => {\n            response = Buffer.concat([response, data]);\n            const { messages, remaining } = splitBuffer(response);\n            messages.forEach((message) => {\n                this._processMessage(message);\n            });\n            response = remaining;\n        });\n        this.socket.on(\"end\", () => {\n            this.emit(\"close\");\n            this.socket.destroy();\n            this.socket.end();\n        });\n    }\n    destroy() {\n        this.socket.destroy();\n        this.socket.end();\n        super.destroy();\n    }\n    async _write(message) {\n        this.socket.write(message);\n    }\n}\nexports.IpcSocketProvider = IpcSocketProvider;\n//# sourceMappingURL=provider-ipcsocket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItaXBjc29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsNkJBQTZCLG1CQUFPLENBQUMsbUdBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItaXBjc29ja2V0LmpzPzg4NTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklwY1NvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgcHJvdmlkZXJfc29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1zb2NrZXQuanNcIik7XG4vLyBAVE9ETzogSXMgdGhpcyBzdWZmaWNpZW50PyBJcyB0aGlzIHJvYnVzdD8gV2lsbCBuZXdsaW5lcyBvY2N1ciBiZXR3ZWVuXG4vLyBhbGwgcGF5bG9hZHMgYW5kIG9ubHkgYmV0d2VlbiBwYXlsb2Fkcz9cbmZ1bmN0aW9uIHNwbGl0QnVmZmVyKGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGxldCBsYXN0U3RhcnQgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5sID0gZGF0YS5pbmRleE9mKDEwLCBsYXN0U3RhcnQpO1xuICAgICAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlcy5wdXNoKGRhdGEuc3ViYXJyYXkobGFzdFN0YXJ0LCBubCkudG9TdHJpbmcoKS50cmltKCkpO1xuICAgICAgICBsYXN0U3RhcnQgPSBubCArIDE7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2VzLCByZW1haW5pbmc6IGRhdGEuc3ViYXJyYXkobGFzdFN0YXJ0KSB9O1xufVxuLyoqXG4gKiAgQW4gKipJcGNTb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIG92ZXIgYW4gSVBDIHNvY2tldCBvbiB0aGUgaG9zdFxuICogIHdoaWNoIHByb3ZpZGVzIGZhc3QgYWNjZXNzIHRvIHRoZSBub2RlLCBidXQgcmVxdWlyZXMgdGhlIG5vZGUgYW5kXG4gKiAgdGhlIHNjcmlwdCBydW4gb24gdGhlIHNhbWUgbWFjaGluZS5cbiAqL1xuY2xhc3MgSXBjU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9zb2NrZXRfanNfMS5Tb2NrZXRQcm92aWRlciB7XG4gICAgI3NvY2tldDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBzb2NrZXQuXG4gICAgICovXG4gICAgZ2V0IHNvY2tldCgpIHsgcmV0dXJuIHRoaXMuI3NvY2tldDsgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI3NvY2tldCA9ICgwLCBuZXRfMS5jb25uZWN0KShwYXRoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJyZWFkeVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBzdGFydCBJcGNTb2NrZXRQcm92aWRlclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IE5vdyB3aGF0PyBSZXN0YXJ0P1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gQnVmZmVyLmNvbmNhdChbcmVzcG9uc2UsIGRhdGFdKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZXMsIHJlbWFpbmluZyB9ID0gc3BsaXRCdWZmZXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlbWFpbmluZztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGFzeW5jIF93cml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LndyaXRlKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuSXBjU29ja2V0UHJvdmlkZXIgPSBJcGNTb2NrZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWlwY3NvY2tldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonRpcProvider = exports.JsonRpcApiPollingProvider = exports.JsonRpcApiProvider = exports.JsonRpcSigner = void 0;\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\nconst index_js_1 = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nconst abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst subscriber_filterid_js_1 = __webpack_require__(/*! ./subscriber-filterid.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js\");\nconst subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js\");\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof (value)) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof (value.getAddress) === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return (value.map(deepCopy));\n    }\n    if (typeof (value) === \"object\") {\n        return Object.keys(value).reduce((accum, key) => {\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof (value)})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return (value && typeof (value.pollingInterval) === \"number\");\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: (1 << 20),\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends abstract_signer_js_1.AbstractSigner {\n    address;\n    constructor(provider, address) {\n        super(provider);\n        address = (0, index_js_2.getAddress)(address);\n        (0, index_js_5.defineProperties)(this, { address });\n    }\n    connect(provider) {\n        (0, index_js_5.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async () => {\n                const from = await (0, index_js_2.resolveAddress)(_from, this.provider);\n                (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        }\n        else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async () => {\n                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async () => {\n                tx.to = await (0, index_js_2.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [hexTx]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await (new Promise((resolve, reject) => {\n            const timeouts = [1000, 100];\n            let invalids = 0;\n            const checkTx = async () => {\n                try {\n                    // Try getting the transaction\n                    const tx = await this.provider.getTransaction(hash);\n                    if (tx != null) {\n                        resolve(tx.replaceableTransaction(blockNumber));\n                        return;\n                    }\n                }\n                catch (error) {\n                    // If we were cancelled: stop polling.\n                    // If the data is bad: the node returns bad transactions\n                    // If the network changed: calling again will also fail\n                    // If unsupported: likely destroyed\n                    if ((0, index_js_5.isError)(error, \"CANCELLED\") || (0, index_js_5.isError)(error, \"BAD_DATA\") ||\n                        (0, index_js_5.isError)(error, \"NETWORK_ERROR\" || 0)) {\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        reject(error);\n                        return;\n                    }\n                    // Stop-gap for misbehaving backends; see #4513\n                    if ((0, index_js_5.isError)(error, \"INVALID_ARGUMENT\")) {\n                        invalids++;\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        if (invalids > 10) {\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Notify anyone that cares; but we will try again, since\n                    // it is likely an intermittent service error\n                    this.provider.emit(\"error\", (0, index_js_5.makeError)(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", { error }));\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        }));\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0, index_js_2.resolveAddress)(tx.from, this.provider);\n            (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        }\n        else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [hexTx]);\n    }\n    async signMessage(_message) {\n        const message = ((typeof (_message) === \"string\") ? (0, index_js_5.toUtf8Bytes)(_message) : _message);\n        return await this.provider.send(\"personal_sign\", [\n            (0, index_js_5.hexlify)(message), this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await index_js_3.TypedDataEncoder.resolveNames(domain, types, value, async (value) => {\n            const address = await (0, index_js_2.resolveAddress)(value);\n            (0, index_js_5.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(index_js_3.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(), password, null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = ((typeof (_message) === \"string\") ? (0, index_js_5.toUtf8Bytes)(_message) : _message);\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(), (0, index_js_5.hexlify)(message)\n        ]);\n    }\n}\nexports.JsonRpcSigner = JsonRpcSigner;\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nclass JsonRpcApiProvider extends abstract_provider_js_1.AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #pendingDetectNetwork;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no harm in sending it immediately\n        const stallTime = (this._getOption(\"batchMaxCount\") === 1) ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(() => {\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while (payloads.length) {\n                // Create payload batches that satisfy our batch constraints\n                const batch = [(payloads.shift())];\n                while (payloads.length) {\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push((payloads.shift()));\n                    const bytes = JSON.stringify(batch.map((p) => p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift((batch.pop()));\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async () => {\n                    const payload = ((batch.length === 1) ? batch[0].payload : batch.map((p) => p.payload));\n                    this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch) {\n                            if (this.destroyed) {\n                                reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r) => (r.id === payload.id))[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = (0, index_js_5.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result, info: { payload }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    }\n                    catch (error) {\n                        this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                        for (const { reject } of batch) {\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options) {\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        this.#pendingDetectNetwork = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve) => {\n                resolve = _resolve;\n            });\n            this.#notReady = { promise, resolve };\n        }\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof (staticNetwork) === \"boolean\") {\n            (0, index_js_5.assertArgument)(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                this.#network = network_js_1.Network.from(network);\n            }\n        }\n        else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            (0, index_js_5.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */\n    _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */\n    get _network() {\n        (0, index_js_5.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */\n    async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0, index_js_5.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, { type: undefined })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */\n    async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if (this.#network) {\n                    return this.#network;\n                }\n            }\n            else {\n                return network;\n            }\n        }\n        if (this.#pendingDetectNetwork) {\n            return await this.#pendingDetectNetwork;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            this.#pendingDetectNetwork = (async () => {\n                try {\n                    const result = network_js_1.Network.from((0, index_js_5.getBigInt)(await this.send(\"eth_chainId\", [])));\n                    this.#pendingDetectNetwork = null;\n                    return result;\n                }\n                catch (error) {\n                    this.#pendingDetectNetwork = null;\n                    throw error;\n                }\n            })();\n            return await this.#pendingDetectNetwork;\n        }\n        // We are not ready yet; use the primitive _send\n        this.#pendingDetectNetwork = (async () => {\n            const payload = {\n                id: this.#nextId++, method: \"eth_chainId\", params: [], jsonrpc: \"2.0\"\n            };\n            this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n            let result;\n            try {\n                result = (await this._send(payload))[0];\n                this.#pendingDetectNetwork = null;\n            }\n            catch (error) {\n                this.#pendingDetectNetwork = null;\n                this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                throw error;\n            }\n            this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n            if (\"result\" in result) {\n                return network_js_1.Network.from((0, index_js_5.getBigInt)(result.result));\n            }\n            throw this.getRpcError(payload, result);\n        })();\n        return await this.#pendingDetectNetwork;\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */\n    _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async () => {\n            // Bootstrap the network\n            while (this.#network == null && !this.destroyed) {\n                try {\n                    this.#network = await this._detectNetwork();\n                }\n                catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0, index_js_5.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", { event: \"initial-network-discovery\", info: { error } }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */\n    async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */\n    _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new subscriber_filterid_js_1.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);\n            }\n            return new subscriber_filterid_js_1.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new abstract_provider_js_1.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */\n    get ready() { return this.#notReady == null; }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */\n    getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0, index_js_5.toQuantity)((0, index_js_5.getBigInt)(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\"from\", \"to\", \"data\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0, index_js_5.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0, index_js_4.accessListify)(tx.accessList);\n        }\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */\n    getRpcRequest(req) {\n        switch (req.method) {\n            case \"chainId\":\n                return { method: \"eth_chainId\", args: [] };\n            case \"getBlockNumber\":\n                return { method: \"eth_blockNumber\", args: [] };\n            case \"getGasPrice\":\n                return { method: \"eth_gasPrice\", args: [] };\n            case \"getPriorityFee\":\n                return { method: \"eth_maxPriorityFeePerGas\", args: [] };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        (\"0x\" + req.position.toString(16)),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [req.signedTransaction]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [req.blockTag, !!req.includeTransactions]\n                    };\n                }\n                else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [req.blockHash, !!req.includeTransactions]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [req.hash]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [req.hash]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [this.getRpcTransaction(req.transaction), req.blockTag]\n                };\n            case \"estimateGas\": {\n                return {\n                    method: \"eth_estimateGas\",\n                    args: [this.getRpcTransaction(req.transaction)]\n                };\n            }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    }\n                    else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return { method: \"eth_getLogs\", args: [req.filter] };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */\n    getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0, index_js_5.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: (payload.params[0]),\n                    info: { payload, error }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = index_js_1.AbiCoder.getBuiltinCallException((method === \"eth_call\") ? \"call\" : \"estimateGas\", (payload.params[0]), (result ? result.data : null));\n            e.info = { error, payload };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof (error.message) === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\",\n            };\n            return (0, index_js_5.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\n                action: (actionMap[method] || \"unknown\"),\n                reason: \"rejected\",\n                info: { payload, error }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = (payload.params[0]);\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0, index_js_5.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction, info: { error }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0, index_js_5.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", { transaction, info: { error } });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0, index_js_5.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", { transaction, info: { error } });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0, index_js_5.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method, info: { transaction, info: { error } }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0, index_js_5.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method, info: { error, payload }\n            });\n        }\n        return (0, index_js_5.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", { error, payload });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */\n    send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: method }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject) => {\n            this.#payloads.push({\n                resolve, reject,\n                payload: { method, params, id, jsonrpc: \"2.0\" }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof (address) === \"number\") {\n            const accounts = (await accountsPromise);\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0, index_js_5.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0, index_js_2.getAddress)(address);\n        for (const account of accounts) {\n            if ((0, index_js_2.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a) => new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads) {\n            reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\nexports.JsonRpcApiProvider = JsonRpcApiProvider;\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */\nclass JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options) {\n        super(network, options);\n        this.#pollingInterval = 4000;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */\n    get pollingInterval() { return this.#pollingInterval; }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub) => {\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\nexports.JsonRpcApiPollingProvider = JsonRpcApiPollingProvider;\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nclass JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options) {\n        if (url == null) {\n            url = \"http:/\\/localhost:8545\";\n        }\n        super(network, options);\n        if (typeof (url) === \"string\") {\n            this.#connect = new index_js_5.FetchRequest(url);\n        }\n        else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [resp];\n        }\n        return resp;\n    }\n}\nexports.JsonRpcProvider = JsonRpcProvider;\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(/revert/i) && (0, index_js_5.isHexString)(value.data)) {\n        return { message: value.message, data: value.data };\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        }\n        catch (error) { }\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n}\n//# sourceMappingURL=provider-jsonrpc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsaUNBQWlDLEdBQUcsMEJBQTBCLEdBQUcscUJBQXFCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDhGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUMsK0JBQStCLG1CQUFPLENBQUMsdUdBQXdCO0FBQy9ELDZCQUE2QixtQkFBTyxDQUFDLG1HQUFzQjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxpQ0FBaUMsbUJBQU8sQ0FBQywyR0FBMEI7QUFDbkUsZ0NBQWdDLG1CQUFPLENBQUMseUdBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLDBDQUEwQyxPQUFPLEdBQUcsZUFBZTtBQUNuRTtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsMkJBQTJCO0FBQzNGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxDQUF1RDtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsMEpBQTBKLE9BQU87QUFDaks7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUNBQW1DO0FBQzVFO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DO0FBQ2pGO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBLHNGQUFzRiwrQ0FBK0MsMkJBQTJCO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQ0FBa0M7QUFDL0UscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMseURBQXlELFFBQVEsaUJBQWlCO0FBQ2xGLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQSxpQ0FBaUMsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GLDZIQUE2SCw0Q0FBNEMsU0FBUztBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxJQUFJO0FBQ3JHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1HQUFtRyxxQkFBcUIsU0FBUztBQUNqSTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcscUJBQXFCLFNBQVM7QUFDdkk7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFCQUFxQjtBQUNwRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsYUFBYTtBQUNiO0FBQ0Esd0ZBQXdGLGdCQUFnQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsaUZBQWlGLCtDQUErQyxtQkFBbUI7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDLGtFQUFrRSwrQ0FBK0MsMkJBQTJCO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcz9kMWRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgT25lIG9mIHRoZSBtb3N0IGNvbW1vbiB3YXlzIHRvIGludGVyYWN0IHdpdGggdGhlIGJsb2NrY2hhaW4gaXNcbiAqICBieSBhIG5vZGUgcnVubmluZyBhIEpTT04tUlBDIGludGVyZmFjZSB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHRvLFxuICogIGJhc2VkIG9uIHRoZSB0cmFuc3BvcnQsIHVzaW5nOlxuICpcbiAqICAtIEhUVFAgb3IgSFRUUFMgLSBbW0pzb25ScGNQcm92aWRlcl1dXG4gKiAgLSBXZWJTb2NrZXQgLSBbW1dlYlNvY2tldFByb3ZpZGVyXV1cbiAqICAtIElQQyAtIFtbSXBjU29ja2V0UHJvdmlkZXJdXVxuICpcbiAqIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9qc29ucnBjOkpTT04tUlBDIFByb3ZpZGVyICBbYWJvdXQtanNvbnJwY1Byb3ZpZGVyXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY0FwaVByb3ZpZGVyID0gZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0gdm9pZCAwO1xuLy8gQFRPRE86XG4vLyAtIEFkZCB0aGUgYmF0Y2hpbmcgQVBJXG4vLyBodHRwczovL3BsYXlncm91bmQub3Blbi1ycGMub3JnLz9zY2hlbWFVcmw9aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2V0aGVyZXVtL2V0aDEuMC1hcGlzL2Fzc2VtYmxlZC1zcGVjL29wZW5ycGMuanNvbiZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOnNwbGl0VmlldyU1RD10cnVlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6aW5wdXQlNUQ9ZmFsc2UmdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpleGFtcGxlc0Ryb3Bkb3duJTVEPWZhbHNlXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FiaS9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc181ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCIpO1xuY29uc3QgYWJzdHJhY3Rfc2lnbmVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3Qgc3Vic2NyaWJlcl9maWx0ZXJpZF9qc18xID0gcmVxdWlyZShcIi4vc3Vic2NyaWJlci1maWx0ZXJpZC5qc1wiKTtcbmNvbnN0IHN1YnNjcmliZXJfcG9sbGluZ19qc18xID0gcmVxdWlyZShcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCIpO1xuY29uc3QgUHJpbWl0aXZlID0gXCJiaWdpbnQsYm9vbGVhbixmdW5jdGlvbixudW1iZXIsc3RyaW5nLHN5bWJvbFwiLnNwbGl0KC8sL2cpO1xuLy9jb25zdCBNZXRob2RzID0gXCJnZXRBZGRyZXNzLHRoZW5cIi5zcGxpdCgvLC9nKTtcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgUHJpbWl0aXZlLmluZGV4T2YodHlwZW9mICh2YWx1ZSkpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvLyBLZWVwIGFueSBBZGRyZXNzYWJsZVxuICAgIGlmICh0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZS5tYXAoZGVlcENvcHkpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHNob3VsZCBub3QgaGFwcGVuOiAke3ZhbHVlfSAoJHt0eXBlb2YgKHZhbHVlKX0pYCk7XG59XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTsgfSk7XG59XG5mdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzUG9sbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucG9sbGluZ0ludGVydmFsKSA9PT0gXCJudW1iZXJcIik7XG59XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBwb2xsaW5nOiBmYWxzZSxcbiAgICBzdGF0aWNOZXR3b3JrOiBudWxsLFxuICAgIGJhdGNoU3RhbGxUaW1lOiAxMCxcbiAgICBiYXRjaE1heFNpemU6ICgxIDw8IDIwKSxcbiAgICBiYXRjaE1heENvdW50OiAxMDAsXG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLy8gQFRPRE86IFVuY2hlY2tlZCBTaWduZXJzXG5jbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgYWJzdHJhY3Rfc2lnbmVyX2pzXzEuQWJzdHJhY3RTaWduZXIge1xuICAgIGFkZHJlc3M7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzIuZ2V0QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgICgwLCBpbmRleF9qc181LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnQpKGZhbHNlLCBcImNhbm5vdCByZWNvbm5lY3QgSnNvblJwY1NpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgICB9XG4gICAgLy8gSlNPTi1SUEMgd2lsbCBhdXRvbWF0aWFsbHkgZmlsbCBpbiBub25jZSwgZXRjLiBzbyB3ZSBqdXN0IGNoZWNrIGZyb21cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMganVzdCB0aGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXIgc2VudCwgd2hpY2ggaXMgd2hhdFxuICAgIC8vIHRoZSBiYXJlIEpTT04tUlBDIEFQSSBkb2VzO1xuICAgIGFzeW5jIHNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbihfdHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZyb20gbWF0Y2hlcyB0aGUgc2VuZGVyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBfZnJvbSA9IHR4LmZyb207XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKShfZnJvbSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0QXJndW1lbnQpKGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfdG8gPSB0eC50bztcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKShfdG8sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2FpdCB1bnRpbCBhbGwgb2Ygb3VyIHByb3BlcnRpZXMgYXJlIGZpbGxlZCBpblxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICAvLyBUaGlzIGNhbm5vdCBiZSBtaW5lZCBhbnkgZWFybGllciB0aGFuIGFueSByZWNlbnQgYmxvY2tcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIEpTT04tUlBDIG9ubHkgcHJvdmlkZXMgYW5kIG9wYXF1ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgIC8vIGZvciBhIHJlc3BvbnNlLCBhbmQgd2UgbmVlZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uLCBzbyB3ZSBwb2xsXG4gICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgIHJldHVybiBhd2FpdCAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dHMgPSBbMTAwMCwgMTAwXTtcbiAgICAgICAgICAgIGxldCBpbnZhbGlkcyA9IDA7XG4gICAgICAgICAgICBjb25zdCBjaGVja1R4ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHR4LnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oYmxvY2tOdW1iZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBjYW5jZWxsZWQ6IHN0b3AgcG9sbGluZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGEgaXMgYmFkOiB0aGUgbm9kZSByZXR1cm5zIGJhZCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldHdvcmsgY2hhbmdlZDogY2FsbGluZyBhZ2FpbiB3aWxsIGFsc28gZmFpbFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1bnN1cHBvcnRlZDogbGlrZWx5IGRlc3Ryb3llZFxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzUuaXNFcnJvcikoZXJyb3IsIFwiQ0FOQ0VMTEVEXCIpIHx8ICgwLCBpbmRleF9qc181LmlzRXJyb3IpKGVycm9yLCBcIkJBRF9EQVRBXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNS5pc0Vycm9yKShlcnJvciwgXCJORVRXT1JLX0VSUk9SXCIgfHwgKDAsIGluZGV4X2pzXzUuaXNFcnJvcikoZXJyb3IsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AtZ2FwIGZvciBtaXNiZWhhdmluZyBiYWNrZW5kczsgc2VlICM0NTEzXG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNS5pc0Vycm9yKShlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZHMgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbnlvbmUgdGhhdCBjYXJlczsgYnV0IHdlIHdpbGwgdHJ5IGFnYWluLCBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBsaWtlbHkgYW4gaW50ZXJtaXR0ZW50IHNlcnZpY2UgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5lbWl0KFwiZXJyb3JcIiwgKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcImZhaWxlZCB0byBmZXRjaCB0cmFuc2F0aW9uIGFmdGVyIHNlbmRpbmcgKHdpbGwgdHJ5IGFnYWluKVwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBlcnJvciB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYW5vdGhlciA0IHNlY29uZHNcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLl9zZXRUaW1lb3V0KCgpID0+IHsgY2hlY2tUeCgpOyB9LCB0aW1lb3V0cy5wb3AoKSB8fCA0MDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja1R4KCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykodHguZnJvbSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gKDAsIGluZGV4X2pzXzUudG9VdGY4Qnl0ZXMpKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgW1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuaGV4bGlmeSkobWVzc2FnZSksIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDb3B5KF92YWx1ZSk7XG4gICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXMgKGluLXBsYWNlKVxuICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSBhd2FpdCBpbmRleF9qc18zLlR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykodmFsdWUpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0QXJndW1lbnQpKGFkZHJlc3MgIT0gbnVsbCwgXCJUeXBlZERhdGEgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFkZHJlc3NcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGluZGV4X2pzXzMuVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgdW5sb2NrKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBwYXNzd29yZCwgbnVsbFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuICAgIGFzeW5jIF9sZWdhY3lTaWduTWVzc2FnZShfbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCh0eXBlb2YgKF9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyAoMCwgaW5kZXhfanNfNS50b1V0ZjhCeXRlcykoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksICgwLCBpbmRleF9qc181LmhleGxpZnkpKG1lc3NhZ2UpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblJwY1NpZ25lciA9IEpzb25ScGNTaWduZXI7XG4vKipcbiAqICBUaGUgSnNvblJwY0FwaVByb3ZpZGVyIGlzIGFuIGFic3RyYWN0IGNsYXNzIGFuZCAqKk1VU1QqKiBiZVxuICogIHN1Yi1jbGFzc2VkLlxuICpcbiAqICBJdCBwcm92aWRlcyB0aGUgYmFzZSBmb3IgYWxsIEpTT04tUlBDLWJhc2VkIFByb3ZpZGVyIGludGVyYWN0aW9uLlxuICpcbiAqICBTdWItY2xhc3NpbmcgTm90ZXM6XG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIG92ZXJyaWRlIF9zZW5kXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXG4gKi9cbmNsYXNzIEpzb25ScGNBcGlQcm92aWRlciBleHRlbmRzIGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI29wdGlvbnM7XG4gICAgLy8gVGhlIG5leHQgSUQgdG8gdXNlIGZvciB0aGUgSlNPTi1SUEMgSUQgZmllbGRcbiAgICAjbmV4dElkO1xuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXG4gICAgI3BheWxvYWRzO1xuICAgICNkcmFpblRpbWVyO1xuICAgICNub3RSZWFkeTtcbiAgICAjbmV0d29yaztcbiAgICAjcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgI3NjaGVkdWxlRHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIGJhdGNoaW5nLCBubyBoYXJtIGluIHNlbmRpbmcgaXQgaW1tZWRpYXRlbHlcbiAgICAgICAgY29uc3Qgc3RhbGxUaW1lID0gKHRoaXMuX2dldE9wdGlvbihcImJhdGNoTWF4Q291bnRcIikgPT09IDEpID8gMCA6IHRoaXMuX2dldE9wdGlvbihcImJhdGNoU3RhbGxUaW1lXCIpO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdGhpcy4jcGF5bG9hZHM7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGJhdGNoZXMgdGhhdCBzYXRpc2Z5IG91ciBiYXRjaCBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gWyhwYXlsb2Fkcy5zaGlmdCgpKV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSB0aGlzLiNvcHRpb25zLmJhdGNoTWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goKHBheWxvYWRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBKU09OLnN0cmluZ2lmeShiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy4jb3B0aW9ucy5iYXRjaE1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzLnVuc2hpZnQoKGJhdGNoLnBvcCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZXN1bHQgdG8gZWFjaCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgoYmF0Y2gubGVuZ3RoID09PSAxKSA/IGJhdGNoWzBdLnBheWxvYWQgOiBiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyByZXN1bHRzIGluIGJhdGNoIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0LCBwYXlsb2FkIH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXRjaGluZyByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gcmVzdWx0LmZpbHRlcigocikgPT4gKHIuaWQgPT09IHBheWxvYWQuaWQpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyByZXN1bHQ7IHRoZSBub2RlIGZhaWxlZCB1cyBpbiB1bmV4cGVjdGVkIHdheXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcIm1pc3NpbmcgcmVzcG9uc2UgZm9yIHJlcXVlc3RcIiwgXCJCQURfREFUQVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LCBpbmZvOiB7IHBheWxvYWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3ApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBnb29kOyBzZW5kIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3AucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWplY3QgfSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBhdWdtZW50IHRoZSBlcnJvciB3aXRoIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YWxsVGltZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI25leHRJZCA9IDE7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNub3RSZWFkeSA9IHsgcHJvbWlzZSwgcmVzb2x2ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRpY05ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xuICAgICAgICBpZiAodHlwZW9mIChzdGF0aWNOZXR3b3JrKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydEFyZ3VtZW50KSghc3RhdGljTmV0d29yayB8fCBuZXR3b3JrICE9PSBcImFueVwiLCBcInN0YXRpY05ldHdvcmsgY2Fubm90IGJlIHVzZWQgb24gc3BlY2lhbCBuZXR3b3JrICdhbnknXCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNOZXR3b3JrICYmIG5ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRpY05ldHdvcmspIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgc3RhdGljIG5ldHdvcmsgaXMgY29tcGF0YmlsZSB3aXRoIHRoZSBwcm92aWRlZCBuZXR3cm9rXG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkobmV0d29yayA9PSBudWxsIHx8IHN0YXRpY05ldHdvcmsubWF0Y2hlcyhuZXR3b3JrKSwgXCJzdGF0aWNOZXR3b3JrIE1VU1QgbWF0Y2ggbmV0d29yayBvYmplY3RcIiwgXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IHN0YXRpY05ldHdvcms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3B0aW9uICUla2V5JSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgY2FuIHVzZSB0aGlzIHRvIGlucXVpcmUgYWJvdXQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIF9nZXRPcHRpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zW2tleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXRzIHRoZSBbW05ldHdvcmtdXSB0aGlzIHByb3ZpZGVyIGhhcyBjb21taXR0ZWQgdG8uIE9uIGVhY2ggY2FsbCwgdGhlIG5ldHdvcmtcbiAgICAgKiAgaXMgZGV0ZWN0ZWQsIGFuZCBpZiBpdCBoYXMgY2hhbmdlZCwgdGhlIGNhbGwgd2lsbCByZWplY3QuXG4gICAgICovXG4gICAgZ2V0IF9uZXR3b3JrKCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnQpKHRoaXMuI25ldHdvcmssIFwibmV0d29yayBpcyBub3QgYXZhaWxhYmxlIHlldFwiLCBcIk5FVFdPUktfRVJST1JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG5vbi1ub3JtYWxpemVkIHZhbHVlIGJ5IHBlcmZvcm1pbmcgJSVyZXElJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgYmVoYXZpb3Igb2YgYWN0aW9ucyxcbiAgICAgKiAgYW5kIHNob3VsZCBnZW5lcmFsbHkgY2FsbCBgYHN1cGVyLl9wZXJmb3JtYGAgYXMgYSBmYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgbGV0IHR4ID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiAoMCwgaW5kZXhfanNfNS5nZXRCaWdJbnQpKHR4LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIEVJUC0xNTU5IHByb3BlcnRpZXMsIGl0IG1pZ2h0IGJlIG5vbi1FSVAtYTU1OVxuICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzID09IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qga25vdyBhYm91dCBFSVAtMTU1OSAoYW5kIGhlbmNlIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBPYmplY3QuYXNzaWduKHt9LCByZXEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgsIHsgdHlwZTogdW5kZWZpbmVkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5nZXRScGNSZXF1ZXN0KHJlcSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpczsgaXQgZGV0ZWN0cyB0aGUgKmFjdHVhbCogbmV0d29yayB0aGF0XG4gICAgICogIHdlIGFyZSAqKmN1cnJlbnRseSoqIGNvbm5lY3RlZCB0by5cbiAgICAgKlxuICAgICAqICBLZWVwIGluIG1pbmQgdGhhdCBbW3NlbmRdXSBtYXkgb25seSBiZSB1c2VkIG9uY2UgW1tyZWFkeV1dLCBvdGhlcndpc2UgdGhlXG4gICAgICogIF9zZW5kIHByaW1pdGl2ZSBtdXN0IGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMuX2dldE9wdGlvbihcInN0YXRpY05ldHdvcmtcIik7XG4gICAgICAgIGlmIChuZXR3b3JrKSB7XG4gICAgICAgICAgICBpZiAobmV0d29yayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSByZWFkeSwgdXNlIGBgc2VuZGBgLCB3aGljaCBlbmFibGVkIHJlcXVlc3RzIHRvIGJlIGJhdGNoZWRcbiAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKCgwLCBpbmRleF9qc181LmdldEJpZ0ludCkoYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy4jbmV4dElkKyssIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBwYXJhbXM6IFtdLCBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpKVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICBpZiAoXCJyZXN1bHRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbSgoMCwgaW5kZXhfanNfNS5nZXRCaWdJbnQpKHJlc3VsdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzdWx0KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKipNVVNUKiogY2FsbCB0aGlzLiBVbnRpbCBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2FsbHNcbiAgICAgKiAgd2lsbCBiZSBwYXNzZWQgdG8gW1tfc2VuZF1dIGZyb20gW1tzZW5kXV0uIElmIGl0IGlzIG92ZXJyaWRkZW4sIHRoZW5cbiAgICAgKiAgYGBzdXBlci5fc3RhcnQoKWBgICoqTVVTVCoqIGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqICBDYWxsaW5nIGl0IG11bHRpcGxlIHRpbWVzIGlzIHNhZmUgYW5kIGhhcyBubyBlZmZlY3QuXG4gICAgICovXG4gICAgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCB8fCB0aGlzLiNub3RSZWFkeS5yZXNvbHZlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNub3RSZWFkeS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuI25vdFJlYWR5ID0gbnVsbDtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCB0aGUgbmV0d29ya1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuI25ldHdvcmsgPT0gbnVsbCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkpzb25ScGNQcm92aWRlciBmYWlsZWQgdG8gZGV0ZWN0IG5ldHdvcmsgYW5kIGNhbm5vdCBzdGFydCB1cDsgcmV0cnkgaW4gMXMgKHBlcmhhcHMgdGhlIFVSTCBpcyB3cm9uZyBvciB0aGUgbm9kZSBpcyBub3Qgc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJmYWlsZWQgdG8gYm9vdHN0cmFwIG5ldHdvcmsgZGV0ZWN0aW9uXCIsIFwiTkVUV09SS19FUlJPUlwiLCB7IGV2ZW50OiBcImluaXRpYWwtbmV0d29yay1kaXNjb3ZlcnlcIiwgaW5mbzogeyBlcnJvciB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgZGlzcGF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIGluXG4gICAgICogIHN1Yi1jbGFzc2VzIHRvIGRlZmVyIHNlbmRpbmcgZGF0YSB1bnRpbCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqICBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25vdFJlYWR5LnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBTdWJzY3JpYmVyIHRoYXQgd2lsbCBtYW5hZ2UgdGhlICUlc3ViJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZlxuICAgICAqICBzdWJzY3JpcHRpb24gbWFuYWdlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgLy8gUGVuZGluZyBGaWx0ZXJzIGFyZW4ndCBhdmFpbGJsZSB2aWEgcG9sbGluZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfZmlsdGVyaWRfanNfMS5GaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0T3B0aW9uKFwicG9sbGluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9maWx0ZXJpZF9qc18xLkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ycGhhbmVkIExvZ3MgYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseSwgYnkgdGhlIGZpbHRlciwgc2luY2VcbiAgICAgICAgLy8gbG9ncyB3aXRoIHJlbW92ZWQgYXJlIGVtaXR0ZWQgYnkgaXRcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcIm9ycGhhblwiICYmIHN1Yi5maWx0ZXIub3JwaGFuID09PSBcImRyb3AtbG9nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5Vbm1hbmFnZWRTdWJzY3JpYmVyKFwib3JwaGFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0U3Vic2NyaWJlcihzdWIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLlxuICAgICAqL1xuICAgIGdldCByZWFkeSgpIHsgcmV0dXJuIHRoaXMuI25vdFJlYWR5ID09IG51bGw7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyAlJXR4JSUgYXMgYSBub3JtYWxpemVkIEpTT04tUlBDIHRyYW5zYWN0aW9uIHJlcXVlc3QsXG4gICAgICogIHdoaWNoIGhhcyBhbGwgdmFsdWVzIGhleGxpZmllZCBhbmQgYW55IG51bWVyaWMgdmFsdWVzIGNvbnZlcnRlZFxuICAgICAqICB0byBRdWFudGl0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0UnBjVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIEpTT04tUlBDIG5vdyByZXF1aXJlcyBudW1lcmljIHZhbHVlcyB0byBiZSBcInF1YW50aXR5XCIgdmFsdWVzXG4gICAgICAgIFtcImNoYWluSWRcIiwgXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwidHlwZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZHN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJnYXNMaW1pdFwiKSB7XG4gICAgICAgICAgICAgICAgZHN0S2V5ID0gXCJnYXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtkc3RLZXldID0gKDAsIGluZGV4X2pzXzUudG9RdWFudGl0eSkoKDAsIGluZGV4X2pzXzUuZ2V0QmlnSW50KSh0eFtrZXldLCBgdHguJHtrZXl9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFkZHJlc3NlcyBhbmQgZGF0YSBhcmUgbG93ZXJjYXNlXG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSAoMCwgaW5kZXhfanNfNS5oZXhsaWZ5KSh0eFtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYWNjZXNzIGxpc3Qgb2JqZWN0XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRbXCJhY2Nlc3NMaXN0XCJdID0gKDAsIGluZGV4X2pzXzQuYWNjZXNzTGlzdGlmeSkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHJlcXVlc3QgbWV0aG9kIGFuZCBhcmd1bWVudHMgcmVxdWlyZWQgdG8gcGVyZm9ybVxuICAgICAqICAlJXJlcSUlLlxuICAgICAqL1xuICAgIGdldFJwY1JlcXVlc3QocmVxKSB7XG4gICAgICAgIHN3aXRjaCAocmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfYmxvY2tOdW1iZXJcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2FzUHJpY2VcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRQcmlvcml0eUZlZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIjB4XCIgKyByZXEucG9zaXRpb24udG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuc2lnbmVkVHJhbnNhY3Rpb25dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tUYWcsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiYmxvY2tIYXNoXCIgaW4gcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJsb2NrQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrSGFzaCwgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuaGFzaF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuaGFzaF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2NhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMuZ2V0UnBjVHJhbnNhY3Rpb24ocmVxLnRyYW5zYWN0aW9uKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZXN0aW1hdGVHYXNcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMuZ2V0UnBjVHJhbnNhY3Rpb24ocmVxLnRyYW5zYWN0aW9uKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVxLmZpbHRlciAmJiByZXEuZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEuZmlsdGVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZmlsdGVyLmFkZHJlc3MgPSByZXEuZmlsdGVyLmFkZHJlc3MubWFwKGdldExvd2VyQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocmVxLmZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dldExvZ3NcIiwgYXJnczogW3JlcS5maWx0ZXJdIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFuIGV0aGVycy1zdHlsZSBFcnJvciBmb3IgdGhlIGdpdmVuIEpTT04tUlBDIGVycm9yXG4gICAgICogICUlcGF5bG9hZCUlLCBjb2FsZXNjaW5nIHRoZSB2YXJpb3VzIHN0cmluZ3MgYW5kIGVycm9yIHNoYXBlc1xuICAgICAqICB0aGF0IGRpZmZlcmVudCBub2RlcyByZXR1cm4sIGNvZXJjaW5nIHRoZW0gaW50byBhIG1hY2hpbmUtcmVhZGFibGVcbiAgICAgKiAgc3RhbmRhcmRpemVkIGVycm9yLlxuICAgICAqL1xuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIF9lcnJvcikge1xuICAgICAgICBjb25zdCB7IG1ldGhvZCB9ID0gcGF5bG9hZDtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gX2Vycm9yO1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiICYmIGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIW1zZy5tYXRjaCgvcmV2ZXJ0L2kpICYmIG1zZy5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogKHBheWxvYWQucGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiIHx8IG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEoZXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgZSA9IGluZGV4X2pzXzEuQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiKSA/IFwiY2FsbFwiIDogXCJlc3RpbWF0ZUdhc1wiLCAocGF5bG9hZC5wYXJhbXNbMF0pLCAocmVzdWx0ID8gcmVzdWx0LmRhdGEgOiBudWxsKSk7XG4gICAgICAgICAgICBlLmluZm8gPSB7IGVycm9yLCBwYXlsb2FkIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGVzdGltYXRlR2FzIGFuZCBjYWxsIGNhbiByZXR1cm4gYXJiaXRyYXJ5IGNvbnRyYWN0LWRlZmluZWQgdGV4dCwgc28gbm93IHdlXG4gICAgICAgIC8vIHdlIGNhbiBwcm9jZXNzIHRleHQgc2FmZWx5LlxuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoc3BlbHVua01lc3NhZ2UoZXJyb3IpKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWR8ZXRoZXJzLXVzZXItZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25NYXAgPSB7XG4gICAgICAgICAgICAgICAgZXRoX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBwZXJzb25hbF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6IFwic2lnblR5cGVkRGF0YVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IFwic2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgICAgICB3YWxsZXRfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShgdXNlciByZWplY3RlZCBhY3Rpb25gLCBcIkFDVElPTl9SRUpFQ1RFRFwiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoYWN0aW9uTWFwW21ldGhvZF0gfHwgXCJ1bmtub3duXCIpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogXCJyZWplY3RlZFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIgfHwgbWV0aG9kID09PSBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAocGF5bG9hZC5wYXJhbXNbMF0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9ub25jZS9pKSAmJiBtZXNzYWdlLm1hdGNoKC90b28gbG93L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uL2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9vbmx5IHJlcGxheS1wcm90ZWN0ZWQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcImxlZ2FjeSBwcmUtZWlwLTE1NSB0cmFuc2FjdGlvbnMgbm90IHN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogbWV0aG9kLCBpbmZvOiB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB1bnN1cHBvcnRlZCA9ICEhbWVzc2FnZS5tYXRjaCgvdGhlIG1ldGhvZCAuKiBkb2VzIG5vdCBleGlzdC9pKTtcbiAgICAgICAgaWYgKCF1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmRldGFpbHMgJiYgZXJyb3IuZGV0YWlscy5zdGFydHNXaXRoKFwiVW5hdXRob3JpemVkIG1ldGhvZDpcIikpIHtcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcInVuc3VwcG9ydGVkIG9wZXJhdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCwgaW5mbzogeyBlcnJvciwgcGF5bG9hZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcImNvdWxkIG5vdCBjb2FsZXNjZSBlcnJvclwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBlcnJvciwgcGF5bG9hZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlcXVlc3RzIHRoZSAlJW1ldGhvZCUlIHdpdGggJSVwYXJhbXMlJSB2aWEgdGhlIEpTT04tUlBDIHByb3RvY29sXG4gICAgICogIG92ZXIgdGhlIHVuZGVybHlpbmcgY2hhbm5lbC4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxsIG1ldGhvZHNcbiAgICAgKiAgb24gdGhlIGJhY2tlbmQgdGhhdCBkbyBub3QgaGF2ZSBhIGhpZ2gtbGV2ZWwgQVBJIHdpdGhpbiB0aGUgUHJvdmlkZXJcbiAgICAgKiAgQVBJLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHF1ZXVlcyByZXF1ZXN0cyBhY2NvcmRpbmcgdG8gdGhlIGJhdGNoIGNvbnN0cmFpbnRzXG4gICAgICogIGluIHRoZSBvcHRpb25zLCBhc3NpZ25zIHRoZSByZXF1ZXN0IGEgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogICoqRG8gTk9UIG92ZXJyaWRlKiogdGhpcyBtZXRob2QgaW4gc3ViLWNsYXNzZXM7IGluc3RlYWRcbiAgICAgKiAgb3ZlcnJpZGUgW1tfc2VuZF1dIG9yIGZvcmNlIHRoZSBvcHRpb25zIHZhbHVlcyBpbiB0aGVcbiAgICAgKiAgY2FsbCB0byB0aGUgY29uc3RydWN0b3IgdG8gbW9kaWZ5IHRoaXMgbWV0aG9kJ3MgYmVoYXZpb3IuXG4gICAgICovXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBAVE9ETzogY2FjaGUgY2hhaW5JZD8/IHB1cmdlIG9uIHN3aXRjaF9uZXR3b3Jrc1xuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gZGVzdHJveWVkOyBubyBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQgYW55bW9yZVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuI25leHRJZCsrO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jcGF5bG9hZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgbWV0aG9kLCBwYXJhbXMsIGlkLCBqc29ucnBjOiBcIjIuMFwiIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGEgcGVuZGluZyBkcmFpblRpbWVyLCBzZXQgb25lXG4gICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgW1tTaWduZXJdXSBhY2NvdW50IGZvciAgJSVhZGRyZXNzJSUgbWFuYWdlZCBieVxuICAgICAqICB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWFkZHJlc3MlJSBpcyBhIG51bWJlciwgaXQgaXMgdXNlZCBhcyBhbiBpbmRleCBpbiB0aGVcbiAgICAgKiAgdGhlIGFjY291bnRzIGZyb20gW1tsaXN0QWNjb3VudHNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgb24gY2xpZW50cyB3aGljaCBtYW5hZ2UgYWNjb3VudHMgKHN1Y2ggYXNcbiAgICAgKiAgR2V0aCB3aXRoIGltcG9ydGVkIGFjY291bnQgb3IgTWV0YU1hc2spLlxuICAgICAqXG4gICAgICogIFRocm93cyBpZiB0aGUgYWNjb3VudCBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnRzUHJvbWlzZSA9IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIC8vIEFjY291bnQgaW5kZXhcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gKGF3YWl0IGFjY291bnRzUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA+PSBhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIGFjY291bnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWNjb3VudHNbYWRkcmVzc10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IGF3YWl0ICgwLCBpbmRleF9qc181LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50c1Byb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFjY291bnQgYWRkcmVzc1xuICAgICAgICBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzIuZ2V0QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBhY2NvdW50cykge1xuICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc18yLmdldEFkZHJlc3MpKGFjY291bnQpID09PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWNjb3VudFwiKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEFjY291bnRzKCkge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKGEpID0+IG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGEpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBwcm9jZXNzaW5nIHJlcXVlc3RzXG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jZHJhaW5UaW1lcik7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgZm9yIChjb25zdCB7IHBheWxvYWQsIHJlamVjdCB9IG9mIHRoaXMuI3BheWxvYWRzKSB7XG4gICAgICAgICAgICByZWplY3QoKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAvLyBQYXJlbnQgY2xlYW4tdXBcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblJwY0FwaVByb3ZpZGVyID0gSnNvblJwY0FwaVByb3ZpZGVyO1xuLy8gQFRPRE86IHJlbW92ZSB0aGlzIGluIHY3LCBpdCBpcyBub3QgZXhwb3J0ZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uYWxpdHlcbi8vIGlzIGV4cG9zZWQgaW4gdGhlIEpzb25ScGNBcGlQcm92aWRlciBieSBzZXR0aW5nIHBvbGxpbmcgdG8gdHJ1ZS4gSXQgc2hvdWxkXG4vLyBiZSBzYWZlIHRvIHJlbW92ZSByZWdhcmRsZXNzLCBiZWNhdXNlIGl0IGlzbid0IHJlYWNoYWJsZSwgYnV0IGp1c3QgaW4gY2FzZS5cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5jbGFzcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVByb3ZpZGVyIHtcbiAgICAjcG9sbGluZ0ludGVydmFsO1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IDQwMDA7XG4gICAgfVxuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICAgICAgaWYgKGlzUG9sbGFibGUoc3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwgKGRlZmF1bHQ6IDQwMDAgbXMpXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI3BvbGxpbmdJbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzdWIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YikpIHtcbiAgICAgICAgICAgICAgICBzdWIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgPSBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyO1xuLyoqXG4gKiAgVGhlIEpzb25ScGNQcm92aWRlciBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9uIFByb3ZpZGVycyxcbiAqICB3aGljaCBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyBvdmVyIEhUVFAgKG9yIEhUVFBTKSByZXF1ZXN0cy5cbiAqXG4gKiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgYnkgcG9sbGluZyB0aGUgYmFja2VuZCBmb3IgdGhlIGN1cnJlbnQgYmxvY2tcbiAqICBudW1iZXI7IHdoZW4gaXQgYWR2YW5jZXMsIGFsbCBibG9jay1iYXNlIGV2ZW50cyBhcmUgdGhlbiBjaGVja2VkXG4gKiAgZm9yIHVwZGF0ZXMuXG4gKi9cbmNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNjb25uZWN0O1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IG5ldyBpbmRleF9qc181LkZldGNoUmVxdWVzdCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IHVybC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29ubmVjdC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEFsbCByZXF1ZXN0cyBhcmUgb3ZlciBIVFRQLCBzbyB3ZSBjYW4ganVzdCBzdGFydCBoYW5kbGluZyByZXF1ZXN0c1xuICAgICAgICAvLyBXZSBkbyB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gdGhlIGNvbnN0cnVjdG9yIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBhbnlcbiAgICAgICAgLy8gcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmsgKGkuZS4gZXRoX2NoYWluSWQpIHVudGlsIHdlIGFic29sdXRlbHkgaGF2ZSB0by5cbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBhIFBPU1QgY29ubmVjdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCBtZXRob2RcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX2dldENvbm5lY3Rpb24oKTtcbiAgICAgICAgcmVxdWVzdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgbGV0IHJlc3AgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3ApKSB7XG4gICAgICAgICAgICByZXNwID0gW3Jlc3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gSnNvblJwY1Byb3ZpZGVyO1xuZnVuY3Rpb24gc3BlbHVua0RhdGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgKDAsIGluZGV4X2pzXzUuaXNIZXhTdHJpbmcpKHZhbHVlLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsIGRhdGE6IHZhbHVlLmRhdGEgfTtcbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YSh2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzcGVsdW5rRGF0YShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBfc3BlbHVua01lc3NhZ2UodmFsdWVba2V5XSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfc3BlbHVua01lc3NhZ2UoSlNPTi5wYXJzZSh2YWx1ZSksIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBzcGVsdW5rTWVzc2FnZSh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItanNvbnJwYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-pocket.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-pocket.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PocketProvider = void 0;\n/**\n *  [[link-pocket]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Polygon (``matic``)\n *  - Arbitrum (``arbitrum``)\n *\n *  @_subsection: api/providers/thirdparty:Pocket  [providers-pocket]\n */\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"eth-mainnet.gateway.pokt.network\";\n        case \"goerli\":\n            return \"eth-goerli.gateway.pokt.network\";\n        case \"matic\":\n            return \"poly-mainnet.gateway.pokt.network\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai-rpc.gateway.pokt.network\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **PocketProvider** connects to the [[link-pocket]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-pocket-signup).\n */\nclass PocketProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    /**\n     *  The Application ID for the Pocket connection.\n     */\n    applicationId;\n    /**\n     *  The Application Secret for making authenticated requests\n     *  to the Pocket connection.\n     */\n    applicationSecret;\n    /**\n     *  Create a new **PocketProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n     *  API key.\n     */\n    constructor(_network, applicationId, applicationSecret) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (applicationId == null) {\n            applicationId = defaultApplicationId;\n        }\n        if (applicationSecret == null) {\n            applicationSecret = null;\n        }\n        const options = { staticNetwork: network };\n        const request = PocketProvider.getRequest(network, applicationId, applicationSecret);\n        super(request, network, options);\n        (0, index_js_1.defineProperties)(this, { applicationId, applicationSecret });\n    }\n    _getProvider(chainId) {\n        try {\n            return new PocketProvider(chainId, this.applicationId, this.applicationSecret);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%% with\n     *  %%applicationId%%.\n     */\n    static getRequest(network, applicationId, applicationSecret) {\n        if (applicationId == null) {\n            applicationId = defaultApplicationId;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/v1/lb/${applicationId}`);\n        request.allowGzip = true;\n        if (applicationSecret) {\n            request.setCredentials(\"\", applicationSecret);\n        }\n        if (applicationId === defaultApplicationId) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0, community_js_1.showThrottleMessage)(\"PocketProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationId);\n    }\n}\nexports.PocketProvider = PocketProvider;\n//# sourceMappingURL=provider-pocket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItcG9ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsbUZBQWM7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMscUdBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGlEQUFpRCxrQ0FBa0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCLFNBQVMsY0FBYztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci1wb2NrZXQuanM/NjE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9ja2V0UHJvdmlkZXIgPSB2b2lkIDA7XG4vKipcbiAqICBbW2xpbmstcG9ja2V0XV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXG4gKiAgdmFyaW91cyBibG9ja2NoYWlucyBvdmVyIEpTT04tUlBDLlxuICpcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXG4gKlxuICogIC0gRXRoZXJldW0gTWFpbm5ldCAoYGBtYWlubmV0YGApXG4gKiAgLSBHb2VybGkgVGVzdG5ldCAoYGBnb2VybGlgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OlBvY2tldCAgW3Byb3ZpZGVycy1wb2NrZXRdXG4gKi9cbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl9qc29ucnBjX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCIpO1xuY29uc3QgZGVmYXVsdEFwcGxpY2F0aW9uSWQgPSBcIjYyZTFhZDUxYjM3YjhlMDAzOTRiZGEzYlwiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGgtbWFpbm5ldC5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGgtZ29lcmxpLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seS1tYWlubmV0LmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpYy1tdW1iYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbXVtYmFpLXJwYy5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKipcbiAqICBUaGUgKipQb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstcG9ja2V0XV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1wb2NrZXQtc2lnbnVwKS5cbiAqL1xuY2xhc3MgUG9ja2V0UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY1Byb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEFwcGxpY2F0aW9uIElEIGZvciB0aGUgUG9ja2V0IGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXBwbGljYXRpb25JZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIEFwcGxpY2F0aW9uIFNlY3JldCBmb3IgbWFraW5nIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHNcbiAgICAgKiAgdG8gdGhlIFBvY2tldCBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFwcGxpY2F0aW9uU2VjcmV0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2NrZXRQcm92aWRlcioqLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQgY29ubmVjdGluZyB0byBgYG1haW5uZXRgYCB3aXRoIGEgaGlnaGx5IHRocm90dGxlZFxuICAgICAqICBBUEkga2V5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCkge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcHBsaWNhdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uSWQgPSBkZWZhdWx0QXBwbGljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBwbGljYXRpb25TZWNyZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBwbGljYXRpb25TZWNyZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IFBvY2tldFByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgYXBwbGljYXRpb25JZCwgYXBwbGljYXRpb25TZWNyZXQpO1xuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9ja2V0UHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcHBsaWNhdGlvbklkLCB0aGlzLmFwcGxpY2F0aW9uU2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSUgd2l0aFxuICAgICAqICAlJWFwcGxpY2F0aW9uSWQlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVxdWVzdChuZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCkge1xuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvbklkID0gZGVmYXVsdEFwcGxpY2F0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc18xLkZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS92MS9sYi8ke2FwcGxpY2F0aW9uSWR9YCk7XG4gICAgICAgIHJlcXVlc3QuYWxsb3dHemlwID0gdHJ1ZTtcbiAgICAgICAgaWYgKGFwcGxpY2F0aW9uU2VjcmV0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNldENyZWRlbnRpYWxzKFwiXCIsIGFwcGxpY2F0aW9uU2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCA9PT0gZGVmYXVsdEFwcGxpY2F0aW9uSWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKFwiUG9ja2V0UHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBwbGljYXRpb25JZCA9PT0gZGVmYXVsdEFwcGxpY2F0aW9uSWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9ja2V0UHJvdmlkZXIgPSBQb2NrZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLXBvY2tldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-pocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  [[link-quicknode]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Holesky Testnet (``holesky``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\n *  - Base Mainnet (``base``);\n *  - Base Goerli Testnet (``base-goerli``);\n *  - Base Sepolia Testnet (``base-sepolia``);\n *  - BNB Smart Chain Mainnet (``bnb``)\n *  - BNB Smart Chain Testnet (``bnbt``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:QuickNode  [providers-quicknode]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuickNodeProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst defaultToken = \"919b412a057b5e9c9b6dce193c5a60242d6efadb\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"ethers.quiknode.pro\";\n        case \"goerli\":\n            return \"ethers.ethereum-goerli.quiknode.pro\";\n        case \"sepolia\":\n            return \"ethers.ethereum-sepolia.quiknode.pro\";\n        case \"holesky\":\n            return \"ethers.ethereum-holesky.quiknode.pro\";\n        case \"arbitrum\":\n            return \"ethers.arbitrum-mainnet.quiknode.pro\";\n        case \"arbitrum-goerli\":\n            return \"ethers.arbitrum-goerli.quiknode.pro\";\n        case \"arbitrum-sepolia\":\n            return \"ethers.arbitrum-sepolia.quiknode.pro\";\n        case \"base\":\n            return \"ethers.base-mainnet.quiknode.pro\";\n        case \"base-goerli\":\n            return \"ethers.base-goerli.quiknode.pro\";\n        case \"base-spolia\":\n            return \"ethers.base-sepolia.quiknode.pro\";\n        case \"bnb\":\n            return \"ethers.bsc.quiknode.pro\";\n        case \"bnbt\":\n            return \"ethers.bsc-testnet.quiknode.pro\";\n        case \"matic\":\n            return \"ethers.matic.quiknode.pro\";\n        case \"matic-mumbai\":\n            return \"ethers.matic-testnet.quiknode.pro\";\n        case \"optimism\":\n            return \"ethers.optimism.quiknode.pro\";\n        case \"optimism-goerli\":\n            return \"ethers.optimism-goerli.quiknode.pro\";\n        case \"optimism-sepolia\":\n            return \"ethers.optimism-sepolia.quiknode.pro\";\n        case \"xdai\":\n            return \"ethers.xdai.quiknode.pro\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/*\n@TODO:\n  These networks are not currently present in the Network\n  default included networks. Research them and ensure they\n  are EVM compatible and work with ethers\n\n  http://ethers.matic-amoy.quiknode.pro\n\n  http://ethers.avalanche-mainnet.quiknode.pro\n  http://ethers.avalanche-testnet.quiknode.pro\n  http://ethers.blast-sepolia.quiknode.pro\n  http://ethers.celo-mainnet.quiknode.pro\n  http://ethers.fantom.quiknode.pro\n  http://ethers.imx-demo.quiknode.pro\n  http://ethers.imx-mainnet.quiknode.pro\n  http://ethers.imx-testnet.quiknode.pro\n  http://ethers.near-mainnet.quiknode.pro\n  http://ethers.near-testnet.quiknode.pro\n  http://ethers.nova-mainnet.quiknode.pro\n  http://ethers.scroll-mainnet.quiknode.pro\n  http://ethers.scroll-testnet.quiknode.pro\n  http://ethers.tron-mainnet.quiknode.pro\n  http://ethers.zkevm-mainnet.quiknode.pro\n  http://ethers.zkevm-testnet.quiknode.pro\n  http://ethers.zksync-mainnet.quiknode.pro\n  http://ethers.zksync-testnet.quiknode.pro\n*/\n/**\n *  The **QuickNodeProvider** connects to the [[link-quicknode]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API token is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-quicknode).\n */\nclass QuickNodeProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    /**\n     *  The API token.\n     */\n    token;\n    /**\n     *  Creates a new **QuickNodeProvider**.\n     */\n    constructor(_network, token) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (token == null) {\n            token = defaultToken;\n        }\n        const request = QuickNodeProvider.getRequest(network, token);\n        super(request, network, { staticNetwork: network });\n        (0, index_js_1.defineProperties)(this, { token });\n    }\n    _getProvider(chainId) {\n        try {\n            return new QuickNodeProvider(chainId, this.token);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    isCommunityResource() {\n        return (this.token === defaultToken);\n    }\n    /**\n     *  Returns a new request prepared for %%network%% and the\n     *  %%token%%.\n     */\n    static getRequest(network, token) {\n        if (token == null) {\n            token = defaultToken;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/${token}`);\n        request.allowGzip = true;\n        //if (projectSecret) { request.setCredentials(\"\", projectSecret); }\n        if (token === defaultToken) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0, community_js_1.showThrottleMessage)(\"QuickNodeProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\nexports.QuickNodeProvider = QuickNodeProvider;\n//# sourceMappingURL=provider-quicknode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItcXVpY2tub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLHVCQUF1QixtQkFBTyxDQUFDLHVGQUFnQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFELGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixHQUFHLE1BQU07QUFDL0Y7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLXF1aWNrbm9kZS5qcz8xMTk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgW1tsaW5rLXF1aWNrbm9kZV1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gSG9sZXNreSBUZXN0bmV0IChgYGhvbGVza3lgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBBcmJpdHJ1bSBHb2VybGkgVGVzdG5ldCAoYGBhcmJpdHJ1bS1nb2VybGlgYClcbiAqICAtIEFyYml0cnVtIFNlcG9saWEgVGVzdG5ldCAoYGBhcmJpdHJ1bS1zZXBvbGlhYGApXG4gKiAgLSBCYXNlIE1haW5uZXQgKGBgYmFzZWBgKTtcbiAqICAtIEJhc2UgR29lcmxpIFRlc3RuZXQgKGBgYmFzZS1nb2VybGlgYCk7XG4gKiAgLSBCYXNlIFNlcG9saWEgVGVzdG5ldCAoYGBiYXNlLXNlcG9saWFgYCk7XG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gTWFpbm5ldCAoYGBibmJgYClcbiAqICAtIEJOQiBTbWFydCBDaGFpbiBUZXN0bmV0IChgYGJuYnRgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpRdWlja05vZGUgIFtwcm92aWRlcnMtcXVpY2tub2RlXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1aWNrTm9kZVByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGNvbW11bml0eV9qc18xID0gcmVxdWlyZShcIi4vY29tbXVuaXR5LmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG5jb25zdCBkZWZhdWx0VG9rZW4gPSBcIjkxOWI0MTJhMDU3YjVlOWM5YjZkY2UxOTNjNWE2MDI0MmQ2ZWZhZGJcIjtcbmZ1bmN0aW9uIGdldEhvc3QobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuZXRoZXJldW0tZ29lcmxpLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmV0aGVyZXVtLXNlcG9saWEucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJob2xlc2t5XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuZXRoZXJldW0taG9sZXNreS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYXJiaXRydW0tbWFpbm5ldC5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmFyYml0cnVtLWdvZXJsaS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLXNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5hcmJpdHJ1bS1zZXBvbGlhLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmJhc2UtbWFpbm5ldC5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImJhc2UtZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYmFzZS1nb2VybGkucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlLXNwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmJhc2Utc2Vwb2xpYS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImJuYlwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmJzYy5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImJuYnRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5ic2MtdGVzdG5ldC5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMubWF0aWMucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpYy1tdW1iYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5tYXRpYy10ZXN0bmV0LnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5vcHRpbWlzbS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLm9wdGltaXNtLWdvZXJsaS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLXNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5vcHRpbWlzbS1zZXBvbGlhLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwieGRhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLnhkYWkucXVpa25vZGUucHJvXCI7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcbn1cbi8qXG5AVE9ETzpcbiAgVGhlc2UgbmV0d29ya3MgYXJlIG5vdCBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgTmV0d29ya1xuICBkZWZhdWx0IGluY2x1ZGVkIG5ldHdvcmtzLiBSZXNlYXJjaCB0aGVtIGFuZCBlbnN1cmUgdGhleVxuICBhcmUgRVZNIGNvbXBhdGlibGUgYW5kIHdvcmsgd2l0aCBldGhlcnNcblxuICBodHRwOi8vZXRoZXJzLm1hdGljLWFtb3kucXVpa25vZGUucHJvXG5cbiAgaHR0cDovL2V0aGVycy5hdmFsYW5jaGUtbWFpbm5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5hdmFsYW5jaGUtdGVzdG5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5ibGFzdC1zZXBvbGlhLnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLmNlbG8tbWFpbm5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5mYW50b20ucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuaW14LWRlbW8ucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuaW14LW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuaW14LXRlc3RuZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMubmVhci1tYWlubmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLm5lYXItdGVzdG5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5ub3ZhLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuc2Nyb2xsLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuc2Nyb2xsLXRlc3RuZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMudHJvbi1tYWlubmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLnprZXZtLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuemtldm0tdGVzdG5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy56a3N5bmMtbWFpbm5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy56a3N5bmMtdGVzdG5ldC5xdWlrbm9kZS5wcm9cbiovXG4vKipcbiAqICBUaGUgKipRdWlja05vZGVQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstcXVpY2tub2RlXV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIHRva2VuIGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLXF1aWNrbm9kZSkuXG4gKi9cbmNsYXNzIFF1aWNrTm9kZVByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkgdG9rZW4uXG4gICAgICovXG4gICAgdG9rZW47XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipRdWlja05vZGVQcm92aWRlcioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCB0b2tlbikge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmICh0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGRlZmF1bHRUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gUXVpY2tOb2RlUHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCB0b2tlbik7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIHsgc3RhdGljTmV0d29yazogbmV0d29yayB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyB0b2tlbiB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVpY2tOb2RlUHJvdmlkZXIoY2hhaW5JZCwgdGhpcy50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRQcm92aWRlcihjaGFpbklkKTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnRva2VuID09PSBkZWZhdWx0VG9rZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyByZXF1ZXN0IHByZXBhcmVkIGZvciAlJW5ldHdvcmslJSBhbmQgdGhlXG4gICAgICogICUldG9rZW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVxdWVzdChuZXR3b3JrLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW4gPSBkZWZhdWx0VG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc18xLkZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS8ke3Rva2VufWApO1xuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIC8vaWYgKHByb2plY3RTZWNyZXQpIHsgcmVxdWVzdC5zZXRDcmVkZW50aWFscyhcIlwiLCBwcm9qZWN0U2VjcmV0KTsgfVxuICAgICAgICBpZiAodG9rZW4gPT09IGRlZmF1bHRUb2tlbikge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSBhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICAoMCwgY29tbXVuaXR5X2pzXzEuc2hvd1Rocm90dGxlTWVzc2FnZSkoXCJRdWlja05vZGVQcm92aWRlclwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5RdWlja05vZGVQcm92aWRlciA9IFF1aWNrTm9kZVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItcXVpY2tub2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-socket.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SocketProvider = exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = void 0;\nconst abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\n/**\n *  A **SocketSubscriber** uses a socket transport to handle events and\n *  should use [[_emit]] to manage the events.\n */\nclass SocketSubscriber {\n    #provider;\n    #filter;\n    /**\n     *  The filter.\n     */\n    get filter() { return JSON.parse(this.#filter); }\n    #filterId;\n    #paused;\n    #emitPromise;\n    /**\n     *  Creates a new **SocketSubscriber** attached to %%provider%% listening\n     *  to %%filter%%.\n     */\n    constructor(provider, filter) {\n        this.#provider = provider;\n        this.#filter = JSON.stringify(filter);\n        this.#filterId = null;\n        this.#paused = null;\n        this.#emitPromise = null;\n    }\n    start() {\n        this.#filterId = this.#provider.send(\"eth_subscribe\", this.filter).then((filterId) => {\n            ;\n            this.#provider._register(filterId, this);\n            return filterId;\n        });\n    }\n    stop() {\n        (this.#filterId).then((filterId) => {\n            this.#provider.send(\"eth_unsubscribe\", [filterId]);\n        });\n        this.#filterId = null;\n    }\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n    pause(dropWhilePaused) {\n        (0, index_js_1.assert)(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", { operation: \"pause(false)\" });\n        this.#paused = !!dropWhilePaused;\n    }\n    resume() {\n        this.#paused = null;\n    }\n    /**\n     *  @_ignore:\n     */\n    _handleMessage(message) {\n        if (this.#filterId == null) {\n            return;\n        }\n        if (this.#paused === null) {\n            let emitPromise = this.#emitPromise;\n            if (emitPromise == null) {\n                emitPromise = this._emit(this.#provider, message);\n            }\n            else {\n                emitPromise = emitPromise.then(async () => {\n                    await this._emit(this.#provider, message);\n                });\n            }\n            this.#emitPromise = emitPromise.then(() => {\n                if (this.#emitPromise === emitPromise) {\n                    this.#emitPromise = null;\n                }\n            });\n        }\n    }\n    /**\n     *  Sub-classes **must** override this to emit the events on the\n     *  provider.\n     */\n    async _emit(provider, message) {\n        throw new Error(\"sub-classes must implemente this; _emit\");\n    }\n}\nexports.SocketSubscriber = SocketSubscriber;\n/**\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n *  ``\"block\"`` events.\n */\nclass SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider) {\n        super(provider, [\"newHeads\"]);\n    }\n    async _emit(provider, message) {\n        provider.emit(\"block\", parseInt(message.number));\n    }\n}\nexports.SocketBlockSubscriber = SocketBlockSubscriber;\n/**\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\n *  ``\"pending\"`` events.\n */\nclass SocketPendingSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider) {\n        super(provider, [\"newPendingTransactions\"]);\n    }\n    async _emit(provider, message) {\n        provider.emit(\"pending\", message);\n    }\n}\nexports.SocketPendingSubscriber = SocketPendingSubscriber;\n/**\n *  A **SocketEventSubscriber** listens for event logs.\n */\nclass SocketEventSubscriber extends SocketSubscriber {\n    #logFilter;\n    /**\n     *  The filter.\n     */\n    get logFilter() { return JSON.parse(this.#logFilter); }\n    /**\n     *  @_ignore:\n     */\n    constructor(provider, filter) {\n        super(provider, [\"logs\", filter]);\n        this.#logFilter = JSON.stringify(filter);\n    }\n    async _emit(provider, message) {\n        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n    }\n}\nexports.SocketEventSubscriber = SocketEventSubscriber;\n/**\n *  A **SocketProvider** is backed by a long-lived connection over a\n *  socket, which can subscribe and receive real-time messages over\n *  its communication channel.\n */\nclass SocketProvider extends provider_jsonrpc_js_1.JsonRpcApiProvider {\n    #callbacks;\n    // Maps each filterId to its subscriber\n    #subs;\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    #pending;\n    /**\n     *  Creates a new **SocketProvider** connected to %%network%%.\n     *\n     *  If unspecified, the network will be discovered.\n     */\n    constructor(network, _options) {\n        // Copy the options\n        const options = Object.assign({}, (_options != null) ? _options : {});\n        // Support for batches is generally not supported for\n        // connection-base providers; if this changes in the future\n        // the _send should be updated to reflect this\n        (0, index_js_1.assertArgument)(options.batchMaxCount == null || options.batchMaxCount === 1, \"sockets-based providers do not support batches\", \"options.batchMaxCount\", _options);\n        options.batchMaxCount = 1;\n        // Socket-based Providers (generally) cannot change their network,\n        // since they have a long-lived connection; but let people override\n        // this if they have just cause.\n        if (options.staticNetwork == null) {\n            options.staticNetwork = true;\n        }\n        super(network, options);\n        this.#callbacks = new Map();\n        this.#subs = new Map();\n        this.#pending = new Map();\n    }\n    // This value is only valid after _start has been called\n    /*\n    get _network(): Network {\n        if (this.#network == null) {\n            throw new Error(\"this shouldn't happen\");\n        }\n        return this.#network.clone();\n    }\n    */\n    _getSubscriber(sub) {\n        switch (sub.type) {\n            case \"close\":\n                return new abstract_provider_js_1.UnmanagedSubscriber(\"close\");\n            case \"block\":\n                return new SocketBlockSubscriber(this);\n            case \"pending\":\n                return new SocketPendingSubscriber(this);\n            case \"event\":\n                return new SocketEventSubscriber(this, sub.filter);\n            case \"orphan\":\n                // Handled auto-matically within AbstractProvider\n                // when the log.removed = true\n                if (sub.filter.orphan === \"drop-log\") {\n                    return new abstract_provider_js_1.UnmanagedSubscriber(\"drop-log\");\n                }\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Register a new subscriber. This is used internalled by Subscribers\n     *  and generally is unecessary unless extending capabilities.\n     */\n    _register(filterId, subscriber) {\n        this.#subs.set(filterId, subscriber);\n        const pending = this.#pending.get(filterId);\n        if (pending) {\n            for (const message of pending) {\n                subscriber._handleMessage(message);\n            }\n            this.#pending.delete(filterId);\n        }\n    }\n    async _send(payload) {\n        // WebSocket provider doesn't accept batches\n        (0, index_js_1.assertArgument)(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n        // @TODO: stringify payloads here and store to prevent mutations\n        // Prepare a promise to respond to\n        const promise = new Promise((resolve, reject) => {\n            this.#callbacks.set(payload.id, { payload, resolve, reject });\n        });\n        // Wait until the socket is connected before writing to it\n        await this._waitUntilReady();\n        // Write the request to the socket\n        await this._write(JSON.stringify(payload));\n        return [await promise];\n    }\n    // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n\n        for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n\n        this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */\n    /**\n     *  Sub-classes **must** call this with messages received over their\n     *  transport to be processed and dispatched.\n     */\n    async _processMessage(message) {\n        const result = (JSON.parse(message));\n        if (result && typeof (result) === \"object\" && \"id\" in result) {\n            const callback = this.#callbacks.get(result.id);\n            if (callback == null) {\n                this.emit(\"error\", (0, index_js_1.makeError)(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\n                    reasonCode: \"UNKNOWN_ID\",\n                    result\n                }));\n                return;\n            }\n            this.#callbacks.delete(result.id);\n            callback.resolve(result);\n        }\n        else if (result && result.method === \"eth_subscription\") {\n            const filterId = result.params.subscription;\n            const subscriber = this.#subs.get(filterId);\n            if (subscriber) {\n                subscriber._handleMessage(result.params.result);\n            }\n            else {\n                let pending = this.#pending.get(filterId);\n                if (pending == null) {\n                    pending = [];\n                    this.#pending.set(filterId, pending);\n                }\n                pending.push(result.params.result);\n            }\n        }\n        else {\n            this.emit(\"error\", (0, index_js_1.makeError)(\"received unexpected message\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNEXPECTED_MESSAGE\",\n                result\n            }));\n            return;\n        }\n    }\n    /**\n     *  Sub-classes **must** override this to send %%message%% over their\n     *  transport.\n     */\n    async _write(message) {\n        throw new Error(\"sub-classes must override this\");\n    }\n}\nexports.SocketProvider = SocketProvider;\n//# sourceMappingURL=provider-socket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItc29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsNkJBQTZCLEdBQUcsK0JBQStCLEdBQUcsNkJBQTZCLEdBQUcsd0JBQXdCO0FBQ25KLCtCQUErQixtQkFBTyxDQUFDLHVHQUF3QjtBQUMvRCxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUMsOEJBQThCLG1CQUFPLENBQUMscUdBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0ksMkJBQTJCO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQztBQUM1RTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLXNvY2tldC5qcz8xYjMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgR2VuZXJpYyBsb25nLWxpdmVkIHNvY2tldCBwcm92aWRlci5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIG5vdGVzXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIG92ZXJyaWRlIHRoZSBgX3dyaXRlKHN0cmluZylgIG1ldGhvZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIGBfcHJvY2Vzc01lc3NhZ2Uoc3RyaW5nKWAgZm9yIGVhY2ggbWVzc2FnZVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6U29ja2V0IFByb3ZpZGVycyAgW2Fib3V0LXNvY2tldFByb3ZpZGVyXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5Tb2NrZXRFdmVudFN1YnNjcmliZXIgPSBleHBvcnRzLlNvY2tldFBlbmRpbmdTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRCbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLlNvY2tldFN1YnNjcmliZXIgPSB2b2lkIDA7XG5jb25zdCBhYnN0cmFjdF9wcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbi8qKlxuICogIEEgKipTb2NrZXRTdWJzY3JpYmVyKiogdXNlcyBhIHNvY2tldCB0cmFuc3BvcnQgdG8gaGFuZGxlIGV2ZW50cyBhbmRcbiAqICBzaG91bGQgdXNlIFtbX2VtaXRdXSB0byBtYW5hZ2UgdGhlIGV2ZW50cy5cbiAqL1xuY2xhc3MgU29ja2V0U3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaWx0ZXIuXG4gICAgICovXG4gICAgZ2V0IGZpbHRlcigpIHsgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jZmlsdGVyKTsgfVxuICAgICNmaWx0ZXJJZDtcbiAgICAjcGF1c2VkO1xuICAgICNlbWl0UHJvbWlzZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNvY2tldFN1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUgbGlzdGVuaW5nXG4gICAgICogIHRvICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBKU09OLnN0cmluZ2lmeShmaWx0ZXIpO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuI2VtaXRQcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkID0gdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF9zdWJzY3JpYmVcIiwgdGhpcy5maWx0ZXIpLnRoZW4oKGZpbHRlcklkKSA9PiB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVnaXN0ZXIoZmlsdGVySWQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgKHRoaXMuI2ZpbHRlcklkKS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF91bnN1YnNjcmliZVwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQFRPRE86IHBhdXNlIHNob3VsZCB0cmFwIHRoZSBjdXJyZW50IGJsb2NrTnVtYmVyLCB1bnN1YiwgYW5kIG9uIHJlc3VtZSB1c2UgZ2V0TG9nc1xuICAgIC8vICAgICAgICBhbmQgcmVzdW1lXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZHJvcFdoaWxlUGF1c2VkLCBcInByZXNlcnZlIGxvZ3Mgd2hpbGUgcGF1c2VkIG5vdCBzdXBwb3J0ZWQgYnkgU29ja2V0U3Vic2NyaWJlciB5ZXRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicGF1c2UoZmFsc2UpXCIgfSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGVtaXRQcm9taXNlID0gdGhpcy4jZW1pdFByb21pc2U7XG4gICAgICAgICAgICBpZiAoZW1pdFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVtaXRQcm9taXNlID0gdGhpcy5fZW1pdCh0aGlzLiNwcm92aWRlciwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0UHJvbWlzZSA9IGVtaXRQcm9taXNlLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0KHRoaXMuI3Byb3ZpZGVyLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2VtaXRQcm9taXNlID0gZW1pdFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2VtaXRQcm9taXNlID09PSBlbWl0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNlbWl0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gZW1pdCB0aGUgZXZlbnRzIG9uIHRoZVxuICAgICAqICBwcm92aWRlci5cbiAgICAgKi9cbiAgICBhc3luYyBfZW1pdChwcm92aWRlciwgbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudGUgdGhpczsgX2VtaXRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXRTdWJzY3JpYmVyID0gU29ja2V0U3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipTb2NrZXRCbG9ja1N1YnNjcmliZXIqKiBsaXN0ZW5zIGZvciBgYG5ld0hlYWRzYGAgZXZlbnRzIGFuZCBlbWl0c1xuICogIGBgXCJibG9ja1wiYGAgZXZlbnRzLlxuICovXG5jbGFzcyBTb2NrZXRCbG9ja1N1YnNjcmliZXIgZXh0ZW5kcyBTb2NrZXRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIsIFtcIm5ld0hlYWRzXCJdKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvdmlkZXIuZW1pdChcImJsb2NrXCIsIHBhcnNlSW50KG1lc3NhZ2UubnVtYmVyKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXRCbG9ja1N1YnNjcmliZXIgPSBTb2NrZXRCbG9ja1N1YnNjcmliZXI7XG4vKipcbiAqICBBICoqU29ja2V0UGVuZGluZ1N1YnNjcmliZXIqKiBsaXN0ZW5zIGZvciBwZW5kaW5nIHRyYW5zYWNpdG9ucyBhbmQgZW1pdHNcbiAqICBgYFwicGVuZGluZ1wiYGAgZXZlbnRzLlxuICovXG5jbGFzcyBTb2NrZXRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIFNvY2tldFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlciwgW1wibmV3UGVuZGluZ1RyYW5zYWN0aW9uc1wiXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0KHByb3ZpZGVyLCBtZXNzYWdlKSB7XG4gICAgICAgIHByb3ZpZGVyLmVtaXQoXCJwZW5kaW5nXCIsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0UGVuZGluZ1N1YnNjcmliZXIgPSBTb2NrZXRQZW5kaW5nU3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipTb2NrZXRFdmVudFN1YnNjcmliZXIqKiBsaXN0ZW5zIGZvciBldmVudCBsb2dzLlxuICovXG5jbGFzcyBTb2NrZXRFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBTb2NrZXRTdWJzY3JpYmVyIHtcbiAgICAjbG9nRmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmlsdGVyLlxuICAgICAqL1xuICAgIGdldCBsb2dGaWx0ZXIoKSB7IHJldHVybiBKU09OLnBhcnNlKHRoaXMuI2xvZ0ZpbHRlcik7IH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlciwgW1wibG9nc1wiLCBmaWx0ZXJdKTtcbiAgICAgICAgdGhpcy4jbG9nRmlsdGVyID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLmxvZ0ZpbHRlciwgcHJvdmlkZXIuX3dyYXBMb2cobWVzc2FnZSwgcHJvdmlkZXIuX25ldHdvcmspKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldEV2ZW50U3Vic2NyaWJlciA9IFNvY2tldEV2ZW50U3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipTb2NrZXRQcm92aWRlcioqIGlzIGJhY2tlZCBieSBhIGxvbmctbGl2ZWQgY29ubmVjdGlvbiBvdmVyIGFcbiAqICBzb2NrZXQsIHdoaWNoIGNhbiBzdWJzY3JpYmUgYW5kIHJlY2VpdmUgcmVhbC10aW1lIG1lc3NhZ2VzIG92ZXJcbiAqICBpdHMgY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICovXG5jbGFzcyBTb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjQXBpUHJvdmlkZXIge1xuICAgICNjYWxsYmFja3M7XG4gICAgLy8gTWFwcyBlYWNoIGZpbHRlcklkIHRvIGl0cyBzdWJzY3JpYmVyXG4gICAgI3N1YnM7XG4gICAgLy8gSWYgYW55IGV2ZW50cyBjb21lIGluIGJlZm9yZSBhIHN1YnNjcmliZXIgaGFzIGZpbmlzaGVkXG4gICAgLy8gcmVnaXN0ZXJpbmcsIHF1ZXVlIHRoZW1cbiAgICAjcGVuZGluZztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNvY2tldFByb3ZpZGVyKiogY29ubmVjdGVkIHRvICUlbmV0d29yayUlLlxuICAgICAqXG4gICAgICogIElmIHVuc3BlY2lmaWVkLCB0aGUgbmV0d29yayB3aWxsIGJlIGRpc2NvdmVyZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmV0d29yaywgX29wdGlvbnMpIHtcbiAgICAgICAgLy8gQ29weSB0aGUgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgKF9vcHRpb25zICE9IG51bGwpID8gX29wdGlvbnMgOiB7fSk7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIGJhdGNoZXMgaXMgZ2VuZXJhbGx5IG5vdCBzdXBwb3J0ZWQgZm9yXG4gICAgICAgIC8vIGNvbm5lY3Rpb24tYmFzZSBwcm92aWRlcnM7IGlmIHRoaXMgY2hhbmdlcyBpbiB0aGUgZnV0dXJlXG4gICAgICAgIC8vIHRoZSBfc2VuZCBzaG91bGQgYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoaXNcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKG9wdGlvbnMuYmF0Y2hNYXhDb3VudCA9PSBudWxsIHx8IG9wdGlvbnMuYmF0Y2hNYXhDb3VudCA9PT0gMSwgXCJzb2NrZXRzLWJhc2VkIHByb3ZpZGVycyBkbyBub3Qgc3VwcG9ydCBiYXRjaGVzXCIsIFwib3B0aW9ucy5iYXRjaE1heENvdW50XCIsIF9vcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5iYXRjaE1heENvdW50ID0gMTtcbiAgICAgICAgLy8gU29ja2V0LWJhc2VkIFByb3ZpZGVycyAoZ2VuZXJhbGx5KSBjYW5ub3QgY2hhbmdlIHRoZWlyIG5ldHdvcmssXG4gICAgICAgIC8vIHNpbmNlIHRoZXkgaGF2ZSBhIGxvbmctbGl2ZWQgY29ubmVjdGlvbjsgYnV0IGxldCBwZW9wbGUgb3ZlcnJpZGVcbiAgICAgICAgLy8gdGhpcyBpZiB0aGV5IGhhdmUganVzdCBjYXVzZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhdGljTmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN0YXRpY05ldHdvcmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNjYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3N1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BlbmRpbmcgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8vIFRoaXMgdmFsdWUgaXMgb25seSB2YWxpZCBhZnRlciBfc3RhcnQgaGFzIGJlZW4gY2FsbGVkXG4gICAgLypcbiAgICBnZXQgX25ldHdvcmsoKTogTmV0d29yayB7XG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRoaXMgc2hvdWxkbid0IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yay5jbG9uZSgpO1xuICAgIH1cbiAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuVW5tYW5hZ2VkU3Vic2NyaWJlcihcImNsb3NlXCIpO1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTb2NrZXRCbG9ja1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU29ja2V0UGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvY2tldEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJvcnBoYW5cIjpcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGVkIGF1dG8tbWF0aWNhbGx5IHdpdGhpbiBBYnN0cmFjdFByb3ZpZGVyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgbG9nLnJlbW92ZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5maWx0ZXIub3JwaGFuID09PSBcImRyb3AtbG9nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhYnN0cmFjdF9wcm92aWRlcl9qc18xLlVubWFuYWdlZFN1YnNjcmliZXIoXCJkcm9wLWxvZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZWdpc3RlciBhIG5ldyBzdWJzY3JpYmVyLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxsZWQgYnkgU3Vic2NyaWJlcnNcbiAgICAgKiAgYW5kIGdlbmVyYWxseSBpcyB1bmVjZXNzYXJ5IHVubGVzcyBleHRlbmRpbmcgY2FwYWJpbGl0aWVzLlxuICAgICAqL1xuICAgIF9yZWdpc3RlcihmaWx0ZXJJZCwgc3Vic2NyaWJlcikge1xuICAgICAgICB0aGlzLiNzdWJzLnNldChmaWx0ZXJJZCwgc3Vic2NyaWJlcik7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLiNwZW5kaW5nLmdldChmaWx0ZXJJZCk7XG4gICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGVuZGluZykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuX2hhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNwZW5kaW5nLmRlbGV0ZShmaWx0ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICAvLyBXZWJTb2NrZXQgcHJvdmlkZXIgZG9lc24ndCBhY2NlcHQgYmF0Y2hlc1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoIUFycmF5LmlzQXJyYXkocGF5bG9hZCksIFwiV2ViU29ja2V0IGRvZXMgbm90IHN1cHBvcnQgYmF0Y2ggc2VuZFwiLCBcInBheWxvYWRcIiwgcGF5bG9hZCk7XG4gICAgICAgIC8vIEBUT0RPOiBzdHJpbmdpZnkgcGF5bG9hZHMgaGVyZSBhbmQgc3RvcmUgdG8gcHJldmVudCBtdXRhdGlvbnNcbiAgICAgICAgLy8gUHJlcGFyZSBhIHByb21pc2UgdG8gcmVzcG9uZCB0b1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jY2FsbGJhY2tzLnNldChwYXlsb2FkLmlkLCB7IHBheWxvYWQsIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhaXQgdW50aWwgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYmVmb3JlIHdyaXRpbmcgdG8gaXRcbiAgICAgICAgYXdhaXQgdGhpcy5fd2FpdFVudGlsUmVhZHkoKTtcbiAgICAgICAgLy8gV3JpdGUgdGhlIHJlcXVlc3QgdG8gdGhlIHNvY2tldFxuICAgICAgICBhd2FpdCB0aGlzLl93cml0ZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIHJldHVybiBbYXdhaXQgcHJvbWlzZV07XG4gICAgfVxuICAgIC8vIFN1Yi1jbGFzc2VzIG11c3QgY2FsbCB0aGlzIG9uY2UgdGhleSBhcmUgY29ubmVjdGVkXG4gICAgLypcbiAgICBhc3luYyBfc3RhcnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh0aGlzLiNyZWFkeSkgeyByZXR1cm47IH1cblxuICAgICAgICBmb3IgKGNvbnN0IHsgcGF5bG9hZCB9IG9mIHRoaXMuI2NhbGxiYWNrcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fd3JpdGUoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jcmVhZHkgPSAoYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhd2FpdCBzdXBlci5fc3RhcnQoKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCB0aGlzIHdpdGggbWVzc2FnZXMgcmVjZWl2ZWQgb3ZlciB0aGVpclxuICAgICAqICB0cmFuc3BvcnQgdG8gYmUgcHJvY2Vzc2VkIGFuZCBkaXNwYXRjaGVkLlxuICAgICAqL1xuICAgIGFzeW5jIF9wcm9jZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChKU09OLnBhcnNlKG1lc3NhZ2UpKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgKHJlc3VsdCkgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLiNjYWxsYmFja3MuZ2V0KHJlc3VsdC5pZCk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsICgwLCBpbmRleF9qc18xLm1ha2VFcnJvcikoXCJyZWNlaXZlZCByZXN1bHQgZm9yIHVua25vd24gaWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uQ29kZTogXCJVTktOT1dOX0lEXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYWxsYmFja3MuZGVsZXRlKHJlc3VsdC5pZCk7XG4gICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ICYmIHJlc3VsdC5tZXRob2QgPT09IFwiZXRoX3N1YnNjcmlwdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IHJlc3VsdC5wYXJhbXMuc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuI3N1YnMuZ2V0KGZpbHRlcklkKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5faGFuZGxlTWVzc2FnZShyZXN1bHQucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcGVuZGluZyA9IHRoaXMuI3BlbmRpbmcuZ2V0KGZpbHRlcklkKTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZy5zZXQoZmlsdGVySWQsIHBlbmRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZW5kaW5nLnB1c2gocmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgKDAsIGluZGV4X2pzXzEubWFrZUVycm9yKShcInJlY2VpdmVkIHVuZXhwZWN0ZWQgbWVzc2FnZVwiLCBcIlVOS05PV05fRVJST1JcIiwge1xuICAgICAgICAgICAgICAgIHJlYXNvbkNvZGU6IFwiVU5FWFBFQ1RFRF9NRVNTQUdFXCIsXG4gICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gc2VuZCAlJW1lc3NhZ2UlJSBvdmVyIHRoZWlyXG4gICAgICogIHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBhc3luYyBfd3JpdGUobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXRQcm92aWRlciA9IFNvY2tldFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItc29ja2V0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-websocket.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebSocketProvider = void 0;\nconst ws_js_1 = __webpack_require__(/*! ./ws.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/ws.js\"); /*-browser*/\nconst provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\");\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */\nclass WebSocketProvider extends provider_socket_js_1.SocketProvider {\n    #connect;\n    #websocket;\n    get websocket() {\n        if (this.#websocket == null) {\n            throw new Error(\"websocket closed\");\n        }\n        return this.#websocket;\n    }\n    constructor(url, network, options) {\n        super(network, options);\n        if (typeof (url) === \"string\") {\n            this.#connect = () => { return new ws_js_1.WebSocket(url); };\n            this.#websocket = this.#connect();\n        }\n        else if (typeof (url) === \"function\") {\n            this.#connect = url;\n            this.#websocket = url();\n        }\n        else {\n            this.#connect = null;\n            this.#websocket = url;\n        }\n        this.websocket.onopen = async () => {\n            try {\n                await this._start();\n                this.resume();\n            }\n            catch (error) {\n                console.log(\"failed to start WebsocketProvider\", error);\n                // @TODO: now what? Attempt reconnect?\n            }\n        };\n        this.websocket.onmessage = (message) => {\n            this._processMessage(message.data);\n        };\n        /*\n                this.websocket.onclose = (event) => {\n                    // @TODO: What event.code should we reconnect on?\n                    const reconnect = false;\n                    if (reconnect) {\n                        this.pause(true);\n                        if (this.#connect) {\n                            this.#websocket = this.#connect();\n                            this.#websocket.onopen = ...\n                            // @TODO: this requires the super class to rebroadcast; move it there\n                        }\n                        this._reconnect();\n                    }\n                };\n        */\n    }\n    async _write(message) {\n        this.websocket.send(message);\n    }\n    async destroy() {\n        if (this.#websocket != null) {\n            this.#websocket.close();\n            this.#websocket = null;\n        }\n        super.destroy();\n    }\n}\nexports.WebSocketProvider = WebSocketProvider;\n//# sourceMappingURL=provider-websocket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBUyxHQUFHO0FBQ3BDLDZCQUE2QixtQkFBTyxDQUFDLG1HQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItd2Vic29ja2V0LmpzPzZmMmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgd3NfanNfMSA9IHJlcXVpcmUoXCIuL3dzLmpzXCIpOyAvKi1icm93c2VyKi9cbmNvbnN0IHByb3ZpZGVyX3NvY2tldF9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItc29ja2V0LmpzXCIpO1xuLyoqXG4gKiAgQSBKU09OLVJQQyBwcm92aWRlciB3aGljaCBpcyBiYWNrZWQgYnkgYSBXZWJTb2NrZXQuXG4gKlxuICogIFdlYlNvY2tldHMgYXJlIG9mdGVuIHByZWZlcnJlZCBiZWNhdXNlIHRoZXkgcmV0YWluIGEgbGl2ZSBjb25uZWN0aW9uXG4gKiAgdG8gYSBzZXJ2ZXIsIHdoaWNoIHBlcm1pdHMgbW9yZSBpbnN0YW50IGFjY2VzcyB0byBldmVudHMuXG4gKlxuICogIEhvd2V2ZXIsIHRoaXMgaW5jdXJzIGhpZ2hlciBzZXJ2ZXIgaW5mcmFzdHVydHVyZSBjb3N0cywgc28gYWRkaXRpb25hbFxuICogIHJlc291cmNlcyBtYXkgYmUgcmVxdWlyZWQgdG8gaG9zdCB5b3VyIG93biBXZWJTb2NrZXQgbm9kZXMgYW5kIG1hbnlcbiAqICB0aGlyZC1wYXJ0eSBzZXJ2aWNlcyBjaGFyZ2UgYWRkaXRpb25hbCBmZWVzIGZvciBXZWJTb2NrZXQgZW5kcG9pbnRzLlxuICovXG5jbGFzcyBXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX3NvY2tldF9qc18xLlNvY2tldFByb3ZpZGVyIHtcbiAgICAjY29ubmVjdDtcbiAgICAjd2Vic29ja2V0O1xuICAgIGdldCB3ZWJzb2NrZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLiN3ZWJzb2NrZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2Vic29ja2V0IGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd2Vic29ja2V0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSAoKSA9PiB7IHJldHVybiBuZXcgd3NfanNfMS5XZWJTb2NrZXQodXJsKTsgfTtcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldCA9IHRoaXMuI2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHVybCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldCA9IHVybCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25vcGVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBzdGFydCBXZWJzb2NrZXRQcm92aWRlclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IG5vdyB3aGF0PyBBdHRlbXB0IHJlY29ubmVjdD9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2hhdCBldmVudC5jb2RlIHNob3VsZCB3ZSByZWNvbm5lY3Qgb24/XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSB0aGlzLiNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0Lm9ub3BlbiA9IC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiB0aGlzIHJlcXVpcmVzIHRoZSBzdXBlciBjbGFzcyB0byByZWJyb2FkY2FzdDsgbW92ZSBpdCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAqL1xuICAgIH1cbiAgICBhc3luYyBfd3JpdGUobWVzc2FnZSkge1xuICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy4jd2Vic29ja2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJTb2NrZXRQcm92aWRlciA9IFdlYlNvY2tldFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItd2Vic29ja2V0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/provider.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.Block = exports.copyRequest = exports.FeeData = void 0;\n//import { resolveAddress } from \"@ethersproject/address\";\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nclass FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    gasPrice;\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of heavy load\n     *  and lowering when less busy.\n     *\n     *  The actual fee per gas will be the base fee for the block\n     *  and the priority fee, up to the max fee per gas.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxFeePerGas;\n    /**\n     *  The additional amout to pay per gas to encourage a validator\n     *  to include the transaction.\n     *\n     *  The purpose of this is to compensate the validator for the\n     *  adjusted risk for including a given transaction.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\n        (0, index_js_1.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\n        };\n    }\n}\nexports.FeeData = FeeData;\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */\nfunction copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0, index_js_1.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0, index_js_1.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0, index_js_1.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0, index_js_2.accessListify)(req.accessList);\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    return result;\n}\nexports.copyRequest = copyRequest;\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nclass Block {\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  sequential number that is one higher than the parent block.\n     */\n    number;\n    /**\n     *  The block hash.\n     *\n     *  This hash includes all properties, so can be safely used to identify\n     *  an exact set of block properties.\n     */\n    hash;\n    /**\n     *  The timestamp for this block, which is the number of seconds since\n     *  epoch that this block was included.\n     */\n    timestamp;\n    /**\n     *  The block hash of the parent block.\n     */\n    parentHash;\n    /**\n     *  The hash tree root of the parent beacon block for the given\n     *  execution block. See [[link-eip-4788]].\n     */\n    parentBeaconBlockRoot;\n    /**\n     *  The nonce.\n     *\n     *  On legacy networks, this is the random number inserted which\n     *  permitted the difficulty target to be reached.\n     */\n    nonce;\n    /**\n     *  The difficulty target.\n     *\n     *  On legacy networks, this is the proof-of-work target required\n     *  for a block to meet the protocol rules to be included.\n     *\n     *  On modern networks, this is a random number arrived at using\n     *  randao.  @TODO: Find links?\n     */\n    difficulty;\n    /**\n     *  The total gas limit for this block.\n     */\n    gasLimit;\n    /**\n     *  The total gas used in this block.\n     */\n    gasUsed;\n    /**\n     *  The root hash for the global state after applying changes\n     *  in this block.\n     */\n    stateRoot;\n    /**\n     *  The hash of the transaction receipts trie.\n     */\n    receiptsRoot;\n    /**\n     *  The total amount of blob gas consumed by the transactions\n     *  within the block. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The running total of blob gas consumed in excess of the\n     *  target, prior to the block. See [[link-eip-4844]].\n     */\n    excessBlobGas;\n    /**\n     *  The miner coinbase address, wihch receives any subsidies for\n     *  including this block.\n     */\n    miner;\n    /**\n     *  Any extra data the validator wished to include.\n     */\n    extraData;\n    /**\n     *  The base fee per gas that all transactions in this block were\n     *  charged.\n     *\n     *  This adjusts after each block, depending on how congested the network\n     *  is.\n     */\n    baseFeePerGas;\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */\n    constructor(block, provider) {\n        this.#transactions = block.transactions.map((tx) => {\n            if (typeof (tx) !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0, index_js_1.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot,\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */\n    get transactions() {\n        return this.#transactions.map((tx) => {\n            if (typeof (tx) === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */\n    get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0, index_js_1.assert)(typeof (txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash, miner, nonce, number, parentHash, timestamp,\n            parentBeaconBlockRoot, stateRoot, receiptsRoot,\n            transactions,\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return {\n                        value: txs[index++], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */\n    get length() { return this.#transactions.length; }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */\n    get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */\n    async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof (indexOrHash) === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        }\n        else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions) {\n                if (typeof (v) === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n                else {\n                    if (v.hash === hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof (tx) === \"string\") {\n            return (await this.provider.getTransaction(tx));\n        }\n        else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */\n    getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof (indexOrHash) === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs) {\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0, index_js_1.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */\n    isMined() { return !!this.hash; }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */\n    isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */\n    orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\nexports.Block = Block;\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */\nclass Log {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransaction]] to get the [[TransactionResponse]].\n     */\n    transactionHash;\n    /**\n     *  The block hash of the block this log occurred in. Use the\n     *  [[Log-getBlock]] to get the [[Block]].\n     */\n    blockHash;\n    /**\n     *  The block number of the block this log occurred in. It is preferred\n     *  to use the [[Block-hash]] when fetching the related [[Block]],\n     *  since in the case of an orphaned block, the block at that height may\n     *  have changed.\n     */\n    blockNumber;\n    /**\n     *  If the **Log** represents a block that was removed due to an orphaned\n     *  block, this will be true.\n     *\n     *  This can only happen within an orphan event listener.\n     */\n    removed;\n    /**\n     *  The address of the contract that emitted this log.\n     */\n    address;\n    /**\n     *  The data included in this log when it was emitted.\n     */\n    data;\n    /**\n     *  The indexed topics included in this log when it was emitted.\n     *\n     *  All topics are included in the bloom filters, so they can be\n     *  efficiently filtered using the [[Provider-getLogs]] method.\n     */\n    topics;\n    /**\n     *  The index within the block this log occurred at. This is generally\n     *  not useful to developers, but can be used with the various roots\n     *  to proof inclusion within a block.\n     */\n    index;\n    /**\n     *  The index within the transaction of this log.\n     */\n    transactionIndex;\n    /**\n     *  @_ignore:\n     */\n    constructor(log, provider) {\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0, index_js_1.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex,\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */\n    toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0, index_js_1.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0, index_js_1.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */\n    async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0, index_js_1.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\nexports.Log = Log;\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n/**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */\nclass TransactionReceipt {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The address the transaction was sent to.\n     */\n    to;\n    /**\n     *  The sender of the transaction.\n     */\n    from;\n    /**\n     *  The address of the contract if the transaction was directly\n     *  responsible for deploying one.\n     *\n     *  This is non-null **only** if the ``to`` is empty and the ``data``\n     *  was successfully executed as initcode.\n     */\n    contractAddress;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The index of this transaction within the block transactions.\n     */\n    index;\n    /**\n     *  The block hash of the [[Block]] this transaction was included in.\n     */\n    blockHash;\n    /**\n     *  The block number of the [[Block]] this transaction was included in.\n     */\n    blockNumber;\n    /**\n     *  The bloom filter bytes that represent all logs that occurred within\n     *  this transaction. This is generally not useful for most developers,\n     *  but can be used to validate the included logs.\n     */\n    logsBloom;\n    /**\n     *  The actual amount of gas used by this transaction.\n     *\n     *  When creating a transaction, the amount of gas that will be used can\n     *  only be approximated, but the sender must pay the gas fee for the\n     *  entire gas limit. After the transaction, the difference is refunded.\n     */\n    gasUsed;\n    /**\n     *  The gas used for BLObs. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The amount of gas used by all transactions within the block for this\n     *  and all transactions with a lower ``index``.\n     *\n     *  This is generally not useful for developers but can be used to\n     *  validate certain aspects of execution.\n     */\n    cumulativeGasUsed;\n    /**\n     *  The actual gas price used during execution.\n     *\n     *  Due to the complexity of [[link-eip-1559]] this value can only\n     *  be caluclated after the transaction has been mined, snce the base\n     *  fee is protocol-enforced.\n     */\n    gasPrice;\n    /**\n     *  The price paid per BLOB in gas. See [[link-eip-4844]].\n     */\n    blobGasPrice;\n    /**\n     *  The [[link-eip-2718]] transaction type.\n     */\n    type;\n    //readonly byzantium!: boolean;\n    /**\n     *  The status of this transaction, indicating success (i.e. ``1``) or\n     *  a revert (i.e. ``0``).\n     *\n     *  This is available in post-byzantium blocks, but some backends may\n     *  backfill this value.\n     */\n    status;\n    /**\n     *  The root hash of this transaction.\n     *\n     *  This is no present and was only included in pre-byzantium blocks, but\n     *  could be used to validate certain parts of the receipt.\n     */\n    root;\n    #logs;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.#logs = Object.freeze(tx.logs.map((log) => {\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        }\n        else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0, index_js_1.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */\n    get logs() { return this.#logs; }\n    /**\n     *  Returns a JSON-compatible representation.\n     */\n    toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, \n        status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash, blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash, index, logs, logsBloom, root, status, to\n        };\n    }\n    /**\n     *  @_ignore:\n     */\n    get length() { return this.logs.length; }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return { value: this.logs[index++], done: false };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */\n    get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */\n    async getResult() {\n        return (await this.provider.getTransactionResult(this.hash));\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */\n    reorderedEvent(other) {\n        (0, index_js_1.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\nexports.TransactionReceipt = TransactionReceipt;\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */\nclass TransactionResponse {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    provider;\n    /**\n     *  The block number of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockNumber;\n    /**\n     *  The blockHash of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockHash;\n    /**\n     *  The index within the block that this transaction resides at.\n     */\n    index;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The [[link-eip-2718]] transaction envelope type. This is\n     *  ``0`` for legacy transactions types.\n     */\n    type;\n    /**\n     *  The receiver of this transaction.\n     *\n     *  If ``null``, then the transaction is an initcode transaction.\n     *  This means the result of executing the [[data]] will be deployed\n     *  as a new contract on chain (assuming it does not revert) and the\n     *  address may be computed using [[getCreateAddress]].\n     */\n    to;\n    /**\n     *  The sender of this transaction. It is implicitly computed\n     *  from the transaction pre-image hash (as the digest) and the\n     *  [[signature]] using ecrecover.\n     */\n    from;\n    /**\n     *  The nonce, which is used to prevent replay attacks and offer\n     *  a method to ensure transactions from a given sender are explicitly\n     *  ordered.\n     *\n     *  When sending a transaction, this must be equal to the number of\n     *  transactions ever sent by [[from]].\n     */\n    nonce;\n    /**\n     *  The maximum units of gas this transaction can consume. If execution\n     *  exceeds this, the entries transaction is reverted and the sender\n     *  is charged for the full amount, despite not state changes being made.\n     */\n    gasLimit;\n    /**\n     *  The gas price can have various values, depending on the network.\n     *\n     *  In modern networks, for transactions that are included this is\n     *  the //effective gas price// (the fee per gas that was actually\n     *  charged), while for transactions that have not been included yet\n     *  is the [[maxFeePerGas]].\n     *\n     *  For legacy transactions, or transactions on legacy networks, this\n     *  is the fee that will be charged per unit of gas the transaction\n     *  consumes.\n     */\n    gasPrice;\n    /**\n     *  The maximum priority fee (per unit of gas) to allow a\n     *  validator to charge the sender. This is inclusive of the\n     *  [[maxFeeFeePerGas]].\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  The maximum fee (per unit of gas) to allow this transaction\n     *  to charge the sender.\n     */\n    maxFeePerGas;\n    /**\n     *  The [[link-eip-4844]] max fee per BLOb gas.\n     */\n    maxFeePerBlobGas;\n    /**\n     *  The data.\n     */\n    data;\n    /**\n     *  The value, in wei. Use [[formatEther]] to format this value\n     *  as ether.\n     */\n    value;\n    /**\n     *  The chain ID.\n     */\n    chainId;\n    /**\n     *  The signature.\n     */\n    signature;\n    /**\n     *  The [[link-eip-2930]] access list for transaction types that\n     *  support it, otherwise ``null``.\n     */\n    accessList;\n    /**\n     *  The [[link-eip-4844]] BLOb versioned hashes.\n     */\n    blobVersionedHashes;\n    #startBlock;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.provider = provider;\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = (tx.accessList != null) ? tx.accessList : null;\n        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */\n    toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList, blockNumber, blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data, from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce, signature, to, index, type,\n            value: toJson(this.value),\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */\n    async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */\n    async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0, index_js_1.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(_confirms, _timeout) {\n        const confirms = (_confirms == null) ? 1 : _confirms;\n        const timeout = (_timeout == null) ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = (startBlock === -1) ? true : false;\n        const checkReplacement = async () => {\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0, index_js_1.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while (nextScan <= blockNumber) {\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block) {\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for (let i = 0; i < block.length; i++) {\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        }\n                        else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0, index_js_1.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt) => {\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0, index_js_1.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null, reason: null, invocation: null, revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                }, receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if ((await receipt.confirmations()) >= confirms) {\n                return checkReceipt(receipt);\n            }\n        }\n        else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject) => {\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = () => { cancellers.forEach((c) => c()); };\n            // On cancel, stop scanning for replacements\n            cancellers.push(() => { stopScanning = true; });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(() => {\n                    cancel();\n                    reject((0, index_js_1.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(() => { clearTimeout(timer); });\n            }\n            const txListener = async (receipt) => {\n                // Done; return it!\n                if ((await receipt.confirmations()) >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async () => {\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    }\n                    catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0, index_js_1.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */\n    isMined() {\n        return (this.blockHash != null);\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */\n    removedEvent() {\n        (0, index_js_1.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */\n    reorderedEvent(other) {\n        (0, index_js_1.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        (0, index_js_1.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */\n    replaceableTransaction(startBlock) {\n        (0, index_js_1.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nexports.TransactionResponse = TransactionResponse;\nfunction createOrphanedBlockFilter(block) {\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return { orphan: \"reorder-transaction\", tx, other };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return { orphan: \"drop-transaction\", tx };\n}\nfunction createRemovedLogFilter(log) {\n    return { orphan: \"drop-log\", log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        } };\n}\n//# sourceMappingURL=provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsMEJBQTBCLEdBQUcsV0FBVyxHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxlQUFlO0FBQzlILFdBQVcsaUJBQWlCO0FBQzVCLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJLQUEySztBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1HQUFtRztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLG9DQUFvQztBQUMxSztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrR0FBK0c7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQztBQUMvRTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOENBQThDO0FBQ3RGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsNEJBQTRCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILDRCQUE0QjtBQUMvSSxzSUFBc0ksNEJBQTRCO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci5qcz85Y2Q1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlY2VpcHQgPSBleHBvcnRzLkxvZyA9IGV4cG9ydHMuQmxvY2sgPSBleHBvcnRzLmNvcHlSZXF1ZXN0ID0gZXhwb3J0cy5GZWVEYXRhID0gdm9pZCAwO1xuLy9pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9Kc29uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuLy8gQFRPRE8/IDxUIGV4dGVuZHMgRmVlRGF0YSA9IHsgfT4gaW1wbGVtZW50cyBSZXF1aXJlZDxUPlxuLyoqXG4gKiAgQSAqKkZlZURhdGEqKiB3cmFwcyBhbGwgdGhlIGZlZS1yZWxhdGVkIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGhcbiAqICB0aGUgbmV0d29yay5cbiAqL1xuY2xhc3MgRmVlRGF0YSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgZm9yIGxlZ2FjeSBuZXR3b3Jrcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIHRvIHBheSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIGlzIGRlZmluZWQgYnkgdGhlIG5ldHdvcmsgYW5kIGJhc2VkIG9uXG4gICAgICogIGNvbmdlc3Rpb24sIGluY3JlYXNpbmcgdGhlIGNvc3QgZHVyaW5nIHRpbWVzIG9mIGhlYXZ5IGxvYWRcbiAgICAgKiAgYW5kIGxvd2VyaW5nIHdoZW4gbGVzcyBidXN5LlxuICAgICAqXG4gICAgICogIFRoZSBhY3R1YWwgZmVlIHBlciBnYXMgd2lsbCBiZSB0aGUgYmFzZSBmZWUgZm9yIHRoZSBibG9ja1xuICAgICAqICBhbmQgdGhlIHByaW9yaXR5IGZlZSwgdXAgdG8gdGhlIG1heCBmZWUgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heEZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZGl0aW9uYWwgYW1vdXQgdG8gcGF5IHBlciBnYXMgdG8gZW5jb3VyYWdlIGEgdmFsaWRhdG9yXG4gICAgICogIHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gY29tcGVuc2F0ZSB0aGUgdmFsaWRhdG9yIGZvciB0aGVcbiAgICAgKiAgYWRqdXN0ZWQgcmlzayBmb3IgaW5jbHVkaW5nIGEgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBGZWVEYXRhIGZvciAlJWdhc1ByaWNlJSUsICUlbWF4RmVlUGVyR2FzJSUgYW5kXG4gICAgICogICUlbWF4UHJpb3JpdHlGZWVQZXJHYXMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBnYXNQcmljZTogZ2V0VmFsdWUoZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldFZhbHVlKG1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIkZlZURhdGFcIixcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24oZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24obWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24obWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRmVlRGF0YSA9IEZlZURhdGE7XG47XG4vKipcbiAqICBSZXR1cm5zIGEgY29weSBvZiAlJXJlcSUlIHdpdGggYWxsIHByb3BlcnRpZXMgY29lcmNlZCB0byB0aGVpciBzdHJpY3RcbiAqICB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gY29weVJlcXVlc3QocmVxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLy8gVGhlc2UgY291bGQgYmUgYWRkcmVzc2VzLCBFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzXG4gICAgaWYgKHJlcS50bykge1xuICAgICAgICByZXN1bHQudG8gPSByZXEudG87XG4gICAgfVxuICAgIGlmIChyZXEuZnJvbSkge1xuICAgICAgICByZXN1bHQuZnJvbSA9IHJlcS5mcm9tO1xuICAgIH1cbiAgICBpZiAocmVxLmRhdGEpIHtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShyZXEuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGJpZ0ludEtleXMgPSBcImNoYWluSWQsZ2FzTGltaXQsZ2FzUHJpY2UsbWF4RmVlUGVyR2FzLG1heFByaW9yaXR5RmVlUGVyR2FzLHZhbHVlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiaWdJbnRLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gKDAsIGluZGV4X2pzXzEuZ2V0QmlnSW50KShyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlcktleXMgPSBcInR5cGUsbm9uY2VcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG51bWJlcktleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSAoMCwgaW5kZXhfanNfMS5nZXROdW1iZXIpKHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgaWYgKHJlcS5hY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gKDAsIGluZGV4X2pzXzIuYWNjZXNzTGlzdGlmeSkocmVxLmFjY2Vzc0xpc3QpO1xuICAgIH1cbiAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuYmxvY2tUYWcgPSByZXEuYmxvY2tUYWc7XG4gICAgfVxuICAgIGlmIChcImVuYWJsZUNjaXBSZWFkXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5lbmFibGVDY2lwUmVhZCA9ICEhcmVxLmVuYWJsZUNjaXBSZWFkO1xuICAgIH1cbiAgICBpZiAoXCJjdXN0b21EYXRhXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5jdXN0b21EYXRhID0gcmVxLmN1c3RvbURhdGE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNvcHlSZXF1ZXN0ID0gY29weVJlcXVlc3Q7XG4vKipcbiAqICBBICoqQmxvY2sqKiByZXByZXNlbnRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGZ1bGwgYmxvY2sgb25cbiAqICBFdGhlcmV1bS5cbiAqL1xuY2xhc3MgQmxvY2sge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBibG9jayB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIsIHNvbWV0aW1lcyBjYWxsZWQgdGhlIGJsb2NrIGhlaWdodC4gVGhpcyBpcyBhXG4gICAgICogIHNlcXVlbnRpYWwgbnVtYmVyIHRoYXQgaXMgb25lIGhpZ2hlciB0aGFuIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgbnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaC5cbiAgICAgKlxuICAgICAqICBUaGlzIGhhc2ggaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMsIHNvIGNhbiBiZSBzYWZlbHkgdXNlZCB0byBpZGVudGlmeVxuICAgICAqICBhbiBleGFjdCBzZXQgb2YgYmxvY2sgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdGltZXN0YW1wIGZvciB0aGlzIGJsb2NrLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiAgZXBvY2ggdGhhdCB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZC5cbiAgICAgKi9cbiAgICB0aW1lc3RhbXA7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgcGFyZW50SGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggdHJlZSByb290IG9mIHRoZSBwYXJlbnQgYmVhY29uIGJsb2NrIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgZXhlY3V0aW9uIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00Nzg4XV0uXG4gICAgICovXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSByYW5kb20gbnVtYmVyIGluc2VydGVkIHdoaWNoXG4gICAgICogIHBlcm1pdHRlZCB0aGUgZGlmZmljdWx0eSB0YXJnZXQgdG8gYmUgcmVhY2hlZC5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcHJvb2Ytb2Ytd29yayB0YXJnZXQgcmVxdWlyZWRcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgT24gbW9kZXJuIG5ldHdvcmtzLCB0aGlzIGlzIGEgcmFuZG9tIG51bWJlciBhcnJpdmVkIGF0IHVzaW5nXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xuICAgICAqL1xuICAgIGRpZmZpY3VsdHk7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgbGltaXQgZm9yIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgdXNlZCBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggZm9yIHRoZSBnbG9iYWwgc3RhdGUgYWZ0ZXIgYXBwbHlpbmcgY2hhbmdlc1xuICAgICAqICBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIHN0YXRlUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRzIHRyaWUuXG4gICAgICovXG4gICAgcmVjZWlwdHNSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgYW1vdW50IG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGJ5IHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgd2l0aGluIHRoZSBibG9jay4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgcnVubmluZyB0b3RhbCBvZiBibG9iIGdhcyBjb25zdW1lZCBpbiBleGNlc3Mgb2YgdGhlXG4gICAgICogIHRhcmdldCwgcHJpb3IgdG8gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgZXhjZXNzQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmVyIGNvaW5iYXNlIGFkZHJlc3MsIHdpaGNoIHJlY2VpdmVzIGFueSBzdWJzaWRpZXMgZm9yXG4gICAgICogIGluY2x1ZGluZyB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIG1pbmVyO1xuICAgIC8qKlxuICAgICAqICBBbnkgZXh0cmEgZGF0YSB0aGUgdmFsaWRhdG9yIHdpc2hlZCB0byBpbmNsdWRlLlxuICAgICAqL1xuICAgIGV4dHJhRGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxuICAgICAqICBjaGFyZ2VkLlxuICAgICAqXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xuICAgICAqICBpcy5cbiAgICAgKi9cbiAgICBiYXNlRmVlUGVyR2FzO1xuICAgICN0cmFuc2FjdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgbmVjZXNzYXJ5IGFzIHRoZSB1bmxlc3MgaW1wbGVtZW50aW5nIGFcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgaGFzaDogZ2V0VmFsdWUoYmxvY2suaGFzaCksXG4gICAgICAgICAgICBudW1iZXI6IGJsb2NrLm51bWJlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogYmxvY2sudGltZXN0YW1wLFxuICAgICAgICAgICAgcGFyZW50SGFzaDogYmxvY2sucGFyZW50SGFzaCxcbiAgICAgICAgICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdDogYmxvY2sucGFyZW50QmVhY29uQmxvY2tSb290LFxuICAgICAgICAgICAgbm9uY2U6IGJsb2NrLm5vbmNlLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogYmxvY2suZGlmZmljdWx0eSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBibG9jay5nYXNMaW1pdCxcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJsb2NrLmdhc1VzZWQsXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogYmxvY2suYmxvYkdhc1VzZWQsXG4gICAgICAgICAgICBleGNlc3NCbG9iR2FzOiBibG9jay5leGNlc3NCbG9iR2FzLFxuICAgICAgICAgICAgbWluZXI6IGJsb2NrLm1pbmVyLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBibG9jay5leHRyYURhdGEsXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBnZXRWYWx1ZShibG9jay5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHN0YXRlUm9vdDogYmxvY2suc3RhdGVSb290LFxuICAgICAgICAgICAgcmVjZWlwdHNSb290OiBibG9jay5yZWNlaXB0c1Jvb3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxuICAgICAqICB0aGV5IHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgKiAgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXG4gICAgICogIHRyYW5zYWN0aW9ucywgYnkgcGFzc2luZyBgYHRydWVgYCB0byAlJXByZWZldGNoVHhzJSVcbiAgICAgKiAgaW50byBbW1Byb3ZpZGVyLWdldEJsb2NrXV0uXG4gICAgICovXG4gICAgZ2V0IHByZWZldGNoZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMuI3RyYW5zYWN0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcmVmZXRjaGVkIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0cmFuc2FjdGlvblJlc3BvbnNlcygpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQmxvY2tcIixcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRvSnNvbihkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIGV4dHJhRGF0YSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKGdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHRvSnNvbih0aGlzLmV4Y2Vzc0Jsb2JHYXMpLFxuICAgICAgICAgICAgaGFzaCwgbWluZXIsIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnRyYW5zYWN0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4c1tpbmRleCsrXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWpzLWRhdGVdXSB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZCBhdC5cbiAgICAgKi9cbiAgICBnZXQgZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXN0YW1wID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcCAqIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSB0cmFuc2FjdGlvbiBhdCAlJWluZGV4ZSUlIHdpdGhpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGludGVybmFsIHZhbHVlIGJ5IGl0cyBpbmRleCBvciBoYXNoXG4gICAgICAgIGxldCB0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0eCA9IHRoaXMuI3RyYW5zYWN0aW9uc1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLiN0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Lmhhc2ggPT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIHR4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgKipCbG9jayoqIHdhcyBmZXRjaGVkIHdpdGggYSByZXF1ZXN0IHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB0aGlzIHdpbGwgYWxsb3cgc3luY2hyb25vdXMgYWNjZXNzIHRvIHRob3NlIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQsIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRQcmVmZXRjaGVkVHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy5wcmVmZXRjaGVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4T3JIYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB0eCBvZiB0eHMpIHtcbiAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSBpbmRleE9ySGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwibm8gbWF0Y2hpbmcgdHJhbnNhY3Rpb25cIiwgXCJpbmRleE9ySGFzaFwiLCBpbmRleE9ySGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBiZWVuIG1pbmVkLiBUaGlzIHByb3ZpZGVzIGEgdHlwZSBndWFyZFxuICAgICAqICBmb3IgYWxsIHByb3BlcnRpZXMgb24gYSBbW01pbmVkQmxvY2tdXS5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkgeyByZXR1cm4gISF0aGlzLmhhc2g7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgYW4gW1tsaW5rLWVpcC0yOTMwXV0gYmxvY2suXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYmFzZUZlZVBlckdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIG9ycGhhbmVkRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc01pbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2NrID0gQmxvY2s7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMb2dcbi8qKlxuICogIEEgKipMb2cqKiBpbiBFdGhlcmV1bSByZXByZXNlbnRzIGFuIGV2ZW50IHRoYXQgaGFzIGJlZW4gaW5jbHVkZWQgaW4gYVxuICogIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBgYExPRypgYCBvcGNvZGVzLCB3aGljaCBhcmUgbW9zdCBjb21tb25seSB1c2VkIGJ5XG4gKiAgU29saWRpdHkncyBlbWl0IGZvciBhbm5vdW5jaW5nIGV2ZW50cy5cbiAqL1xuY2xhc3MgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldFRyYW5zYWN0aW9uXV0gdG8gZ2V0IHRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRCbG9ja11dIHRvIGdldCB0aGUgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIEl0IGlzIHByZWZlcnJlZFxuICAgICAqICB0byB1c2UgdGhlIFtbQmxvY2staGFzaF1dIHdoZW4gZmV0Y2hpbmcgdGhlIHJlbGF0ZWQgW1tCbG9ja11dLFxuICAgICAqICBzaW5jZSBpbiB0aGUgY2FzZSBvZiBhbiBvcnBoYW5lZCBibG9jaywgdGhlIGJsb2NrIGF0IHRoYXQgaGVpZ2h0IG1heVxuICAgICAqICBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSAqKkxvZyoqIHJlcHJlc2VudHMgYSBibG9jayB0aGF0IHdhcyByZW1vdmVkIGR1ZSB0byBhbiBvcnBoYW5lZFxuICAgICAqICBibG9jaywgdGhpcyB3aWxsIGJlIHRydWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aGluIGFuIG9ycGhhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICByZW1vdmVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhhdCBlbWl0dGVkIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4ZWQgdG9waWNzIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiAgQWxsIHRvcGljcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGJsb29tIGZpbHRlcnMsIHNvIHRoZXkgY2FuIGJlXG4gICAgICogIGVmZmljaWVudGx5IGZpbHRlcmVkIHVzaW5nIHRoZSBbW1Byb3ZpZGVyLWdldExvZ3NdXSBtZXRob2QuXG4gICAgICovXG4gICAgdG9waWNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBhdC4gVGhpcyBpcyBnZW5lcmFsbHlcbiAgICAgKiAgbm90IHVzZWZ1bCB0byBkZXZlbG9wZXJzLCBidXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgdmFyaW91cyByb290c1xuICAgICAqICB0byBwcm9vZiBpbmNsdXNpb24gd2l0aGluIGEgYmxvY2suXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIG9mIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSW5kZXg7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBsb2cucmVtb3ZlZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3MsXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LCByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcImxvZ1wiLFxuICAgICAgICAgICAgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsXG4gICAgICAgICAgICByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgYmxvY2sgdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSghIWJsb2NrLCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoISF0eCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvdCB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzXG4gICAgICogIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoISFyZWNlaXB0LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uIHJlY2VpcHRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nID0gTG9nO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVHJhbnNhY3Rpb24gUmVjZWlwdFxuLypcbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5VHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IGZhbHNlO1xuICAgIHN0YXR1czogbnVsbDtcbiAgICByb290OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnl6YW50aXVtVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IHRydWU7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgcm9vdDogbnVsbDtcbn1cbiovXG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCBhXG4gKiAgdHJhbnNhY3Rpb24gdGhhdCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciBpdCBoYXMgYmVlbiBtaW5lZC5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3MgdGhlIHRyYW5zYWN0aW9uIHdhcyBzZW50IHRvLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBkaXJlY3RseVxuICAgICAqICByZXNwb25zaWJsZSBmb3IgZGVwbG95aW5nIG9uZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vbi1udWxsICoqb25seSoqIGlmIHRoZSBgYHRvYGAgaXMgZW1wdHkgYW5kIHRoZSBgYGRhdGFgYFxuICAgICAqICB3YXMgc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkIGFzIGluaXRjb2RlLlxuICAgICAqL1xuICAgIGNvbnRyYWN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IG9mIHRoaXMgdHJhbnNhY3Rpb24gd2l0aGluIHRoZSBibG9jayB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9vbSBmaWx0ZXIgYnl0ZXMgdGhhdCByZXByZXNlbnQgYWxsIGxvZ3MgdGhhdCBvY2N1cnJlZCB3aXRoaW5cbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCBmb3IgbW9zdCBkZXZlbG9wZXJzLFxuICAgICAqICBidXQgY2FuIGJlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGluY2x1ZGVkIGxvZ3MuXG4gICAgICovXG4gICAgbG9nc0Jsb29tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGFtb3VudCBvZiBnYXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiwgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCB3aWxsIGJlIHVzZWQgY2FuXG4gICAgICogIG9ubHkgYmUgYXBwcm94aW1hdGVkLCBidXQgdGhlIHNlbmRlciBtdXN0IHBheSB0aGUgZ2FzIGZlZSBmb3IgdGhlXG4gICAgICogIGVudGlyZSBnYXMgbGltaXQuIEFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgdGhlIGRpZmZlcmVuY2UgaXMgcmVmdW5kZWQuXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyB1c2VkIGZvciBCTE9icy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xuICAgICAqICBhbmQgYWxsIHRyYW5zYWN0aW9ucyB3aXRoIGEgbG93ZXIgYGBpbmRleGBgLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHZhbGlkYXRlIGNlcnRhaW4gYXNwZWN0cyBvZiBleGVjdXRpb24uXG4gICAgICovXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgZ2FzIHByaWNlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gdGhlIGNvbXBsZXhpdHkgb2YgW1tsaW5rLWVpcC0xNTU5XV0gdGhpcyB2YWx1ZSBjYW4gb25seVxuICAgICAqICBiZSBjYWx1Y2xhdGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCwgc25jZSB0aGUgYmFzZVxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmljZSBwYWlkIHBlciBCTE9CIGluIGdhcy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvL3JlYWRvbmx5IGJ5emFudGl1bSE6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0dXMgb2YgdGhpcyB0cmFuc2FjdGlvbiwgaW5kaWNhdGluZyBzdWNjZXNzIChpLmUuIGBgMWBgKSBvclxuICAgICAqICBhIHJldmVydCAoaS5lLiBgYDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBhdmFpbGFibGUgaW4gcG9zdC1ieXphbnRpdW0gYmxvY2tzLCBidXQgc29tZSBiYWNrZW5kcyBtYXlcbiAgICAgKiAgYmFja2ZpbGwgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0dXM7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vIHByZXNlbnQgYW5kIHdhcyBvbmx5IGluY2x1ZGVkIGluIHByZS1ieXphbnRpdW0gYmxvY2tzLCBidXRcbiAgICAgKiAgY291bGQgYmUgdXNlZCB0byB2YWxpZGF0ZSBjZXJ0YWluIHBhcnRzIG9mIHRoZSByZWNlaXB0LlxuICAgICAqL1xuICAgIHJvb3Q7XG4gICAgI2xvZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNsb2dzID0gT2JqZWN0LmZyZWV6ZSh0eC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgZ2FzUHJpY2UgPSBCTl8wO1xuICAgICAgICBpZiAodHguZWZmZWN0aXZlR2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5lZmZlY3RpdmVHYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHR4LmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHR4LmJsb2JHYXNQcmljZSxcbiAgICAgICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgICAgICAvL2J5emFudGl1bTogdHguYnl6YW50aXVtLFxuICAgICAgICAgICAgc3RhdHVzOiB0eC5zdGF0dXMsXG4gICAgICAgICAgICByb290OiB0eC5yb290XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZ3MgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7IHJldHVybiB0aGlzLiNsb2dzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBjb250cmFjdEFkZHJlc3MsIGhhc2gsIGluZGV4LCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBsb2dzQmxvb20sIGxvZ3MsIC8vYnl6YW50aXVtLCBcbiAgICAgICAgc3RhdHVzLCByb290IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy9ieXphbnRpdW0sIFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHRvSnNvbih0aGlzLmN1bXVsYXRpdmVHYXNVc2VkKSxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdG9Kc29uKHRoaXMuYmxvYkdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNjdGlvbiBjYW5ub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVvcmRlcmVkRXZlbnQob3RoZXIpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvblJlY2VpcHQgPSBUcmFuc2FjdGlvblJlY2VpcHQ7XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5jbGFzcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgaXMgY29ubmVjdGVkIHRvLCB3aGljaCB3aWxsIGluZmx1ZW5jZSBob3cgaXRzXG4gICAgICogIG1ldGhvZHMgd2lsbCByZXNvbHZlIGl0cyBhc3luYyBpbnNwZWN0aW9uIG1ldGhvZHMuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9ja0hhc2ggb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gcmVzaWRlcyBhdC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIGVudmVsb3BlIHR5cGUuIFRoaXMgaXNcbiAgICAgKiAgYGAwYGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgdHlwZXMuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY2VpdmVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgSWYgYGBudWxsYGAsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGluaXRjb2RlIHRyYW5zYWN0aW9uLlxuICAgICAqICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBbW2RhdGFdXSB3aWxsIGJlIGRlcGxveWVkXG4gICAgICogIGFzIGEgbmV3IGNvbnRyYWN0IG9uIGNoYWluIChhc3N1bWluZyBpdCBkb2VzIG5vdCByZXZlcnQpIGFuZCB0aGVcbiAgICAgKiAgYWRkcmVzcyBtYXkgYmUgY29tcHV0ZWQgdXNpbmcgW1tnZXRDcmVhdGVBZGRyZXNzXV0uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi4gSXQgaXMgaW1wbGljaXRseSBjb21wdXRlZFxuICAgICAqICBmcm9tIHRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UgaGFzaCAoYXMgdGhlIGRpZ2VzdCkgYW5kIHRoZVxuICAgICAqICBbW3NpZ25hdHVyZV1dIHVzaW5nIGVjcmVjb3Zlci5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UsIHdoaWNoIGlzIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcyBhbmQgb2ZmZXJcbiAgICAgKiAgYSBtZXRob2QgdG8gZW5zdXJlIHRyYW5zYWN0aW9ucyBmcm9tIGEgZ2l2ZW4gc2VuZGVyIGFyZSBleHBsaWNpdGx5XG4gICAgICogIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZW5kaW5nIGEgdHJhbnNhY3Rpb24sIHRoaXMgbXVzdCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICogIHRyYW5zYWN0aW9ucyBldmVyIHNlbnQgYnkgW1tmcm9tXV0uXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHVuaXRzIG9mIGdhcyB0aGlzIHRyYW5zYWN0aW9uIGNhbiBjb25zdW1lLiBJZiBleGVjdXRpb25cbiAgICAgKiAgZXhjZWVkcyB0aGlzLCB0aGUgZW50cmllcyB0cmFuc2FjdGlvbiBpcyByZXZlcnRlZCBhbmQgdGhlIHNlbmRlclxuICAgICAqICBpcyBjaGFyZ2VkIGZvciB0aGUgZnVsbCBhbW91bnQsIGRlc3BpdGUgbm90IHN0YXRlIGNoYW5nZXMgYmVpbmcgbWFkZS5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBjYW4gaGF2ZSB2YXJpb3VzIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogIEluIG1vZGVybiBuZXR3b3JrcywgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBpbmNsdWRlZCB0aGlzIGlzXG4gICAgICogIHRoZSAvL2VmZmVjdGl2ZSBnYXMgcHJpY2UvLyAodGhlIGZlZSBwZXIgZ2FzIHRoYXQgd2FzIGFjdHVhbGx5XG4gICAgICogIGNoYXJnZWQpLCB3aGlsZSBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgaGF2ZSBub3QgYmVlbiBpbmNsdWRlZCB5ZXRcbiAgICAgKiAgaXMgdGhlIFtbbWF4RmVlUGVyR2FzXV0uXG4gICAgICpcbiAgICAgKiAgRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIG9yIHRyYW5zYWN0aW9ucyBvbiBsZWdhY3kgbmV0d29ya3MsIHRoaXNcbiAgICAgKiAgaXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgY2hhcmdlZCBwZXIgdW5pdCBvZiBnYXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogIGNvbnN1bWVzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgYVxuICAgICAqICB2YWxpZGF0b3IgdG8gY2hhcmdlIHRoZSBzZW5kZXIuIFRoaXMgaXMgaW5jbHVzaXZlIG9mIHRoZVxuICAgICAqICBbW21heEZlZUZlZVBlckdhc11dLlxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgdGhpcyB0cmFuc2FjdGlvblxuICAgICAqICB0byBjaGFyZ2UgdGhlIHNlbmRlci5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBtYXggZmVlIHBlciBCTE9iIGdhcy5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJCbG9iR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUsIGluIHdlaS4gVXNlIFtbZm9ybWF0RXRoZXJdXSB0byBmb3JtYXQgdGhpcyB2YWx1ZVxuICAgICAqICBhcyBldGhlci5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElELlxuICAgICAqL1xuICAgIGNoYWluSWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcbiAgICAgKiAgc3VwcG9ydCBpdCwgb3RoZXJ3aXNlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFjY2Vzc0xpc3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBCTE9iIHZlcnNpb25lZCBoYXNoZXMuXG4gICAgICovXG4gICAgYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAjc3RhcnRCbG9jaztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5ibG9ja051bWJlciA9ICh0eC5ibG9ja051bWJlciAhPSBudWxsKSA/IHR4LmJsb2NrTnVtYmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSAodHguYmxvY2tIYXNoICE9IG51bGwpID8gdHguYmxvY2tIYXNoIDogbnVsbDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcbiAgICAgICAgdGhpcy5pbmRleCA9IHR4LmluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gdHgudG8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckdhcyA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckJsb2JHYXMgPSAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckJsb2JHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkgPyB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIDogbnVsbDtcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QsIGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRvSnNvbih0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24odGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJCbG9iR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0ICgwLCBpbmRleF9qc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICAgICAgdHg6IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vdCBtaW5lZCB5ZXQuLi5cbiAgICAgICAgICAgIGlmICh0eCA9PSBudWxsIHx8IHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdGhpcy5ibG9ja051bWJlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoX2NvbmZpcm1zLCBfdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb25maXJtcyA9IChfY29uZmlybXMgPT0gbnVsbCkgPyAxIDogX2NvbmZpcm1zO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF90aW1lb3V0ID09IG51bGwpID8gMCA6IF90aW1lb3V0O1xuICAgICAgICBsZXQgc3RhcnRCbG9jayA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgIGxldCBuZXh0U2NhbiA9IC0xO1xuICAgICAgICBsZXQgc3RvcFNjYW5uaW5nID0gKHN0YXJ0QmxvY2sgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY2hlY2tSZXBsYWNlbWVudCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBjb3VudCBmb3IgdGhpcyBzZW5kZXJcbiAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIG5vbmNlIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmZyb20pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vIHRyYW5zYWN0aW9uIG9yIG91ciBub25jZSBoYXMgbm90IGJlZW4gbWluZWQgeWV0OyBidXQgd2VcbiAgICAgICAgICAgIC8vIGNhbiBzdGFydCBzY2FubmluZyBsYXRlciB3aGVuIHdlIGRvIHN0YXJ0XG4gICAgICAgICAgICBpZiAobm9uY2UgPCB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRCbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW5lZCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZDsgc3RhcnQgc2Nhbm5pbmcgZm9yIHRoYXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHRvIHNjYW47IGxvb2sgYmFjayBhIGZldyBleHRyYSBibG9ja3MgZm9yIHNhZmV0eVxuICAgICAgICAgICAgaWYgKG5leHRTY2FuID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5leHRTY2FuID0gc3RhcnRCbG9jayAtIDM7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTY2FuIDwgdGhpcy4jc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG5leHRTY2FuIDw9IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGJsb2NrIHRvIHNjYW5cbiAgICAgICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sobmV4dFNjYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2ggPT09IHRoaXMuaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRoYXQgcmVwbGFjZWQgdXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgYmxvY2suZ2V0VHJhbnNhY3Rpb24oaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSB0aGlzLmZyb20gJiYgdHgubm9uY2UgPT09IHRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4Lmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCByZXRyeSB0aGlzIG9uIHRoZSBuZXh0IGJsb2NrICh0aGlzIGNhc2UgY291bGQgYmUgb3B0aW1pemVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxKSA8IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHRoaXMuZGF0YSAmJiB0eC50byA9PT0gdGhpcy50byAmJiB0eC52YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwicmVwcmljZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcInRyYW5zYWN0aW9uIGV4ZWN1dGlvbiByZXZlcnRlZFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCwgcmVhc29uOiBudWxsLCBpbnZvY2F0aW9uOiBudWxsLCByZXZlcnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG86IHJlY2VpcHQudG8sXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHJlY2VpcHQuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJcIiAvLyBAVE9ETzogaW4gdjcsIHNwbGl0IG91dCBzZW5kVHJhbnNhY3Rpb24gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIH0sIHJlY2VpcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5oYXNoKTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tSZWNlaXB0KHJlY2VpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNlaXB0KSB7XG4gICAgICAgICAgICBpZiAoKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhyb3dzIGlmIGEgcmVwbGFjZW1lbnQgd2FzIGZvdW5kXG4gICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAvLyBBbGxvdyBudWxsIG9ubHkgd2hlbiB0aGUgY29uZmlybXMgaXMgMFxuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FpdGVyID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gTGlzdCBvZiB0aGluZ3MgdG8gY2FuY2VsIHdoZW4gd2UgaGF2ZSBhIHJlc3VsdCAob25lIHdheSBvciB0aGUgb3RoZXIpXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsZXJzID0gW107XG4gICAgICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7IGNhbmNlbGxlcnMuZm9yRWFjaCgoYykgPT4gYygpKTsgfTtcbiAgICAgICAgICAgIC8vIE9uIGNhbmNlbCwgc3RvcCBzY2FubmluZyBmb3IgcmVwbGFjZW1lbnRzXG4gICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBzdG9wU2Nhbm5pbmcgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIC8vIFNldCB1cCBhbnkgdGltZW91dCByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKDAsIGluZGV4X2pzXzEubWFrZUVycm9yKShcIndhaXQgZm9yIHRyYW5zYWN0aW9uIHRpbWVvdXRcIiwgXCJUSU1FT1VUXCIpKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4TGlzdGVuZXIgPSBhc3luYyAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERvbmU7IHJldHVybiBpdCFcbiAgICAgICAgICAgICAgICBpZiAoKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2hlY2tSZWNlaXB0KHJlY2VpcHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYodGhpcy5oYXNoLCB0eExpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBXZSBzdXBwb3J0IHJlcGxhY2VtZW50IGRldGVjdGlvbjsgc3RhcnQgY2hlY2tpbmdcbiAgICAgICAgICAgIGlmIChzdGFydEJsb2NrID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhpcyB0aHJvd3Mgb25seSBpZiBvbmUgaXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQgKHdpdGggZW5vdWdoIGNvbmZpcm1zKTsgcmUtdGhyb3cgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNFcnJvcikoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBodGUgdHJhbnNhY3Rpb24gaXMgYSBDYW5jdW4gKGkuZS4gYGB0eXBlID09IDNgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIGFiaWxpdHkgdG9cbiAgICAgKiAgZGV0ZWN0IChhbmQgdGhyb3cgYW4gZXJyb3IpIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyByZXBsYWNlZCwgd2hpY2hcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYnkgZGV2ZWxvcGVycyBhbmQgaXMgaW50ZW5kZWRcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxuICAgICAqICBoYXZlIGRldmFzdGF0aW5nIHBlcmZvcm1hbmNlIGNvbnNlcXVlbmNlcyBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAqL1xuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoTnVtYmVyLmlzSW50ZWdlcihzdGFydEJsb2NrKSAmJiBzdGFydEJsb2NrID49IDAsIFwiaW52YWxpZCBzdGFydEJsb2NrXCIsIFwic3RhcnRCbG9ja1wiLCBzdGFydEJsb2NrKTtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgdHguI3N0YXJ0QmxvY2sgPSBzdGFydEJsb2NrO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvblJlc3BvbnNlID0gVHJhbnNhY3Rpb25SZXNwb25zZTtcbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1ibG9ja1wiLCBoYXNoOiBibG9jay5oYXNoLCBudW1iZXI6IGJsb2NrLm51bWJlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcInJlb3JkZXItdHJhbnNhY3Rpb25cIiwgdHgsIG90aGVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC10cmFuc2FjdGlvblwiLCB0eCB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljczogT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleFxuICAgICAgICB9IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NonceManager = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js\");\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nclass NonceManager extends abstract_signer_js_1.AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer;\n    #noncePromise;\n    #delta;\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer) {\n        super(signer.provider);\n        (0, index_js_1.defineProperties)(this, { signer });\n        this.#noncePromise = null;\n        this.#delta = 0;\n    }\n    async getAddress() {\n        return this.signer.getAddress();\n    }\n    connect(provider) {\n        return new NonceManager(this.signer.connect(provider));\n    }\n    async getNonce(blockTag) {\n        if (blockTag === \"pending\") {\n            if (this.#noncePromise == null) {\n                this.#noncePromise = super.getNonce(\"pending\");\n            }\n            const delta = this.#delta;\n            return (await this.#noncePromise) + delta;\n        }\n        return super.getNonce(blockTag);\n    }\n    /**\n     *  Manually increment the nonce. This may be useful when managng\n     *  offline transactions.\n     */\n    increment() {\n        this.#delta++;\n    }\n    /**\n     *  Resets the nonce, causing the **NonceManager** to reload the current\n     *  nonce from the blockchain on the next transaction.\n     */\n    reset() {\n        this.#delta = 0;\n        this.#noncePromise = null;\n    }\n    async sendTransaction(tx) {\n        const noncePromise = this.getNonce(\"pending\");\n        this.increment();\n        tx = await this.signer.populateTransaction(tx);\n        tx.nonce = await noncePromise;\n        // @TODO: Maybe handle interesting/recoverable errors?\n        // Like don't increment if the tx was certainly not sent\n        return await this.signer.sendTransaction(tx);\n    }\n    signTransaction(tx) {\n        return this.signer.signTransaction(tx);\n    }\n    signMessage(message) {\n        return this.signer.signMessage(message);\n    }\n    signTypedData(domain, types, value) {\n        return this.signer.signTypedData(domain, types, value);\n    }\n}\nexports.NonceManager = NonceManager;\n//# sourceMappingURL=signer-noncemanager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvc2lnbmVyLW5vbmNlbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLDZCQUE2QixtQkFBTyxDQUFDLG1HQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9zaWduZXItbm9uY2VtYW5hZ2VyLmpzPzExMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vbmNlTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBhYnN0cmFjdF9zaWduZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXNpZ25lci5qc1wiKTtcbi8qKlxuICogIEEgKipOb25jZU1hbmFnZXIqKiB3cmFwcyBhbm90aGVyIFtbU2lnbmVyXV0gYW5kIGF1dG9tYXRpY2FsbHkgbWFuYWdlc1xuICogIHRoZSBub25jZSwgZW5zdXJpbmcgc2VyaWFsaXplZCBhbmQgc2VxdWVudGlhbCBub25jZXMgYXJlIHVzZWQgZHVyaW5nXG4gKiAgdHJhbnNhY3Rpb24uXG4gKi9cbmNsYXNzIE5vbmNlTWFuYWdlciBleHRlbmRzIGFic3RyYWN0X3NpZ25lcl9qc18xLkFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIFNpZ25lciBiZWluZyBtYW5hZ2VkLlxuICAgICAqL1xuICAgIHNpZ25lcjtcbiAgICAjbm9uY2VQcm9taXNlO1xuICAgICNkZWx0YTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5vbmNlTWFuYWdlcioqIHRvIG1hbmFnZSAlJXNpZ25lciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNpZ25lcikge1xuICAgICAgICBzdXBlcihzaWduZXIucHJvdmlkZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHNpZ25lciB9KTtcbiAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGVsdGEgPSAwO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9uY2VNYW5hZ2VyKHRoaXMuc2lnbmVyLmNvbm5lY3QocHJvdmlkZXIpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI25vbmNlUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gc3VwZXIuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLiNkZWx0YTtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy4jbm9uY2VQcm9taXNlKSArIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXROb25jZShibG9ja1RhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBNYW51YWxseSBpbmNyZW1lbnQgdGhlIG5vbmNlLiBUaGlzIG1heSBiZSB1c2VmdWwgd2hlbiBtYW5hZ25nXG4gICAgICogIG9mZmxpbmUgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGluY3JlbWVudCgpIHtcbiAgICAgICAgdGhpcy4jZGVsdGErKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc2V0cyB0aGUgbm9uY2UsIGNhdXNpbmcgdGhlICoqTm9uY2VNYW5hZ2VyKiogdG8gcmVsb2FkIHRoZSBjdXJyZW50XG4gICAgICogIG5vbmNlIGZyb20gdGhlIGJsb2NrY2hhaW4gb24gdGhlIG5leHQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuI2RlbHRhID0gMDtcbiAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IG5vbmNlUHJvbWlzZSA9IHRoaXMuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICB0aGlzLmluY3JlbWVudCgpO1xuICAgICAgICB0eCA9IGF3YWl0IHRoaXMuc2lnbmVyLnBvcHVsYXRlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICB0eC5ub25jZSA9IGF3YWl0IG5vbmNlUHJvbWlzZTtcbiAgICAgICAgLy8gQFRPRE86IE1heWJlIGhhbmRsZSBpbnRlcmVzdGluZy9yZWNvdmVyYWJsZSBlcnJvcnM/XG4gICAgICAgIC8vIExpa2UgZG9uJ3QgaW5jcmVtZW50IGlmIHRoZSB0eCB3YXMgY2VydGFpbmx5IG5vdCBzZW50XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbih0eCk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vbmNlTWFuYWdlciA9IE5vbmNlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25lci1ub25jZW1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FilterIdPendingSubscriber = exports.FilterIdEventSubscriber = exports.FilterIdSubscriber = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js\");\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */\n    _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */\n    _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */\n    _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            }\n            catch (error) {\n                if (!(0, index_js_1.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n            await this._emitResults(this.#provider, result);\n        }\n        catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() { this.start(); }\n}\nexports.FilterIdSubscriber = FilterIdSubscriber;\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new subscriber_polling_js_1.PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\nexports.FilterIdEventSubscriber = FilterIdEventSubscriber;\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\nexports.FilterIdPendingSubscriber = FilterIdPendingSubscriber;\n//# sourceMappingURL=subscriber-filterid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRywrQkFBK0IsR0FBRywwQkFBMEI7QUFDaEcsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLGdDQUFnQyxtQkFBTyxDQUFDLHlHQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzPzk4NGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIgPSBleHBvcnRzLkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5GaWx0ZXJJZFN1YnNjcmliZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEgPSByZXF1aXJlKFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIik7XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLyoqXG4gKiAgU29tZSBiYWNrZW5kcyBzdXBwb3J0IHN1YnNjcmliaW5nIHRvIGV2ZW50cyB1c2luZyBhIEZpbHRlciBJRC5cbiAqXG4gKiAgV2hlbiBzdWJzY3JpYmluZyB3aXRoIHRoaXMgdGVjaG5pcXVlLCB0aGUgbm9kZSBpc3N1ZXMgYSB1bmlxdWVcbiAqICAvL0ZpbHRlciBJRC8vLiBBdCB0aGlzIHBvaW50IHRoZSBub2RlIGRlZGljYXRlcyByZXNvdXJjZXMgdG9cbiAqICB0aGUgZmlsdGVyLCBzbyB0aGF0IHBlcmlvZGljIGNhbGxzIHRvIGZvbGxvdyB1cCBvbiB0aGUgLy9GaWx0ZXIgSUQvL1xuICogIHdpbGwgcmVjZWl2ZSBhbnkgZXZlbnRzIHNpbmNlIHRoZSBsYXN0IGNhbGwuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmNsYXNzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXJJZFByb21pc2U7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAjbmV0d29yaztcbiAgICAjaGF1bHQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiB3aGljaCB3aWxsIHVzZWQgW1tfc3Vic2NyaWJlXV1cbiAgICAgKiAgYW5kIFtbX2VtaXRSZXN1bHRzXV0gdG8gc2V0dXAgdGhlIHN1YnNjcmlwdGlvbiBhbmQgcHJvdmlkZSB0aGUgZXZlbnRcbiAgICAgKiAgdG8gdGhlICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIHRvIGJlZ2luIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHRoZSBldmVudHMuXG4gICAgICovXG4gICAgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSByZWNvdmVyeSBvbiBlcnJvcnMuXG4gICAgICovXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodGhpcy4jZmlsdGVySWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSB0aGlzLl9zdWJzY3JpYmUodGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBGaWx0ZXIgSURcbiAgICAgICAgICAgIGxldCBmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gYXdhaXQgdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgaW5kZXhfanNfMS5pc0Vycm9yKShlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikgfHwgZXJyb3Iub3BlcmF0aW9uICE9PSBcImV0aF9uZXdGaWx0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IEZpbHRlciBJRDsgZG93bmdyYWRlIHRvXG4gICAgICAgICAgICAvLyBwb2xsaW5nXG4gICAgICAgICAgICBpZiAoZmlsdGVySWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuX3JlY292ZXJTdWJzY3JpYmVyKHRoaXMsIHRoaXMuX3JlY292ZXIodGhpcy4jcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbmV0d29yay5jaGFpbklkICE9PSBuZXR3b3JrLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFpZCBjaGFuZ2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2hhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZW1pdFJlc3VsdHModGhpcy4jcHJvdmlkZXIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkBUT0RPXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgI3RlYXJkb3duKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZFByb21pc2UgPSB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgIGlmIChmaWx0ZXJJZFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICBmaWx0ZXJJZFByb21pc2UudGhlbigoZmlsdGVySWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNoYXVsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG5leHBvcnRzLkZpbHRlcklkU3Vic2NyaWJlciA9IEZpbHRlcklkU3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgRmlsdGVySWRFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xuICAgICNldmVudDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlXG4gICAgICogIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jZXZlbnQgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIF9yZWNvdmVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ0V2ZW50U3Vic2NyaWJlcihwcm92aWRlciwgdGhpcy4jZXZlbnQpO1xuICAgIH1cbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkID0gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdGaWx0ZXJcIiwgW3RoaXMuI2V2ZW50XSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJJZDtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jZXZlbnQsIHByb3ZpZGVyLl93cmFwTG9nKHJlc3VsdCwgcHJvdmlkZXIuX25ldHdvcmspKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVySWRFdmVudFN1YnNjcmliZXIgPSBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIHBlbmRpbmcgdHJhbnNhY3Rpb25zIGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciA9IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLWZpbHRlcmlkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.PollingBlockTagSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nfunction getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0, index_js_1.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0, index_js_1.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\nexports.getPollingSubscriber = getPollingSubscriber;\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval() { return this.#interval; }\n    set pollingInterval(value) { this.#interval = value; }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        }\n        catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\nexports.PollingBlockSubscriber = PollingBlockSubscriber;\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber) => {\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) { this.stop(); }\n    resume() { this.start(); }\n}\nexports.OnBlockSubscriber = OnBlockSubscriber;\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\n    #tag;\n    #lastBlock;\n    constructor(provider, tag) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#lastBlock = -2;\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) {\n            return;\n        }\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        }\n        else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\nexports.PollingBlockTagSubscriber = PollingBlockTagSubscriber;\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\nexports.PollingOrphanSubscriber = PollingOrphanSubscriber;\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider, hash) {\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\nexports.PollingTransactionSubscriber = PollingTransactionSubscriber;\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\nexports.PollingEventSubscriber = PollingEventSubscriber;\n//# sourceMappingURL=subscriber-polling.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLG9DQUFvQyxHQUFHLCtCQUErQixHQUFHLGlDQUFpQyxHQUFHLHlCQUF5QixHQUFHLDhCQUE4QixHQUFHLDRCQUE0QjtBQUN2TyxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsZUFBZTtBQUNmO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzPzE5ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGxpbmdFdmVudFN1YnNjcmliZXIgPSBleHBvcnRzLlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgPSBleHBvcnRzLlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyID0gZXhwb3J0cy5Qb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyID0gZXhwb3J0cy5PbkJsb2NrU3Vic2NyaWJlciA9IGV4cG9ydHMuUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciA9IGV4cG9ydHMuZ2V0UG9sbGluZ1N1YnNjcmliZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgcG9sbGluZyBzdWJzY3JpYmVyIGZvciBjb21tb24gZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5mdW5jdGlvbiBnZXRQb2xsaW5nU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIocHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNIZXhTdHJpbmcpKGV2ZW50LCAzMikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgcG9sbGluZyBldmVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJnZXRQb2xsaW5nU3Vic2NyaWJlclwiLCBpbmZvOiB7IGV2ZW50IH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0UG9sbGluZ1N1YnNjcmliZXIgPSBnZXRQb2xsaW5nU3Vic2NyaWJlcjtcbi8vIEBUT0RPOiByZWZhY3RvciB0aGlzXG4vKipcbiAqICBBICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIHBvbGxzIGF0IGEgcmVndWxhciBpbnRlcnZhbCBmb3IgYSBjaGFuZ2VcbiAqICBpbiB0aGUgYmxvY2sgbnVtYmVyLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5jbGFzcyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjaW50ZXJ2YWw7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNpbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jaW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7IHRoaXMuI2ludGVydmFsID0gdmFsdWU7IH1cbiAgICBhc3luYyAjcG9sbCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCBwb2xsIHRvIHNldHVwIG91ciBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE86IFB1dCBhIGNhcCBvbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHBlciBsb29wP1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyICE9PSB0aGlzLiNibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSB0aGlzLiNibG9ja051bWJlciArIDE7IGIgPD0gYmxvY2tOdW1iZXI7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm92aWRlci5lbWl0KFwiYmxvY2tcIiwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogTWlub3IgYnVtcCwgYWRkIGFuIFwiZXJyb3JcIiBldmVudCB0byBsZXQgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIC8vICAgICAgICBrbm93IHRoaW5ncyB3ZW50IGF3cnkuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICAgICAgdGhpcy4jcG9sbCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9jbGVhclRpbWVvdXQodGhpcy4jcG9sbGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciA9IFBvbGxpbmdCbG9ja1N1YnNjcmliZXI7XG4vKipcbiAqICBBbiAqKk9uQmxvY2tTdWJzY3JpYmVyKiogY2FuIGJlIHN1Yi1jbGFzc2VkLCB3aXRoIGEgW1tfcG9sbF1dXG4gKiAgaW1wbG1lbnRhdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmNsYXNzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGw7XG4gICAgI3J1bm5pbmc7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKk9uQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcG9sbCA9IChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcG9sbChibG9ja051bWJlciwgdGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB0aGlzLnN0b3AoKTsgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG5leHBvcnRzLk9uQmxvY2tTdWJzY3JpYmVyID0gT25CbG9ja1N1YnNjcmliZXI7XG5jbGFzcyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICN0YWc7XG4gICAgI2xhc3RCbG9jaztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgdGFnKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jdGFnID0gdGFnO1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCk7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKHRoaXMuI3RhZyk7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay5udW1iZXIgPiB0aGlzLiNsYXN0QmxvY2spIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jdGFnLCBibG9jay5udW1iZXIpO1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyID0gUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlcjtcbi8qKlxuICogIEBfaWdub3JlOlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5jbGFzcyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4jZmlsdGVyKTtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyID0gUG9sbGluZ09ycGhhblN1YnNjcmliZXI7XG4vKipcbiAqICBBICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvblxuICogIGhhc2ggZm9yIGl0cyByZWNlaXB0LlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5jbGFzcyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNoYXNoO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlaGFzaCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBoYXNoKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaGFzaCA9IGhhc2g7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNoYXNoKTtcbiAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2hhc2gsIHR4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciA9IFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXI7XG4vKipcbiAqICBBICoqUG9sbGluZ0V2ZW50U3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiBmaWx0ZXIgZm9yIGl0cyBsb2dzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5jbGFzcyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcG9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIFRoZSBpbml0aWFsIGJsb2NrIGhhc24ndCBiZWVuIGRldGVybWluZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjb3B5KHRoaXMuI2ZpbHRlcik7XG4gICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSB0aGlzLiNibG9ja051bWJlciArIDE7XG4gICAgICAgIGZpbHRlci50b0Jsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgIC8vIE5vIGxvZ3MgY291bGQganVzdCBtZWFuIHRoZSBub2RlIGhhcyBub3QgaW5kZXhlZCB0aGVtIHlldCxcbiAgICAgICAgLy8gc28gd2Uga2VlcCBhIHNsaWRpbmcgd2luZG93IG9mIDYwIGJsb2NrcyB0byBrZWVwIHNjYW5uaW5nXG4gICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyIDwgYmxvY2tOdW1iZXIgLSA2MCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5lbWl0KHRoaXMuI2ZpbHRlciwgbG9nKTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWR2YW5jZSB0aGUgYmxvY2sgbnVtYmVyIHdoZW4gbG9ncyB3ZXJlIGZvdW5kIHRvXG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciBuZXR3b3JrcyAobGlrZSBCTkIgYW5kIFBvbHlnb24pIHdoaWNoIG1heVxuICAgICAgICAgICAgLy8gc2FjcmlmaWNlIGV2ZW50IGNvbnNpc3RlbmN5IGZvciBibG9jayBldmVudCBzcGVlZFxuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmdFdmVudFN1YnNjcmliZXIgPSBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1wb2xsaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/providers/ws.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/ws.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebSocket = void 0;\nvar ws_1 = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ethers/node_modules/ws/index.js\");\nObject.defineProperty(exports, \"WebSocket\", ({ enumerable: true, get: function () { return ws_1.WebSocket; } }));\n//# sourceMappingURL=ws.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvd3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLFdBQVcsbUJBQU8sQ0FBQyxnRUFBSTtBQUN2Qiw2Q0FBNEMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDOUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvd3MuanM/YzFiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViU29ja2V0ID0gdm9pZCAwO1xudmFyIHdzXzEgPSByZXF1aXJlKFwid3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdzXzEuV2ViU29ja2V0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/providers/ws.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/transaction/accesslist.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/transaction/accesslist.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.accessListify = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0, index_js_1.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index) => {\n            (0, index_js_2.assertArgument)((0, index_js_2.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                (0, index_js_2.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0, index_js_2.assertArgument)(set != null && typeof (set) === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0, index_js_2.assertArgument)(value != null && typeof (value) === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\nexports.accessListify = accessListify;\n//# sourceMappingURL=accesslist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILE1BQU07QUFDN0g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLE1BQU07QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcz8wNmViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hY2Nlc3NMaXN0aWZ5ID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6ICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKGFkZHIpLFxuICAgICAgICBzdG9yYWdlS2V5czogc3RvcmFnZUtleXMubWFwKChzdG9yYWdlS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18yLmlzSGV4U3RyaW5nKShzdG9yYWdlS2V5LCAzMiksIFwiaW52YWxpZCBzbG90XCIsIGBzdG9yYWdlS2V5c1ske2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0FjY2Vzc0xpc3RdXSBmcm9tIGFueSBldGhlcnMtc3VwcG9ydGVkIGFjY2Vzcy1saXN0IHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChzZXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKHNldC5sZW5ndGggPT09IDIsIFwiaW52YWxpZCBzbG90IHNldFwiLCBgdmFsdWVbJHtpbmRleH1dYCwgc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShzZXQgIT0gbnVsbCAmJiB0eXBlb2YgKHNldCkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhZGRyZXNzLXNsb3Qgc2V0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWNjZXNzIGxpc3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoYWRkcikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZSgoYWNjdW0sIHN0b3JhZ2VLZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW3N0b3JhZ2VLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KGFkZHIsIE9iamVjdC5rZXlzKHN0b3JhZ2VLZXlzKS5zb3J0KCkpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFjY2Vzc0xpc3RpZnkgPSBhY2Nlc3NMaXN0aWZ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzbGlzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/transaction/accesslist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/transaction/address.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/transaction/address.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.recoverAddress = exports.computeAddress = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nfunction computeAddress(key) {\n    let pubkey;\n    if (typeof (key) === \"string\") {\n        pubkey = index_js_2.SigningKey.computePublicKey(key, false);\n    }\n    else {\n        pubkey = key.publicKey;\n    }\n    return (0, index_js_1.getAddress)((0, index_js_2.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\nexports.computeAddress = computeAddress;\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nfunction recoverAddress(digest, signature) {\n    return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));\n}\nexports.recoverAddress = recoverAddress;\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3RyYW5zYWN0aW9uL2FkZHJlc3MuanM/YWQ5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb3ZlckFkZHJlc3MgPSBleHBvcnRzLmNvbXB1dGVBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIGZvciB0aGUgJSVrZXklJS5cbiAqXG4gKiAgVGhlIGtleSBtYXkgYmUgYW55IHN0YW5kYXJkIGZvcm0gb2YgcHVibGljIGtleSBvciBhIHByaXZhdGUga2V5LlxuICovXG5mdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBsZXQgcHVia2V5O1xuICAgIGlmICh0eXBlb2YgKGtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHVia2V5ID0gaW5kZXhfanNfMi5TaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoa2V5LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdWJrZXkgPSBrZXkucHVibGljS2V5O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykoKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KShcIjB4XCIgKyBwdWJrZXkuc3Vic3RyaW5nKDQpKS5zdWJzdHJpbmcoMjYpKTtcbn1cbmV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcztcbi8qKlxuICogIFJldHVybnMgdGhlIHJlY292ZXJlZCBhZGRyZXNzIGZvciB0aGUgcHJpdmF0ZSBrZXkgdGhhdCB3YXNcbiAqICB1c2VkIHRvIHNpZ24gJSVkaWdlc3QlJSB0aGF0IHJlc3VsdGVkIGluICUlc2lnbmF0dXJlJSUuXG4gKi9cbmZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKGluZGV4X2pzXzIuU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSk7XG59XG5leHBvcnRzLnJlY292ZXJBZGRyZXNzID0gcmVjb3ZlckFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/transaction/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/transaction/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Each state-changing operation on Ethereum requires a transaction.\n *\n *  @_section api/transaction:Transactions  [about-transactions]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = void 0;\nnull;\nvar accesslist_js_1 = __webpack_require__(/*! ./accesslist.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/accesslist.js\");\nObject.defineProperty(exports, \"accessListify\", ({ enumerable: true, get: function () { return accesslist_js_1.accessListify; } }));\nvar address_js_1 = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/address.js\");\nObject.defineProperty(exports, \"computeAddress\", ({ enumerable: true, get: function () { return address_js_1.computeAddress; } }));\nObject.defineProperty(exports, \"recoverAddress\", ({ enumerable: true, get: function () { return address_js_1.recoverAddress; } }));\nvar transaction_js_1 = __webpack_require__(/*! ./transaction.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/transaction.js\");\nObject.defineProperty(exports, \"Transaction\", ({ enumerable: true, get: function () { return transaction_js_1.Transaction; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCO0FBQzdGO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsMkZBQWlCO0FBQy9DLGlEQUFnRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNqSSxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBYztBQUN6QyxrREFBaUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDaEksa0RBQWlELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2hJLHVCQUF1QixtQkFBTyxDQUFDLDZGQUFrQjtBQUNqRCwrQ0FBOEMsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDOUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi9pbmRleC5qcz9jZjk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgRWFjaCBzdGF0ZS1jaGFuZ2luZyBvcGVyYXRpb24gb24gRXRoZXJldW0gcmVxdWlyZXMgYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS90cmFuc2FjdGlvbjpUcmFuc2FjdGlvbnMgIFthYm91dC10cmFuc2FjdGlvbnNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBleHBvcnRzLnJlY292ZXJBZGRyZXNzID0gZXhwb3J0cy5jb21wdXRlQWRkcmVzcyA9IGV4cG9ydHMuYWNjZXNzTGlzdGlmeSA9IHZvaWQgMDtcbm51bGw7XG52YXIgYWNjZXNzbGlzdF9qc18xID0gcmVxdWlyZShcIi4vYWNjZXNzbGlzdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFjY2Vzc0xpc3RpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFjY2Vzc2xpc3RfanNfMS5hY2Nlc3NMaXN0aWZ5OyB9IH0pO1xudmFyIGFkZHJlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc19qc18xLmNvbXB1dGVBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVjb3ZlckFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfanNfMS5yZWNvdmVyQWRkcmVzczsgfSB9KTtcbnZhciB0cmFuc2FjdGlvbl9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb24uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNhY3Rpb25fanNfMS5UcmFuc2FjdGlvbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/transaction/transaction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/transaction/transaction.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst addresses_js_1 = __webpack_require__(/*! ../constants/addresses.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/constants/addresses.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst accesslist_js_1 = __webpack_require__(/*! ./accesslist.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/accesslist.js\");\nconst address_js_1 = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/address.js\");\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0, index_js_1.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0, accesslist_js_1.accessListify)(value);\n    }\n    catch (error) {\n        (0, index_js_3.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0, index_js_3.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0, index_js_3.getBigInt)(_value, param);\n    (0, index_js_3.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0, index_js_3.getBigInt)(_value, \"value\");\n    const result = (0, index_js_3.toBeArray)(value);\n    (0, index_js_3.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0, accesslist_js_1.accessListify)(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction formatHashes(value, param) {\n    (0, index_js_3.assertArgument)(Array.isArray(value), `invalid ${param}`, \"value\", value);\n    for (let i = 0; i < value.length; i++) {\n        (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = (0, index_js_3.decodeRlp)(data);\n    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0, index_js_3.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    }\n    else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0, index_js_3.assertArgument)(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = index_js_2.Signature.from({\n            r: (0, index_js_3.zeroPadValue)(fields[7], 32),\n            s: (0, index_js_3.zeroPadValue)(fields[8], 32),\n            v\n        });\n        tx.hash = (0, index_js_2.keccak256)(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0, index_js_3.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0, index_js_3.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0, index_js_3.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0, index_js_3.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = index_js_2.Signature.getChainIdV(chainId, sig.v);\n    }\n    else if (BigInt(sig.v) !== v) {\n        (0, index_js_3.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0, index_js_3.toBeArray)(v));\n    fields.push((0, index_js_3.toBeArray)(sig.r));\n    fields.push((0, index_js_3.toBeArray)(sig.s));\n    return (0, index_js_3.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    }\n    catch (error) {\n        (0, index_js_3.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0, index_js_3.zeroPadValue)(fields[1], 32);\n    const s = (0, index_js_3.zeroPadValue)(fields[2], 32);\n    const signature = index_js_2.Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));\n    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0, index_js_3.hexlify)(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0, index_js_3.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    tx.hash = (0, index_js_2.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0, index_js_3.toBeArray)(sig.r));\n        fields.push((0, index_js_3.toBeArray)(sig.s));\n    }\n    return (0, index_js_3.concat)([\"0x02\", (0, index_js_3.encodeRlp)(fields)]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));\n    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0, index_js_3.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0, index_js_3.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    tx.hash = (0, index_js_2.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0, index_js_3.toBeArray)(sig.r));\n        fields.push((0, index_js_3.toBeArray)(sig.s));\n    }\n    return (0, index_js_3.concat)([\"0x01\", (0, index_js_3.encodeRlp)(fields)]);\n}\nfunction _parseEip4844(data) {\n    const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));\n    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), \"invalid field count for transaction type: 3\", \"data\", (0, index_js_3.hexlify)(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0, index_js_3.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10]\n    };\n    (0, index_js_3.assertArgument)(tx.to != null, \"invalid address for transaction type: 3\", \"data\", data);\n    (0, index_js_3.assertArgument)(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n        (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    tx.hash = (0, index_js_2.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || addresses_js_1.ZeroAddress),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0, index_js_3.toBeArray)(sig.r));\n        fields.push((0, index_js_3.toBeArray)(sig.s));\n    }\n    return (0, index_js_3.concat)([\"0x03\", (0, index_js_3.encodeRlp)(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nclass Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    #maxFeePerBlobGas;\n    #blobVersionedHashes;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type() { return this.#type; }\n    set type(value) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                this.#type = 3;\n                break;\n            default:\n                (0, index_js_3.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName() {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n            case 3: return \"eip-4844\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to() {\n        const value = this.#to;\n        if (value == null && this.type === 3) {\n            return addresses_js_1.ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        this.#to = (value == null) ? null : (0, index_js_1.getAddress)(value);\n    }\n    /**\n     *  The transaction nonce.\n     */\n    get nonce() { return this.#nonce; }\n    set nonce(value) { this.#nonce = (0, index_js_3.getNumber)(value, \"value\"); }\n    /**\n     *  The gas limit.\n     */\n    get gasLimit() { return this.#gasLimit; }\n    set gasLimit(value) { this.#gasLimit = (0, index_js_3.getBigInt)(value); }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = (value == null) ? null : (0, index_js_3.getBigInt)(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = (value == null) ? null : (0, index_js_3.getBigInt)(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = (value == null) ? null : (0, index_js_3.getBigInt)(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data() { return this.#data; }\n    set data(value) { this.#data = (0, index_js_3.hexlify)(value); }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value() { return this.#value; }\n    set value(value) {\n        this.#value = (0, index_js_3.getBigInt)(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = (0, index_js_3.getBigInt)(value); }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature() { return this.#sig || null; }\n    set signature(value) {\n        this.#sig = (value == null) ? null : index_js_2.Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = (value == null) ? null : (0, accesslist_js_1.accessListify)(value);\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */\n    get maxFeePerBlobGas() {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        this.#maxFeePerBlobGas = (value == null) ? null : (0, index_js_3.getBigInt)(value, \"maxFeePerBlobGas\");\n    }\n    /**\n     *  The BLOB versioned hashes for Cancun transactions.\n     */\n    get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            (0, index_js_3.assertArgument)(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for (let i = 0; i < value.length; i++) {\n                (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0, index_js_2.keccak256)(this.serialized);\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash() {\n        return (0, index_js_2.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0, address_js_1.recoverAddress)(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return index_js_2.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned() {\n        return this.signature != null;\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized() {\n        (0, index_js_3.assert)(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, this.signature);\n            case 1:\n                return _serializeEip2930(this, this.signature);\n            case 2:\n                return _serializeEip1559(this, this.signature);\n            case 3:\n                return _serializeEip4844(this, this.signature);\n        }\n        (0, index_js_3.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized() {\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this);\n            case 1:\n                return _serializeEip2930(this);\n            case 2:\n                return _serializeEip1559(this);\n            case 3:\n                return _serializeEip4844(this);\n        }\n        (0, index_js_3.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".unsignedSerialized\" });\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return (types.pop());\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0, index_js_3.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0, index_js_3.assert)(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        (0, index_js_3.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        }\n        else {\n            if (hasFee) {\n                types.push(2);\n            }\n            else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            }\n            else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            }\n            else if (hasBlob && this.to) {\n                types.push(3);\n            }\n            else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON() {\n        const s = (v) => {\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof (tx) === \"string\") {\n            const payload = (0, index_js_3.getBytes)(tx);\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch (payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n                case 3: return Transaction.from(_parseEip4844(payload));\n            }\n            (0, index_js_3.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = index_js_2.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        if (tx.hash != null) {\n            (0, index_js_3.assertArgument)(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n            (0, index_js_3.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0, index_js_3.assertArgument)(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n            (0, index_js_3.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n}\nexports.Transaction = Transaction;\n//# sourceMappingURL=transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLGtHQUEyQjtBQUMxRCxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLHdCQUF3QixtQkFBTyxDQUFDLDJGQUFpQjtBQUNqRCxxQkFBcUIsbUJBQU8sQ0FBQyxxRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNO0FBQzFFLG9CQUFvQixrQkFBa0I7QUFDdEMsOEZBQThGLFFBQVEsZ0JBQWdCLEVBQUU7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RCx5SUFBeUksRUFBRTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QyxnSUFBZ0ksRUFBRTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsaUVBQWlFLDBCQUEwQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRywwQkFBMEI7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGtDQUFrQztBQUNuSTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMklBQTJJLGFBQWE7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtS0FBbUssYUFBYTtBQUNoTCw2SEFBNkgsYUFBYTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsbUJBQW1CO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanM/NmNjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBhZGRyZXNzZXNfanNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvYWRkcmVzc2VzLmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWNjZXNzbGlzdF9qc18xID0gcmVxdWlyZShcIi4vYWNjZXNzbGlzdC5qc1wiKTtcbmNvbnN0IGFkZHJlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MuanNcIik7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IEJOX01BWF9VSU5UID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzTGlzdCh2YWx1ZSwgcGFyYW0pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIGFjY2Vzc2xpc3RfanNfMS5hY2Nlc3NMaXN0aWZ5KSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXROdW1iZXIpKF92YWx1ZSwgcGFyYW0pO1xufVxuZnVuY3Rpb24gaGFuZGxlVWludChfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBCTl8wO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkoX3ZhbHVlLCBwYXJhbSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHZhbHVlIDw9IEJOX01BWF9VSU5ULCBcInZhbHVlIGV4Y2VlZHMgdWludCBzaXplXCIsIHBhcmFtLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKF92YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KShfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KSh2YWx1ZSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdC5sZW5ndGggPD0gMzIsIGB2YWx1ZSB0b28gbGFyZ2VgLCBgdHguJHtuYW1lfWAsIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgYWNjZXNzbGlzdF9qc18xLmFjY2Vzc0xpc3RpZnkpKHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEhhc2hlcyh2YWx1ZSwgcGFyYW0pIHtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGBpbnZhbGlkICR7cGFyYW19YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCAkeyBwYXJhbSB9IGhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9ICgwLCBpbmRleF9qc18zLmRlY29kZVJscCkoZGF0YSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSA2KSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciBsZWdhY3kgdHJhbnNhY3Rpb25cIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAwLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzFdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1szXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZmllbGRzWzVdKSxcbiAgICAgICAgY2hhaW5JZDogQk5fMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBjb25zdCB2ID0gaGFuZGxlVWludChmaWVsZHNbNl0sIFwidlwiKTtcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcbiAgICBpZiAociA9PT0gQk5fMCAmJiBzID09PSBCTl8wKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXG4gICAgICAgIGxldCBjaGFpbklkID0gKHYgLSBCTl8zNSkgLyBCTl8yO1xuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShjaGFpbklkICE9PSBCTl8wIHx8ICh2ID09PSBCTl8yNyB8fCB2ID09PSBCTl8yOCksIFwibm9uLWNhbm9uaWNhbCBsZWdhY3kgdlwiLCBcInZcIiwgZmllbGRzWzZdKTtcbiAgICAgICAgdHguc2lnbmF0dXJlID0gaW5kZXhfanNfMi5TaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiAoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKGZpZWxkc1s3XSwgMzIpLFxuICAgICAgICAgICAgczogKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKShmaWVsZHNbOF0sIDMyKSxcbiAgICAgICAgICAgIHZcbiAgICAgICAgfSk7XG4gICAgICAgIHR4Lmhhc2ggPSAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTGVnYWN5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICBdO1xuICAgIGxldCBjaGFpbklkID0gQk5fMDtcbiAgICBpZiAodHguY2hhaW5JZCAhPSBCTl8wKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSAoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKHR4LmNoYWluSWQsIFwidHguY2hhaW5JZFwiKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIGNoYWluSWQgaW4gdGhlIHR4IGFuZCBhbiBFSVAtMTU1IHYgaW4gdGhlIHNpZ25hdHVyZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXkgYWdyZWUgd2l0aCBlYWNoIG90aGVyXG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSghc2lnIHx8IHNpZy5uZXR3b3JrViA9PSBudWxsIHx8IHNpZy5sZWdhY3lDaGFpbklkID09PSBjaGFpbklkLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHguc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IGNoYWluSWQsIGJ1dCBFSVAtMTU1IGhhdmUgYSBkZXJpdmVkIGltcGxpY2l0IGNoYWluSWRcbiAgICAgICAgY29uc3QgbGVnYWN5ID0gdHguc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChsZWdhY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IGxlZ2FjeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShjaGFpbklkKSk7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZW5jb2RlUmxwKShmaWVsZHMpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoYXQgdHguc2lnbmF0dXJlLCBjaGFpbklkLCBhbmQgc2lnXG4gICAgLy8gICAgICAgIG1hdGNoIGJ1dCB0aGF0IGxvZ2ljIGNvdWxkIGJyZWFrIGV4aXN0aW5nIGNvZGUsIHNvIHNjaGVkdWxlXG4gICAgLy8gICAgICAgIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIGJ1bXAuXG4gICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSB2XG4gICAgbGV0IHYgPSBCaWdJbnQoMjcgKyBzaWcueVBhcml0eSk7XG4gICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgdiA9IGluZGV4X2pzXzIuU2lnbmF0dXJlLmdldENoYWluSWRWKGNoYWluSWQsIHNpZy52KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQmlnSW50KHNpZy52KSAhPT0gdikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIHNpZ25hdHVyZVxuICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkodikpO1xuICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkoc2lnLnIpKTtcbiAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5zKSk7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmVuY29kZVJscCkoZmllbGRzKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzKSB7XG4gICAgbGV0IHlQYXJpdHk7XG4gICAgdHJ5IHtcbiAgICAgICAgeVBhcml0eSA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwieVBhcml0eVwiKTtcbiAgICAgICAgaWYgKHlQYXJpdHkgIT09IDAgJiYgeVBhcml0eSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHlQYXJpdHlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIiwgXCJ5UGFyaXR5XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSAoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKGZpZWxkc1sxXSwgMzIpO1xuICAgIGNvbnN0IHMgPSAoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKGZpZWxkc1syXSwgMzIpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGluZGV4X2pzXzIuU2lnbmF0dXJlLmZyb20oeyByLCBzLCB5UGFyaXR5IH0pO1xuICAgIHR4LnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDE1NTkoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9ICgwLCBpbmRleF9qc18zLmRlY29kZVJscCkoKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKGRhdGEpLnNsaWNlKDEpKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDEyKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAyXCIsIFwiZGF0YVwiLCAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDIsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGZpZWxkc1s3XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMTU1OSBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9ICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuY29uY2F0KShbXCIweDAyXCIsICgwLCBpbmRleF9qc18zLmVuY29kZVJscCkoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gKDAsIGluZGV4X2pzXzMuZGVjb2RlUmxwKSgoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoZGF0YSkuc2xpY2UoMSkpO1xuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDggfHwgZmllbGRzLmxlbmd0aCA9PT0gMTEpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJkYXRhXCIsICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNF0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNV0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGZpZWxkc1s2XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzddLCBcImFjY2Vzc0xpc3RcIilcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0eC5oYXNoID0gKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KShkYXRhKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSg4KSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5jb25jYXQpKFtcIjB4MDFcIiwgKDAsIGluZGV4X2pzXzMuZW5jb2RlUmxwKShmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXA0ODQ0KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSAoMCwgaW5kZXhfanNfMy5kZWNvZGVSbHApKCgwLCBpbmRleF9qc18zLmdldEJ5dGVzKShkYXRhKS5zbGljZSgxKSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gMTEgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTQpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDNcIiwgXCJkYXRhXCIsICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogaGFuZGxlVWludChmaWVsZHNbOV0sIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogZmllbGRzWzEwXVxuICAgIH07XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHR4LnRvICE9IG51bGwsIFwiaW52YWxpZCBhZGRyZXNzIGZvciB0cmFuc2FjdGlvbiB0eXBlOiAzXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoQXJyYXkuaXNBcnJheSh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSwgXCJpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoZXM6IG11c3QgYmUgYW4gYXJyYXlcIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHguYmxvYlZlcnNpb25lZEhhc2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXNbaV0sIDMyKSwgYGludmFsaWQgYmxvYlZlcnNpb25lZEhhc2ggYXQgaW5kZXggJHtpfTogbXVzdCBiZSBsZW5ndGggMzJgLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIC8vIFVuc2lnbmVkIEVJUC00ODQ0IFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDExKSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9ICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTEpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNDg0NCh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBhZGRyZXNzZXNfanNfMS5aZXJvQWRkcmVzcyksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckJsb2JHYXMgfHwgMCwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxuICAgICAgICBmb3JtYXRIYXNoZXModHguYmxvYlZlcnNpb25lZEhhc2hlcyB8fCBbXSwgXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIpXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5jb25jYXQpKFtcIjB4MDNcIiwgKDAsIGluZGV4X2pzXzMuZW5jb2RlUmxwKShmaWVsZHMpXSk7XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb24qKiBkZXNjcmliZXMgYW4gb3BlcmF0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uXG4gKiAgRXRoZXJldW0gYnkgYW4gRXh0ZXJuYWxseSBPd25lZCBBY2NvdW50IChFT0EpLiBJdCBpbmNsdWRlc1xuICogIHdobyAodGhlIFtbdG9dXSBhZGRyZXNzKSwgd2hhdCAodGhlIFtbZGF0YV1dKSBhbmQgaG93IG11Y2ggKHRoZVxuICogIFtbdmFsdWVdXSBpbiBldGhlcikgdGhlIG9wZXJhdGlvbiBzaG91bGQgZW50YWlsLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICB0eC5kYXRhID0gXCIweDEyMzRcIjtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgICN0eXBlO1xuICAgICN0bztcbiAgICAjZGF0YTtcbiAgICAjbm9uY2U7XG4gICAgI2dhc0xpbWl0O1xuICAgICNnYXNQcmljZTtcbiAgICAjbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgI21heEZlZVBlckdhcztcbiAgICAjdmFsdWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3NpZztcbiAgICAjYWNjZXNzTGlzdDtcbiAgICAjbWF4RmVlUGVyQmxvYkdhcztcbiAgICAjYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICpcbiAgICAgKiAgSWYgbnVsbCwgdGhlIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluZmVycmVkIGJhc2VkIG9uXG4gICAgICogIGV4cGxpY2l0IHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLiN0eXBlOyB9XG4gICAgc2V0IHR5cGUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSBcImxlZ2FjeVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImJlcmxpblwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC0yOTMwXCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwibG9uZG9uXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTE1NTlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jdW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtNDg0NFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJlaXAtMjkzMFwiO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gXCJlaXAtNDg0NFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXG4gICAgICogIHRyYW5zYWN0aW9uIGlzIGFuIGBgaW5pdGBgIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB0bygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN0bztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzc2VzX2pzXzEuWmVyb0FkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgdG8odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdG8gPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIG5vbmNlLlxuICAgICAqL1xuICAgIGdldCBub25jZSgpIHsgcmV0dXJuIHRoaXMuI25vbmNlOyB9XG4gICAgc2V0IG5vbmNlKHZhbHVlKSB7IHRoaXMuI25vbmNlID0gKDAsIGluZGV4X2pzXzMuZ2V0TnVtYmVyKSh2YWx1ZSwgXCJ2YWx1ZVwiKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIGxpbWl0LlxuICAgICAqL1xuICAgIGdldCBnYXNMaW1pdCgpIHsgcmV0dXJuIHRoaXMuI2dhc0xpbWl0OyB9XG4gICAgc2V0IGdhc0xpbWl0KHZhbHVlKSB7IHRoaXMuI2dhc0xpbWl0ID0gKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MgdGhpcyBkZWZpbmVzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIHBhaWQuIE9uXG4gICAgICogIEVJUC0xNTU5IG5ldHdvcmtzLCB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzUHJpY2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZ2FzUHJpY2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICh0aGlzLnR5cGUgPT09IDAgfHwgdGhpcy50eXBlID09PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgZ2FzUHJpY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSwgXCJnYXNQcmljZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSBwZXIgdW5pdCBvZiBnYXMgdG8gcGF5LiBPbiBsZWdhY3lcbiAgICAgKiAgbmV0d29ya3MgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSwgXCJtYXhGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gZGF0YS4gRm9yIGBgaW5pdGBgIHRyYW5zYWN0aW9ucyB0aGlzIGlzIHRoZVxuICAgICAqICBkZXBsb3ltZW50IGNvZGUuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XG4gICAgc2V0IGRhdGEodmFsdWUpIHsgdGhpcy4jZGF0YSA9ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGV0aGVyIChpbiB3ZWkpIHRvIHNlbmQgaW4gdGhpcyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsdWU7IH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSAoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoaXMgdHJhbnNhY3Rpb24gaXMgdmFsaWQgb24uXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIElmIHNpZ25lZCwgdGhlIHNpZ25hdHVyZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy4jc2lnIHx8IG51bGw7IH1cbiAgICBzZXQgc2lnbmF0dXJlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3NpZyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBpbmRleF9qc18yLlNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhY2Nlc3MgbGlzdC5cbiAgICAgKlxuICAgICAqICBBbiBhY2Nlc3MgbGlzdCBwZXJtaXRzIGRpc2NvdW50ZWQgKGJ1dCBwcmUtcGFpZCkgYWNjZXNzIHRvXG4gICAgICogIGJ5dGVjb2RlIGFuZCBzdGF0ZSB2YXJpYWJsZSBhY2Nlc3Mgd2l0aGluIGNvbnRyYWN0IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYWNjZXNzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhY2Nlc3NMaXN0IHx8IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAxIHx8IHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGFzc2lnbiB0aGUgdmFsdWUgb3IgYmVjb21lXG4gICAgICAgICAgICAgICAgLy8gYSBsaXZlIG9iamVjdCBpdHNlbGYsIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBhY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGFjY2Vzc2xpc3RfanNfMS5hY2Nlc3NMaXN0aWZ5KSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4IGZlZSBwZXIgYmxvYiBnYXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IG1heEZlZVBlckJsb2JHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyQmxvYkdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhGZWVQZXJCbG9iR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEJMT0IgdmVyc2lvbmVkIGhhc2hlcyBmb3IgQ2FuY3VuIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgYmxvYlZlcnNpb25lZEhhc2hlcygpIHtcbiAgICAgICAgLy8gQFRPRE86IE11dGF0aW9uIGlzIGluY29uc2lzdGVudDsgaWYgdW5zZXQsIHRoZSByZXR1cm5lZCB2YWx1ZVxuICAgICAgICAvLyBjYW5ub3QgbXV0YXRlIHRoZSBvYmplY3QsIGlmIHNldCBpdCBjYW5cbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYmxvYlZlcnNpb25lZEhhc2hlcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkodmFsdWUpLCBcImJsb2JWZXJzaW9uZWRIYXNoZXMgbXVzdCBiZSBhbiBBcnJheVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaFwiLCBgdmFsdWVbJHtpfV1gLCB2YWx1ZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBUcmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jdG8gPSBudWxsO1xuICAgICAgICB0aGlzLiNub25jZSA9IDA7XG4gICAgICAgIHRoaXMuI2dhc0xpbWl0ID0gQk5fMDtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBcIjB4XCI7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gQk5fMDtcbiAgICAgICAgdGhpcy4jY2hhaW5JZCA9IEJOXzA7XG4gICAgICAgIHRoaXMuI3NpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJCbG9iR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaCwgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBoYXNoKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikodGhpcy5zZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmUtaW1hZ2UgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGRpZ2VzdCB0aGF0IGEgW1tTaWduZXJdXSBtdXN0IHNpZ24gdG8gYXV0aG9yaXplXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikodGhpcy51bnNpZ25lZFNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRpbmcgYWRkcmVzcywgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBhZGRyZXNzX2pzXzEucmVjb3ZlckFkZHJlc3MpKHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb21QdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhfanNfMi5TaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkodGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBzaWduZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCBwcm9wZXJ0aWVzIHJlcXVpcmluZyBhIHNpZ25lZFxuICAgICAqICB0cmFuc2FjdGlvbiBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNTaWduZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZSAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB0aHJvd3MgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHVuc2lnbmVkLiBGb3IgdGhlIHByZS1pbWFnZSxcbiAgICAgKiAgdXNlIFtbdW5zaWduZWRTZXJpYWxpemVkXV0uXG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkodGhpcy5zaWduYXR1cmUgIT0gbnVsbCwgXCJjYW5ub3Qgc2VyaWFsaXplIHVuc2lnbmVkIHRyYW5zYWN0aW9uOyBtYXliZSB5b3UgbWVhbnQgLnVuc2lnbmVkU2VyaWFsaXplZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDE1NTkodGhpcywgdGhpcy5zaWduYXR1cmUpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNDg0NCh0aGlzLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlLlxuICAgICAqXG4gICAgICogIFRoZSBoYXNoIG9mIHRoaXMgaXMgdGhlIGRpZ2VzdCB3aGljaCBuZWVkcyB0byBiZSBzaWduZWQgdG9cbiAgICAgKiAgYXV0aG9yaXplIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkU2VyaWFsaXplZCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmluZmVyVHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVMZWdhY3kodGhpcyk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDQ4NDQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi51bnNpZ25lZFNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgbW9zdCBcImxpa2VseVwiIHR5cGU7IGN1cnJlbnRseSB0aGUgaGlnaGVzdFxuICAgICAqICBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpbmZlclR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5pbmZlclR5cGVzKCk7XG4gICAgICAgIC8vIFByZWZlciBMb25kb24gKEVJUC0xNTU5KSBvdmVyIENhbmN1biAoQkxPYilcbiAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YoMikgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBoaWdoZXN0IGluZmVycmVkIHR5cGVcbiAgICAgICAgcmV0dXJuICh0eXBlcy5wb3AoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBWYWxpZGF0ZXMgdGhlIGV4cGxpY2l0IHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIGNvbXBhdGlibGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gdHlwZXMuXG4gICAgICovXG4gICAgaW5mZXJUeXBlcygpIHtcbiAgICAgICAgLy8gQ2hlY2tzIHRoYXQgdGhlcmUgYXJlIG5vIGNvbmZsaWN0aW5nIHByb3BlcnRpZXMgc2V0XG4gICAgICAgIGNvbnN0IGhhc0dhc1ByaWNlID0gdGhpcy5nYXNQcmljZSAhPSBudWxsO1xuICAgICAgICBjb25zdCBoYXNGZWUgPSAodGhpcy5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICBjb25zdCBoYXNBY2Nlc3NMaXN0ID0gKHRoaXMuYWNjZXNzTGlzdCAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaGFzQmxvYiA9ICh0aGlzLiNtYXhGZWVQZXJCbG9iR2FzICE9IG51bGwgfHwgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyk7XG4gICAgICAgIC8vaWYgKGhhc0dhc1ByaWNlICYmIGhhc0ZlZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZSBhbmQgbWF4RmVlUGVyR2FzXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgaWYgKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHRoaXMubWF4RmVlUGVyR2FzID49IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsIFwicHJpb3JpdHlGZWUgY2Fubm90IGJlIG1vcmUgdGhhbiBtYXhGZWVcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vaWYgKHRoaXMudHlwZSA9PT0gMiAmJiBoYXNHYXNQcmljZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZVwiKTtcbiAgICAgICAgLy99XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoIWhhc0ZlZSB8fCAodGhpcy50eXBlICE9PSAwICYmIHRoaXMudHlwZSAhPT0gMSksIFwidHJhbnNhY3Rpb24gdHlwZSBjYW5ub3QgaGF2ZSBtYXhGZWVQZXJHYXMgb3IgbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHRoaXMudHlwZSAhPT0gMCB8fCAhaGFzQWNjZXNzTGlzdCwgXCJsZWdhY3kgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgYWNjZXNzTGlzdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIC8vIEV4cGxpY2l0IHR5cGVcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzRmVlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQmxvYiAmJiB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYmVybGluIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMWBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQmVybGluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBsb25kb24gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAyYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGFuIFtbbGluay1laXAtNDg0NF1dIEJMT0JcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHRyYW5zYWNpdG9uLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIEpTT04tZnJpZW5kbHkgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcyA9ICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHModGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogcyh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBzKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBzKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHZhbHVlOiBzKHRoaXMudmFsdWUpLFxuICAgICAgICAgICAgY2hhaW5JZDogcyh0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgc2lnOiB0aGlzLnNpZ25hdHVyZSA/IHRoaXMuc2lnbmF0dXJlLnRvSlNPTigpIDogbnVsbCxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IHRoaXMuYWNjZXNzTGlzdFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgKipUcmFuc2FjdGlvbioqIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9yIGFcbiAgICAgKiAgVHJhbnNhY3Rpb24tbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHgpIHtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykodHgpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWRbMF0gPj0gMHg3ZikgeyAvLyBAVE9ETzogPiB2cyA+PSA/P1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUxlZ2FjeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDI5MzAocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMTU1OShwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXA0ODQ0KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4RmVlUGVyQmxvYkdhcyA9IHR4Lm1heEZlZVBlckJsb2JHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gaW5kZXhfanNfMi5TaWduYXR1cmUuZnJvbSh0eC5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gdHguYWNjZXNzTGlzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYmxvYlZlcnNpb25lZEhhc2hlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmhhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgaGFzaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShyZXN1bHQuaGFzaCA9PT0gdHguaGFzaCwgXCJoYXNoIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lIGZyb21cIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkocmVzdWx0LmZyb20udG9Mb3dlckNhc2UoKSA9PT0gKHR4LmZyb20gfHwgXCJcIikudG9Mb3dlckNhc2UoKSwgXCJmcm9tIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/transaction/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/base58.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/base58.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeBase58 = exports.encodeBase58 = void 0;\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst maths_js_1 = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for (let i = 0; i < Alphabet.length; i++) {\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0, errors_js_1.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */\nfunction encodeBase58(_value) {\n    const bytes = (0, data_js_1.getBytes)(_value);\n    let value = (0, maths_js_1.toBigInt)(bytes);\n    let result = \"\";\n    while (value) {\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    // Account for leading padding zeros\n    for (let i = 0; i < bytes.length; i++) {\n        if (bytes[i]) {\n            break;\n        }\n        result = Alphabet[0] + result;\n    }\n    return result;\n}\nexports.encodeBase58 = encodeBase58;\n/**\n *  Decode the Base58-encoded %%value%%.\n */\nfunction decodeBase58(value) {\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}\nexports.decodeBase58 = decodeBase58;\n//# sourceMappingURL=base58.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9iYXNlNTguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsMkVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvYmFzZTU4LmpzPzY4MzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBUaGUgW0Jhc2U1OCBFbmNvZGluZ10obGluay1iYXNlNTgpIHNjaGVtZSBhbGxvd3MgYSAqKm51bWVyaWMqKiB2YWx1ZVxuICogIHRvIGJlIGVuY29kZWQgYXMgYSBjb21wYWN0IHN0cmluZyB1c2luZyBhIHJhZGl4IG9mIDU4IHVzaW5nIG9ubHlcbiAqICBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMuIENvbmZ1c2luZ2x5IHNpbWlsYXIgY2hhcmFjdGVycyBhcmUgb21pdHRlZFxuICogIChpLmUuIGBgXCJsME9cImBgKS5cbiAqXG4gKiAgTm90ZSB0aGF0IEJhc2U1OCBlbmNvZGVzIGEgKipudW1lcmljKiogdmFsdWUsIG5vdCBhcmJpdHJhcnkgYnl0ZXMsXG4gKiAgc2luY2UgYW55IHplcm8tYnl0ZXMgb24gdGhlIGxlZnQgd291bGQgZ2V0IHJlbW92ZWQuIFRvIG1pdGlnYXRlIHRoaXNcbiAqICBpc3N1ZSBtb3N0IHNjaGVtZXMgdGhhdCB1c2UgQmFzZTU4IGNob29zZSBzcGVjaWZpYyBoaWdoLW9yZGVyIHZhbHVlc1xuICogIHRvIGVuc3VyZSBub24temVybyBwcmVmaXhlcy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6QmFzZTU4IEVuY29kaW5nIFthYm91dC1iYXNlNThdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlQmFzZTU4ID0gZXhwb3J0cy5lbmNvZGVCYXNlNTggPSB2b2lkIDA7XG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5jb25zdCBtYXRoc19qc18xID0gcmVxdWlyZShcIi4vbWF0aHMuanNcIik7XG5jb25zdCBBbHBoYWJldCA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xubGV0IExvb2t1cCA9IG51bGw7XG5mdW5jdGlvbiBnZXRBbHBoYShsZXR0ZXIpIHtcbiAgICBpZiAoTG9va3VwID09IG51bGwpIHtcbiAgICAgICAgTG9va3VwID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIExvb2t1cFtBbHBoYWJldFtpXV0gPSBCaWdJbnQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gTG9va3VwW2xldHRlcl07XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShyZXN1bHQgIT0gbnVsbCwgYGludmFsaWQgYmFzZTU4IHZhbHVlYCwgXCJsZXR0ZXJcIiwgbGV0dGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzU4ID0gQmlnSW50KDU4KTtcbi8qKlxuICogIEVuY29kZSAlJXZhbHVlJSUgYXMgYSBCYXNlNTgtZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJhc2U1OChfdmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9ICgwLCBkYXRhX2pzXzEuZ2V0Qnl0ZXMpKF92YWx1ZSk7XG4gICAgbGV0IHZhbHVlID0gKDAsIG1hdGhzX2pzXzEudG9CaWdJbnQpKGJ5dGVzKTtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbTnVtYmVyKHZhbHVlICUgQk5fNTgpXSArIHJlc3VsdDtcbiAgICAgICAgdmFsdWUgLz0gQk5fNTg7XG4gICAgfVxuICAgIC8vIEFjY291bnQgZm9yIGxlYWRpbmcgcGFkZGluZyB6ZXJvc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJ5dGVzW2ldKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFswXSArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZW5jb2RlQmFzZTU4ID0gZW5jb2RlQmFzZTU4O1xuLyoqXG4gKiAgRGVjb2RlIHRoZSBCYXNlNTgtZW5jb2RlZCAlJXZhbHVlJSUuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUJhc2U1OCh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICo9IEJOXzU4O1xuICAgICAgICByZXN1bHQgKz0gZ2V0QWxwaGEodmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWNvZGVCYXNlNTggPSBkZWNvZGVCYXNlNTg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNTguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/base58.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/base64.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/base64.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeBase64 = exports.decodeBase64 = void 0;\n/**\n *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode\n *  arbitrary bytes into a string using 65 printable symbols, the\n *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,\n *  ``\"+\"`` and ``\"/\"`` with the ``\"=\"`` used for padding.\n *\n *  @_subsection: api/utils:Base64 Encoding  [about-base64]\n */\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\n/**\n *  Decodes the base-64 encoded %%value%%.\n *\n *  @example:\n *    // The decoded value is always binary data...\n *    result = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n *    //_result:\n *\n *    // ...use toUtf8String to convert it to a string.\n *    toUtf8String(result)\n *    //_result:\n *\n *    // Decoding binary data\n *    decodeBase64(\"EjQ=\")\n *    //_result:\n */\nfunction decodeBase64(value) {\n    return (0, data_js_1.getBytesCopy)(Buffer.from(value, \"base64\"));\n}\nexports.decodeBase64 = decodeBase64;\n;\n/**\n *  Encodes %%data%% as a base-64 encoded string.\n *\n *  @example:\n *    // Encoding binary data as a hexstring\n *    encodeBase64(\"0x1234\")\n *    //_result:\n *\n *    // Encoding binary data as a Uint8Array\n *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n *    //_result:\n *\n *    // The input MUST be data...\n *    encodeBase64(\"Hello World!!\")\n *    //_error:\n *\n *    // ...use toUtf8Bytes for this.\n *    encodeBase64(toUtf8Bytes(\"Hello World!!\"))\n *    //_result:\n */\nfunction encodeBase64(data) {\n    return Buffer.from((0, data_js_1.getBytes)(data)).toString(\"base64\");\n}\nexports.encodeBase64 = encodeBase64;\n//# sourceMappingURL=base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9iYXNlNjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9iYXNlNjQuanM/Y2IyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlQmFzZTY0ID0gZXhwb3J0cy5kZWNvZGVCYXNlNjQgPSB2b2lkIDA7XG4vKipcbiAqICBbQmFzZTY0IGVuY29kaW5nXShsaW5rLXdpa2ktYmFzZTY0KSB1c2luZyA2LWJpdCB3b3JkcyB0byBlbmNvZGVcbiAqICBhcmJpdHJhcnkgYnl0ZXMgaW50byBhIHN0cmluZyB1c2luZyA2NSBwcmludGFibGUgc3ltYm9scywgdGhlXG4gKiAgdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSBhbHBoYWJldCwgdGhlIGRpZ2l0cyBgYDBgYCB0aHJvdWdoIGBgOWBgLFxuICogIGBgXCIrXCJgYCBhbmQgYGBcIi9cImBgIHdpdGggdGhlIGBgXCI9XCJgYCB1c2VkIGZvciBwYWRkaW5nLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNjQgRW5jb2RpbmcgIFthYm91dC1iYXNlNjRdXG4gKi9cbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG4vKipcbiAqICBEZWNvZGVzIHRoZSBiYXNlLTY0IGVuY29kZWQgJSV2YWx1ZSUlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBiaW5hcnkgZGF0YS4uLlxuICogICAgcmVzdWx0ID0gZGVjb2RlQmFzZTY0KFwiU0dWc2JHOGdWMjl5YkdRaElRPT1cIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyAuLi51c2UgdG9VdGY4U3RyaW5nIHRvIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuXG4gKiAgICB0b1V0ZjhTdHJpbmcocmVzdWx0KVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIERlY29kaW5nIGJpbmFyeSBkYXRhXG4gKiAgICBkZWNvZGVCYXNlNjQoXCJFalE9XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgZGF0YV9qc18xLmdldEJ5dGVzQ29weSkoQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpKTtcbn1cbmV4cG9ydHMuZGVjb2RlQmFzZTY0ID0gZGVjb2RlQmFzZTY0O1xuO1xuLyoqXG4gKiAgRW5jb2RlcyAlJWRhdGElJSBhcyBhIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gRW5jb2RpbmcgYmluYXJ5IGRhdGEgYXMgYSBoZXhzdHJpbmdcbiAqICAgIGVuY29kZUJhc2U2NChcIjB4MTIzNFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVuY29kaW5nIGJpbmFyeSBkYXRhIGFzIGEgVWludDhBcnJheVxuICogICAgZW5jb2RlQmFzZTY0KG5ldyBVaW50OEFycmF5KFsgMHgxMiwgMHgzNCBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaGUgaW5wdXQgTVVTVCBiZSBkYXRhLi4uXG4gKiAgICBlbmNvZGVCYXNlNjQoXCJIZWxsbyBXb3JsZCEhXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyAuLi51c2UgdG9VdGY4Qnl0ZXMgZm9yIHRoaXMuXG4gKiAgICBlbmNvZGVCYXNlNjQodG9VdGY4Qnl0ZXMoXCJIZWxsbyBXb3JsZCEhXCIpKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjQoZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgZGF0YV9qc18xLmdldEJ5dGVzKShkYXRhKSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG5leHBvcnRzLmVuY29kZUJhc2U2NCA9IGVuY29kZUJhc2U2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/data.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = void 0;\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0, errors_js_1.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nfunction getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\nexports.getBytes = getBytes;\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nfunction getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\nexports.getBytesCopy = getBytesCopy;\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nfunction isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nexports.isBytesLike = isBytesLike;\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nfunction hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\nexports.hexlify = hexlify;\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nfunction concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\nexports.concat = concat;\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nfunction dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\nexports.dataLength = dataLength;\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nfunction dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0, errors_js_1.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\nexports.dataSlice = dataSlice;\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nfunction stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nexports.stripZerosLeft = stripZerosLeft;\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0, errors_js_1.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nfunction zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\nexports.zeroPadValue = zeroPadValue;\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nfunction zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\nexports.zeroPadBytes = zeroPadBytes;\n//# sourceMappingURL=data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9kYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsZ0JBQWdCO0FBQ3RPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9kYXRhLmpzPzk4MzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnplcm9QYWRCeXRlcyA9IGV4cG9ydHMuemVyb1BhZFZhbHVlID0gZXhwb3J0cy5zdHJpcFplcm9zTGVmdCA9IGV4cG9ydHMuZGF0YVNsaWNlID0gZXhwb3J0cy5kYXRhTGVuZ3RoID0gZXhwb3J0cy5jb25jYXQgPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmlzQnl0ZXNMaWtlID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuZ2V0Qnl0ZXNDb3B5ID0gZXhwb3J0cy5nZXRCeXRlcyA9IHZvaWQgMDtcbi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmZ1bmN0aW9uIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgY29weSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubWF0Y2goL14weChbMC05YS1mXVswLTlhLWZdKSokL2kpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgQnl0ZXNMaWtlIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUuIElmIGFscmVhZHkgYSBVaW50OEFycmF5XG4gKiAgdGhlIG9yaWdpbmFsICUldmFsdWUlJSBpcyByZXR1cm5lZDsgaWYgYSBjb3B5IGlzIHJlcXVpcmVkIHVzZVxuICogIFtbZ2V0Qnl0ZXNDb3B5XV0uXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzQ29weVxuICovXG5mdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbmV4cG9ydHMuZ2V0Qnl0ZXMgPSBnZXRCeXRlcztcbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5mdW5jdGlvbiBnZXRCeXRlc0NvcHkodmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCB0cnVlKTtcbn1cbmV4cG9ydHMuZ2V0Qnl0ZXNDb3B5ID0gZ2V0Qnl0ZXNDb3B5O1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbSGV4U3RyaW5nXV0uXG4gKlxuICogIElmICUlbGVuZ3RoJSUgaXMgYGB0cnVlYGAgb3IgYSAvL251bWJlci8vLCBpdCBhbHNvIGNoZWNrcyB0aGF0XG4gKiAgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVsZW5ndGglJSAoaWYgYSAvL251bWJlci8vKVxuICogIGJ5dGVzIG9mIGRhdGEgKGUuZy4gYGAweDEyMzRgYCBpcyAyIGJ5dGVzKS5cbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpO1xufVxuZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGlzQnl0ZXNMaWtlO1xuY29uc3QgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIHJlcHJlc2VudGF0aW9uIG9mICUlZGF0YSUlLlxuICovXG5mdW5jdGlvbiBoZXhsaWZ5KGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gYnl0ZXNbaV07XG4gICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuaGV4bGlmeSA9IGhleGxpZnk7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgY29uY2F0ZW5hdGluZyBhbGwgdmFsdWVzXG4gKiAgd2l0aGluICUlZGF0YSUlLlxuICovXG5mdW5jdGlvbiBjb25jYXQoZGF0YXMpIHtcbiAgICByZXR1cm4gXCIweFwiICsgZGF0YXMubWFwKChkKSA9PiBoZXhsaWZ5KGQpLnN1YnN0cmluZygyKSkuam9pbihcIlwiKTtcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZnVuY3Rpb24gZGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKS5sZW5ndGg7XG59XG5leHBvcnRzLmRhdGFMZW5ndGggPSBkYXRhTGVuZ3RoO1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5mdW5jdGlvbiBkYXRhU2xpY2UoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgaWYgKGVuZCAhPSBudWxsICYmIGVuZCA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShmYWxzZSwgXCJjYW5ub3Qgc2xpY2UgYmV5b25kIGRhdGEgYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBieXRlcy5sZW5ndGgsIG9mZnNldDogZW5kXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcy5zbGljZSgoc3RhcnQgPT0gbnVsbCkgPyAwIDogc3RhcnQsIChlbmQgPT0gbnVsbCkgPyBieXRlcy5sZW5ndGggOiBlbmQpKTtcbn1cbmV4cG9ydHMuZGF0YVNsaWNlID0gZGF0YVNsaWNlO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZnVuY3Rpb24gc3RyaXBaZXJvc0xlZnQoZGF0YSkge1xuICAgIGxldCBieXRlcyA9IGhleGxpZnkoZGF0YSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChieXRlcy5zdGFydHNXaXRoKFwiMDBcIikpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBieXRlcztcbn1cbmV4cG9ydHMuc3RyaXBaZXJvc0xlZnQgPSBzdHJpcFplcm9zTGVmdDtcbmZ1bmN0aW9uIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBsZWZ0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShsZW5ndGggPj0gYnl0ZXMubGVuZ3RoLCBcInBhZGRpbmcgZXhjZWVkcyBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShieXRlcyksXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBvZmZzZXQ6IGxlbmd0aCArIDFcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHJlc3VsdC5maWxsKDApO1xuICAgIGlmIChsZWZ0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIGxlbmd0aCAtIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKmxlZnQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqdmFsdWVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGB1aW50MTI4YGApLlxuICovXG5mdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbmV4cG9ydHMuemVyb1BhZFZhbHVlID0gemVyb1BhZFZhbHVlO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqcmlnaHQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqYnl0ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYGJ5dGVzMTZgYCkuXG4gKi9cbmZ1bmN0aW9uIHplcm9QYWRCeXRlcyhkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIGZhbHNlKTtcbn1cbmV4cG9ydHMuemVyb1BhZEJ5dGVzID0gemVyb1BhZEJ5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;\nconst _version_js_1 = __webpack_require__(/*! ../_version.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/_version.js\");\nconst properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nfunction isError(error, code) {\n    return (error && error.code === code);\n}\nexports.isError = isError;\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nfunction isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\nexports.isCallException = isCallException;\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nfunction makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js_1.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0, properties_js_1.defineProperties)(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0, properties_js_1.defineProperties)(error, { shortMessage });\n    }\n    return error;\n}\nexports.makeError = makeError;\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nfunction assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\nexports.assert = assert;\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nfunction assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nexports.assertArgument = assertArgument;\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nexports.assertArgumentCount = assertArgumentCount;\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nfunction assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\nexports.assertNormalize = assertNormalize;\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nfunction assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\nexports.assertPrivate = assertPrivate;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLHVCQUF1QixHQUFHLGVBQWU7QUFDdkwsc0JBQXNCLG1CQUFPLENBQUMsNEVBQWdCO0FBQzlDLHdCQUF3QixtQkFBTyxDQUFDLHFGQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QixhQUFhLElBQUksb0JBQW9CLG1CQUFtQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGdCQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQyxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDhCQUE4QjtBQUMvRTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxLQUFLO0FBQ0w7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTSxPQUFPO0FBQ3pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9lcnJvcnMuanM/ZGJmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEFsbCBlcnJvcnMgaW4gZXRoZXJzIGluY2x1ZGUgcHJvcGVydGllcyB0byBlbnN1cmUgdGhleSBhcmUgYm90aFxuICogIGh1bWFuLXJlYWRhYmxlIChpLmUuIGBgLm1lc3NhZ2VgYCkgYW5kIG1hY2hpbmUtcmVhZGFibGUgKGkuZS4gYGAuY29kZWBgKS5cbiAqXG4gKiAgVGhlIFtbaXNFcnJvcl1dIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoZSBlcnJvciBgYGNvZGVgYCBhbmRcbiAqICBwcm92aWRlIGEgdHlwZSBndWFyZCBmb3IgdGhlIHByb3BlcnRpZXMgcHJlc2VudCBvbiB0aGF0IGVycm9yIGludGVyZmFjZS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZXJyb3JzOkVycm9ycyAgW2Fib3V0LWVycm9yc11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRQcml2YXRlID0gZXhwb3J0cy5hc3NlcnROb3JtYWxpemUgPSBleHBvcnRzLmFzc2VydEFyZ3VtZW50Q291bnQgPSBleHBvcnRzLmFzc2VydEFyZ3VtZW50ID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLm1ha2VFcnJvciA9IGV4cG9ydHMuaXNDYWxsRXhjZXB0aW9uID0gZXhwb3J0cy5pc0Vycm9yID0gdm9pZCAwO1xuY29uc3QgX3ZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9fdmVyc2lvbi5qc1wiKTtcbmNvbnN0IHByb3BlcnRpZXNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXMuanNcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbIFwiICsgKHZhbHVlLm1hcChzdHJpbmdpZnkpKS5qb2luKFwiLCBcIikgKyBcIiBdXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldICYgMHhmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwieyBcIiArIGtleXMubWFwKChrKSA9PiBgJHtzdHJpbmdpZnkoayl9OiAke3N0cmluZ2lmeSh2YWx1ZVtrXSl9YCkuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgWyBDT1VMRCBOT1QgU0VSSUFMSVpFIF1gO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmIHRoZSAlJWVycm9yJSUgbWF0Y2hlcyBhbiBlcnJvciB0aHJvd24gYnkgZXRoZXJzXG4gKiAgdGhhdCBtYXRjaGVzIHRoZSBlcnJvciAlJWNvZGUlJS5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhhdCAlJWVycm9yJSVcbiAqICBtYXRjaGVzIGFuIEV0aGVyc0Vycm9yIHR5cGUsIHdoaWNoIG1lYW5zIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAqICBiZSBzZXQuXG4gKlxuICogIEBTZWUgW0Vycm9yQ29kZXNdKGFwaTpFcnJvckNvZGUpXG4gKiAgQGV4YW1wbGVcbiAqICAgIHRyeSB7XG4gKiAgICAgIC8vIGNvZGUuLi4uXG4gKiAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgIGlmIChpc0Vycm9yKGUsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAqICAgICAgICAgIC8vIFRoZSBUeXBlIEd1YXJkIGhhcyB2YWxpZGF0ZWQgdGhpcyBvYmplY3RcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKGUuZGF0YSk7XG4gKiAgICAgIH1cbiAqICAgIH1cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcihlcnJvciwgY29kZSkge1xuICAgIHJldHVybiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gY29kZSk7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlZXJyb3IlJSBpcyBhIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXS5cbiAqL1xuZnVuY3Rpb24gaXNDYWxsRXhjZXB0aW9uKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIik7XG59XG5leHBvcnRzLmlzQ2FsbEV4Y2VwdGlvbiA9IGlzQ2FsbEV4Y2VwdGlvbjtcbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcGVuZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lc3NhZ2UlJSxcbiAqICBldGhlcnMgdmVyc2lvbiwgJSVjb2RlJSUgYW5kIGFsbCBhZGRpdGlvbmFsIHByb3BlcnRpZXMsIHNlcmlhbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgbGV0IHNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gW107XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gaW5mbyB8fCBcImNvZGVcIiBpbiBpbmZvIHx8IFwibmFtZVwiIGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHdpbGwgb3ZlcndyaXRlIHBvcHVsYXRlZCB2YWx1ZXM6ICR7c3RyaW5naWZ5KGluZm8pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic2hvcnRNZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGluZm9ba2V5XSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBzdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNTU1cIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1bY291bGQgbm90IHNlcmlhbGl6ZSBvYmplY3RdXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBkZXRhaWxzLnB1c2goYHZlcnNpb249JHtfdmVyc2lvbl9qc18xLnZlcnNpb259YCk7XG4gICAgICAgIGlmIChkZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBkZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlcnJvcjtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBcIklOVkFMSURfQVJHVU1FTlRcIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTlVNRVJJQ19GQVVMVFwiOlxuICAgICAgICBjYXNlIFwiQlVGRkVSX09WRVJSVU5cIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAoMCwgcHJvcGVydGllc19qc18xLmRlZmluZVByb3BlcnRpZXMpKGVycm9yLCB7IGNvZGUgfSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlcnJvciwgaW5mbyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5zaG9ydE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAoMCwgcHJvcGVydGllc19qc18xLmRlZmluZVByb3BlcnRpZXMpKGVycm9yLCB7IHNob3J0TWVzc2FnZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0cy5tYWtlRXJyb3IgPSBtYWtlRXJyb3I7XG4vKipcbiAqICBUaHJvd3MgYW4gRXRoZXJzRXJyb3Igd2l0aCAlJW1lc3NhZ2UlJSwgJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgZXJyb3JcbiAqICAlJWluZm8lJSB3aGVuICUlY2hlY2slJSBpcyBmYWxzaXNoLi5cbiAqXG4gKiAgQHNlZSBbW2FwaTptYWtlRXJyb3JdXVxuICovXG5mdW5jdGlvbiBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgIHRocm93IG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogIEEgc2ltcGxlIGhlbHBlciB0byBzaW1wbHkgZW5zdXJpbmcgcHJvdmlkZWQgYXJndW1lbnRzIG1hdGNoIGV4cGVjdGVkXG4gKiAgY29uc3RyYWludHMsIHRocm93aW5nIGlmIG5vdC5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoZSAlJWNoZWNrJSUgaGFzIGJlZW4gYXNzZXJ0ZWQgdHJ1ZSwgc29cbiAqICBhbnkgZnVydGhlciBjb2RlIGRvZXMgbm90IG5lZWQgYWRkaXRpb25hbCBjb21waWxlLXRpbWUgY2hlY2tzLlxuICovXG5mdW5jdGlvbiBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5leHBvcnRzLmFzc2VydEFyZ3VtZW50ID0gYXNzZXJ0QXJndW1lbnQ7XG5mdW5jdGlvbiBhc3NlcnRBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzc2VydChjb3VudCA+PSBleHBlY3RlZENvdW50LCBcIm1pc3NpbmcgYXJndWVtbnRcIiArIG1lc3NhZ2UsIFwiTUlTU0lOR19BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xuICAgIGFzc2VydChjb3VudCA8PSBleHBlY3RlZENvdW50LCBcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG59XG5leHBvcnRzLmFzc2VydEFyZ3VtZW50Q291bnQgPSBhc3NlcnRBcmd1bWVudENvdW50O1xuY29uc3QgX25vcm1hbGl6ZUZvcm1zID0gW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0ucmVkdWNlKChhY2N1bSwgZm9ybSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEdlbmVyYWwgdGVzdCBmb3Igbm9ybWFsaXplXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKGZvcm0gPT09IFwiTkZEXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICAgICAgYWNjdW0ucHVzaChmb3JtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gYWNjdW07XG59LCBbXSk7XG4vKipcbiAqICBUaHJvd3MgaWYgdGhlIG5vcm1hbGl6YXRpb24gJSVmb3JtJSUgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm9ybWFsaXplKGZvcm0pIHtcbiAgICBhc3NlcnQoX25vcm1hbGl6ZUZvcm1zLmluZGV4T2YoZm9ybSkgPj0gMCwgXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGluZm86IHsgZm9ybSB9XG4gICAgfSk7XG59XG5leHBvcnRzLmFzc2VydE5vcm1hbGl6ZSA9IGFzc2VydE5vcm1hbGl6ZTtcbi8qKlxuICogIE1hbnkgY2xhc3NlcyB1c2UgZmlsZS1zY29wZWQgdmFsdWVzIHRvIGd1YXJkIHRoZSBjb25zdHJ1Y3RvcixcbiAqICBtYWtpbmcgaXQgZWZmZWN0aXZlbHkgcHJpdmF0ZS4gVGhpcyBmYWNpbGl0YXRlcyB0aGF0IHBhdHRlcm5cbiAqICBieSBlbnN1cmluZyB0aGUgJSVnaXZlbkdhdXJkJSUgbWF0Y2hlcyB0aGUgZmlsZS1zY29wZWQgJSVndWFyZCUlLFxuICogIHRocm93aW5nIGlmIG5vdCwgaW5kaWNhdGluZyB0aGUgJSVjbGFzc05hbWUlJSBpZiBwcm92aWRlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShnaXZlbkd1YXJkLCBndWFyZCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChnaXZlbkd1YXJkICE9PSBndWFyZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gY2xhc3NOYW1lLCBvcGVyYXRpb24gPSBcIm5ld1wiO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gXCIuXCI7XG4gICAgICAgICAgICBvcGVyYXRpb24gKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgcHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlICR7bWV0aG9kfWZyb20qIG1ldGhvZHNgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRQcml2YXRlID0gYXNzZXJ0UHJpdmF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/events.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventPayload = void 0;\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */\nconst properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */\nclass EventPayload {\n    /**\n     *  The event filter.\n     */\n    filter;\n    /**\n     *  The **EventEmitterable**.\n     */\n    emitter;\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */\n    constructor(emitter, listener, filter) {\n        this.#listener = listener;\n        (0, properties_js_1.defineProperties)(this, { emitter, filter });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */\n    async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n}\nexports.EventPayload = EventPayload;\n//# sourceMappingURL=events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9ldmVudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMscUZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL2V2ZW50cy5qcz8wZjJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudFBheWxvYWQgPSB2b2lkIDA7XG4vKipcbiAqICBFdmVudHMgYWxsb3cgZm9yIGFwcGxpY2F0aW9ucyB0byB1c2UgdGhlIG9ic2VydmVyIHBhdHRlcm4sIHdoaWNoXG4gKiAgYWxsb3dzIHN1YnNjcmliaW5nIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgb3V0c2lkZSB0aGUgbm9ybWFsXG4gKiAgZXhlY3V0aW9uIHBhdGhzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2V2ZW50czpFdmVudHMgIFthYm91dC1ldmVudHNdXG4gKi9cbmNvbnN0IHByb3BlcnRpZXNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXMuanNcIik7XG4vKipcbiAqICBXaGVuIGFuIFtbRXZlbnRFbWl0dGVyYWJsZV1dIHRyaWdnZXJzIGEgW1tMaXN0ZW5lcl1dLCB0aGVcbiAqICBjYWxsYmFjayBhbHdheXMgYWhhcyBvbmUgYWRkaXRpb25hbCBhcmd1bWVudCBwYXNzZWQsIHdoaWNoIGlzXG4gKiAgYW4gKipFdmVudFBheWxvYWQqKi5cbiAqL1xuY2xhc3MgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IGZpbHRlci5cbiAgICAgKi9cbiAgICBmaWx0ZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSAqKkV2ZW50RW1pdHRlcmFibGUqKi5cbiAgICAgKi9cbiAgICBlbWl0dGVyO1xuICAgICNsaXN0ZW5lcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqRXZlbnRQYXlsb2FkKiogZm9yICUlZW1pdHRlciUlIHdpdGhcbiAgICAgKiAgdGhlICUlbGlzdGVuZXIlJSBhbmQgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW1pdHRlciwgbGlzdGVuZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNsaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAoMCwgcHJvcGVydGllc19qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgZW1pdHRlciwgZmlsdGVyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVW5yZWdpc3RlciB0aGUgdHJpZ2dlcmVkIGxpc3RlbmVyIGZvciBmdXR1cmUgZXZlbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBpZiAodGhpcy4jbGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuZW1pdHRlci5vZmYodGhpcy5maWx0ZXIsIHRoaXMuI2xpc3RlbmVyKTtcbiAgICB9XG59XG5leHBvcnRzLkV2ZW50UGF5bG9hZCA9IEV2ZW50UGF5bG9hZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchResponse = exports.FetchRequest = exports.FetchCancelSignal = void 0;\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nconst base64_js_1 = __webpack_require__(/*! ./base64.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/base64.js\");\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nconst utf8_js_1 = __webpack_require__(/*! ./utf8.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/utf8.js\");\nconst geturl_js_1 = __webpack_require__(/*! ./geturl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/geturl.js\");\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = (0, geturl_js_1.createGetUrl)();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": (match[1] || \"text/plain\"),\n        }, (match[2] ? (0, base64_js_1.decodeBase64)(match[3]) : unpercent(match[3])));\n    }\n    catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        }\n        catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nclass FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request) {\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners) {\n                setTimeout(() => { listener(); }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        (0, errors_js_1.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() { return this.#cancelled; }\n    checkSignal() {\n        (0, errors_js_1.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\nexports.FetchCancelSignal = FetchCancelSignal;\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nclass FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    #getUrlFunc;\n    /**\n     *  The fetch URL to request.\n     */\n    get url() { return this.#url; }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n    get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        }\n        else if (typeof (body) === \"string\") {\n            this.#body = (0, utf8_js_1.toUtf8Bytes)(body);\n            this.#bodyType = \"text/plain\";\n        }\n        else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        }\n        else if (typeof (body) === \"object\") {\n            this.#body = (0, utf8_js_1.toUtf8Bytes)(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        }\n        else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */\n    hasBody() {\n        return (this.#body != null);\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n    get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n    get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${(0, base64_js_1.encodeBase64)((0, utf8_js_1.toUtf8Bytes)(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n    getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n    setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n    clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [key, headers[key]], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n    get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n    setCredentials(username, password) {\n        (0, errors_js_1.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n    get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n    get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */\n    get timeout() { return this.#timeout; }\n    set timeout(timeout) {\n        (0, errors_js_1.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n    get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n    get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */\n    get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */\n    get getUrlFunc() {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        this.#getUrlFunc = value;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */\n    constructor(url) {\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n        this.#getUrlFunc = null;\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0, data_js_1.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n    setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        (0, errors_js_1.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\", reason: \"timeout\", request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    }\n                    catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof (error.stall) !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                        // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            }\n            catch (error) { }\n            // Things won't get any better on another attempt; abort\n            return response;\n        }\n        else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            }\n            catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof (error.stall) !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    send() {\n        (0, errors_js_1.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.send\" });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n    cancel() {\n        (0, errors_js_1.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.cancel\" });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n    redirect(location) {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0, errors_js_1.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */\n    clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        clone.#getUrlFunc = this.#getUrlFunc;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n    static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n    static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */\n    static createGetUrlFunc(options) {\n        return (0, geturl_js_1.createGetUrl)(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n    static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n    static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\nexports.FetchRequest = FetchRequest;\n;\n/**\n *  The response for a FetchRequest.\n */\nclass FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0, data_js_1.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */\n    get statusCode() { return this.#statusCode; }\n    /**\n     *  The response status message.\n     */\n    get statusMessage() { return this.#statusMessage; }\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n    get headers() { return Object.assign({}, this.#headers); }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n    get body() {\n        return (this.#body == null) ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n    get bodyText() {\n        try {\n            return (this.#body == null) ? \"\" : (0, utf8_js_1.toUtf8String)(this.#body);\n        }\n        catch (error) {\n            (0, errors_js_1.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\", info: { response: this }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n    get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        }\n        catch (error) {\n            (0, errors_js_1.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\", info: { response: this }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [key, headers[key]], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request) {\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = ((body == null) ? null : new Uint8Array(body));\n        this.#request = (request || null);\n        this.#error = { message: \"\" };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */\n    makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        }\n        else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = { message, error };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n    throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        }\n        else {\n            (0, errors_js_1.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0, properties_js_1.defineProperties)(error, { stall, throttle: true });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n    getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true if the response has a body.\n     */\n    hasBody() {\n        return (this.#body != null);\n    }\n    /**\n     *  The request made for this response.\n     */\n    get request() { return this.#request; }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n    ok() {\n        return (this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300);\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n    assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        let requestUrl = null;\n        if (this.request) {\n            requestUrl = this.request.url;\n        }\n        let responseBody = null;\n        try {\n            if (this.#body) {\n                responseBody = (0, utf8_js_1.toUtf8String)(this.#body);\n            }\n        }\n        catch (e) { }\n        (0, errors_js_1.assert)(false, message, \"SERVER_ERROR\", {\n            request: (this.request || \"unknown request\"), response: this, error,\n            info: {\n                requestUrl, responseBody,\n                responseStatus: `${this.statusCode} ${this.statusMessage}`\n            }\n        });\n    }\n}\nexports.FetchResponse = FetchResponse;\nfunction getTime() { return (new Date()).getTime(); }\nfunction unpercent(value) {\n    return (0, utf8_js_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyx5QkFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRLEVBQUUsU0FBUztBQUMxRDtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsZ0RBQWdELHVFQUF1RTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVMsR0FBRyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQTZCLE1BQU0sMEJBQTBCLFVBQVUsOEJBQThCLE9BQU8seURBQXlEO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsZ0NBQWdDO0FBQ3pJO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxrQ0FBa0M7QUFDaEo7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWEsRUFBRSwwQkFBMEIsS0FBSyx5QkFBeUI7QUFDMUcsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUIsT0FBTyx5REFBeUQ7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQixFQUFFLG1CQUFtQjtBQUMvRCw4REFBOEQsUUFBUTtBQUN0RTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQixFQUFFLHFCQUFxQixFQUFFLFFBQVE7QUFDaEg7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsdUJBQXVCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBLHlDQUF5QyxpQkFBaUIsRUFBRSxtQkFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCLEVBQUUsbUJBQW1CO0FBQ3pFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvZmV0Y2guanM/M2JkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmV0Y2hSZXNwb25zZSA9IGV4cG9ydHMuRmV0Y2hSZXF1ZXN0ID0gZXhwb3J0cy5GZXRjaENhbmNlbFNpZ25hbCA9IHZvaWQgMDtcbi8qKlxuICogIEZldGNoaW5nIGNvbnRlbnQgZnJvbSB0aGUgd2ViIGlzIGVudmlyb25tZW50LXNwZWNpZmljLCBzbyBFdGhlcnNcbiAqICBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiB0aGF0IGVhY2ggZW52aXJvbm1lbnQgY2FuIGltcGxlbWVudCB0byBwcm92aWRlXG4gKiAgdGhpcyBzZXJ2aWNlLlxuICpcbiAqICBPbiBbTm9kZS5qc10obGluay1ub2RlKSwgdGhlIGBgaHR0cGBgIGFuZCBgYGh0dHBzYGAgbGlicyBhcmUgdXNlZCB0b1xuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxuICogIGFuZCBwb3B1bGF0ZSB0aGUgW1tGZXRjaFJlc3BvbnNlXV0uXG4gKlxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiAgYGBQcm9taXNlYGAgaXMgd2FpdGVkIG9uIHRvIHJldHJpZXZlIHRoZSBwYXlsb2FkLlxuICpcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcbiAqICBzdWNoIGFzIHJlZGlyZWN0cywgc2VydmVyIHRocm90dGxpbmcsIGF1dGhlbnRpY2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmNvbnN0IGJhc2U2NF9qc18xID0gcmVxdWlyZShcIi4vYmFzZTY0LmpzXCIpO1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuY29uc3QgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllcy5qc1wiKTtcbmNvbnN0IHV0ZjhfanNfMSA9IHJlcXVpcmUoXCIuL3V0ZjguanNcIik7XG5jb25zdCBnZXR1cmxfanNfMSA9IHJlcXVpcmUoXCIuL2dldHVybC5qc1wiKTtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGRlZmF1bHRHZXRVcmxGdW5jID0gKDAsIGdldHVybF9qc18xLmNyZWF0ZUdldFVybCkoKTtcbmNvbnN0IHJlRGF0YSA9IG5ldyBSZWdFeHAoXCJeZGF0YTooW147Ol0qKT8oO2Jhc2U2NCk/LCguKikkXCIsIFwiaVwiKTtcbmNvbnN0IHJlSXBmcyA9IG5ldyBSZWdFeHAoXCJeaXBmczovXFwvKGlwZnMvKT8oLiopJFwiLCBcImlcIik7XG4vLyBJZiBsb2NrZWQsIG5ldyBHYXRld2F5cyBjYW5ub3QgYmUgYWRkZWRcbmxldCBsb2NrZWQgPSBmYWxzZTtcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUkxzXG5hc3luYyBmdW5jdGlvbiBkYXRhR2F0ZXdheUZ1bmModXJsLCBzaWduYWwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZURhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDIwMCwgXCJPS1wiLCB7XG4gICAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiAobWF0Y2hbMV0gfHwgXCJ0ZXh0L3BsYWluXCIpLFxuICAgICAgICB9LCAobWF0Y2hbMl0gPyAoMCwgYmFzZTY0X2pzXzEuZGVjb2RlQmFzZTY0KShtYXRjaFszXSkgOiB1bnBlcmNlbnQobWF0Y2hbM10pKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIGRhdGE6IFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRmV0Y2hHYXRld2F5RnVuY11dIGZvciBmZXRjaGluZyBjb250ZW50IGZyb20gYSBzdGFuZGFyZFxuICogIElQRlMgZ2F0ZXdheSBob3N0ZWQgYXQgJSViYXNlVXJsJSUuXG4gKi9cbmZ1bmN0aW9uIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2F0ZXdheUlwZnModXJsLCBzaWduYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlSXBmcyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBsaW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlcXVlc3QoYCR7YmFzZVVybH0ke21hdGNoWzJdfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgXCJCQUQgUkVRVUVTVCAoaW52YWxpZCBJUEZTIFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdhdGV3YXlJcGZzO1xufVxuY29uc3QgR2F0ZXdheXMgPSB7XG4gICAgXCJkYXRhXCI6IGRhdGFHYXRld2F5RnVuYyxcbiAgICBcImlwZnNcIjogZ2V0SXBmc0dhdGV3YXlGdW5jKFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiKVxufTtcbmNvbnN0IGZldGNoU2lnbmFscyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKCF0aGlzLiNjYW5jZWxsZWQsIFwic2luZ2FsIGFscmVhZHkgY2FuY2VsbGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmZXRjaENhbmNlbFNpZ25hbC5hZGRDYW5jZWxMaXN0ZW5lclwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIGdldCBjYW5jZWxsZWQoKSB7IHJldHVybiB0aGlzLiNjYW5jZWxsZWQ7IH1cbiAgICBjaGVja1NpZ25hbCgpIHtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoIXRoaXMuY2FuY2VsbGVkLCBcImNhbmNlbGxlZFwiLCBcIkNBTkNFTExFRFwiLCB7fSk7XG4gICAgfVxufVxuZXhwb3J0cy5GZXRjaENhbmNlbFNpZ25hbCA9IEZldGNoQ2FuY2VsU2lnbmFsO1xuLy8gQ2hlY2sgdGhlIHNpZ25hbCwgdGhyb3dpbmcgaWYgaXQgaXMgY2FuY2VsbGVkXG5mdW5jdGlvbiBjaGVja1NpZ25hbChzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBzaWduYWwuY2hlY2tTaWduYWwoKTtcbiAgICByZXR1cm4gc2lnbmFsO1xufVxuLyoqXG4gKiAgUmVwcmVzZW50cyBhIHJlcXVlc3QgZm9yIGEgcmVzb3VyY2UgdXNpbmcgYSBVUkkuXG4gKlxuICogIEJ5IGRlZmF1bHQsIHRoZSBzdXBwb3J0ZWQgc2NoZW1lcyBhcmUgYGBIVFRQYGAsIGBgSFRUUFNgYCwgYGBkYXRhOmBgLFxuICogIGFuZCBgYElQRlM6YGAuXG4gKlxuICogIEFkZGl0aW9uYWwgc2NoZW1lcyBjYW4gYmUgYWRkZWQgZ2xvYmFsbHkgdXNpbmcgW1tyZWdpc3RlckdhdGV3YXldXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KFwiaHR0cHM6Ly93d3cucmljbW9vLmNvbVwiKVxuICogICAgcmVzcCA9IGF3YWl0IHJlcS5zZW5kKClcbiAqICAgIHJlc3AuYm9keS5sZW5ndGhcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgICNnZXRVcmxGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJMIHRvIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIHNldCB1cmwodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGEgYm9keSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cbiAgICAgKiAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXG4gICAgICogIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgKS5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYHRleHQvcGxhaW5gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcbiAgICAgKiAgc2V0IHRvIGBgYXBwbGljYXRpb24vanNvbmBgLlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIHNldCBib2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSAoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKShib2R5KTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSAoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKShKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBJZiBubyBtZXRob2RcbiAgICAgKiAgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQsIHRoZW4gYGBHRVRgYCBpcyB1c2VkIGlmIHRoZSBib2R5IGlzXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcbiAgICAgKiAga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcbiAgICAgKiAgaW4gdGhlIGBgRmV0Y2hSZXF1ZXN0YGAuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNjcmVkcykge1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHsoMCwgYmFzZTY0X2pzXzEuZW5jb2RlQmFzZTY0KSgoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKSh0aGlzLiNjcmVkcykpfWA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gPSBcImd6aXBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9PSBudWxsICYmIHRoaXMuI2JvZHlUeXBlKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0gU3RyaW5nKHRoaXMuYm9keS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlIHRvICUldmFsdWUlJS4gQWxsIHZhbHVlcyBhcmUgY29lcmNlZFxuICAgICAqICB0byBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzW1N0cmluZyhrZXkpLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENsZWFyIGFsbCBoZWFkZXJzLCByZXNldHRpbmcgYWxsIGludHJpbnNpYyBoZWFkZXJzLlxuICAgICAqL1xuICAgIGNsZWFySGVhZGVycygpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IHt9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGZvciB0aGUgYGBBdXRob3JpemF0aW9uYGAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIFRvIHNldCB0aGUgY3JlZGVudGlhbHMsIHVzZSB0aGUgYGBzZXRDcmVkZW50aWFsc2BgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjcmVkcyB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0cyBhbiBgYEF1dGhvcml6YXRpb25gYCBmb3IgJSV1c2VybmFtZSUlIHdpdGggJSVwYXNzd29yZCUlLlxuICAgICAqL1xuICAgIHNldENyZWRlbnRpYWxzKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKCF1c2VybmFtZS5tYXRjaCgvOi8pLCBcImludmFsaWQgYmFzaWMgYXV0aGVudGljYXRpb24gdXNlcm5hbWVcIiwgXCJ1c2VybmFtZVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI2NyZWRzID0gYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuYWJsZSBhbmQgcmVxdWVzdCBnemlwLWVuY29kZWQgcmVzcG9uc2VzLiBUaGUgcmVzcG9uc2Ugd2lsbFxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0d6aXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xuICAgIH1cbiAgICBzZXQgYWxsb3dHemlwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxuICAgICAqICBjaGFubmVscy4gLy8oZGVmYXVsdDogZmFsc2UpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNhbGxvd0luc2VjdXJlO1xuICAgIH1cbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBmb3IgYSBjb21wbGV0ZSByZXNwb25zZS5cbiAgICAgKiAgLy8oZGVmYXVsdDogNSBtaW51dGVzKS8vXG4gICAgICovXG4gICAgZ2V0IHRpbWVvdXQoKSB7IHJldHVybiB0aGlzLiN0aW1lb3V0OyB9XG4gICAgc2V0IHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHRpbWVvdXQgPj0gMCwgXCJ0aW1lb3V0IG11c3QgYmUgbm9uLXplcm9cIiwgXCJ0aW1lb3V0XCIsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcbiAgICAgKiAgZHVyaW5nIGEgcmVkaXJlY3Rpb24gb3IgcmV0cnkgaW4gY2FzZSBvZiBzZXJ2ZXIgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxuICAgICAqICBjb250ZW50IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWZsaWdodCB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcbiAgICAgICAgdGhpcy4jcHJlZmxpZ2h0ID0gcHJlZmxpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXNwb25zZSwgb2ZmZXJpbmcgYW5cbiAgICAgKiAgb3Bwb3J0dW5pdHkgdG8gcHJvdmlkZSBjbGllbnQtbGV2ZWwgdGhyb3R0bGluZyBvciB1cGRhdGluZ1xuICAgICAqICByZXNwb25zZSBkYXRhLlxuICAgICAqXG4gICAgICogIEFueSBlcnJvciB0aHJvd24gaW4gdGhpcyBjYXVzZXMgdGhlIGBgc2VuZCgpYGAgdG8gdGhyb3cuXG4gICAgICpcbiAgICAgKiAgVG8gc2NoZWR1bGUgYSByZXRyeSBhdHRlbXB0IChhc3N1bWluZyB0aGUgbWF4aW11bSByZXRyeSBsaW1pdFxuICAgICAqICBoYXMgbm90IGJlZW4gcmVhY2hlZCksIHVzZSBbW3Jlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcl1dLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByb2Nlc3NGdW5jKHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHJldHJ5IGF0dGVtcHQuXG4gICAgICovXG4gICAgZ2V0IHJldHJ5RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JldHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCByZXRyeUZ1bmMocmV0cnkpIHtcbiAgICAgICAgdGhpcy4jcmV0cnkgPSByZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcbiAgICAgKiAgYnJvd3NlcnMpLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxuICAgICAqICBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdXNpbmcgW1tyZWdpc3RlckdldFVybF1dLlxuICAgICAqICBJZiB0aGlzIGhhcyBiZWVuIHNldCwgc2V0dGluZyBpcyB0byBgYG51bGxgYCB3aWxsIGNhdXNlXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXG4gICAgICogIHVzaW5nIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcbiAgICAgKiAgZm9yIGRldmVsb3BlcnMgdGhhdCB3aXNoIHRvIGludGVyY2VwdCByZXF1ZXN0cyBvciB0b1xuICAgICAqICBjb25maWd1cmVnZSBhIHByb3h5IG9yIG90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGdldCBnZXRVcmxGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0VXJsRnVuYyB8fCBkZWZhdWx0R2V0VXJsRnVuYztcbiAgICB9XG4gICAgc2V0IGdldFVybEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEZldGNoUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIE9uY2UgY3JlYXRlZCwgZWFjaCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGJlZm9yZSBpc3N1aW5nIGFcbiAgICAgKiAgYGAuc2VuZCgpYGAgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jZ3ppcCA9IHRydWU7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IDMwMDAwMDtcbiAgICAgICAgdGhpcy4jdGhyb3R0bGUgPSB7XG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogTUFYX0FUVEVNUFRTXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyAoMCwgZGF0YV9qc18xLmhleGxpZnkpKHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxuICAgICAqICBhdHRlbXB0cyBhbmQgZXhwb25lbnRpYWwtYmFja29mZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNsb3RJbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgPSBwYXJhbXMuc2xvdEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWF4QXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMgPSBwYXJhbXMubWF4QXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3NlbmQoYXR0ZW1wdCwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXhjZWVkZWQgbWF4aW11bSByZXRyeSBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShnZXRUaW1lKCkgPD0gZXhwaXJlcywgXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdC5zZW5kXCIsIHJlYXNvbjogXCJ0aW1lb3V0XCIsIHJlcXVlc3Q6IF9yZXF1ZXN0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWl0KGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBjb25zdCBzY2hlbWUgPSAocmVxLnVybC5zcGxpdChcIjpcIilbMF0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gUHJvY2VzcyBhbnkgR2F0ZXdheXNcbiAgICAgICAgaWYgKHNjaGVtZSBpbiBHYXRld2F5cykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgR2F0ZXdheXNbc2NoZW1lXShyZXEudXJsLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRmV0Y2hSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRocm90dGxpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBhIHByZWZsaWdodCBmdW5jdGlvbjsgdXBkYXRlIHRoZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLnByZWZsaWdodEZ1bmMpIHtcbiAgICAgICAgICAgIHJlcSA9IGF3YWl0IHRoaXMucHJlZmxpZ2h0RnVuYyhyZXEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmdldFVybEZ1bmMocmVxLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKHJlc3Auc3RhdHVzQ29kZSwgcmVzcC5zdGF0dXNNZXNzYWdlLCByZXNwLmhlYWRlcnMsIHJlc3AuYm9keSwgX3JlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMikge1xuICAgICAgICAgICAgLy8gUmVkaXJlY3RcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5yZWRpcmVjdChsb2NhdGlvbikuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIDAsIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gVGhpbmdzIHdvbid0IGdldCBhbnkgYmV0dGVyIG9uIGFub3RoZXIgYXR0ZW1wdDsgYWJvcnRcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICBpZiAodGhpcy5yZXRyeUZ1bmMgPT0gbnVsbCB8fCAoYXdhaXQgdGhpcy5yZXRyeUZ1bmMocmVxLCByZXNwb25zZSwgYXR0ZW1wdCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VJbnQocmV0cnlBZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YWxsID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBlcnJvci5zdGFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgYnkgc2VuZGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZW5kKCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSh0aGlzLiNzaWduYWwgPT0gbnVsbCwgXCJyZXF1ZXN0IGFscmVhZHkgc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3Quc2VuZFwiIH0pO1xuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNzZW5kKDAsIGdldFRpbWUoKSArIHRoaXMudGltZW91dCwgMCwgdGhpcywgbmV3IEZldGNoUmVzcG9uc2UoMCwgXCJcIiwge30sIG51bGwsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbmNlbHMgdGhlIGluZmxpZ2h0IHJlc3BvbnNlLCBjYXVzaW5nIGEgYGBDQU5DRUxMRURgYFxuICAgICAqICBlcnJvciB0byBiZSByZWplY3RlZCBmcm9tIHRoZSBbW3NlbmRdXS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHRoaXMuI3NpZ25hbCAhPSBudWxsLCBcInJlcXVlc3QgaGFzIG5vdCBiZWVuIHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LmNhbmNlbFwiIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBmZXRjaFNpZ25hbHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cbiAgICAgKiAgdG8gJSVsb2NhdGlvbiUlLlxuICAgICAqL1xuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGlvbnNcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcmVkaXJlY3Rpbmc6XG4gICAgICAgIC8vIC0gbm9uLUdFVCByZXF1ZXN0c1xuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxuICAgICAgICAvLyAtIHRvIG5vbi1IVFRQIChvciBub24tSFRUUFMpIHByb3RvY29scyBbdGhpcyBjb3VsZCBiZSByZWxheGVkP11cbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkodGhpcy5tZXRob2QgPT09IFwiR0VUXCIgJiYgKGN1cnJlbnQgIT09IFwiaHR0cHNcIiB8fCB0YXJnZXQgIT09IFwiaHR0cFwiKSAmJiBsb2NhdGlvbi5tYXRjaCgvXmh0dHBzPzovKSwgYHVuc3VwcG9ydGVkIHJlZGlyZWN0YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgcmVkaXJlY3QoJHt0aGlzLm1ldGhvZH0gJHtKU09OLnN0cmluZ2lmeSh0aGlzLnVybCl9ID0+ICR7SlNPTi5zdHJpbmdpZnkobG9jYXRpb24pfSlgXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgcmVxdWVzdCwgd2l0aCBhIG5ldyBVUkxcbiAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChsb2NhdGlvbik7XG4gICAgICAgIHJlcS5tZXRob2QgPSBcIkdFVFwiO1xuICAgICAgICByZXEuYWxsb3dHemlwID0gdGhpcy5hbGxvd0d6aXA7XG4gICAgICAgIHJlcS50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICByZXEuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgIHJlcS4jYm9keSA9IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcS4jYm9keVR5cGUgPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgLy8gRG8gbm90IGZvcndhcmQgY3JlZGVudGlhbHMgdW5sZXNzIG9uIHRoZSBzYW1lIGRvbWFpbjsgb25seSBhYnNvbHV0ZVxuICAgICAgICAvL3JlcS5hbGxvd0luc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIC8vIHBhdGhzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOyBtYXkgd2FudCBhIHdheSB0byBzcGVjaWZ5IHRvIGZvcndhcmQ/XG4gICAgICAgIC8vc2V0U3RvcmUocmVxLiNwcm9wcywgXCJjcmVkc1wiLCBnZXRTdG9yZSh0aGlzLiNwcm9zLCBcImNyZWRzXCIpKTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBjb3B5IG9mIHRoaXMgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgRmV0Y2hSZXF1ZXN0KHRoaXMudXJsKTtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IG1ldGhvZFwiIChpLmUuIG51bGwpXG4gICAgICAgIGNsb25lLiNtZXRob2QgPSB0aGlzLiNtZXRob2Q7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBib2R5XCIgd2l0aCB0eXBlLCBjb3B5aW5nIHRoZSBVaW50OEFycmF5IGlzIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgIGNsb25lLiNib2R5ID0gdGhpcy4jYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jYm9keVR5cGUgPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IGhlYWRlcnNcIlxuICAgICAgICBjbG9uZS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICAvLyBDcmVkZW50aWFscyBpcyByZWFkb25seSwgc28gd2UgY29weSBpbnRlcm5hbGx5XG4gICAgICAgIGNsb25lLiNjcmVkcyA9IHRoaXMuI2NyZWRzO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcbiAgICAgICAgICAgIGNsb25lLmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLiNwcmVmbGlnaHQgPSB0aGlzLiNwcmVmbGlnaHQ7XG4gICAgICAgIGNsb25lLiNwcm9jZXNzID0gdGhpcy4jcHJvY2VzcztcbiAgICAgICAgY2xvbmUuI3JldHJ5ID0gdGhpcy4jcmV0cnk7XG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgTG9ja3MgYWxsIHN0YXRpYyBjb25maWd1cmF0aW9uIGZvciBnYXRld2F5cyBhbmQgRmV0Y2hHZXRVcmxGdW5jXG4gICAgICogIHJlZ2lzdHJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9ja0NvbmZpZygpIHtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgY3VycmVudCBHYXRld2F5IGZ1bmN0aW9uIGZvciAlJXNjaGVtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRHYXRld2F5KHNjaGVtZSkge1xuICAgICAgICByZXR1cm4gR2F0ZXdheXNbc2NoZW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgdGhlICUlZnVuYyUlIHdoZW4gZmV0Y2hpbmcgVVJJcyB1c2luZyAlJXNjaGVtZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XG4gICAgICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSBcImh0dHBcIiB8fCBzY2hlbWUgPT09IFwiaHR0cHNcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIEdhdGV3YXlzW3NjaGVtZV0gPSBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlICUlZ2V0VXJsJSUgd2hlbiBmZXRjaGluZyBVUklzIG92ZXIgSFRUUCBhbmQgSFRUUFMgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdEdldFVybEZ1bmMgPSBnZXRVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZ2V0VXJsIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcy5cbiAgICAgKlxuICAgICAqICBUaGUgYXZhaWxhYmxlICUlb3B0aW9ucyUlIGFyZSBkZXBlbmRlbnQgb24gdGhlIHBsYXRmb3JtXG4gICAgICogIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkZWZhdWx0IGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgaXMgdXNlZnVsXG4gICAgICogIHdoZW4gdHJ5aW5nIHRvIGN1c3RvbWl6ZSBzaW1wbGUgYmVoYXZpb3VyIHdoZW4gZmV0Y2hpbmcgSFRUUFxuICAgICAqICBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVHZXRVcmxGdW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBnZXR1cmxfanNfMS5jcmVhdGVHZXRVcmwpKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIFwiZmV0Y2hcIiBkYXRhIFVSSXMuXG4gICAgICpcbiAgICAgKiAgTm90ZSB0aGF0IHRoaXMgaXMgYXV0b21hdGljYWxseSBkb25lIGludGVybmFsbHkgdG8gc3VwcG9ydFxuICAgICAqICBkYXRhIFVSSXMsIHNvIGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gcmVnaXN0ZXIgaXQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgZ2VuZXJhbGx5IHNvbWV0aGluZyB0aGF0IGlzIG5lZWRlZCwgYnV0IG1heVxuICAgICAqICBiZSB1c2VmdWwgaW4gYSB3cmFwcGVyIHRvIHBlcmZvbSBjdXN0b20gZGF0YSBVUkkgZnVuY3Rpb25hbGl0eS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRGF0YUdhdGV3YXkoKSB7XG4gICAgICAgIHJldHVybiBkYXRhR2F0ZXdheUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGZldGNoIElQRlMgKHVudmFsaWRhdGVkKSBmcm9tXG4gICAgICogIGEgY3VzdG9tIGdhdGV3YXkgYmFzZVVybC5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCBJUEZTIGdhdGV3YXkgdXNlZCBpbnRlcm5hbGx5IGlzXG4gICAgICogIGBgXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCJgYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICAgICAgcmV0dXJuIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKTtcbiAgICB9XG59XG5leHBvcnRzLkZldGNoUmVxdWVzdCA9IEZldGNoUmVxdWVzdDtcbjtcbi8qKlxuICogIFRoZSByZXNwb25zZSBmb3IgYSBGZXRjaFJlcXVlc3QuXG4gKi9cbmNsYXNzIEZldGNoUmVzcG9uc2Uge1xuICAgICNzdGF0dXNDb2RlO1xuICAgICNzdGF0dXNNZXNzYWdlO1xuICAgICNoZWFkZXJzO1xuICAgICNib2R5O1xuICAgICNyZXF1ZXN0O1xuICAgICNlcnJvcjtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXNwb25zZSBzdGF0dXM9JHt0aGlzLnN0YXR1c0NvZGV9IGJvZHk9JHt0aGlzLiNib2R5ID8gKDAsIGRhdGFfanNfMS5oZXhsaWZ5KSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c01lc3NhZ2UoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNNZXNzYWdlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBvciBgYG51bGxgYCBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHkgYXMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZywgb3IgdGhlIGVtcHR5XG4gICAgICogIHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgVVRGLTggZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYm9keVRleHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBcIlwiIDogKDAsIHV0ZjhfanNfMS50b1V0ZjhTdHJpbmcpKHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoZmFsc2UsIFwicmVzcG9uc2UgYm9keSBpcyBub3QgdmFsaWQgVVRGLTggZGF0YVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImJvZHlUZXh0XCIsIGluZm86IHsgcmVzcG9uc2U6IHRoaXMgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBkZWNvZGVkIGFzIEpTT04uXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgSlNPTi1lbmNvZGVkIGRhdGFcbiAgICAgKiAgb3IgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICovXG4gICAgZ2V0IGJvZHlKc29uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5ib2R5VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBKU09OXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keUpzb25cIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzLCBib2R5LCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI3N0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLiNzdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZSgoYWNjdW0sIGspID0+IHtcbiAgICAgICAgICAgIGFjY3VtW2sudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcoaGVhZGVyc1trXSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy4jYm9keSA9ICgoYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheShib2R5KSk7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSAocmVxdWVzdCB8fCBudWxsKTtcbiAgICAgICAgdGhpcy4jZXJyb3IgPSB7IG1lc3NhZ2U6IFwiXCIgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIFJlc3BvbnNlIHdpdGggbWF0Y2hpbmcgaGVhZGVycyBhbmQgYm9keSwgYnV0IHdpdGhcbiAgICAgKiAgYW4gZXJyb3Igc3RhdHVzIGNvZGUgKGkuZS4gNTk5KSBhbmQgJSVtZXNzYWdlJSUgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJWVycm9yJSUuXG4gICAgICovXG4gICAgbWFrZVNlcnZlckVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgIGxldCBzdGF0dXNNZXNzYWdlO1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9OyAke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIHN0YXR1c01lc3NhZ2UsIHRoaXMuaGVhZGVycywgdGhpcy5ib2R5LCB0aGlzLiNyZXF1ZXN0IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIHJlc3BvbnNlLiNlcnJvciA9IHsgbWVzc2FnZSwgZXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgY2FsbGVkIHdpdGhpbiBhIFtyZXF1ZXN0LnByb2Nlc3NGdW5jXShGZXRjaFJlcXVlc3QtcHJvY2Vzc0Z1bmMpXG4gICAgICogIGNhbGwsIGNhdXNlcyB0aGUgcmVxdWVzdCB0byByZXRyeSBhcyBpZiB0aHJvdHRsZWQgZm9yICUlc3RhbGwlJVxuICAgICAqICBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgdGhyb3dUaHJvdHRsZUVycm9yKG1lc3NhZ2UsIHN0YWxsKSB7XG4gICAgICAgIGlmIChzdGFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFsbCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwidGhyb3R0bGluZyByZXF1ZXN0c1wiKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKShlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgdmFsdWUgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVxdWVzdCBtYWRlIGZvciB0aGlzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyByZXNwb25zZSB3YXMgYSBzdWNjZXNzIHN0YXR1c0NvZGUuXG4gICAgICovXG4gICAgb2soKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZXJyb3IubWVzc2FnZSA9PT0gXCJcIiAmJiB0aGlzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHRoaXMuc3RhdHVzQ29kZSA8IDMwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgYSBgYFNFUlZFUl9FUlJPUmBgIGlmIHRoaXMgcmVzcG9uc2UgaXMgbm90IG9rLlxuICAgICAqL1xuICAgIGFzc2VydE9rKCkge1xuICAgICAgICBpZiAodGhpcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWVzc2FnZSwgZXJyb3IgfSA9IHRoaXMuI2Vycm9yO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBzZXJ2ZXIgcmVzcG9uc2UgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RVcmwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJsID0gdGhpcy5yZXF1ZXN0LnVybDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VCb2R5ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VCb2R5ID0gKDAsIHV0ZjhfanNfMS50b1V0ZjhTdHJpbmcpKHRoaXMuI2JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoZmFsc2UsIG1lc3NhZ2UsIFwiU0VSVkVSX0VSUk9SXCIsIHtcbiAgICAgICAgICAgIHJlcXVlc3Q6ICh0aGlzLnJlcXVlc3QgfHwgXCJ1bmtub3duIHJlcXVlc3RcIiksIHJlc3BvbnNlOiB0aGlzLCBlcnJvcixcbiAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXJsLCByZXNwb25zZUJvZHksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VTdGF0dXM6IGAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkZldGNoUmVzcG9uc2UgPSBGZXRjaFJlc3BvbnNlO1xuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKSh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/fixednumber.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/fixednumber.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FixedNumber = void 0;\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst maths_js_1 = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nconst properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while (result.length < decimals) {\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        (0, errors_js_1.assert)(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        if (val > BN_0) {\n            val = (0, maths_js_1.fromTwos)((0, maths_js_1.mask)(val, width), width);\n        }\n        else {\n            val = -(0, maths_js_1.fromTwos)((0, maths_js_1.mask)(-val, width), width);\n        }\n    }\n    else {\n        const limit = (BN_1 << width);\n        (0, errors_js_1.assert)(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof (value) === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof (value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        }\n        else if (value === \"ufixed\") {\n            signed = false;\n        }\n        else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0, errors_js_1.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    }\n    else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue) => {\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0, errors_js_1.assertArgument)(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0, errors_js_1.assertArgument)((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0, errors_js_1.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return { signed, width, decimals, name };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return (negative + str);\n    }\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) {\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return (negative + str);\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nclass FixedNumber {\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    format;\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _value;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */\n    constructor(guard, value, format) {\n        (0, errors_js_1.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0, properties_js_1.defineProperties)(this, { format: format.name, _value });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed() { return this.#format.signed; }\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width() { return this.#format.width; }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals() { return this.#format.decimals; }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value() { return this.#val; }\n    #checkFormat(other) {\n        (0, errors_js_1.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other) { return this.#add(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other) { return this.#add(other, \"add\"); }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other) { return this.#sub(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other) { return this.#sub(other, \"sub\"); }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other) { return this.#mul(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other) { return this.#mul(other, \"mul\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0, errors_js_1.assert)((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0, errors_js_1.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other) { return this.#div(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other) { return this.#div(other, \"div\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other) {\n        (0, errors_js_1.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        (0, errors_js_1.assert)((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n    cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        }\n        else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n    eq(other) { return this.cmp(other) === 0; }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n    lt(other) { return this.cmp(other) < 0; }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n    lte(other) { return this.cmp(other) <= 0; }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n    gt(other) { return this.cmp(other) > 0; }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n    gte(other) { return this.cmp(other) >= 0; }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero() { return (this.#val === BN_0); }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative() { return (this.#val < BN_0); }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString() { return this._value; }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value, _decimals, _format) {\n        const decimals = (_decimals == null) ? 0 : (0, maths_js_1.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0, maths_js_1.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0, errors_js_1.assert)((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        }\n        else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0, errors_js_1.assertArgument)(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n        // Pad out the decimals\n        while (decimal.length < format.decimals) {\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0, errors_js_1.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value, _format) {\n        let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0, maths_js_1.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\nexports.FixedNumber = FixedNumber;\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9maXhlZG51bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBWTtBQUN2Qyx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2QkFBNkI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvZml4ZWRudW1iZXIuanM/MGRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRml4ZWROdW1iZXIgPSB2b2lkIDA7XG4vKipcbiAqICBUaGUgKipGaXhlZE51bWJlcioqIGNsYXNzIHBlcm1pdHMgdXNpbmcgdmFsdWVzIHdpdGggZGVjaW1hbCBwbGFjZXMsXG4gKiAgdXNpbmcgZml4ZWQtcG9udCBtYXRoLlxuICpcbiAqICBGaXhlZC1wb2ludCBtYXRoIGlzIHN0aWxsIGJhc2VkIG9uIGludGVnZXJzIHVuZGVyLXRoZS1ob29kLCBidXQgdXNlcyBhblxuICogIGludGVybmFsIG9mZnNldCB0byBzdG9yZSBmcmFjdGlvbmFsIGNvbXBvbmVudHMgYmVsb3csIGFuZCBlYWNoIG9wZXJhdGlvblxuICogIGNvcnJlY3RzIGZvciB0aGlzIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9maXhlZC1wb2ludC1tYXRoOkZpeGVkLVBvaW50IE1hdGhzICBbYWJvdXQtZml4ZWQtcG9pbnQtbWF0aF1cbiAqL1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuY29uc3QgbWF0aHNfanNfMSA9IHJlcXVpcmUoXCIuL21hdGhzLmpzXCIpO1xuY29uc3QgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllcy5qc1wiKTtcbmNvbnN0IEJOX04xID0gQmlnSW50KC0xKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fNSA9IEJpZ0ludCg1KTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuLy8gQ29uc3RhbnQgdG8gcHVsbCB6ZXJvcyBmcm9tIGZvciBtdWx0aXBsaWVyc1xubGV0IFplcm9zID0gXCIwMDAwXCI7XG53aGlsZSAoWmVyb3MubGVuZ3RoIDwgODApIHtcbiAgICBaZXJvcyArPSBaZXJvcztcbn1cbi8vIFJldHVybnMgYSBzdHJpbmcgXCIxXCIgZm9sbG93ZWQgYnkgZGVjaW1hbCBcIjBcInNcbmZ1bmN0aW9uIGdldFRlbnMoZGVjaW1hbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBkZWNpbWFscykge1xuICAgICAgICByZXN1bHQgKz0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KFwiMVwiICsgcmVzdWx0LnN1YnN0cmluZygwLCBkZWNpbWFscykpO1xufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWwsIGZvcm1hdCwgc2FmZU9wKSB7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZm9ybWF0LndpZHRoKTtcbiAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xuICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgIHZhbCA9ICgwLCBtYXRoc19qc18xLmZyb21Ud29zKSgoMCwgbWF0aHNfanNfMS5tYXNrKSh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gLSgwLCBtYXRoc19qc18xLmZyb21Ud29zKSgoMCwgbWF0aHNfanNfMS5tYXNrKSgtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCB3aWR0aCk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICB2YWwgPSAoKCh2YWwgJSBsaW1pdCkgKyBsaW1pdCkgJSBsaW1pdCkgJiAobGltaXQgLSBCTl8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGdldEZvcm1hdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YWx1ZSA9IGBmaXhlZDEyOHgke3ZhbHVlfWA7XG4gICAgfVxuICAgIGxldCBzaWduZWQgPSB0cnVlO1xuICAgIGxldCB3aWR0aCA9IDEyODtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gUGFyc2UgdGhlIGZvcm1hdCBzdHJpbmdcbiAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShtYXRjaCwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHZba2V5XSkgPT09IHR5cGUsIFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKFwiICsga2V5ICsgXCIgbm90IFwiICsgdHlwZSArIFwiKVwiLCBcImZvcm1hdC5cIiArIGtleSwgdltrZXldKTtcbiAgICAgICAgICAgIHJldHVybiB2W2tleV07XG4gICAgICAgIH07XG4gICAgICAgIHNpZ25lZCA9IGNoZWNrKFwic2lnbmVkXCIsIFwiYm9vbGVhblwiLCBzaWduZWQpO1xuICAgICAgICB3aWR0aCA9IGNoZWNrKFwid2lkdGhcIiwgXCJudW1iZXJcIiwgd2lkdGgpO1xuICAgICAgICBkZWNpbWFscyA9IGNoZWNrKFwiZGVjaW1hbHNcIiwgXCJudW1iZXJcIiwgZGVjaW1hbHMpO1xuICAgIH1cbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKCh3aWR0aCAlIDgpID09PSAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsIFwiZm9ybWF0LndpZHRoXCIsIHdpZHRoKTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGRlY2ltYWxzIDw9IDgwLCBcImludmFsaWQgRml4ZWROdW1iZXIgZGVjaW1hbHMgKHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IG5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgcmV0dXJuIHsgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMsIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCwgZGVjaW1hbHMpIHtcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xuICAgIGlmICh2YWwgPCBCTl8wKSB7XG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG4gICAgICAgIHZhbCAqPSBCTl9OMTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygpO1xuICAgIC8vIE5vIGRlY2ltYWwgcG9pbnQgZm9yIHdob2xlIHZhbHVlc1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcbiAgICB9XG4gICAgLy8gUGFkIG91dCB0byB0aGUgd2hvbGUgY29tcG9uZW50IChpbmNsdWRpbmcgYSB3aG9sZSBkaWdpdClcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8PSBkZWNpbWFscykge1xuICAgICAgICBzdHIgPSBaZXJvcyArIHN0cjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBkZWNpbWFsIHBvaW50XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gZGVjaW1hbHM7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCkgKyBcIi5cIiArIHN0ci5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIC8vIFRyaW0gdGhlIHdob2xlIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyWzBdID09PSBcIjBcIiAmJiBzdHJbMV0gIT09IFwiLlwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIC8vIFRyaW0gdGhlIGRlY2ltYWwgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxuICAgIHdoaWxlIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIjBcIiAmJiBzdHJbc3RyLmxlbmd0aCAtIDJdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG59XG4vKipcbiAqICBBIEZpeGVkTnVtYmVyIHJlcHJlc2VudHMgYSB2YWx1ZSBvdmVyIGl0cyBbW0ZpeGVkRm9ybWF0XV1cbiAqICBhcml0aG1ldGljIGZpZWxkLlxuICpcbiAqICBBIEZpeGVkTnVtYmVyIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbWF0aCwgbG9zc2xlc3NseSwgb25cbiAqICB2YWx1ZXMgd2hpY2ggaGF2ZSBkZWNtaWFsIHBsYWNlcy5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBoYXMgYSBmaXhlZCBiaXQtd2lkdGggdG8gc3RvcmUgdmFsdWVzIGluLCBhbmQgc3RvcmVzIGFsbFxuICogIHZhbHVlcyBpbnRlcm5hbGx5IGJ5IG11bHRpcGx5aW5nIHRoZSB2YWx1ZSBieSAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mXG4gKiAgJSVkZWNpbWFscyUlLlxuICpcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGdyb3cgdG9vIGhpZ2ggKGNsb3NlIHRvXG4gKiAgcG9zaXRpdmUgaW5maW5pdHkpIG9yIHRvbyBsb3cgKGNsb3NlIHRvIG5lZ2F0aXZlIGluZmluaXR5KSwgdGhlIHZhbHVlXG4gKiAgaXMgc2FpZCB0byAvL292ZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhbiA4LWJpdCBzaWduZWQgdmFsdWUsIHdpdGggMCBkZWNpbWFscyBtYXkgb25seSBiZSB3aXRoaW5cbiAqICB0aGUgcmFuZ2UgYGAtMTI4YGAgdG8gYGAxMjdgYDsgc28gYGAtMTI4IC0gMWBgIHdpbGwgb3ZlcmZsb3cgYW5kIGJlY29tZVxuICogIGBgMTI3YGAuIExpa2V3aXNlLCBgYDEyNyArIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWUgYGAtMTI3YGAuXG4gKlxuICogIE1hbnkgb3BlcmF0aW9uIGhhdmUgYSBub3JtYWwgYW5kIC8vdW5zYWZlLy8gdmFyaWFudC4gVGhlIG5vcm1hbCB2YXJpYW50XG4gKiAgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiBhbnkgb3ZlcmZsb3csIHdoaWxlIHRoZSAvL3Vuc2FmZS8vXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGFsbG93IG92ZXJmbG93LCBjb3JydXB0aW5nIGl0cyB2YWx1ZSB2YWx1ZS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBiZWNvbWUgdG9vIHNtYWxsXG4gKiAgKGNsb3NlIHRvIHplcm8pLCB0aGUgdmFsdWUgbG9zZXMgcHJlY2lzb24gYW5kIGlzIHNhaWQgdG8gLy91bmRlcmZsb3cvLy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGFuIHZhbHVlIHdpdGggMSBkZWNpbWFsIHBsYWNlIG1heSBzdG9yZSBhIG51bWJlciBhcyBzbWFsbFxuICogIGFzIGBgMC4xYGAsIGJ1dCB0aGUgdmFsdWUgb2YgYGAwLjEgLyAyYGAgaXMgYGAwLjA1YGAsIHdoaWNoIGNhbm5vdCBmaXRcbiAqICBpbnRvIDEgZGVjaW1hbCBwbGFjZSwgc28gdW5kZXJmbG93IG9jY3VycyB3aGljaCBtZWFucyBwcmVjaXNpb24gaXMgbG9zdFxuICogIGFuZCB0aGUgdmFsdWUgYmVjb21lcyBgYDBgYC5cbiAqXG4gKiAgU29tZSBvcGVyYXRpb25zIGhhdmUgYSBub3JtYWwgYW5kIC8vc2lnbmFsbGluZy8vIHZhcmlhbnQuIFRoZSBub3JtYWxcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgaWdub3JlIHVuZGVyZmxvdywgd2hpbGUgdGhlIC8vc2lnbmFsbGluZy8vIHZhcmlhbnRcbiAqICB3aWxsIHRob3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gdW5kZXJmbG93LlxuICovXG5jbGFzcyBGaXhlZE51bWJlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBzcGVjaWZpYyBmaXhlZC1wb2ludCBhcml0aG1ldGljIGZpZWxkIGZvciB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIGZvcm1hdDtcbiAgICAjZm9ybWF0O1xuICAgIC8vIFRoZSBhY3R1YWwgdmFsdWUgKGFjY291bnRpbmcgZm9yIGRlY2ltYWxzKVxuICAgICN2YWw7XG4gICAgLy8gQSBiYXNlLTEwIHZhbHVlIHRvIG11bHRpcGxlIHZhbHVlcyBieSB0byBtYWludGFpbiB0aGUgbWFnbml0dWRlXG4gICAgI3RlbnM7XG4gICAgLyoqXG4gICAgICogIFRoaXMgaXMgYSBwcm9wZXJ0eSBzbyBjb25zb2xlLmxvZyBzaG93cyBhIGh1bWFuLW1lYW5pbmdmdWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdmFsdWU7XG4gICAgLy8gVXNlIHRoaXMgd2hlbiBjaGFuZ2luZyB0aGlzIGZpbGUgdG8gZ2V0IHNvbWUgdHlwaW5nIGluZm8sXG4gICAgLy8gYnV0IHRoZW4gc3dpdGNoIHRvIGFueSB0byBtYXNrIHRoZSBpbnRlcm5hbCB0eXBlXG4gICAgLy9jb25zdHJ1Y3RvcihndWFyZDogYW55LCB2YWx1ZTogYmlnaW50LCBmb3JtYXQ6IF9GaXhlZEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIkZpeGVkTnVtYmVyXCIpO1xuICAgICAgICB0aGlzLiN2YWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy4jZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICBjb25zdCBfdmFsdWUgPSB0b1N0cmluZyh2YWx1ZSwgZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGZvcm1hdDogZm9ybWF0Lm5hbWUsIF92YWx1ZSB9KTtcbiAgICAgICAgdGhpcy4jdGVucyA9IGdldFRlbnMoZm9ybWF0LmRlY2ltYWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIHRydWUsIG5lZ2F0aXZlIHZhbHVlcyBhcmUgcGVybWl0dGVkLCBvdGhlcndpc2Ugb25seVxuICAgICAqICBwb3NpdGl2ZSB2YWx1ZXMgYW5kIHplcm8gYXJlIGFsbG93ZWQuXG4gICAgICovXG4gICAgZ2V0IHNpZ25lZCgpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5zaWduZWQ7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBiaXRzIGF2YWlsYWJsZSB0byBzdG9yZSB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LndpZHRoOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaW4gdGhlIGZpeGVkLXBvaW50IGFyaXRobWVudCBmaWVsZC5cbiAgICAgKi9cbiAgICBnZXQgZGVjaW1hbHMoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQuZGVjaW1hbHM7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlIGFzIGFuIGludGVnZXIsIGJhc2VkIG9uIHRoZSBzbWFsbGVzdCB1bml0IHRoZVxuICAgICAqICBbW2RlY2ltYWxzXV0gYWxsb3cuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsOyB9XG4gICAgI2NoZWNrRm9ybWF0KG90aGVyKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkodGhpcy5mb3JtYXQgPT09IG90aGVyLmZvcm1hdCwgXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgfVxuICAgICNjaGVja1ZhbHVlKHZhbCwgc2FmZU9wKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBCaWdJbnQodGhpcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmcm9tVHdvcyhtYXNrKHZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrZWQgPSBtYXNrKHZhbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA9PT0gbWFza2VkKSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFza2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsID0gY2hlY2tWYWx1ZSh2YWwsIHRoaXMuI2Zvcm1hdCwgc2FmZU9wKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbCwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgI2FkZChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCArIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIGFkZFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIGFkZChvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyLCBcImFkZFwiKTsgfVxuICAgICNzdWIobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgLSBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3ViVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIHN1YihvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyLCBcInN1YlwiKTsgfVxuICAgICNtdWwobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogby4jdmFsKSAvIHRoaXMuI3RlbnMsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93IGFuZCB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBtdWxVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bChvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyLCBcIm11bFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMgb3IgaWYgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bFNpZ25hbChvdGhlcikge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsICogb3RoZXIuI3ZhbDtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoKHZhbHVlICUgdGhpcy4jdGVucykgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgbXVsXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwibXVsU2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyB0aGlzLiN0ZW5zLCBcIm11bFNpZ25hbFwiKTtcbiAgICB9XG4gICAgI2RpdihvLCBzYWZlT3ApIHtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoby4jdmFsICE9PSBCTl8wLCBcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZcIiwgZmF1bHQ6IFwiZGl2aWRlLWJ5LXplcm9cIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogdGhpcy4jdGVucykgLyBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLiBBXG4gICAgICogIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3cgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdlVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jZGl2KG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLiBBXG4gICAgICogIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3cgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdihvdGhlcikgeyByZXR1cm4gdGhpcy4jZGl2KG90aGVyLCBcImRpdlwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiB1bmRlcmZsb3dcbiAgICAgKiAgKHByZWNpc2lvbiBsb3NzKSBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2U2lnbmFsKG90aGVyKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKG90aGVyLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoKHZhbHVlICUgb3RoZXIuI3ZhbCkgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgZGl2XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2U2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyBvdGhlci4jdmFsLCBcImRpdlNpZ25hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBjb21wYXJpc29uIHJlc3VsdCBiZXR3ZWVuICUldGhpcyUlIGFuZCAlJW90aGVyJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBzdWl0YWJsZSBmb3IgdXNlIGluIHNvcnRpbmcsIHdoZXJlIGBgLTFgYCBpbXBsaWVzICUldGhpcyUlXG4gICAgICogIGlzIHNtYWxsZXIsIGBgMWBgIGltcGxpZXMgJSV0aGlzJSUgaXMgbGFyZ2VyIGFuZCBgYDBgYCBpbXBsaWVzXG4gICAgICogIGJvdGggYXJlIGVxdWFsLlxuICAgICAqL1xuICAgIGNtcChvdGhlcikge1xuICAgICAgICBsZXQgYSA9IHRoaXMudmFsdWUsIGIgPSBvdGhlci52YWx1ZTtcbiAgICAgICAgLy8gQ29lcmNlIGEgYW5kIGIgdG8gdGhlIHNhbWUgbWFnbml0dWRlXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIG90aGVyLmRlY2ltYWxzO1xuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBiICo9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgYSAqPSBnZXRUZW5zKC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tbnBhcmVcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA9PT0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDwgMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0KG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPiAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0ZShvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID49IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIGxhcmdlc3QgKippbnRlZ2VyKipcbiAgICAgKiAgdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlY2ltYWwgY29tcG9uZW50IG9mIHRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYGAwYGAuXG4gICAgICovXG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPCBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgLT0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImZsb29yXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIHNtYWxsZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGNlaWxpbmcoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgKz0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImNlaWxpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBkZWNpbWFsIGNvbXBvbmVudFxuICAgICAqICByb3VuZGVkIHVwIG9uIHRpZXMgYXQgJSVkZWNpbWFscyUlIHBsYWNlcy5cbiAgICAgKi9cbiAgICByb3VuZChkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBlbm91Z2ggcHJlY2lzaW9uIHRvIG5vdCBhbHJlYWR5IGJlIHJvdW5kZWRcbiAgICAgICAgaWYgKGRlY2ltYWxzID49IHRoaXMuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIGRlY2ltYWxzO1xuICAgICAgICBjb25zdCBidW1wID0gQk5fNSAqIGdldFRlbnMoZGVsdGEgLSAxKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSArIGJ1bXA7XG4gICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLyB0ZW5zKSAqIHRlbnM7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIHRoaXMuI2Zvcm1hdCwgXCJyb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCB0aGlzLiNmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGVxdWFsIHRvIGBgMGBgLlxuICAgICAqL1xuICAgIGlzWmVybygpIHsgcmV0dXJuICh0aGlzLiN2YWwgPT09IEJOXzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBsZXNzIHRoYW4gYGAwYGAuXG4gICAgICovXG4gICAgaXNOZWdhdGl2ZSgpIHsgcmV0dXJuICh0aGlzLiN2YWwgPCBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgJSV0aGlzJSUuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmxvYXQgYXBwcm94aW1hdGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gSUVFRSA3NTQgcHJlY2lzc2lvbiAob3IgbGFjayB0aGVyZW9mKSwgdGhpcyBmdW5jdGlvblxuICAgICAqICBjYW4gb25seSByZXR1cm4gYW4gYXBwcm94aW1hdGlvbiBhbmQgbW9zdCB2YWx1ZXMgd2lsbCBjb250YWluXG4gICAgICogIHJvdW5kaW5nIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgc2FtZSB2YWx1ZSBidXQgaGFzIGhhZFxuICAgICAqICBpdHMgZmllbGQgc2V0IHRvICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZSB2YWx1ZSBjYW5ub3QgZml0IGludG8gJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICB0b0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy50b1N0cmluZygpLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSBkaXZpZGVkIGJ5XG4gICAgICogICUlZGVjaW1hbCUlIHBsYWNlcyB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSAob25jZSBhZGp1c3RlZFxuICAgICAqICBmb3IgJSVkZWNpbWFscyUlKSBjYW5ub3QgZml0IGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3dcbiAgICAgKiAgb3IgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21WYWx1ZShfdmFsdWUsIF9kZWNpbWFscywgX2Zvcm1hdCkge1xuICAgICAgICBjb25zdCBkZWNpbWFscyA9IChfZGVjaW1hbHMgPT0gbnVsbCkgPyAwIDogKDAsIG1hdGhzX2pzXzEuZ2V0TnVtYmVyKShfZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGxldCB2YWx1ZSA9ICgwLCBtYXRoc19qc18xLmdldEJpZ0ludCkoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGRlY2ltYWxzIC0gZm9ybWF0LmRlY2ltYWxzO1xuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSgodmFsdWUgJSB0ZW5zKSA9PT0gQk5fMCwgXCJ2YWx1ZSBsb3NlcyBwcmVjaXNpb24gZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVmFsdWVcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUgLz0gdGVucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlICo9IGdldFRlbnMoLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvdyBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfdmFsdWUubWF0Y2goL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLyk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkobWF0Y2ggJiYgKG1hdGNoWzJdLmxlbmd0aCArIG1hdGNoWzNdLmxlbmd0aCkgPiAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgc3RyaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBsZXQgd2hvbGUgPSAobWF0Y2hbMl0gfHwgXCIwXCIpLCBkZWNpbWFsID0gKG1hdGNoWzNdIHx8IFwiXCIpO1xuICAgICAgICAvLyBQYWQgb3V0IHRoZSBkZWNpbWFsc1xuICAgICAgICB3aGlsZSAoZGVjaW1hbC5sZW5ndGggPCBmb3JtYXQuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gWmVyb3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgcHJlY2lzaW9uIGlzIHNhZmVcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoZGVjaW1hbC5zdWJzdHJpbmcoZm9ybWF0LmRlY2ltYWxzKS5tYXRjaCgvXjAqJC8pLCBcInRvbyBtYW55IGRlY2ltYWxzIGZvciBmb3JtYXRcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tU3RyaW5nXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZW1vdmUgZXh0cmEgcGFkZGluZ1xuICAgICAgICBkZWNpbWFsID0gZGVjaW1hbC5zdWJzdHJpbmcoMCwgZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdJbnQobWF0Y2hbMV0gKyB3aG9sZSArIGRlY2ltYWwpO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvblxuICAgICAqICAlJXZhbHVlJSUgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgY2Fubm90IGZpdFxuICAgICAqICBpbiAlJWZvcm1hdCUlIGR1ZSB0byBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKF92YWx1ZSwgX2Zvcm1hdCkge1xuICAgICAgICBsZXQgdmFsdWUgPSAoMCwgbWF0aHNfanNfMS50b0JpZ0ludCkoKDAsIGRhdGFfanNfMS5nZXRCeXRlcykoX3ZhbHVlLCBcInZhbHVlXCIpKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgbWF0aHNfanNfMS5mcm9tVHdvcykodmFsdWUsIGZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21CeXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRml4ZWROdW1iZXIgPSBGaXhlZE51bWJlcjtcbi8vY29uc3QgZjEgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMTIuNTZcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnN0IGYyID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjAuM1wiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc29sZS5sb2coZjEuZGl2U2lnbmFsKGYyKSk7XG4vL2NvbnN0IEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/geturl.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/geturl.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUrl = exports.createGetUrl = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/ethers/node_modules/tslib/tslib.es6.js\");\nconst http_1 = tslib_1.__importDefault(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = tslib_1.__importDefault(__webpack_require__(/*! https */ \"https\"));\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\n/**\n *  @_ignore:\n */\nfunction createGetUrl(options) {\n    async function getUrl(req, signal) {\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        (0, errors_js_1.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n            info: { protocol },\n            operation: \"request\"\n        });\n        (0, errors_js_1.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        const method = req.method;\n        const headers = Object.assign({}, req.headers);\n        const reqOptions = { method, headers };\n        if (options) {\n            if (options.agent) {\n                reqOptions.agent = options.agent;\n            }\n        }\n        const request = ((protocol === \"http\") ? http_1.default : https_1.default).request(req.url, reqOptions);\n        request.setTimeout(req.timeout);\n        const body = req.body;\n        if (body) {\n            request.write(Buffer.from(body));\n        }\n        request.end();\n        return new Promise((resolve, reject) => {\n            // @TODO: Node 15 added AbortSignal; once we drop support for\n            // Node14, we can add that in here too\n            request.once(\"response\", (resp) => {\n                const statusCode = resp.statusCode || 0;\n                const statusMessage = resp.statusMessage || \"\";\n                const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {\n                    let value = resp.headers[name] || \"\";\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {});\n                let body = null;\n                //resp.setEncoding(\"utf8\");\n                resp.on(\"data\", (chunk) => {\n                    if (signal) {\n                        try {\n                            signal.checkSignal();\n                        }\n                        catch (error) {\n                            return reject(error);\n                        }\n                    }\n                    if (body == null) {\n                        body = chunk;\n                    }\n                    else {\n                        const newBody = new Uint8Array(body.length + chunk.length);\n                        newBody.set(body, 0);\n                        newBody.set(chunk, body.length);\n                        body = newBody;\n                    }\n                });\n                resp.on(\"end\", () => {\n                    if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                        body = (0, data_js_1.getBytes)((0, zlib_1.gunzipSync)(body));\n                    }\n                    resolve({ statusCode, statusMessage, headers, body });\n                });\n                resp.on(\"error\", (error) => {\n                    //@TODO: Should this just return nornal response with a server error?\n                    error.response = { statusCode, statusMessage, headers, body };\n                    reject(error);\n                });\n            });\n            request.on(\"error\", (error) => { reject(error); });\n        });\n    }\n    return getUrl;\n}\nexports.createGetUrl = createGetUrl;\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\n/**\n *  @_ignore:\n */\nasync function getUrl(req, signal) {\n    return defaultGetUrl(req, signal);\n}\nexports.getUrl = getUrl;\n//# sourceMappingURL=geturl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9nZXR1cmwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLG9CQUFvQjtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBTztBQUMvQix1Q0FBdUMsbUJBQU8sQ0FBQyxrQkFBTTtBQUNyRCx3Q0FBd0MsbUJBQU8sQ0FBQyxvQkFBTztBQUN2RCxlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsNkVBQWE7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLFNBQVM7QUFDOUcsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QztBQUN4Qyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBMEM7QUFDeEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLDZDQUE2QyxnQkFBZ0I7QUFDN0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL2dldHVybC5qcz9mMDU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVcmwgPSBleHBvcnRzLmNyZWF0ZUdldFVybCA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBodHRwXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cFwiKSk7XG5jb25zdCBodHRwc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImh0dHBzXCIpKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdldFVybChvcHRpb25zKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgc2lnbmFsKSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkocHJvdG9jb2wgPT09IFwiaHR0cFwiIHx8IHByb3RvY29sID09PSBcImh0dHBzXCIsIGB1bnN1cHBvcnRlZCBwcm90b2NvbCAke3Byb3RvY29sfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIGluZm86IHsgcHJvdG9jb2wgfSxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHByb3RvY29sID09PSBcImh0dHBzXCIgfHwgIXJlcS5jcmVkZW50aWFscyB8fCByZXEuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uLCBcImluc2VjdXJlIGF1dGhvcml6ZWQgY29ubmVjdGlvbnMgdW5zdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHJlcS5oZWFkZXJzKTtcbiAgICAgICAgY29uc3QgcmVxT3B0aW9ucyA9IHsgbWV0aG9kLCBoZWFkZXJzIH07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hZ2VudCkge1xuICAgICAgICAgICAgICAgIHJlcU9wdGlvbnMuYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAoKHByb3RvY29sID09PSBcImh0dHBcIikgPyBodHRwXzEuZGVmYXVsdCA6IGh0dHBzXzEuZGVmYXVsdCkucmVxdWVzdChyZXEudXJsLCByZXFPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdC5zZXRUaW1lb3V0KHJlcS50aW1lb3V0KTtcbiAgICAgICAgY29uc3QgYm9keSA9IHJlcS5ib2R5O1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgcmVxdWVzdC53cml0ZShCdWZmZXIuZnJvbShib2R5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBOb2RlIDE1IGFkZGVkIEFib3J0U2lnbmFsOyBvbmNlIHdlIGRyb3Agc3VwcG9ydCBmb3JcbiAgICAgICAgICAgIC8vIE5vZGUxNCwgd2UgY2FuIGFkZCB0aGF0IGluIGhlcmUgdG9vXG4gICAgICAgICAgICByZXF1ZXN0Lm9uY2UoXCJyZXNwb25zZVwiLCAocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXNwLnN0YXR1c0NvZGUgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNNZXNzYWdlID0gcmVzcC5zdGF0dXNNZXNzYWdlIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5rZXlzKHJlc3AuaGVhZGVycyB8fCB7fSkucmVkdWNlKChhY2N1bSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSByZXNwLmhlYWRlcnNbbmFtZV0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvL3Jlc3Auc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgICAgIHJlc3Aub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Qm9keSA9IG5ldyBVaW50OEFycmF5KGJvZHkubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JvZHkuc2V0KGJvZHksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Qm9keS5zZXQoY2h1bmssIGJvZHkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBuZXdCb2R5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcC5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC1lbmNvZGluZ1wiXSA9PT0gXCJnemlwXCIgJiYgYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9ICgwLCBkYXRhX2pzXzEuZ2V0Qnl0ZXMpKCgwLCB6bGliXzEuZ3VuemlwU3luYykoYm9keSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzLCBib2R5IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3Aub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy9AVE9ETzogU2hvdWxkIHRoaXMganVzdCByZXR1cm4gbm9ybmFsIHJlc3BvbnNlIHdpdGggYSBzZXJ2ZXIgZXJyb3I/XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0geyBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzLCBib2R5IH07XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlcXVlc3Qub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHsgcmVqZWN0KGVycm9yKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VXJsO1xufVxuZXhwb3J0cy5jcmVhdGVHZXRVcmwgPSBjcmVhdGVHZXRVcmw7XG4vLyBAVE9ETzogcmVtb3ZlIGluIHY3OyBwcm92aWRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuY29uc3QgZGVmYXVsdEdldFVybCA9IGNyZWF0ZUdldFVybCh7fSk7XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgc2lnbmFsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRHZXRVcmwocmVxLCBzaWduYWwpO1xufVxuZXhwb3J0cy5nZXRVcmwgPSBnZXRVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXR1cmwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/geturl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  There are many simple utilities required to interact with\n *  Ethereum and to simplify the library, without increasing\n *  the library dependencies for simple functions.\n *\n *  @_section api/utils:Utilities  [about-utils]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.encodeRlp = exports.decodeRlp = exports.defineProperties = exports.resolveProperties = exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.toBigInt = exports.getUint = exports.getNumber = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.makeError = exports.assertNormalize = exports.assertPrivate = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.isError = exports.isCallException = exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = void 0;\nexports.uuidV4 = exports.Utf8ErrorFuncs = void 0;\nvar base58_js_1 = __webpack_require__(/*! ./base58.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/base58.js\");\nObject.defineProperty(exports, \"decodeBase58\", ({ enumerable: true, get: function () { return base58_js_1.decodeBase58; } }));\nObject.defineProperty(exports, \"encodeBase58\", ({ enumerable: true, get: function () { return base58_js_1.encodeBase58; } }));\nvar base64_js_1 = __webpack_require__(/*! ./base64.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/base64.js\");\nObject.defineProperty(exports, \"decodeBase64\", ({ enumerable: true, get: function () { return base64_js_1.decodeBase64; } }));\nObject.defineProperty(exports, \"encodeBase64\", ({ enumerable: true, get: function () { return base64_js_1.encodeBase64; } }));\nvar data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nObject.defineProperty(exports, \"getBytes\", ({ enumerable: true, get: function () { return data_js_1.getBytes; } }));\nObject.defineProperty(exports, \"getBytesCopy\", ({ enumerable: true, get: function () { return data_js_1.getBytesCopy; } }));\nObject.defineProperty(exports, \"isHexString\", ({ enumerable: true, get: function () { return data_js_1.isHexString; } }));\nObject.defineProperty(exports, \"isBytesLike\", ({ enumerable: true, get: function () { return data_js_1.isBytesLike; } }));\nObject.defineProperty(exports, \"hexlify\", ({ enumerable: true, get: function () { return data_js_1.hexlify; } }));\nObject.defineProperty(exports, \"concat\", ({ enumerable: true, get: function () { return data_js_1.concat; } }));\nObject.defineProperty(exports, \"dataLength\", ({ enumerable: true, get: function () { return data_js_1.dataLength; } }));\nObject.defineProperty(exports, \"dataSlice\", ({ enumerable: true, get: function () { return data_js_1.dataSlice; } }));\nObject.defineProperty(exports, \"stripZerosLeft\", ({ enumerable: true, get: function () { return data_js_1.stripZerosLeft; } }));\nObject.defineProperty(exports, \"zeroPadValue\", ({ enumerable: true, get: function () { return data_js_1.zeroPadValue; } }));\nObject.defineProperty(exports, \"zeroPadBytes\", ({ enumerable: true, get: function () { return data_js_1.zeroPadBytes; } }));\nvar errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nObject.defineProperty(exports, \"isCallException\", ({ enumerable: true, get: function () { return errors_js_1.isCallException; } }));\nObject.defineProperty(exports, \"isError\", ({ enumerable: true, get: function () { return errors_js_1.isError; } }));\nObject.defineProperty(exports, \"assert\", ({ enumerable: true, get: function () { return errors_js_1.assert; } }));\nObject.defineProperty(exports, \"assertArgument\", ({ enumerable: true, get: function () { return errors_js_1.assertArgument; } }));\nObject.defineProperty(exports, \"assertArgumentCount\", ({ enumerable: true, get: function () { return errors_js_1.assertArgumentCount; } }));\nObject.defineProperty(exports, \"assertPrivate\", ({ enumerable: true, get: function () { return errors_js_1.assertPrivate; } }));\nObject.defineProperty(exports, \"assertNormalize\", ({ enumerable: true, get: function () { return errors_js_1.assertNormalize; } }));\nObject.defineProperty(exports, \"makeError\", ({ enumerable: true, get: function () { return errors_js_1.makeError; } }));\nvar events_js_1 = __webpack_require__(/*! ./events.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/events.js\");\nObject.defineProperty(exports, \"EventPayload\", ({ enumerable: true, get: function () { return events_js_1.EventPayload; } }));\nvar fetch_js_1 = __webpack_require__(/*! ./fetch.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/fetch.js\");\nObject.defineProperty(exports, \"FetchRequest\", ({ enumerable: true, get: function () { return fetch_js_1.FetchRequest; } }));\nObject.defineProperty(exports, \"FetchResponse\", ({ enumerable: true, get: function () { return fetch_js_1.FetchResponse; } }));\nObject.defineProperty(exports, \"FetchCancelSignal\", ({ enumerable: true, get: function () { return fetch_js_1.FetchCancelSignal; } }));\nvar fixednumber_js_1 = __webpack_require__(/*! ./fixednumber.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/fixednumber.js\");\nObject.defineProperty(exports, \"FixedNumber\", ({ enumerable: true, get: function () { return fixednumber_js_1.FixedNumber; } }));\nvar maths_js_1 = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nObject.defineProperty(exports, \"fromTwos\", ({ enumerable: true, get: function () { return maths_js_1.fromTwos; } }));\nObject.defineProperty(exports, \"toTwos\", ({ enumerable: true, get: function () { return maths_js_1.toTwos; } }));\nObject.defineProperty(exports, \"mask\", ({ enumerable: true, get: function () { return maths_js_1.mask; } }));\nObject.defineProperty(exports, \"getBigInt\", ({ enumerable: true, get: function () { return maths_js_1.getBigInt; } }));\nObject.defineProperty(exports, \"getNumber\", ({ enumerable: true, get: function () { return maths_js_1.getNumber; } }));\nObject.defineProperty(exports, \"getUint\", ({ enumerable: true, get: function () { return maths_js_1.getUint; } }));\nObject.defineProperty(exports, \"toBigInt\", ({ enumerable: true, get: function () { return maths_js_1.toBigInt; } }));\nObject.defineProperty(exports, \"toNumber\", ({ enumerable: true, get: function () { return maths_js_1.toNumber; } }));\nObject.defineProperty(exports, \"toBeHex\", ({ enumerable: true, get: function () { return maths_js_1.toBeHex; } }));\nObject.defineProperty(exports, \"toBeArray\", ({ enumerable: true, get: function () { return maths_js_1.toBeArray; } }));\nObject.defineProperty(exports, \"toQuantity\", ({ enumerable: true, get: function () { return maths_js_1.toQuantity; } }));\nvar properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nObject.defineProperty(exports, \"resolveProperties\", ({ enumerable: true, get: function () { return properties_js_1.resolveProperties; } }));\nObject.defineProperty(exports, \"defineProperties\", ({ enumerable: true, get: function () { return properties_js_1.defineProperties; } }));\nvar rlp_decode_js_1 = __webpack_require__(/*! ./rlp-decode.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/rlp-decode.js\");\nObject.defineProperty(exports, \"decodeRlp\", ({ enumerable: true, get: function () { return rlp_decode_js_1.decodeRlp; } }));\nvar rlp_encode_js_1 = __webpack_require__(/*! ./rlp-encode.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/rlp-encode.js\");\nObject.defineProperty(exports, \"encodeRlp\", ({ enumerable: true, get: function () { return rlp_encode_js_1.encodeRlp; } }));\nvar units_js_1 = __webpack_require__(/*! ./units.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/units.js\");\nObject.defineProperty(exports, \"formatEther\", ({ enumerable: true, get: function () { return units_js_1.formatEther; } }));\nObject.defineProperty(exports, \"parseEther\", ({ enumerable: true, get: function () { return units_js_1.parseEther; } }));\nObject.defineProperty(exports, \"formatUnits\", ({ enumerable: true, get: function () { return units_js_1.formatUnits; } }));\nObject.defineProperty(exports, \"parseUnits\", ({ enumerable: true, get: function () { return units_js_1.parseUnits; } }));\nvar utf8_js_1 = __webpack_require__(/*! ./utf8.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/utf8.js\");\nObject.defineProperty(exports, \"toUtf8Bytes\", ({ enumerable: true, get: function () { return utf8_js_1.toUtf8Bytes; } }));\nObject.defineProperty(exports, \"toUtf8CodePoints\", ({ enumerable: true, get: function () { return utf8_js_1.toUtf8CodePoints; } }));\nObject.defineProperty(exports, \"toUtf8String\", ({ enumerable: true, get: function () { return utf8_js_1.toUtf8String; } }));\nObject.defineProperty(exports, \"Utf8ErrorFuncs\", ({ enumerable: true, get: function () { return utf8_js_1.Utf8ErrorFuncs; } }));\nvar uuid_js_1 = __webpack_require__(/*! ./uuid.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/uuid.js\");\nObject.defineProperty(exports, \"uuidV4\", ({ enumerable: true, get: function () { return uuid_js_1.uuidV4; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CO0FBQy9qQyxjQUFjLEdBQUcsc0JBQXNCO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWE7QUFDdkMsZ0RBQStDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzNILGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNuQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDakgsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILCtDQUE4QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN2SCwrQ0FBOEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdkgsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLDBDQUF5QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM3Ryw4Q0FBNkMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDckgsNkNBQTRDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ25ILGtEQUFpRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM3SCxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLG1EQUFrRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNqSSwyQ0FBMEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDakgsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HLGtEQUFpRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMvSCx1REFBc0QsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDekksaURBQWdELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzdILG1EQUFrRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNqSSw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWE7QUFDdkMsZ0RBQStDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzNILGlCQUFpQixtQkFBTyxDQUFDLDJFQUFZO0FBQ3JDLGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCxpREFBZ0QsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDNUgscURBQW9ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3BJLHVCQUF1QixtQkFBTyxDQUFDLHVGQUFrQjtBQUNqRCwrQ0FBOEMsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDOUgsaUJBQWlCLG1CQUFPLENBQUMsMkVBQVk7QUFDckMsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILDBDQUF5QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM5Ryx3Q0FBdUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDMUcsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCwyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEgsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCwyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEgsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN0SCxzQkFBc0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDL0MscURBQW9ELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQ3pJLG9EQUFtRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUN2SSxzQkFBc0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDL0MsNkNBQTRDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQ3pILHNCQUFzQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMvQyw2Q0FBNEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDekgsaUJBQWlCLG1CQUFPLENBQUMsMkVBQVk7QUFDckMsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN0SCwrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILGdCQUFnQixtQkFBTyxDQUFDLHlFQUFXO0FBQ25DLCtDQUE4QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN2SCxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakksZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILGtEQUFpRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM3SCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDN0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9pbmRleC5qcz83N2YzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgVGhlcmUgYXJlIG1hbnkgc2ltcGxlIHV0aWxpdGllcyByZXF1aXJlZCB0byBpbnRlcmFjdCB3aXRoXG4gKiAgRXRoZXJldW0gYW5kIHRvIHNpbXBsaWZ5IHRoZSBsaWJyYXJ5LCB3aXRob3V0IGluY3JlYXNpbmdcbiAqICB0aGUgbGlicmFyeSBkZXBlbmRlbmNpZXMgZm9yIHNpbXBsZSBmdW5jdGlvbnMuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvdXRpbHM6VXRpbGl0aWVzICBbYWJvdXQtdXRpbHNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9VdGY4U3RyaW5nID0gZXhwb3J0cy50b1V0ZjhDb2RlUG9pbnRzID0gZXhwb3J0cy50b1V0ZjhCeXRlcyA9IGV4cG9ydHMucGFyc2VVbml0cyA9IGV4cG9ydHMuZm9ybWF0VW5pdHMgPSBleHBvcnRzLnBhcnNlRXRoZXIgPSBleHBvcnRzLmZvcm1hdEV0aGVyID0gZXhwb3J0cy5lbmNvZGVSbHAgPSBleHBvcnRzLmRlY29kZVJscCA9IGV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSBleHBvcnRzLnRvUXVhbnRpdHkgPSBleHBvcnRzLnRvQmVBcnJheSA9IGV4cG9ydHMudG9CZUhleCA9IGV4cG9ydHMudG9OdW1iZXIgPSBleHBvcnRzLnRvQmlnSW50ID0gZXhwb3J0cy5nZXRVaW50ID0gZXhwb3J0cy5nZXROdW1iZXIgPSBleHBvcnRzLmdldEJpZ0ludCA9IGV4cG9ydHMubWFzayA9IGV4cG9ydHMudG9Ud29zID0gZXhwb3J0cy5mcm9tVHdvcyA9IGV4cG9ydHMuRml4ZWROdW1iZXIgPSBleHBvcnRzLkZldGNoQ2FuY2VsU2lnbmFsID0gZXhwb3J0cy5GZXRjaFJlc3BvbnNlID0gZXhwb3J0cy5GZXRjaFJlcXVlc3QgPSBleHBvcnRzLkV2ZW50UGF5bG9hZCA9IGV4cG9ydHMubWFrZUVycm9yID0gZXhwb3J0cy5hc3NlcnROb3JtYWxpemUgPSBleHBvcnRzLmFzc2VydFByaXZhdGUgPSBleHBvcnRzLmFzc2VydEFyZ3VtZW50Q291bnQgPSBleHBvcnRzLmFzc2VydEFyZ3VtZW50ID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLmlzRXJyb3IgPSBleHBvcnRzLmlzQ2FsbEV4Y2VwdGlvbiA9IGV4cG9ydHMuemVyb1BhZEJ5dGVzID0gZXhwb3J0cy56ZXJvUGFkVmFsdWUgPSBleHBvcnRzLnN0cmlwWmVyb3NMZWZ0ID0gZXhwb3J0cy5kYXRhU2xpY2UgPSBleHBvcnRzLmRhdGFMZW5ndGggPSBleHBvcnRzLmNvbmNhdCA9IGV4cG9ydHMuaGV4bGlmeSA9IGV4cG9ydHMuaXNCeXRlc0xpa2UgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5nZXRCeXRlc0NvcHkgPSBleHBvcnRzLmdldEJ5dGVzID0gZXhwb3J0cy5lbmNvZGVCYXNlNjQgPSBleHBvcnRzLmRlY29kZUJhc2U2NCA9IGV4cG9ydHMuZW5jb2RlQmFzZTU4ID0gZXhwb3J0cy5kZWNvZGVCYXNlNTggPSB2b2lkIDA7XG5leHBvcnRzLnV1aWRWNCA9IGV4cG9ydHMuVXRmOEVycm9yRnVuY3MgPSB2b2lkIDA7XG52YXIgYmFzZTU4X2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlNTguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVCYXNlNThcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2U1OF9qc18xLmRlY29kZUJhc2U1ODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUJhc2U1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZTU4X2pzXzEuZW5jb2RlQmFzZTU4OyB9IH0pO1xudmFyIGJhc2U2NF9qc18xID0gcmVxdWlyZShcIi4vYmFzZTY0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQmFzZTY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlNjRfanNfMS5kZWNvZGVCYXNlNjQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVCYXNlNjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2U2NF9qc18xLmVuY29kZUJhc2U2NDsgfSB9KTtcbnZhciBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5nZXRCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJ5dGVzQ29weVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLmdldEJ5dGVzQ29weTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSGV4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuaXNIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0J5dGVzTGlrZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLmlzQnl0ZXNMaWtlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4bGlmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLmhleGxpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5jb25jYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkYXRhTGVuZ3RoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuZGF0YUxlbmd0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRhdGFTbGljZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLmRhdGFTbGljZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmlwWmVyb3NMZWZ0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuc3RyaXBaZXJvc0xlZnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ6ZXJvUGFkVmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS56ZXJvUGFkVmFsdWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ6ZXJvUGFkQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS56ZXJvUGFkQnl0ZXM7IH0gfSk7XG52YXIgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NhbGxFeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLmlzQ2FsbEV4Y2VwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLmlzRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLmFzc2VydDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydEFyZ3VtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydEFyZ3VtZW50Q291bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50Q291bnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRQcml2YXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5hc3NlcnRQcml2YXRlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0Tm9ybWFsaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5hc3NlcnROb3JtYWxpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLm1ha2VFcnJvcjsgfSB9KTtcbnZhciBldmVudHNfanNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50cy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzX2pzXzEuRXZlbnRQYXlsb2FkOyB9IH0pO1xudmFyIGZldGNoX2pzXzEgPSByZXF1aXJlKFwiLi9mZXRjaC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZldGNoUmVxdWVzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmV0Y2hfanNfMS5GZXRjaFJlcXVlc3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmZXRjaF9qc18xLkZldGNoUmVzcG9uc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaENhbmNlbFNpZ25hbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmV0Y2hfanNfMS5GZXRjaENhbmNlbFNpZ25hbDsgfSB9KTtcbnZhciBmaXhlZG51bWJlcl9qc18xID0gcmVxdWlyZShcIi4vZml4ZWRudW1iZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaXhlZE51bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZml4ZWRudW1iZXJfanNfMS5GaXhlZE51bWJlcjsgfSB9KTtcbnZhciBtYXRoc19qc18xID0gcmVxdWlyZShcIi4vbWF0aHMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tVHdvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS5mcm9tVHdvczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVHdvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS50b1R3b3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLm1hc2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCaWdJbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEuZ2V0QmlnSW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLmdldE51bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFVpbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEuZ2V0VWludDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmlnSW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLnRvQmlnSW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9OdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEudG9OdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0JlSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLnRvQmVIZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0JlQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEudG9CZUFycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9RdWFudGl0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS50b1F1YW50aXR5OyB9IH0pO1xudmFyIHByb3BlcnRpZXNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlUHJvcGVydGllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcGVydGllc19qc18xLnJlc29sdmVQcm9wZXJ0aWVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmaW5lUHJvcGVydGllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcGVydGllc19qc18xLmRlZmluZVByb3BlcnRpZXM7IH0gfSk7XG52YXIgcmxwX2RlY29kZV9qc18xID0gcmVxdWlyZShcIi4vcmxwLWRlY29kZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVJscFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmxwX2RlY29kZV9qc18xLmRlY29kZVJscDsgfSB9KTtcbnZhciBybHBfZW5jb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9ybHAtZW5jb2RlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlUmxwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBybHBfZW5jb2RlX2pzXzEuZW5jb2RlUmxwOyB9IH0pO1xudmFyIHVuaXRzX2pzXzEgPSByZXF1aXJlKFwiLi91bml0cy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdEV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c19qc18xLmZvcm1hdEV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHNfanNfMS5wYXJzZUV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0VW5pdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzX2pzXzEuZm9ybWF0VW5pdHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVVuaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c19qc18xLnBhcnNlVW5pdHM7IH0gfSk7XG52YXIgdXRmOF9qc18xID0gcmVxdWlyZShcIi4vdXRmOC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOEJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGY4X2pzXzEudG9VdGY4Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhDb2RlUG9pbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGY4X2pzXzEudG9VdGY4Q29kZVBvaW50czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOF9qc18xLnRvVXRmOFN0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0ZjhFcnJvckZ1bmNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGY4X2pzXzEuVXRmOEVycm9yRnVuY3M7IH0gfSk7XG52YXIgdXVpZF9qc18xID0gcmVxdWlyZShcIi4vdXVpZC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV1aWRWNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXVpZF9qc18xLnV1aWRWNDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/maths.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/maths.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nfunction fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0, errors_js_1.assert)((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n    return value;\n}\nexports.fromTwos = fromTwos;\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nfunction toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = (BN_1 << (width - BN_1));\n    if (value < BN_0) {\n        value = -value;\n        (0, errors_js_1.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    }\n    else {\n        (0, errors_js_1.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n    return value;\n}\nexports.toTwos = toTwos;\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nfunction mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\nexports.mask = mask;\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getBigInt(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            }\n            catch (e) {\n                (0, errors_js_1.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0, errors_js_1.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\nexports.getBigInt = getBigInt;\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nfunction getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0, errors_js_1.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\nexports.getUint = getUint;\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nfunction toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\nexports.toBigInt = toBigInt;\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getNumber(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\":\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            }\n            catch (e) {\n                (0, errors_js_1.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0, errors_js_1.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\nexports.getNumber = getNumber;\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nfunction toNumber(value) {\n    return getNumber(toBigInt(value));\n}\nexports.toNumber = toNumber;\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nfunction toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    }\n    else {\n        const width = getNumber(_width, \"width\");\n        (0, errors_js_1.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while (result.length < (width * 2)) {\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\nexports.toBeHex = toBeHex;\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nfunction toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\nexports.toBeArray = toBeArray;\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nfunction toQuantity(value) {\n    let result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) {\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\nexports.toQuantity = toQuantity;\n//# sourceMappingURL=maths.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9tYXRocy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsZ0JBQWdCO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixVQUFVO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixPQUFPO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvbWF0aHMuanM/NDljYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9RdWFudGl0eSA9IGV4cG9ydHMudG9CZUFycmF5ID0gZXhwb3J0cy50b0JlSGV4ID0gZXhwb3J0cy50b051bWJlciA9IGV4cG9ydHMuZ2V0TnVtYmVyID0gZXhwb3J0cy50b0JpZ0ludCA9IGV4cG9ydHMuZ2V0VWludCA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5tYXNrID0gZXhwb3J0cy50b1R3b3MgPSBleHBvcnRzLmZyb21Ud29zID0gdm9pZCAwO1xuLyoqXG4gKiAgU29tZSBtYXRoZW1hdGljIG9wZXJhdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxuICovXG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbi8vY29uc3QgQk5fTWF4MjU2ID0gKEJOXzEgPDwgQmlnSW50KDI1NikpIC0gQk5fMTtcbi8vIElFRUUgNzU0IHN1cHBvcnQgNTMtYml0cyBvZiBtYW50aXNzYVxuY29uc3QgbWF4VmFsdWUgPSAweDFmZmZmZmZmZmZmZmZmO1xuLyoqXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgZnJvbSBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZiAlJXdpZHRoJSVcbiAqICBiaXRzIHRvIGl0cyB2YWx1ZS5cbiAqXG4gKiAgSWYgdGhlIGhpZ2hlc3QgYml0IGlzIGBgMWBgLCB0aGUgcmVzdWx0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuZnJvbVR3b3MgPSBmcm9tVHdvcztcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIHRvVHdvcyhfdmFsdWUsIF93aWR0aCkge1xuICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XG4gICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgaWYgKHZhbHVlIDwgQk5fMCkge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkodmFsdWUgPD0gbGltaXQsIFwidG9vIGxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuICgofnZhbHVlKSAmIG1hc2spICsgQk5fMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy50b1R3b3MgPSB0b1R3b3M7XG4vKipcbiAqICBNYXNrICUldmFsdWUlJSB3aXRoIGEgYml0bWFzayBvZiAlJWJpdHMlJSBvbmVzLlxuICovXG5mdW5jdGlvbiBtYXNrKF92YWx1ZSwgX2JpdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IGJpdHMgPSBCaWdJbnQoZ2V0TnVtYmVyKF9iaXRzLCBcImJpdHNcIikpO1xuICAgIHJldHVybiB2YWx1ZSAmICgoQk5fMSA8PCBiaXRzKSAtIEJOXzEpO1xufVxuZXhwb3J0cy5tYXNrID0gbWFzaztcbi8qKlxuICogIEdldHMgYSBCaWdJbnQgZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSBCaWdJbnQsIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIGdldEJpZ0ludCh2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOiByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIiAmJiB2YWx1ZVsxXSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1CaWdJbnQodmFsdWUuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBpbnZhbGlkIEJpZ051bWJlcmlzaCBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydHMuZ2V0QmlnSW50ID0gZ2V0QmlnSW50O1xuLyoqXG4gKiAgUmV0dXJucyAlJXZhbHVlJSUgYXMgYSBiaWdpbnQsIHZhbGlkYXRpbmcgaXQgaXMgdmFsaWQgYXMgYSBiaWdpbnRcbiAqICB2YWx1ZSBhbmQgdGhhdCBpdCBpcyBwb3NpdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VWludCh2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0VWludCA9IGdldFVpbnQ7XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKlxuICogQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnSW50LiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG5leHBvcnRzLnRvQmlnSW50ID0gdG9CaWdJbnQ7XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKEJpZ0ludCh2YWx1ZSksIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgaW52YWxpZCBudW1lcmljIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydHMuZ2V0TnVtYmVyID0gZ2V0TnVtYmVyO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgbnVtYmVyLiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLiBUaHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBzYWZlLlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBnZXROdW1iZXIodG9CaWdJbnQodmFsdWUpKTtcbn1cbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gaGV4c3RyaW5nLCBvcHRpb25hbGx5IHBhZGRlZCB0b1xuICogICUld2lkdGglJSBieXRlcy5cbiAqL1xuZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHdpZHRoICogMiA+PSByZXN1bHQubGVuZ3RoLCBgdmFsdWUgZXhjZWVkcyB3aWR0aCAoJHt3aWR0aH0gYnl0ZXMpYCwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b0JlSGV4XCIsXG4gICAgICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGFkIHRoZSB2YWx1ZSB0byB0aGUgcmVxdWlyZWQgd2lkdGhcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAod2lkdGggKiAyKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbmV4cG9ydHMudG9CZUhleCA9IHRvQmVIZXg7XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQmVBcnJheShfdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGlmICh2YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW10pO1xuICAgIH1cbiAgICBsZXQgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiAyO1xuICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudG9CZUFycmF5ID0gdG9CZUFycmF5O1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbSGV4U3RyaW5nXV0gZm9yICUldmFsdWUlJSBzYWZlIHRvIHVzZSBhcyBhIC8vUXVhbnRpdHkvLy5cbiAqXG4gKiAgQSAvL1F1YW50aXR5Ly8gZG9lcyBub3QgaGF2ZSBhbmQgbGVhZGluZyAwIHZhbHVlcyB1bmxlc3MgdGhlIHZhbHVlIGlzXG4gKiAgdGhlIGxpdGVyYWwgdmFsdWUgYDB4MGAuIFRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIGZvciBKU1NPTi1SUENcbiAqICBudW1lcmljIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSAoMCwgZGF0YV9qc18xLmhleGxpZnkpKCgwLCBkYXRhX2pzXzEuaXNCeXRlc0xpa2UpKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbmV4cG9ydHMudG9RdWFudGl0eSA9IHRvUXVhbnRpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRocy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/maths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/properties.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defineProperties = exports.resolveProperties = void 0;\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nasync function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\nexports.resolveProperties = resolveProperties;\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nfunction defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\nexports.defineProperties = defineProperties;\n//# sourceMappingURL=properties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9wcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyx5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwQ0FBMEM7QUFDdkY7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL3Byb3BlcnRpZXMuanM/YzRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFByb3BlcnR5IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6UHJvcGVydGllcyAgW2Fib3V0LXByb3BlcnRpZXNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSB2b2lkIDA7XG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyh2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGtleXMubWFwKChrKSA9PiBQcm9taXNlLnJlc29sdmUodmFsdWVba10pKSk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgdiwgaW5kZXgpID0+IHtcbiAgICAgICAgYWNjdW1ba2V5c1tpbmRleF1dID0gdjtcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSByZXNvbHZlUHJvcGVydGllcztcbi8qKlxuICogIEFzc2lnbnMgdGhlICUldmFsdWVzJSUgdG8gJSV0YXJnZXQlJSBhcyByZWFkLW9ubHkgdmFsdWVzLlxuICpcbiAqICBJdCAlJXR5cGVzJSUgaXMgc3BlY2lmaWVkLCB0aGUgdmFsdWVzIGFyZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgdmFsdWVzLCB0eXBlcykge1xuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSAodHlwZXMgPyB0eXBlc1trZXldIDogbnVsbCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBjaGVja1R5cGUodmFsdWUsIHR5cGUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZGVmaW5lUHJvcGVydGllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/properties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/rlp-decode.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/rlp-decode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n//See: https://github.com/ethereum/wiki/wiki/RLP\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeRlp = void 0;\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst data_js_2 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while (result.length < 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0, errors_js_1.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length, offset\n        });\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0, errors_js_1.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data, length: 0, offset: 1\n    });\n    const checkOffset = (offset) => {\n        (0, errors_js_1.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length: data.length, offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0, data_js_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nfunction decodeRlp(_data) {\n    const data = (0, data_js_2.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0, errors_js_1.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\nexports.decodeRlp = decodeRlp;\n//# sourceMappingURL=rlp-decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9ybHAtZGVjb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL3JscC1kZWNvZGUuanM/ZGJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVSbHAgPSB2b2lkIDA7XG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5jb25zdCBkYXRhX2pzXzIgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuZnVuY3Rpb24gaGV4bGlmeUJ5dGUodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgMikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSAocmVzdWx0ICogMjU2KSArIGRhdGFbb2Zmc2V0ICsgaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBjaGlsZE9mZnNldCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKGNoaWxkT2Zmc2V0IDwgb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCBjaGlsZE9mZnNldCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWQucmVzdWx0KTtcbiAgICAgICAgY2hpbGRPZmZzZXQgKz0gZGVjb2RlZC5jb25zdW1lZDtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoY2hpbGRPZmZzZXQgPD0gb2Zmc2V0ICsgMSArIGxlbmd0aCwgXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShkYXRhLmxlbmd0aCAhPT0gMCwgXCJkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IDAsIG9mZnNldDogMVxuICAgIH0pO1xuICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShvZmZzZXQgPD0gZGF0YS5sZW5ndGgsIFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoOiBkYXRhLmxlbmd0aCwgb2Zmc2V0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gQXJyYXkgd2l0aCBleHRyYSBsZW5ndGggcHJlZml4XG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGY4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGMwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4YzA7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgZGF0YV9qc18xLmhleGxpZnkpKGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHg4MCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweDgwO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIGRhdGFfanNfMS5oZXhsaWZ5KShkYXRhLnNsaWNlKG9mZnNldCArIDEsIG9mZnNldCArIDEgKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6IDEsIHJlc3VsdDogaGV4bGlmeUJ5dGUoZGF0YVtvZmZzZXRdKSB9O1xufVxuLyoqXG4gKiAgRGVjb2RlcyAlJWRhdGElJSBpbnRvIHRoZSBzdHJ1Y3R1cmVkIGRhdGEgaXQgcmVwcmVzZW50cy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlUmxwKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBkYXRhX2pzXzIuZ2V0Qnl0ZXMpKF9kYXRhLCBcImRhdGFcIik7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgMCk7XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShkZWNvZGVkLmNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCwgXCJ1bmV4cGVjdGVkIGp1bmsgYWZ0ZXIgcmxwIHBheWxvYWRcIiwgXCJkYXRhXCIsIF9kYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlZC5yZXN1bHQ7XG59XG5leHBvcnRzLmRlY29kZVJscCA9IGRlY29kZVJscDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1kZWNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/rlp-decode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/rlp-encode.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/rlp-encode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n//See: https://github.com/ethereum/wiki/wiki/RLP\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeRlp = void 0;\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0, data_js_1.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */\nfunction encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}\nexports.encodeRlp = encodeRlp;\n//# sourceMappingURL=rlp-encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9ybHAtZW5jb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9ybHAtZW5jb2RlLmpzPzc4MzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlUmxwID0gdm9pZCAwO1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbmZ1bmN0aW9uIGFycmF5aWZ5SW50ZWdlcih2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQudW5zaGlmdCh2YWx1ZSAmIDB4ZmYpO1xuICAgICAgICB2YWx1ZSA+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IFtdO1xuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLmNvbmNhdChfZW5jb2RlKGNoaWxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHBheWxvYWQudW5zaGlmdCgweGMwICsgcGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoLnVuc2hpZnQoMHhmNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChwYXlsb2FkKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCgwLCBkYXRhX2pzXzEuZ2V0Qnl0ZXMpKG9iamVjdCwgXCJvYmplY3RcIikpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgIGRhdGEudW5zaGlmdCgweDgwICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKGRhdGEubGVuZ3RoKTtcbiAgICBsZW5ndGgudW5zaGlmdCgweGI3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgcmV0dXJuIGxlbmd0aC5jb25jYXQoZGF0YSk7XG59XG5jb25zdCBuaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKipcbiAqICBFbmNvZGVzICUlb2JqZWN0JSUgYXMgYW4gUkxQLWVuY29kZWQgW1tEYXRhSGV4U3RyaW5nXV0uXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAoY29uc3QgdiBvZiBfZW5jb2RlKG9iamVjdCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiAmIDB4Zl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmVuY29kZVJscCA9IGVuY29kZVJscDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1lbmNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/rlp-encode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/units.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/units.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = void 0;\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst fixednumber_js_1 = __webpack_require__(/*! ./fixednumber.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/fixednumber.js\");\nconst maths_js_1 = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nfunction formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0, errors_js_1.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0, maths_js_1.getNumber)(unit, \"unit\");\n    }\n    return fixednumber_js_1.FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\nexports.formatUnits = formatUnits;\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nfunction parseUnits(value, unit) {\n    (0, errors_js_1.assertArgument)(typeof (value) === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0, errors_js_1.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0, maths_js_1.getNumber)(unit, \"unit\");\n    }\n    return fixednumber_js_1.FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\nexports.parseUnits = parseUnits;\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nexports.formatEther = formatEther;\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n}\nexports.parseEther = parseEther;\n//# sourceMappingURL=units.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91bml0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsNkVBQWE7QUFDekMseUJBQXlCLG1CQUFPLENBQUMsdUZBQWtCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLDJFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHNCQUFzQjtBQUMzRjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxzQkFBc0I7QUFDbEY7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvdW5pdHMuanM/Nzc2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VFdGhlciA9IGV4cG9ydHMuZm9ybWF0RXRoZXIgPSBleHBvcnRzLnBhcnNlVW5pdHMgPSBleHBvcnRzLmZvcm1hdFVuaXRzID0gdm9pZCAwO1xuLyoqXG4gKiAgTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBFdGhlcmV1bSByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlcywgd2hpY2ggdXNlXG4gKiAgdGhlIHNtYWxsZXN0IG1hZ25pdHVkZSB1bml0LlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBkZWFsaW5nIHdpdGggZG9sbGFycyBhbmQgY2VudHMuIFNpbmNlIGRvbGxhcnNcbiAqICBhcmUgZGl2aXNpYmxlLCBub24taW50ZWdlciB2YWx1ZXMgYXJlIHBvc3NpYmxlLCBzdWNoIGFzIGBgJDEwLjc3YGAuXG4gKiAgQnkgdXNpbmcgdGhlIHNtYWxsZXN0IGluZGl2aXNpYmxlIHVuaXQgKGkuZS4gY2VudHMpLCB0aGUgdmFsdWUgY2FuXG4gKiAgYmUga2VwdCBhcyB0aGUgaW50ZWdlciBgYDEwNzdgYC5cbiAqXG4gKiAgV2hlbiByZWNlaXZpbmcgZGVjaW1hbCBpbnB1dCBmcm9tIHRoZSB1c2VyIChhcyBhIGRlY2ltYWwgc3RyaW5nKSxcbiAqICB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGFuZCB3aGVuIHNob3dpbmcgYSB1c2VyXG4gKiAgYSB2YWx1ZSwgdGhlIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqICBUaGlzIGNyZWF0ZXMgYSBjbGVhciBkaXN0aW5jdGlvbiwgYmV0d2VlbiB2YWx1ZXMgdG8gYmUgdXNlZCBieSBjb2RlXG4gKiAgKGludGVnZXJzKSBhbmQgdmFsdWVzIHVzZWQgZm9yIGRpc3BsYXkgbG9naWMgdG8gdXNlcnMgKGRlY2ltYWxzKS5cbiAqXG4gKiAgVGhlIG5hdGl2ZSB1bml0IGluIEV0aGVyZXVtLCAvL2V0aGVyLy8gaXMgZGl2aXNpYmxlIHRvIDE4IGRlY2ltYWwgcGxhY2VzLFxuICogIHdoZXJlIGVhY2ggaW5kaXZpZHVhbCB1bml0IGlzIGNhbGxlZCBhIC8vd2VpLy8uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6VW5pdCBDb252ZXJzaW9uICBbYWJvdXQtdW5pdHNdXG4gKi9cbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuY29uc3QgZml4ZWRudW1iZXJfanNfMSA9IHJlcXVpcmUoXCIuL2ZpeGVkbnVtYmVyLmpzXCIpO1xuY29uc3QgbWF0aHNfanNfMSA9IHJlcXVpcmUoXCIuL21hdGhzLmpzXCIpO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8sIGFzc3VtaW5nICUldW5pdCUlIGRlY2ltYWxcbiAqICBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgYmUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvciB0aGUgbmFtZSBvZlxuICogIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICpcbiAqL1xuZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsIHVuaXQpIHtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh1bml0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdCk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gKDAsIG1hdGhzX2pzXzEuZ2V0TnVtYmVyKSh1bml0LCBcInVuaXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmaXhlZG51bWJlcl9qc18xLkZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudG9TdHJpbmcoKTtcbn1cbmV4cG9ydHMuZm9ybWF0VW5pdHMgPSBmb3JtYXRVbml0cztcbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSV2YWx1ZSUlIHRvIGEgQmlnSW50LCBhc3N1bWluZ1xuICogICUldW5pdCUlIGRlY2ltYWwgcGxhY2VzLiBUaGUgJSV1bml0JSUgbWF5IHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqICBvciB0aGUgbmFtZSBvZiBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh1bml0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdCk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gKDAsIG1hdGhzX2pzXzEuZ2V0TnVtYmVyKSh1bml0LCBcInVuaXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmaXhlZG51bWJlcl9qc18xLkZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudmFsdWU7XG59XG5leHBvcnRzLnBhcnNlVW5pdHMgPSBwYXJzZVVuaXRzO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8gdXNpbmcgMTggZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSkge1xuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIDE4KTtcbn1cbmV4cG9ydHMuZm9ybWF0RXRoZXIgPSBmb3JtYXRFdGhlcjtcbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSVldGhlciUlIHRvIGEgQmlnSW50LCB1c2luZyAxOFxuICogIGRlY2ltYWwgcGxhY2VzLlxuICovXG5mdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcbn1cbmV4cG9ydHMucGFyc2VFdGhlciA9IHBhcnNlRXRoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/units.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/utf8.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/utf8.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toUtf8CodePoints = exports.toUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = void 0;\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0, errors_js_1.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0, errors_js_1.assertArgument)(typeof (badCodepoint) === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */\nexports.Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = exports.Utf8ErrorFuncs.error;\n    }\n    const bytes = (0, data_js_1.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            }\n            else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nfunction toUtf8Bytes(str, form) {\n    (0, errors_js_1.assertArgument)(typeof (str) === \"string\", \"invalid string value\", \"str\", str);\n    if (form != null) {\n        (0, errors_js_1.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0, errors_js_1.assertArgument)(i < str.length && ((c2 & 0xfc00) === 0xdc00), \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nexports.toUtf8String = toUtf8String;\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nfunction toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\nexports.toUtf8CodePoints = toUtf8CodePoints;\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91dGY4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWE7QUFDekM7QUFDQSwwRUFBMEUsU0FBUyxFQUFFLE9BQU87QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91dGY4LmpzPzMxNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvVXRmOENvZGVQb2ludHMgPSBleHBvcnRzLnRvVXRmOFN0cmluZyA9IGV4cG9ydHMudG9VdGY4Qnl0ZXMgPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gdm9pZCAwO1xuLyoqXG4gKiAgVXNpbmcgc3RyaW5ncyBpbiBFdGhlcmV1bSAob3IgYW55IHNlY3VyaXR5LWJhc2Qgc3lzdGVtKSByZXF1aXJlc1xuICogIGFkZGl0aW9uYWwgY2FyZS4gVGhlc2UgdXRpbGl0aWVzIGF0dGVtcHQgdG8gbWl0aWdhdGUgc29tZSBvZiB0aGVcbiAqICBzYWZldHkgaXNzdWVzIGFzIHdlbGwgYXMgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byByZWNvdmVyIGFuZCBhbmFseXNlXG4gKiAgc3RyaW5ncy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpTdHJpbmdzIGFuZCBVVEYtOCAgW2Fib3V0LXN0cmluZ3NdXG4gKi9cbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFwiQkFEX1BSRUZJWFwiIHx8IHJlYXNvbiA9PT0gXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSUlVOXCIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJMT05HXCIpIHtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKGJhZENvZGVwb2ludCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBiYWQgY29kZSBwb2ludCBmb3IgcmVwbGFjZW1lbnRcIiwgXCJiYWRDb2RlcG9pbnRcIiwgYmFkQ29kZXBvaW50KTtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpO1xufVxuLyoqXG4gKiAgQSBoYW5kZnVsIG9mIHBvcHVsYXIsIGJ1aWx0LWluIFVURi04IGVycm9yIGhhbmRsaW5nIHN0cmF0ZWdpZXMuXG4gKlxuICogICoqYGBcImVycm9yXCJgYCoqIC0gdGhyb3dzIG9uIEFOWSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIG9yXG4gKiAgbm9uLWNhbm9uaWNhbCAob3ZlcmxvbmcpIGNvZGVwb2ludHMgKHRoaXMgaXMgdGhlIGRlZmF1bHQpXG4gKlxuICogICoqYGBcImlnbm9yZVwiYGAqKiAtIHNpbGVudGx5IGRyb3BzIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlXG4gKiAgYW5kIGFjY2VwdHMgbm9uLWNhbm9uaWNhbCAob3ZlcmxvbmcpIGNvZGVwb2ludHNcbiAqXG4gKiAgKipgYFwicmVwbGFjZVwiYGAqKiAtIHJlcGxhY2UgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugd2l0aCB0aGVcbiAqICBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKGkuZS4gYGBcIlxcXFx1ZmZmZFwiYGApIGFuZCBhY2NlcHRzXG4gKiAgbm9uLWNhbm9uaWNhbCAob3ZlcmxvbmcpIGNvZGVwb2ludHNcbiAqXG4gKiAgQHJldHVybnM6IFJlY29yZDxcImVycm9yXCIgfCBcImlnbm9yZVwiIHwgXCJyZXBsYWNlXCIsIFV0ZjhFcnJvckZ1bmM+XG4gKi9cbmV4cG9ydHMuVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogZXJyb3JGdW5jLFxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xufSk7XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKF9ieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IGV4cG9ydHMuVXRmOEVycm9yRnVuY3MuZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gKDAsIGRhdGFfanNfMS5nZXRCeXRlcykoX2J5dGVzLCBcImJ5dGVzXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBJbnZhbGlkIGJ5dGVzIGFyZSBpZ25vcmVkXG4gICAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYyA9IGJ5dGVzW2krK107XG4gICAgICAgIC8vIDB4eHggeHh4eFxuICAgICAgICBpZiAoYyA+PiA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpYnl0ZTsgaG93IG1hbnkgYnl0ZXMgbGVmdCBmb3IgdGhpcyBjaGFyYWN0ZXI/XG4gICAgICAgIGxldCBleHRyYUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGxldCBvdmVybG9uZ01hc2sgPSBudWxsO1xuICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIGlmICgoYyAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmO1xuICAgICAgICAgICAgLy8gMTExMCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDI7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmZjtcbiAgICAgICAgICAgIC8vIDExMTEgMHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMztcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4ZmZmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYyAmIDB4YzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJCQURfUFJFRklYXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIHdlIGhhdmUgZW5vdWdoIGJ5dGVzIGluIG91ciBkYXRhP1xuICAgICAgICBpZiAoaSAtIDEgKyBleHRyYUxlbmd0aCA+PSBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJSVU5cIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGNoYXJcbiAgICAgICAgbGV0IHJlcyA9IGMgJiAoKDEgPDwgKDggLSBleHRyYUxlbmd0aCAtIDEpKSAtIDEpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGV4dHJhTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0Q2hhciA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgLy8gSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICAgICAgaWYgKChuZXh0Q2hhciAmIDB4YzApICE9IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJNSVNTSU5HX0NPTlRJTlVFXCIsIGksIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICByZXMgPSAocmVzIDw8IDYpIHwgKG5leHRDaGFyICYgMHgzZik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGFib3ZlIGxvb3AgZm9yIGludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF4aW11bSBjb2RlIHBvaW50XG4gICAgICAgIGlmIChyZXMgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1VUX09GX1JBTkdFXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgaWYgKHJlcyA+PSAweGQ4MDAgJiYgcmVzIDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiVVRGMTZfU1VSUk9HQVRFXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3Igb3Zlcmxvbmcgc2VxdWVuY2VzIChtb3JlIGJ5dGVzIHRoYW4gbmVlZGVkKVxuICAgICAgICBpZiAocmVzIDw9IG92ZXJsb25nTWFzaykge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUkxPTkdcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcbi8qKlxuICogIFJldHVybnMgdGhlIFVURi04IGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgJSVzdHIlJS5cbiAqXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChzdHIpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nIHZhbHVlXCIsIFwic3RyXCIsIHN0cik7XG4gICAgaWYgKGZvcm0gIT0gbnVsbCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0Tm9ybWFsaXplKShmb3JtKTtcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5leHBvcnRzLnRvVXRmOEJ5dGVzID0gdG9VdGY4Qnl0ZXM7XG47XG4vL2V4cG9ydCBcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cbiAqXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxuICogIChkZWZhdWx0OiBbZXJyb3JdKFV0ZjhFcnJvckZ1bmNzKSlcbiAqL1xuZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbmV4cG9ydHMudG9VdGY4U3RyaW5nID0gdG9VdGY4U3RyaW5nO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggY29kZS1wb2ludHMgZm9yICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5mdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbmV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IHRvVXRmOENvZGVQb2ludHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/utils/uuid.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/uuid.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uuidV4 = void 0;\n/**\n *  Explain UUID and link to RFC here.\n *\n *  @_subsection: api/utils:UUID  [about-uuid]\n */\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/data.js\");\n/**\n *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.\n *\n *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n */\nfunction uuidV4(randomBytes) {\n    const bytes = (0, data_js_1.getBytes)(randomBytes, \"randomBytes\");\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    const value = (0, data_js_1.hexlify)(bytes);\n    return [\n        value.substring(2, 10),\n        value.substring(10, 14),\n        value.substring(14, 18),\n        value.substring(18, 22),\n        value.substring(22, 34),\n    ].join(\"-\");\n}\nexports.uuidV4 = uuidV4;\n//# sourceMappingURL=uuid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91dWlkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL3V1aWQuanM/NjM2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXVpZFY0ID0gdm9pZCAwO1xuLyoqXG4gKiAgRXhwbGFpbiBVVUlEIGFuZCBsaW5rIHRvIFJGQyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpVVUlEICBbYWJvdXQtdXVpZF1cbiAqL1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbi8qKlxuICogIFJldHVybnMgdGhlIHZlcnNpb24gNCBbW2xpbmstdXVpZF1dIGZvciB0aGUgJSVyYW5kb21CeXRlcyUlLlxuICpcbiAqICBAc2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxuICovXG5mdW5jdGlvbiB1dWlkVjQocmFuZG9tQnl0ZXMpIHtcbiAgICBjb25zdCBieXRlcyA9ICgwLCBkYXRhX2pzXzEuZ2V0Qnl0ZXMpKHJhbmRvbUJ5dGVzLCBcInJhbmRvbUJ5dGVzXCIpO1xuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxuICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICAvLyBTZWN0aW9uIDQuNFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs3XSA9IDBiMVxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIGRhdGFfanNfMS5oZXhsaWZ5KShieXRlcyk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIsIDEwKSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDEwLCAxNCksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTgsIDIyKSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIyLCAzNCksXG4gICAgXS5qb2luKFwiLVwiKTtcbn1cbmV4cG9ydHMudXVpZFY0ID0gdXVpZFY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXVpZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/utils/uuid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/base-wallet.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseWallet = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../providers/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nclass BaseWallet extends index_js_3.AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    address;\n    #signingKey;\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */\n    constructor(privateKey, provider) {\n        super(provider);\n        (0, index_js_5.assertArgument)(privateKey && typeof (privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n        this.#signingKey = privateKey;\n        const address = (0, index_js_4.computeAddress)(this.signingKey.publicKey);\n        (0, index_js_5.defineProperties)(this, { address });\n    }\n    // Store private values behind getters to reduce visibility\n    // in console.log\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */\n    get signingKey() { return this.#signingKey; }\n    /**\n     *  The private key for this wallet.\n     */\n    get privateKey() { return this.signingKey.privateKey; }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n    async signTransaction(tx) {\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await (0, index_js_5.resolveProperties)({\n            to: (tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined),\n            from: (tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined)\n        });\n        if (to != null) {\n            tx.to = to;\n        }\n        if (from != null) {\n            tx.from = from;\n        }\n        if (tx.from != null) {\n            (0, index_js_5.assertArgument)((0, index_js_1.getAddress)((tx.from)) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n        // Build the transaction\n        const btx = index_js_4.Transaction.from(tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n        return btx.serialized;\n    }\n    async signMessage(message) {\n        return this.signMessageSync(message);\n    }\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */\n    signMessageSync(message) {\n        return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;\n    }\n    async signTypedData(domain, types, value) {\n        // Populate any ENS names\n        const populated = await index_js_2.TypedDataEncoder.resolveNames(domain, types, value, async (name) => {\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n            (0, index_js_5.assert)(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: { name }\n            });\n            const address = await this.provider.resolveName(name);\n            (0, index_js_5.assert)(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n            return address;\n        });\n        return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n}\nexports.BaseWallet = BaseWallet;\n//# sourceMappingURL=base-wallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvYmFzZS13YWxsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXVCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDhGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd2FsbGV0L2Jhc2Utd2FsbGV0LmpzPzhkNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VXYWxsZXQgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3Byb3ZpZGVycy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc181ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgVGhlICoqQmFzZVdhbGxldCoqIGlzIGEgc3RyZWFtLWxpbmVkIGltcGxlbWVudGF0aW9uIG9mIGFcbiAqICBbW1NpZ25lcl1dIHRoYXQgb3BlcmF0ZXMgd2l0aCBhIHByaXZhdGUga2V5LlxuICpcbiAqICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbW1dhbGxldF1dIGNsYXNzLCBhcyBpdCBvZmZlcnNcbiAqICBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgYW5kIHNpbXBsaWZpZXMgbG9hZGluZyBhIHZhcmlldHlcbiAqICBvZiBKU09OIGZvcm1hdHMsIE1uZW1vbmljIFBocmFzZXMsIGV0Yy5cbiAqXG4gKiAgVGhpcyBjbGFzcyBtYXkgYmUgb2YgdXNlIGZvciB0aG9zZSBhdHRlbXB0aW5nIHRvIGltcGxlbWVudFxuICogIGEgbWluaW1hbCBTaWduZXIuXG4gKi9cbmNsYXNzIEJhc2VXYWxsZXQgZXh0ZW5kcyBpbmRleF9qc18zLkFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHdhbGxldCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgI3NpZ25pbmdLZXk7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgQmFzZVdhbGxldCBmb3IgJSVwcml2YXRlS2V5JSUsIG9wdGlvbmFsbHlcbiAgICAgKiAgY29ubmVjdGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb3ZpZGVyJSUgaXMgbm90IHNwZWNpZmllZCwgb25seSBvZmZsaW5lIG1ldGhvZHMgY2FuXG4gICAgICogIGJlIHVzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSwgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkocHJpdmF0ZUtleSAmJiB0eXBlb2YgKHByaXZhdGVLZXkuc2lnbikgPT09IFwiZnVuY3Rpb25cIiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgdGhpcy4jc2lnbmluZ0tleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW5kZXhfanNfNC5jb21wdXRlQWRkcmVzcykodGhpcy5zaWduaW5nS2V5LnB1YmxpY0tleSk7XG4gICAgICAgICgwLCBpbmRleF9qc181LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgLy8gU3RvcmUgcHJpdmF0ZSB2YWx1ZXMgYmVoaW5kIGdldHRlcnMgdG8gcmVkdWNlIHZpc2liaWxpdHlcbiAgICAvLyBpbiBjb25zb2xlLmxvZ1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tTaWduaW5nS2V5XV0gdXNlZCBmb3Igc2lnbmluZyBwYXlsb2Fkcy5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmluZ0tleSgpIHsgcmV0dXJuIHRoaXMuI3NpZ25pbmdLZXk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHByaXZhdGUga2V5IGZvciB0aGlzIHdhbGxldC5cbiAgICAgKi9cbiAgICBnZXQgcHJpdmF0ZUtleSgpIHsgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5wcml2YXRlS2V5OyB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIHRoaXMuYWRkcmVzczsgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlV2FsbGV0KHRoaXMuI3NpZ25pbmdLZXksIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIC8vIFJlcGxhY2UgYW55IEFkZHJlc3NhYmxlIG9yIEVOUyBuYW1lIHdpdGggYW4gYWRkcmVzc1xuICAgICAgICBjb25zdCB7IHRvLCBmcm9tIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgdG86ICh0eC50byA/ICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKSh0eC50bywgdGhpcy5wcm92aWRlcikgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgZnJvbTogKHR4LmZyb20gPyAoMCwgaW5kZXhfanNfMS5yZXNvbHZlQWRkcmVzcykodHguZnJvbSwgdGhpcy5wcm92aWRlcikgOiB1bmRlZmluZWQpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHgudG8gPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykoKHR4LmZyb20pKSA9PT0gdGhpcy5hZGRyZXNzLCBcInRyYW5zYWN0aW9uIGZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgdHguZnJvbSk7XG4gICAgICAgICAgICBkZWxldGUgdHguZnJvbTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgYnR4ID0gaW5kZXhfanNfNC5UcmFuc2FjdGlvbi5mcm9tKHR4KTtcbiAgICAgICAgYnR4LnNpZ25hdHVyZSA9IHRoaXMuc2lnbmluZ0tleS5zaWduKGJ0eC51bnNpZ25lZEhhc2gpO1xuICAgICAgICByZXR1cm4gYnR4LnNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbk1lc3NhZ2VTeW5jKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQWRkIGEgc2VjaWFsaXplZCBzaWduVHggYW5kIHNpZ25UeXBlZCBzeW5jIHRoYXQgZW5mb3JjZXNcbiAgICAvLyBhbGwgcGFyYW1ldGVycyBhcmUga25vd24/XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNpZ25hdHVyZSBmb3IgJSVtZXNzYWdlJSUgc2lnbmVkIHdpdGggdGhpcyB3YWxsZXQuXG4gICAgICovXG4gICAgc2lnbk1lc3NhZ2VTeW5jKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5zaWduKCgwLCBpbmRleF9qc18yLmhhc2hNZXNzYWdlKShtZXNzYWdlKSkuc2VyaWFsaXplZDtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzXG4gICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IGF3YWl0IGluZGV4X2pzXzIuVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jIChuYW1lKSA9PiB7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGhpcyBzaG91bGQgdXNlIHJlc29sdmVOYW1lOyBhZGRyZXNzZXMgZG9uJ3RcbiAgICAgICAgICAgIC8vICAgICAgICBuZWVkIGEgcHJvdmlkZXJcbiAgICAgICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydCkodGhpcy5wcm92aWRlciAhPSBudWxsLCBcImNhbm5vdCByZXNvbHZlIEVOUyBuYW1lcyB3aXRob3V0IGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsgbmFtZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KShhZGRyZXNzICE9IG51bGwsIFwidW5jb25maWd1cmVkIEVOUyBuYW1lXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5zaWduKGluZGV4X2pzXzIuVHlwZWREYXRhRW5jb2Rlci5oYXNoKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKS5zZXJpYWxpemVkO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVdhbGxldCA9IEJhc2VXYWxsZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXdhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wallet/hdwallet.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/hdwallet.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getIndexedAccountPath = exports.getAccountPath = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.defaultPath = void 0;\n/**\n *  Explain HD Wallets..\n *\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\n */\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../providers/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/providers/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst lang_en_js_1 = __webpack_require__(/*! ../wordlists/lang-en.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\");\nconst base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js\");\nconst mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js\");\nconst json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js\");\n/**\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\n */\nexports.defaultPath = \"m/44'/60'/0'/0/0\";\n// \"Bitcoin seed\"\nconst MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);\nconst HardenedBit = 0x80000000;\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst Nibbles = \"0123456789abcdef\";\nfunction zpad(value, length) {\n    let result = \"\";\n    while (value) {\n        result = Nibbles[value % 16] + result;\n        value = Math.trunc(value / 16);\n    }\n    while (result.length < length * 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction encodeBase58Check(_value) {\n    const value = (0, index_js_4.getBytes)(_value);\n    const check = (0, index_js_4.dataSlice)((0, index_js_1.sha256)((0, index_js_1.sha256)(value)), 0, 4);\n    const bytes = (0, index_js_4.concat)([value, check]);\n    return (0, index_js_4.encodeBase58)(bytes);\n}\nconst _guard = {};\nfunction ser_I(index, chainCode, publicKey, privateKey) {\n    const data = new Uint8Array(37);\n    if (index & HardenedBit) {\n        (0, index_js_4.assert)(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"deriveChild\"\n        });\n        // Data = 0x00 || ser_256(k_par)\n        data.set((0, index_js_4.getBytes)(privateKey), 1);\n    }\n    else {\n        // Data = ser_p(point(k_par))\n        data.set((0, index_js_4.getBytes)(publicKey));\n    }\n    // Data += ser_32(i)\n    for (let i = 24; i >= 0; i -= 8) {\n        data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\n    }\n    const I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)(\"sha512\", chainCode, data));\n    return { IL: I.slice(0, 32), IR: I.slice(32) };\n}\nfunction derivePath(node, path) {\n    const components = path.split(\"/\");\n    (0, index_js_4.assertArgument)(components.length > 0, \"invalid path\", \"path\", path);\n    if (components[0] === \"m\") {\n        (0, index_js_4.assertArgument)(node.depth === 0, `cannot derive root path (i.e. path starting with \"m/\") for a node at non-zero depth ${node.depth}`, \"path\", path);\n        components.shift();\n    }\n    let result = node;\n    for (let i = 0; i < components.length; i++) {\n        const component = components[i];\n        if (component.match(/^[0-9]+'$/)) {\n            const index = parseInt(component.substring(0, component.length - 1));\n            (0, index_js_4.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n            result = result.deriveChild(HardenedBit + index);\n        }\n        else if (component.match(/^[0-9]+$/)) {\n            const index = parseInt(component);\n            (0, index_js_4.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n            result = result.deriveChild(index);\n        }\n        else {\n            (0, index_js_4.assertArgument)(false, \"invalid path component\", `path[${i}]`, component);\n        }\n    }\n    return result;\n}\n/**\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\n *  from an HD Node using the [[link-bip-32]] stantard.\n *\n *  An HD Node forms a hierarchal structure with each HD Node having a\n *  private key and the ability to derive child HD Nodes, defined by\n *  a path indicating the index of each child.\n */\nclass HDNodeWallet extends base_wallet_js_1.BaseWallet {\n    /**\n     *  The compressed public key.\n     */\n    publicKey;\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    fingerprint;\n    /**\n     *  The parent fingerprint.\n     */\n    parentFingerprint;\n    /**\n     *  The mnemonic used to create this HD Node, if available.\n     *\n     *  Sources such as extended keys do not encode the mnemonic, in\n     *  which case this will be ``null``.\n     */\n    mnemonic;\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    chainCode;\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    path;\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    index;\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    depth;\n    /**\n     *  @private\n     */\n    constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {\n        super(signingKey, provider);\n        (0, index_js_4.assertPrivate)(guard, _guard, \"HDNodeWallet\");\n        (0, index_js_4.defineProperties)(this, { publicKey: signingKey.compressedPublicKey });\n        const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(this.publicKey)), 0, 4);\n        (0, index_js_4.defineProperties)(this, {\n            parentFingerprint, fingerprint,\n            chainCode, path, index, depth\n        });\n        (0, index_js_4.defineProperties)(this, { mnemonic });\n    }\n    connect(provider) {\n        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n    }\n    #account() {\n        const account = { address: this.address, privateKey: this.privateKey };\n        const m = this.mnemonic;\n        if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n            account.mnemonic = {\n                path: this.path,\n                locale: \"en\",\n                entropy: m.entropy\n            };\n        }\n        return account;\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    async encrypt(password, progressCallback) {\n        return await (0, json_keystore_js_1.encryptKeystoreJson)(this.#account(), password, { progressCallback });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n    encryptSync(password) {\n        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(this.#account(), password);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpriv`` and can be used to\n     *  reconstruct this HD Node to derive its children.\n     */\n    get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        (0, index_js_4.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\n        return encodeBase58Check((0, index_js_4.concat)([\n            \"0x0488ADE4\", zpad(this.depth, 1), this.parentFingerprint,\n            zpad(this.index, 4), this.chainCode,\n            (0, index_js_4.concat)([\"0x00\", this.privateKey])\n        ]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n    hasPath() { return (this.path != null); }\n    /**\n     *  Returns a neutered HD Node, which removes the private details\n     *  of an HD Node.\n     *\n     *  A neutered node has no private key, but can be used to derive\n     *  child addresses and other public data about the HD Node.\n     */\n    neuter() {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\n    }\n    /**\n     *  Return the child for %%index%%.\n     */\n    deriveChild(_index) {\n        const index = (0, index_js_4.getNumber)(_index, \"index\");\n        (0, index_js_4.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) {\n                path += \"'\";\n            }\n        }\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\n        const ki = new index_js_1.SigningKey((0, index_js_4.toBeHex)(((0, index_js_4.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));\n        return new HDNodeWallet(_guard, ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\n    }\n    /**\n     *  Return the HDNode for %%path%% from this node.\n     */\n    derivePath(path) {\n        return derivePath(this, path);\n    }\n    static #fromSeed(_seed, mnemonic) {\n        (0, index_js_4.assertArgument)((0, index_js_4.isBytesLike)(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n        const seed = (0, index_js_4.getBytes)(_seed, \"seed\");\n        (0, index_js_4.assertArgument)(seed.length >= 16 && seed.length <= 64, \"invalid seed\", \"seed\", \"[REDACTED]\");\n        const I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)(\"sha512\", MasterSecret, seed));\n        const signingKey = new index_js_1.SigningKey((0, index_js_4.hexlify)(I.slice(0, 32)));\n        return new HDNodeWallet(_guard, signingKey, \"0x00000000\", (0, index_js_4.hexlify)(I.slice(32)), \"m\", 0, 0, mnemonic, null);\n    }\n    /**\n     *  Creates a new HD Node from %%extendedKey%%.\n     *\n     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\n     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\n     *  or full HD Node ([[HDNodeWallet) respectively.\n     */\n    static fromExtendedKey(extendedKey) {\n        const bytes = (0, index_js_4.toBeArray)((0, index_js_4.decodeBase58)(extendedKey)); // @TODO: redact\n        (0, index_js_4.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n        const depth = bytes[4];\n        const parentFingerprint = (0, index_js_4.hexlify)(bytes.slice(5, 9));\n        const index = parseInt((0, index_js_4.hexlify)(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = (0, index_js_4.hexlify)(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n        switch ((0, index_js_4.hexlify)(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\":\n            case \"0x043587cf\": {\n                const publicKey = (0, index_js_4.hexlify)(key);\n                return new HDNodeVoidWallet(_guard, (0, index_js_3.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\n            }\n            // Private Key\n            case \"0x0488ade4\":\n            case \"0x04358394 \":\n                if (key[0] !== 0) {\n                    break;\n                }\n                return new HDNodeWallet(_guard, new index_js_1.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\n        }\n        (0, index_js_4.assertArgument)(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n    }\n    /**\n     *  Creates a new random HDNode.\n     */\n    static createRandom(password, path, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (path == null) {\n            path = exports.defaultPath;\n        }\n        if (wordlist == null) {\n            wordlist = lang_en_js_1.LangEn.wordlist();\n        }\n        const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy((0, index_js_1.randomBytes)(16), password, wordlist);\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Create an HD Node from %%mnemonic%%.\n     */\n    static fromMnemonic(mnemonic, path) {\n        if (!path) {\n            path = exports.defaultPath;\n        }\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a mnemonic %%phrase%%.\n     */\n    static fromPhrase(phrase, password, path, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (path == null) {\n            path = exports.defaultPath;\n        }\n        if (wordlist == null) {\n            wordlist = lang_en_js_1.LangEn.wordlist();\n        }\n        const mnemonic = mnemonic_js_1.Mnemonic.fromPhrase(phrase, password, wordlist);\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a %%seed%%.\n     */\n    static fromSeed(seed) {\n        return HDNodeWallet.#fromSeed(seed, null);\n    }\n}\nexports.HDNodeWallet = HDNodeWallet;\n/**\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\n *\n *  The can be created by using an extended ``xpub`` key to\n *  [[HDNodeWallet_fromExtendedKey]] or by\n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\n */\nclass HDNodeVoidWallet extends index_js_2.VoidSigner {\n    /**\n     *  The compressed public key.\n     */\n    publicKey;\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    fingerprint;\n    /**\n     *  The parent node fingerprint.\n     */\n    parentFingerprint;\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    chainCode;\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    path;\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    index;\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    depth;\n    /**\n     *  @private\n     */\n    constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {\n        super(address, provider);\n        (0, index_js_4.assertPrivate)(guard, _guard, \"HDNodeVoidWallet\");\n        (0, index_js_4.defineProperties)(this, { publicKey });\n        const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(publicKey)), 0, 4);\n        (0, index_js_4.defineProperties)(this, {\n            publicKey, fingerprint, parentFingerprint, chainCode, path, index, depth\n        });\n    }\n    connect(provider) {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpub`` and can be used to\n     *  reconstruct this neutered key to derive its children addresses.\n     */\n    get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        (0, index_js_4.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\n        return encodeBase58Check((0, index_js_4.concat)([\n            \"0x0488B21E\",\n            zpad(this.depth, 1),\n            this.parentFingerprint,\n            zpad(this.index, 4),\n            this.chainCode,\n            this.publicKey,\n        ]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n    hasPath() { return (this.path != null); }\n    /**\n     *  Return the child for %%index%%.\n     */\n    deriveChild(_index) {\n        const index = (0, index_js_4.getNumber)(_index, \"index\");\n        (0, index_js_4.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) {\n                path += \"'\";\n            }\n        }\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);\n        const Ki = index_js_1.SigningKey.addPoints(IL, this.publicKey, true);\n        const address = (0, index_js_3.computeAddress)(Ki);\n        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.provider);\n    }\n    /**\n     *  Return the signer for %%path%% from this node.\n     */\n    derivePath(path) {\n        return derivePath(this, path);\n    }\n}\nexports.HDNodeVoidWallet = HDNodeVoidWallet;\n/*\nexport class HDNodeWalletManager {\n    #root: HDNodeWallet;\n\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\n        if (locale == null) { locale = LangEn.wordlist(); }\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\n    }\n\n    getSigner(index?: number): HDNodeWallet {\n        return this.#root.deriveChild((index == null) ? 0: index);\n    }\n}\n*/\n/**\n *  Returns the [[link-bip-32]] path for the account at %%index%%.\n *\n *  This is the pattern used by wallets like Ledger.\n *\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\n *  some software.\n */\nfunction getAccountPath(_index) {\n    const index = (0, index_js_4.getNumber)(_index, \"index\");\n    (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${index}'/0/0`;\n}\nexports.getAccountPath = getAccountPath;\n/**\n *  Returns the path using an alternative pattern for deriving accounts,\n *  at %%index%%.\n *\n *  This derivation path uses the //index// component rather than the\n *  //account// component to derive sequential accounts.\n *\n *  This is the pattern used by wallets like MetaMask.\n */\nfunction getIndexedAccountPath(_index) {\n    const index = (0, index_js_4.getNumber)(_index, \"index\");\n    (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${index}`;\n}\nexports.getIndexedAccountPath = getIndexedAccountPath;\n//# sourceMappingURL=hdwallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvaGR3YWxsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXVCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDhGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsOEZBQXlCO0FBQ3RELHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCxzQkFBc0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUM3QywyQkFBMkIsbUJBQU8sQ0FBQyw0RkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdKQUFnSixXQUFXO0FBQzNKO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLEVBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsRUFBRTtBQUNoRztBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJDQUEyQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixrQkFBa0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RiwwQkFBMEI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsMEJBQTBCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC9oZHdhbGxldC5qcz8xY2VlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJbmRleGVkQWNjb3VudFBhdGggPSBleHBvcnRzLmdldEFjY291bnRQYXRoID0gZXhwb3J0cy5IRE5vZGVWb2lkV2FsbGV0ID0gZXhwb3J0cy5IRE5vZGVXYWxsZXQgPSBleHBvcnRzLmRlZmF1bHRQYXRoID0gdm9pZCAwO1xuLyoqXG4gKiAgRXhwbGFpbiBIRCBXYWxsZXRzLi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkhEIFdhbGxldHMgIFtoZC13YWxsZXRzXVxuICovXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vcHJvdmlkZXJzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBsYW5nX2VuX2pzXzEgPSByZXF1aXJlKFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIik7XG5jb25zdCBiYXNlX3dhbGxldF9qc18xID0gcmVxdWlyZShcIi4vYmFzZS13YWxsZXQuanNcIik7XG5jb25zdCBtbmVtb25pY19qc18xID0gcmVxdWlyZShcIi4vbW5lbW9uaWMuanNcIik7XG5jb25zdCBqc29uX2tleXN0b3JlX2pzXzEgPSByZXF1aXJlKFwiLi9qc29uLWtleXN0b3JlLmpzXCIpO1xuLyoqXG4gKiAgVGhlIGRlZmF1bHQgZGVyaXZhdGlvbiBwYXRoIGZvciBFdGhlcmV1bSBIRCBOb2Rlcy4gKGkuZS4gYGBcIm0vNDQnLzYwJy8wJy8wLzBcImBgKVxuICovXG5leHBvcnRzLmRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XG4vLyBcIkJpdGNvaW4gc2VlZFwiXG5jb25zdCBNYXN0ZXJTZWNyZXQgPSBuZXcgVWludDhBcnJheShbNjYsIDEwNSwgMTE2LCA5OSwgMTExLCAxMDUsIDExMCwgMzIsIDExNSwgMTAxLCAxMDEsIDEwMF0pO1xuY29uc3QgSGFyZGVuZWRCaXQgPSAweDgwMDAwMDAwO1xuY29uc3QgTiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKTtcbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmZ1bmN0aW9uIHpwYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBOaWJibGVzW3ZhbHVlICUgMTZdICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSA9IE1hdGgudHJ1bmModmFsdWUgLyAxNik7XG4gICAgfVxuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgbGVuZ3RoICogMikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVuY29kZUJhc2U1OENoZWNrKF92YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKF92YWx1ZSk7XG4gICAgY29uc3QgY2hlY2sgPSAoMCwgaW5kZXhfanNfNC5kYXRhU2xpY2UpKCgwLCBpbmRleF9qc18xLnNoYTI1NikoKDAsIGluZGV4X2pzXzEuc2hhMjU2KSh2YWx1ZSkpLCAwLCA0KTtcbiAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc180LmNvbmNhdCkoW3ZhbHVlLCBjaGVja10pO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5lbmNvZGVCYXNlNTgpKGJ5dGVzKTtcbn1cbmNvbnN0IF9ndWFyZCA9IHt9O1xuZnVuY3Rpb24gc2VyX0koaW5kZXgsIGNoYWluQ29kZSwgcHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDM3KTtcbiAgICBpZiAoaW5kZXggJiBIYXJkZW5lZEJpdCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKHByaXZhdGVLZXkgIT0gbnVsbCwgXCJjYW5ub3QgZGVyaXZlIGNoaWxkIG9mIG5ldXRlcmVkIG5vZGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRlcml2ZUNoaWxkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERhdGEgPSAweDAwIHx8IHNlcl8yNTYoa19wYXIpXG4gICAgICAgIGRhdGEuc2V0KCgwLCBpbmRleF9qc180LmdldEJ5dGVzKShwcml2YXRlS2V5KSwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxuICAgICAgICBkYXRhLnNldCgoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykocHVibGljS2V5KSk7XG4gICAgfVxuICAgIC8vIERhdGEgKz0gc2VyXzMyKGkpXG4gICAgZm9yIChsZXQgaSA9IDI0OyBpID49IDA7IGkgLT0gOCkge1xuICAgICAgICBkYXRhWzMzICsgKGkgPj4gMyldID0gKChpbmRleCA+PiAoMjQgLSBpKSkgJiAweGZmKTtcbiAgICB9XG4gICAgY29uc3QgSSA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMS5jb21wdXRlSG1hYykoXCJzaGE1MTJcIiwgY2hhaW5Db2RlLCBkYXRhKSk7XG4gICAgcmV0dXJuIHsgSUw6IEkuc2xpY2UoMCwgMzIpLCBJUjogSS5zbGljZSgzMikgfTtcbn1cbmZ1bmN0aW9uIGRlcml2ZVBhdGgobm9kZSwgcGF0aCkge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoY29tcG9uZW50cy5sZW5ndGggPiAwLCBcImludmFsaWQgcGF0aFwiLCBcInBhdGhcIiwgcGF0aCk7XG4gICAgaWYgKGNvbXBvbmVudHNbMF0gPT09IFwibVwiKSB7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShub2RlLmRlcHRoID09PSAwLCBgY2Fubm90IGRlcml2ZSByb290IHBhdGggKGkuZS4gcGF0aCBzdGFydGluZyB3aXRoIFwibS9cIikgZm9yIGEgbm9kZSBhdCBub24temVybyBkZXB0aCAke25vZGUuZGVwdGh9YCwgXCJwYXRoXCIsIHBhdGgpO1xuICAgICAgICBjb21wb25lbnRzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBub2RlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJyQvKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQuc3Vic3RyaW5nKDAsIGNvbXBvbmVudC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIHBhdGggaW5kZXhcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRlcml2ZUNoaWxkKEhhcmRlbmVkQml0ICsgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGluZGV4IDwgSGFyZGVuZWRCaXQsIFwiaW52YWxpZCBwYXRoIGluZGV4XCIsIGBwYXRoWyR7aX1dYCwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kZXJpdmVDaGlsZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBwYXRoIGNvbXBvbmVudFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEFuICoqSEROb2RlV2FsbGV0KiogaXMgYSBbW1NpZ25lcl1dIGJhY2tlZCBieSB0aGUgcHJpdmF0ZSBrZXkgZGVyaXZlZFxuICogIGZyb20gYW4gSEQgTm9kZSB1c2luZyB0aGUgW1tsaW5rLWJpcC0zMl1dIHN0YW50YXJkLlxuICpcbiAqICBBbiBIRCBOb2RlIGZvcm1zIGEgaGllcmFyY2hhbCBzdHJ1Y3R1cmUgd2l0aCBlYWNoIEhEIE5vZGUgaGF2aW5nIGFcbiAqICBwcml2YXRlIGtleSBhbmQgdGhlIGFiaWxpdHkgdG8gZGVyaXZlIGNoaWxkIEhEIE5vZGVzLCBkZWZpbmVkIGJ5XG4gKiAgYSBwYXRoIGluZGljYXRpbmcgdGhlIGluZGV4IG9mIGVhY2ggY2hpbGQuXG4gKi9cbmNsYXNzIEhETm9kZVdhbGxldCBleHRlbmRzIGJhc2Vfd2FsbGV0X2pzXzEuQmFzZVdhbGxldCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgcHVibGljS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmluZ2VycHJpbnQuXG4gICAgICpcbiAgICAgKiAgQSBmaW5nZXJwcmludCBhbGxvd3MgcXVpY2sgcWF5IHRvIGRldGVjdCBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzLFxuICAgICAqICBidXQgZGV2ZWxvcGVycyBzaG91bGQgYmUgcHJlcGFyZWQgdG8gZGVhbCB3aXRoIGNvbGxpc2lvbnMgYXMgaXRcbiAgICAgKiAgaXMgb25seSA0IGJ5dGVzLlxuICAgICAqL1xuICAgIGZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFyZW50IGZpbmdlcnByaW50LlxuICAgICAqL1xuICAgIHBhcmVudEZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbW5lbW9uaWMgdXNlZCB0byBjcmVhdGUgdGhpcyBIRCBOb2RlLCBpZiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiAgU291cmNlcyBzdWNoIGFzIGV4dGVuZGVkIGtleXMgZG8gbm90IGVuY29kZSB0aGUgbW5lbW9uaWMsIGluXG4gICAgICogIHdoaWNoIGNhc2UgdGhpcyB3aWxsIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIG1uZW1vbmljO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxuICAgICAqICB0byBkZXJpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2hhaW5Db2RlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxuICAgICAqXG4gICAgICogIFNpbmNlIGV4dGVuZGVkIGtleXMgZG8gbm90IHByb3ZpZGVyIGZ1bGwgcGF0aCBkZXRhaWxzLCB0aGlzXG4gICAgICogIG1heSBiZSBgYG51bGxgYCwgaWYgaW5zdGFudGlhdGVkIGZyb20gYSBzb3VyY2UgdGhhdCBkb2VzIG5vdFxuICAgICAqICBlbm9jZGUgaXQuXG4gICAgICovXG4gICAgcGF0aDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoaWxkIGluZGV4IG9mIHRoaXMgd2FsbGV0LiBWYWx1ZXMgb3ZlciBgYDIgKlxcKiAzMWBgIGluZGljYXRlXG4gICAgICogIHRoZSBub2RlIGlzIGhhcmRlbmVkLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVwdGggb2YgdGhpcyB3YWxsZXQsIHdoaWNoIGlzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50c1xuICAgICAqICBpbiBpdHMgcGF0aC5cbiAgICAgKi9cbiAgICBkZXB0aDtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgc2lnbmluZ0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoLCBtbmVtb25pYywgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIkhETm9kZVdhbGxldFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwdWJsaWNLZXk6IHNpZ25pbmdLZXkuY29tcHJlc3NlZFB1YmxpY0tleSB9KTtcbiAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSAoMCwgaW5kZXhfanNfNC5kYXRhU2xpY2UpKCgwLCBpbmRleF9qc18xLnJpcGVtZDE2MCkoKDAsIGluZGV4X2pzXzEuc2hhMjU2KSh0aGlzLnB1YmxpY0tleSkpLCAwLCA0KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGhcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc180LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbW5lbW9uaWMgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCB0aGlzLnNpZ25pbmdLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnBhdGgsIHRoaXMuaW5kZXgsIHRoaXMuZGVwdGgsIHRoaXMubW5lbW9uaWMsIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgI2FjY291bnQoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLm1uZW1vbmljO1xuICAgICAgICBpZiAodGhpcy5wYXRoICYmIG0gJiYgbS53b3JkbGlzdC5sb2NhbGUgPT09IFwiZW5cIiAmJiBtLnBhc3N3b3JkID09PSBcIlwiKSB7XG4gICAgICAgICAgICBhY2NvdW50Lm1uZW1vbmljID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IFwiZW5cIixcbiAgICAgICAgICAgICAgICBlbnRyb3B5OiBtLmVudHJvcHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXB0ZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm9ncmVzc0NhbGxiYWNrJSUgaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlY2VpdmUgcGVyaW9kaWNcbiAgICAgKiAgdXBkYXRlcyBhcyB0aGUgZW5jcnlwdGlvbiBwcm9jZXNzIHByb2dyZXNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBlbmNyeXB0KHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCAoMCwganNvbl9rZXlzdG9yZV9qc18xLmVuY3J5cHRLZXlzdG9yZUpzb24pKHRoaXMuI2FjY291bnQoKSwgcGFzc3dvcmQsIHsgcHJvZ3Jlc3NDYWxsYmFjayB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGVuY3J5cHQpIGluc3RlYWQsXG4gICAgICogIHdoaWNoIGFsbG93cyBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIGtlZXAgdGhlIHVzZXIgaW5mb3JtZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2Qgd2lsbCBibG9jayB0aGUgZXZlbnQgbG9vcCAoZnJlZXppbmcgYWxsIFVJKSB1bnRpbFxuICAgICAqICBpdCBpcyBjb21wbGV0ZSwgd2hpY2ggbWF5IGJlIGEgbm9uLXRyaXZpYWwgZHVyYXRpb24uXG4gICAgICovXG4gICAgZW5jcnlwdFN5bmMocGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBqc29uX2tleXN0b3JlX2pzXzEuZW5jcnlwdEtleXN0b3JlSnNvblN5bmMpKHRoaXMuI2FjY291bnQoKSwgcGFzc3dvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV4dGVuZGVkIGtleS5cbiAgICAgKlxuICAgICAqICBUaGlzIGtleSB3aWxsIGJlZ2luIHdpdGggdGhlIHByZWZpeCBgYHhwcml2YGAgYW5kIGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHJlY29uc3RydWN0IHRoaXMgSEQgTm9kZSB0byBkZXJpdmUgaXRzIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGdldCBleHRlbmRlZEtleSgpIHtcbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHRoZSBtYWlubmV0IHZhbHVlcyBmb3Igbm93LCBidXQgaWYgYW55b25lIG5lZWRzXG4gICAgICAgIC8vIHRlc3RuZXQgdmFsdWVzLCBsZXQgbWUga25vdy4gSSBiZWxpZXZlIGN1cnJlbnQgc2VudGltZW50IGlzIHRoYXRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsd2F5cyB1c2UgbWFpbm5ldCwgYW5kIHVzZSBCSVAtNDQgdG8gZGVyaXZlIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vICAgLSBNYWlubmV0OiBwdWJsaWM9MHgwNDg4QjIxRSwgcHJpdmF0ZT0weDA0ODhBREU0XG4gICAgICAgIC8vICAgLSBUZXN0bmV0OiBwdWJsaWM9MHgwNDM1ODdDRiwgcHJpdmF0ZT0weDA0MzU4Mzk0XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soKDAsIGluZGV4X2pzXzQuY29uY2F0KShbXG4gICAgICAgICAgICBcIjB4MDQ4OEFERTRcIiwgenBhZCh0aGlzLmRlcHRoLCAxKSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgICAgIHpwYWQodGhpcy5pbmRleCwgNCksIHRoaXMuY2hhaW5Db2RlLFxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuY29uY2F0KShbXCIweDAwXCIsIHRoaXMucHJpdmF0ZUtleV0pXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHdhbGxldCBoYXMgYSBwYXRoLCBwcm92aWRpbmcgYSBUeXBlIEd1YXJkXG4gICAgICogIHRoYXQgdGhlIHBhdGggaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaGFzUGF0aCgpIHsgcmV0dXJuICh0aGlzLnBhdGggIT0gbnVsbCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldXRlcmVkIEhEIE5vZGUsIHdoaWNoIHJlbW92ZXMgdGhlIHByaXZhdGUgZGV0YWlsc1xuICAgICAqICBvZiBhbiBIRCBOb2RlLlxuICAgICAqXG4gICAgICogIEEgbmV1dGVyZWQgbm9kZSBoYXMgbm8gcHJpdmF0ZSBrZXksIGJ1dCBjYW4gYmUgdXNlZCB0byBkZXJpdmVcbiAgICAgKiAgY2hpbGQgYWRkcmVzc2VzIGFuZCBvdGhlciBwdWJsaWMgZGF0YSBhYm91dCB0aGUgSEQgTm9kZS5cbiAgICAgKi9cbiAgICBuZXV0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsIHRoaXMuYWRkcmVzcywgdGhpcy5wdWJsaWNLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnBhdGgsIHRoaXMuaW5kZXgsIHRoaXMuZGVwdGgsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBjaGlsZCBmb3IgJSVpbmRleCUlLlxuICAgICAqL1xuICAgIGRlcml2ZUNoaWxkKF9pbmRleCkge1xuICAgICAgICBjb25zdCBpbmRleCA9ICgwLCBpbmRleF9qc180LmdldE51bWJlcikoX2luZGV4LCBcImluZGV4XCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoaW5kZXggPD0gMHhmZmZmZmZmZiwgXCJpbnZhbGlkIGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICAvLyBCYXNlIHBhdGhcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoICs9IFwiL1wiICsgKGluZGV4ICYgfkhhcmRlbmVkQml0KTtcbiAgICAgICAgICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IElSLCBJTCB9ID0gc2VyX0koaW5kZXgsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnB1YmxpY0tleSwgdGhpcy5wcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3Qga2kgPSBuZXcgaW5kZXhfanNfMS5TaWduaW5nS2V5KCgwLCBpbmRleF9qc180LnRvQmVIZXgpKCgoMCwgaW5kZXhfanNfNC50b0JpZ0ludCkoSUwpICsgQmlnSW50KHRoaXMucHJpdmF0ZUtleSkpICUgTiwgMzIpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBraSwgdGhpcy5maW5nZXJwcmludCwgKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMubW5lbW9uaWMsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBIRE5vZGUgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG4gICAgc3RhdGljICNmcm9tU2VlZChfc2VlZCwgbW5lbW9uaWMpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc180LmlzQnl0ZXNMaWtlKShfc2VlZCksIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIGNvbnN0IHNlZWQgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoX3NlZWQsIFwic2VlZFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHNlZWQubGVuZ3RoID49IDE2ICYmIHNlZWQubGVuZ3RoIDw9IDY0LCBcImludmFsaWQgc2VlZFwiLCBcInNlZWRcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICBjb25zdCBJID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18xLmNvbXB1dGVIbWFjKShcInNoYTUxMlwiLCBNYXN0ZXJTZWNyZXQsIHNlZWQpKTtcbiAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9IG5ldyBpbmRleF9qc18xLlNpZ25pbmdLZXkoKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoSS5zbGljZSgwLCAzMikpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBzaWduaW5nS2V5LCBcIjB4MDAwMDAwMDBcIiwgKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoSS5zbGljZSgzMikpLCBcIm1cIiwgMCwgMCwgbW5lbW9uaWMsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBIRCBOb2RlIGZyb20gJSVleHRlbmRlZEtleSUlLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWV4dGVuZGVkS2V5JSUgd2lsbCBlaXRoZXIgaGF2ZSBhIHByZWZpeCBvciBgYHhwdWJgYCBvclxuICAgICAqICBgYHhwcml2YGAsIHJldHVybmluZyBhIG5ldXRlcmVkIEhEIE5vZGUgKFtbSEROb2RlVm9pZFdhbGxldF1dKVxuICAgICAqICBvciBmdWxsIEhEIE5vZGUgKFtbSEROb2RlV2FsbGV0KSByZXNwZWN0aXZlbHkuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEtleShleHRlbmRlZEtleSkge1xuICAgICAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc180LnRvQmVBcnJheSkoKDAsIGluZGV4X2pzXzQuZGVjb2RlQmFzZTU4KShleHRlbmRlZEtleSkpOyAvLyBAVE9ETzogcmVkYWN0XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShieXRlcy5sZW5ndGggPT09IDgyIHx8IGVuY29kZUJhc2U1OENoZWNrKGJ5dGVzLnNsaWNlKDAsIDc4KSkgPT09IGV4dGVuZGVkS2V5LCBcImludmFsaWQgZXh0ZW5kZWQga2V5XCIsIFwiZXh0ZW5kZWRLZXlcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIGNvbnN0IGRlcHRoID0gYnl0ZXNbNF07XG4gICAgICAgIGNvbnN0IHBhcmVudEZpbmdlcnByaW50ID0gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMuc2xpY2UoNSwgOSkpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KCgwLCBpbmRleF9qc180LmhleGxpZnkpKGJ5dGVzLnNsaWNlKDksIDEzKSkuc3Vic3RyaW5nKDIpLCAxNik7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9ICgwLCBpbmRleF9qc180LmhleGxpZnkpKGJ5dGVzLnNsaWNlKDEzLCA0NSkpO1xuICAgICAgICBjb25zdCBrZXkgPSBieXRlcy5zbGljZSg0NSwgNzgpO1xuICAgICAgICBzd2l0Y2ggKCgwLCBpbmRleF9qc180LmhleGxpZnkpKGJ5dGVzLnNsaWNlKDAsIDQpKSkge1xuICAgICAgICAgICAgLy8gUHVibGljIEtleVxuICAgICAgICAgICAgY2FzZSBcIjB4MDQ4OGIyMWVcIjpcbiAgICAgICAgICAgIGNhc2UgXCIweDA0MzU4N2NmXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsICgwLCBpbmRleF9qc18zLmNvbXB1dGVBZGRyZXNzKShwdWJsaWNLZXkpLCBwdWJsaWNLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIG51bGwsIGluZGV4LCBkZXB0aCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcml2YXRlIEtleVxuICAgICAgICAgICAgY2FzZSBcIjB4MDQ4OGFkZTRcIjpcbiAgICAgICAgICAgIGNhc2UgXCIweDA0MzU4Mzk0IFwiOlxuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlV2FsbGV0KF9ndWFyZCwgbmV3IGluZGV4X2pzXzEuU2lnbmluZ0tleShrZXkuc2xpY2UoMSkpLCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBudWxsLCBpbmRleCwgZGVwdGgsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGV4dGVuZGVkIGtleSBwcmVmaXhcIiwgXCJleHRlbmRlZEtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgcmFuZG9tIEhETm9kZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUmFuZG9tKHBhc3N3b3JkLCBwYXRoLCB3b3JkbGlzdCkge1xuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGggPSBleHBvcnRzLmRlZmF1bHRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IGxhbmdfZW5fanNfMS5MYW5nRW4ud29yZGxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtbmVtb25pYyA9IG1uZW1vbmljX2pzXzEuTW5lbW9uaWMuZnJvbUVudHJvcHkoKDAsIGluZGV4X2pzXzEucmFuZG9tQnl0ZXMpKDE2KSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYW4gSEQgTm9kZSBmcm9tICUlbW5lbW9uaWMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1uZW1vbmljKG1uZW1vbmljLCBwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcGF0aCA9IGV4cG9ydHMuZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGFuIEhEIE5vZGUgZnJvbSBhIG1uZW1vbmljICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgcGF0aCwgd29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoID0gZXhwb3J0cy5kZWZhdWx0UGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBsYW5nX2VuX2pzXzEuTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBtbmVtb25pY19qc18xLk1uZW1vbmljLmZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYW4gSEQgTm9kZSBmcm9tIGEgJSVzZWVkJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQoc2VlZCwgbnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5IRE5vZGVXYWxsZXQgPSBIRE5vZGVXYWxsZXQ7XG4vKipcbiAqICBBICoqSEROb2RlVm9pZFdhbGxldCoqIGNhbm5vdCBzaWduLCBidXQgcHJvdmlkZXMgYWNjZXNzIHRvXG4gKiAgdGhlIGNoaWxkcmVuIG5vZGVzIG9mIGEgW1tsaW5rLWJpcC0zMl1dIEhEIHdhbGxldCBhZGRyZXNzZXMuXG4gKlxuICogIFRoZSBjYW4gYmUgY3JlYXRlZCBieSB1c2luZyBhbiBleHRlbmRlZCBgYHhwdWJgYCBrZXkgdG9cbiAqICBbW0hETm9kZVdhbGxldF9mcm9tRXh0ZW5kZWRLZXldXSBvciBieVxuICogIFtudWV0ZXJpbmddKEhETm9kZVdhbGxldC1uZXV0ZXIpIGEgW1tIRE5vZGVXYWxsZXRdXS5cbiAqL1xuY2xhc3MgSEROb2RlVm9pZFdhbGxldCBleHRlbmRzIGluZGV4X2pzXzIuVm9pZFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgcHVibGljS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmluZ2VycHJpbnQuXG4gICAgICpcbiAgICAgKiAgQSBmaW5nZXJwcmludCBhbGxvd3MgcXVpY2sgcWF5IHRvIGRldGVjdCBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzLFxuICAgICAqICBidXQgZGV2ZWxvcGVycyBzaG91bGQgYmUgcHJlcGFyZWQgdG8gZGVhbCB3aXRoIGNvbGxpc2lvbnMgYXMgaXRcbiAgICAgKiAgaXMgb25seSA0IGJ5dGVzLlxuICAgICAqL1xuICAgIGZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFyZW50IG5vZGUgZmluZ2VycHJpbnQuXG4gICAgICovXG4gICAgcGFyZW50RmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbmNvZGUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGEgcHVibGljIGtleSB1c2VkXG4gICAgICogIHRvIGRlcml2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjaGFpbkNvZGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXJpdmF0aW9uIHBhdGggb2YgdGhpcyB3YWxsZXQuXG4gICAgICpcbiAgICAgKiAgU2luY2UgZXh0ZW5kZWQga2V5cyBkbyBub3QgcHJvdmlkZXIgZnVsbCBwYXRoIGRldGFpbHMsIHRoaXNcbiAgICAgKiAgbWF5IGJlIGBgbnVsbGBgLCBpZiBpbnN0YW50aWF0ZWQgZnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90XG4gICAgICogIGVub2NkZSBpdC5cbiAgICAgKi9cbiAgICBwYXRoO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hpbGQgaW5kZXggb2YgdGhpcyB3YWxsZXQuIFZhbHVlcyBvdmVyIGBgMiAqXFwqIDMxYGAgaW5kaWNhdGVcbiAgICAgKiAgdGhlIG5vZGUgaXMgaGFyZGVuZWQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gICAgICogIGluIGl0cyBwYXRoLlxuICAgICAqL1xuICAgIGRlcHRoO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBhZGRyZXNzLCBwdWJsaWNLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aCwgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIkhETm9kZVZvaWRXYWxsZXRcIik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgcHVibGljS2V5IH0pO1xuICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9ICgwLCBpbmRleF9qc180LmRhdGFTbGljZSkoKDAsIGluZGV4X2pzXzEucmlwZW1kMTYwKSgoMCwgaW5kZXhfanNfMS5zaGEyNTYpKHB1YmxpY0tleSkpLCAwLCA0KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgcHVibGljS2V5LCBmaW5nZXJwcmludCwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsIHRoaXMuYWRkcmVzcywgdGhpcy5wdWJsaWNLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnBhdGgsIHRoaXMuaW5kZXgsIHRoaXMuZGVwdGgsIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBleHRlbmRlZCBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBrZXkgd2lsbCBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGB4cHViYGAgYW5kIGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHJlY29uc3RydWN0IHRoaXMgbmV1dGVyZWQga2V5IHRvIGRlcml2ZSBpdHMgY2hpbGRyZW4gYWRkcmVzc2VzLlxuICAgICAqL1xuICAgIGdldCBleHRlbmRlZEtleSgpIHtcbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHRoZSBtYWlubmV0IHZhbHVlcyBmb3Igbm93LCBidXQgaWYgYW55b25lIG5lZWRzXG4gICAgICAgIC8vIHRlc3RuZXQgdmFsdWVzLCBsZXQgbWUga25vdy4gSSBiZWxpZXZlIGN1cnJlbnQgc2VudGltZW50IGlzIHRoYXRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsd2F5cyB1c2UgbWFpbm5ldCwgYW5kIHVzZSBCSVAtNDQgdG8gZGVyaXZlIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vICAgLSBNYWlubmV0OiBwdWJsaWM9MHgwNDg4QjIxRSwgcHJpdmF0ZT0weDA0ODhBREU0XG4gICAgICAgIC8vICAgLSBUZXN0bmV0OiBwdWJsaWM9MHgwNDM1ODdDRiwgcHJpdmF0ZT0weDA0MzU4Mzk0XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soKDAsIGluZGV4X2pzXzQuY29uY2F0KShbXG4gICAgICAgICAgICBcIjB4MDQ4OEIyMUVcIixcbiAgICAgICAgICAgIHpwYWQodGhpcy5kZXB0aCwgMSksXG4gICAgICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgenBhZCh0aGlzLmluZGV4LCA0KSxcbiAgICAgICAgICAgIHRoaXMuY2hhaW5Db2RlLFxuICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXksXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHdhbGxldCBoYXMgYSBwYXRoLCBwcm92aWRpbmcgYSBUeXBlIEd1YXJkXG4gICAgICogIHRoYXQgdGhlIHBhdGggaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaGFzUGF0aCgpIHsgcmV0dXJuICh0aGlzLnBhdGggIT0gbnVsbCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBjaGlsZCBmb3IgJSVpbmRleCUlLlxuICAgICAqL1xuICAgIGRlcml2ZUNoaWxkKF9pbmRleCkge1xuICAgICAgICBjb25zdCBpbmRleCA9ICgwLCBpbmRleF9qc180LmdldE51bWJlcikoX2luZGV4LCBcImluZGV4XCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoaW5kZXggPD0gMHhmZmZmZmZmZiwgXCJpbnZhbGlkIGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICAvLyBCYXNlIHBhdGhcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoICs9IFwiL1wiICsgKGluZGV4ICYgfkhhcmRlbmVkQml0KTtcbiAgICAgICAgICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IElSLCBJTCB9ID0gc2VyX0koaW5kZXgsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnB1YmxpY0tleSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IEtpID0gaW5kZXhfanNfMS5TaWduaW5nS2V5LmFkZFBvaW50cyhJTCwgdGhpcy5wdWJsaWNLZXksIHRydWUpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzMuY29tcHV0ZUFkZHJlc3MpKEtpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgYWRkcmVzcywgS2ksIHRoaXMuZmluZ2VycHJpbnQsICgwLCBpbmRleF9qc180LmhleGxpZnkpKElSKSwgcGF0aCwgaW5kZXgsIHRoaXMuZGVwdGggKyAxLCB0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2lnbmVyIGZvciAlJXBhdGglJSBmcm9tIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBkZXJpdmVQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGRlcml2ZVBhdGgodGhpcywgcGF0aCk7XG4gICAgfVxufVxuZXhwb3J0cy5IRE5vZGVWb2lkV2FsbGV0ID0gSEROb2RlVm9pZFdhbGxldDtcbi8qXG5leHBvcnQgY2xhc3MgSEROb2RlV2FsbGV0TWFuYWdlciB7XG4gICAgI3Jvb3Q6IEhETm9kZVdhbGxldDtcblxuICAgIGNvbnN0cnVjdG9yKHBocmFzZTogc3RyaW5nLCBwYXNzd29yZD86IG51bGwgfCBzdHJpbmcsIHBhdGg/OiBudWxsIHwgc3RyaW5nLCBsb2NhbGU/OiBudWxsIHwgV29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHsgcGFzc3dvcmQgPSBcIlwiOyB9XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHsgcGF0aCA9IFwibS80NCcvNjAnLzAnLzBcIjsgfVxuICAgICAgICBpZiAobG9jYWxlID09IG51bGwpIHsgbG9jYWxlID0gTGFuZ0VuLndvcmRsaXN0KCk7IH1cbiAgICAgICAgdGhpcy4jcm9vdCA9IEhETm9kZVdhbGxldC5mcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHBhdGgsIGxvY2FsZSk7XG4gICAgfVxuXG4gICAgZ2V0U2lnbmVyKGluZGV4PzogbnVtYmVyKTogSEROb2RlV2FsbGV0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Jvb3QuZGVyaXZlQ2hpbGQoKGluZGV4ID09IG51bGwpID8gMDogaW5kZXgpO1xuICAgIH1cbn1cbiovXG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstYmlwLTMyXV0gcGF0aCBmb3IgdGhlIGFjY291bnQgYXQgJSVpbmRleCUlLlxuICpcbiAqICBUaGlzIGlzIHRoZSBwYXR0ZXJuIHVzZWQgYnkgd2FsbGV0cyBsaWtlIExlZGdlci5cbiAqXG4gKiAgVGhlcmUgaXMgYWxzbyBhbiBbYWx0ZXJuYXRlIHBhdHRlcm5dKGdldEluZGV4ZWRBY2NvdW50UGF0aCkgdXNlZCBieVxuICogIHNvbWUgc29mdHdhcmUuXG4gKi9cbmZ1bmN0aW9uIGdldEFjY291bnRQYXRoKF9pbmRleCkge1xuICAgIGNvbnN0IGluZGV4ID0gKDAsIGluZGV4X2pzXzQuZ2V0TnVtYmVyKShfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvJHtpbmRleH0nLzAvMGA7XG59XG5leHBvcnRzLmdldEFjY291bnRQYXRoID0gZ2V0QWNjb3VudFBhdGg7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBwYXRoIHVzaW5nIGFuIGFsdGVybmF0aXZlIHBhdHRlcm4gZm9yIGRlcml2aW5nIGFjY291bnRzLFxuICogIGF0ICUlaW5kZXglJS5cbiAqXG4gKiAgVGhpcyBkZXJpdmF0aW9uIHBhdGggdXNlcyB0aGUgLy9pbmRleC8vIGNvbXBvbmVudCByYXRoZXIgdGhhbiB0aGVcbiAqICAvL2FjY291bnQvLyBjb21wb25lbnQgdG8gZGVyaXZlIHNlcXVlbnRpYWwgYWNjb3VudHMuXG4gKlxuICogIFRoaXMgaXMgdGhlIHBhdHRlcm4gdXNlZCBieSB3YWxsZXRzIGxpa2UgTWV0YU1hc2suXG4gKi9cbmZ1bmN0aW9uIGdldEluZGV4ZWRBY2NvdW50UGF0aChfaW5kZXgpIHtcbiAgICBjb25zdCBpbmRleCA9ICgwLCBpbmRleF9qc180LmdldE51bWJlcikoX2luZGV4LCBcImluZGV4XCIpO1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShpbmRleCA+PSAwICYmIGluZGV4IDwgSGFyZGVuZWRCaXQsIFwiaW52YWxpZCBhY2NvdW50IGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgIHJldHVybiBgbS80NCcvNjAnLzAnLzAvJHtpbmRleH1gO1xufVxuZXhwb3J0cy5nZXRJbmRleGVkQWNjb3VudFBhdGggPSBnZXRJbmRleGVkQWNjb3VudFBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZHdhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wallet/hdwallet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wallet/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  When interacting with Ethereum, it is necessary to use a private\n *  key authenticate actions by signing a payload.\n *\n *  Wallets are the simplest way to expose the concept of an\n *  //Externally Owner Account// (EOA) as it wraps a private key\n *  and supports high-level methods to sign common types of interaction\n *  and send transactions.\n *\n *  The class most developers will want to use is [[Wallet]], which\n *  can load a private key directly or from any common wallet format.\n *\n *  The [[HDNodeWallet]] can be used when it is necessary to access\n *  low-level details of how an HD wallets are derived, exported\n *  or imported.\n *\n *  @_section: api/wallet:Wallets  [about-wallets]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wallet = exports.Mnemonic = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.BaseWallet = void 0;\nvar base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js\");\nObject.defineProperty(exports, \"BaseWallet\", ({ enumerable: true, get: function () { return base_wallet_js_1.BaseWallet; } }));\nvar hdwallet_js_1 = __webpack_require__(/*! ./hdwallet.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/hdwallet.js\");\nObject.defineProperty(exports, \"defaultPath\", ({ enumerable: true, get: function () { return hdwallet_js_1.defaultPath; } }));\nObject.defineProperty(exports, \"getAccountPath\", ({ enumerable: true, get: function () { return hdwallet_js_1.getAccountPath; } }));\nObject.defineProperty(exports, \"getIndexedAccountPath\", ({ enumerable: true, get: function () { return hdwallet_js_1.getIndexedAccountPath; } }));\nObject.defineProperty(exports, \"HDNodeWallet\", ({ enumerable: true, get: function () { return hdwallet_js_1.HDNodeWallet; } }));\nObject.defineProperty(exports, \"HDNodeVoidWallet\", ({ enumerable: true, get: function () { return hdwallet_js_1.HDNodeVoidWallet; } }));\nvar json_crowdsale_js_1 = __webpack_require__(/*! ./json-crowdsale.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js\");\nObject.defineProperty(exports, \"isCrowdsaleJson\", ({ enumerable: true, get: function () { return json_crowdsale_js_1.isCrowdsaleJson; } }));\nObject.defineProperty(exports, \"decryptCrowdsaleJson\", ({ enumerable: true, get: function () { return json_crowdsale_js_1.decryptCrowdsaleJson; } }));\nvar json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js\");\nObject.defineProperty(exports, \"isKeystoreJson\", ({ enumerable: true, get: function () { return json_keystore_js_1.isKeystoreJson; } }));\nObject.defineProperty(exports, \"decryptKeystoreJsonSync\", ({ enumerable: true, get: function () { return json_keystore_js_1.decryptKeystoreJsonSync; } }));\nObject.defineProperty(exports, \"decryptKeystoreJson\", ({ enumerable: true, get: function () { return json_keystore_js_1.decryptKeystoreJson; } }));\nObject.defineProperty(exports, \"encryptKeystoreJson\", ({ enumerable: true, get: function () { return json_keystore_js_1.encryptKeystoreJson; } }));\nObject.defineProperty(exports, \"encryptKeystoreJsonSync\", ({ enumerable: true, get: function () { return json_keystore_js_1.encryptKeystoreJsonSync; } }));\nvar mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js\");\nObject.defineProperty(exports, \"Mnemonic\", ({ enumerable: true, get: function () { return mnemonic_js_1.Mnemonic; } }));\nvar wallet_js_1 = __webpack_require__(/*! ./wallet.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/wallet.js\");\nObject.defineProperty(exports, \"Wallet\", ({ enumerable: true, get: function () { return wallet_js_1.Wallet; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGdCQUFnQixHQUFHLCtCQUErQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLHNCQUFzQixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLDZCQUE2QixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQjtBQUN6WSx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDakQsOENBQTZDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzVILG9CQUFvQixtQkFBTyxDQUFDLGtGQUFlO0FBQzNDLCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCxrREFBaUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDakkseURBQXdELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQy9JLGdEQUErQyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM3SCxvREFBbUQsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDckksMEJBQTBCLG1CQUFPLENBQUMsOEZBQXFCO0FBQ3ZELG1EQUFrRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUN6SSx3REFBdUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDbkoseUJBQXlCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3JELGtEQUFpRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUN0SSwyREFBMEQsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDeEosdURBQXNELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQ2hKLHVEQUFzRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUNoSiwyREFBMEQsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDeEosb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWU7QUFDM0MsNENBQTJDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3JILGtCQUFrQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3ZDLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC9pbmRleC5qcz8wYzU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgV2hlbiBpbnRlcmFjdGluZyB3aXRoIEV0aGVyZXVtLCBpdCBpcyBuZWNlc3NhcnkgdG8gdXNlIGEgcHJpdmF0ZVxuICogIGtleSBhdXRoZW50aWNhdGUgYWN0aW9ucyBieSBzaWduaW5nIGEgcGF5bG9hZC5cbiAqXG4gKiAgV2FsbGV0cyBhcmUgdGhlIHNpbXBsZXN0IHdheSB0byBleHBvc2UgdGhlIGNvbmNlcHQgb2YgYW5cbiAqICAvL0V4dGVybmFsbHkgT3duZXIgQWNjb3VudC8vIChFT0EpIGFzIGl0IHdyYXBzIGEgcHJpdmF0ZSBrZXlcbiAqICBhbmQgc3VwcG9ydHMgaGlnaC1sZXZlbCBtZXRob2RzIHRvIHNpZ24gY29tbW9uIHR5cGVzIG9mIGludGVyYWN0aW9uXG4gKiAgYW5kIHNlbmQgdHJhbnNhY3Rpb25zLlxuICpcbiAqICBUaGUgY2xhc3MgbW9zdCBkZXZlbG9wZXJzIHdpbGwgd2FudCB0byB1c2UgaXMgW1tXYWxsZXRdXSwgd2hpY2hcbiAqICBjYW4gbG9hZCBhIHByaXZhdGUga2V5IGRpcmVjdGx5IG9yIGZyb20gYW55IGNvbW1vbiB3YWxsZXQgZm9ybWF0LlxuICpcbiAqICBUaGUgW1tIRE5vZGVXYWxsZXRdXSBjYW4gYmUgdXNlZCB3aGVuIGl0IGlzIG5lY2Vzc2FyeSB0byBhY2Nlc3NcbiAqICBsb3ctbGV2ZWwgZGV0YWlscyBvZiBob3cgYW4gSEQgd2FsbGV0cyBhcmUgZGVyaXZlZCwgZXhwb3J0ZWRcbiAqICBvciBpbXBvcnRlZC5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvd2FsbGV0OldhbGxldHMgIFthYm91dC13YWxsZXRzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhbGxldCA9IGV4cG9ydHMuTW5lbW9uaWMgPSBleHBvcnRzLmVuY3J5cHRLZXlzdG9yZUpzb25TeW5jID0gZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGV4cG9ydHMuaXNLZXlzdG9yZUpzb24gPSBleHBvcnRzLmRlY3J5cHRDcm93ZHNhbGVKc29uID0gZXhwb3J0cy5pc0Nyb3dkc2FsZUpzb24gPSBleHBvcnRzLkhETm9kZVZvaWRXYWxsZXQgPSBleHBvcnRzLkhETm9kZVdhbGxldCA9IGV4cG9ydHMuZ2V0SW5kZXhlZEFjY291bnRQYXRoID0gZXhwb3J0cy5nZXRBY2NvdW50UGF0aCA9IGV4cG9ydHMuZGVmYXVsdFBhdGggPSBleHBvcnRzLkJhc2VXYWxsZXQgPSB2b2lkIDA7XG52YXIgYmFzZV93YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2Utd2FsbGV0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVdhbGxldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV93YWxsZXRfanNfMS5CYXNlV2FsbGV0OyB9IH0pO1xudmFyIGhkd2FsbGV0X2pzXzEgPSByZXF1aXJlKFwiLi9oZHdhbGxldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZHdhbGxldF9qc18xLmRlZmF1bHRQYXRoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QWNjb3VudFBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhkd2FsbGV0X2pzXzEuZ2V0QWNjb3VudFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbmRleGVkQWNjb3VudFBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhkd2FsbGV0X2pzXzEuZ2V0SW5kZXhlZEFjY291bnRQYXRoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSEROb2RlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZHdhbGxldF9qc18xLkhETm9kZVdhbGxldDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhETm9kZVZvaWRXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhkd2FsbGV0X2pzXzEuSEROb2RlVm9pZFdhbGxldDsgfSB9KTtcbnZhciBqc29uX2Nyb3dkc2FsZV9qc18xID0gcmVxdWlyZShcIi4vanNvbi1jcm93ZHNhbGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Nyb3dkc2FsZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fY3Jvd2RzYWxlX2pzXzEuaXNDcm93ZHNhbGVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdENyb3dkc2FsZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fY3Jvd2RzYWxlX2pzXzEuZGVjcnlwdENyb3dkc2FsZUpzb247IH0gfSk7XG52YXIganNvbl9rZXlzdG9yZV9qc18xID0gcmVxdWlyZShcIi4vanNvbi1rZXlzdG9yZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzS2V5c3RvcmVKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2tleXN0b3JlX2pzXzEuaXNLZXlzdG9yZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNyeXB0S2V5c3RvcmVKc29uU3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9rZXlzdG9yZV9qc18xLmRlY3J5cHRLZXlzdG9yZUpzb25TeW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdEtleXN0b3JlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9rZXlzdG9yZV9qc18xLmRlY3J5cHRLZXlzdG9yZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNyeXB0S2V5c3RvcmVKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2tleXN0b3JlX2pzXzEuZW5jcnlwdEtleXN0b3JlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY3J5cHRLZXlzdG9yZUpzb25TeW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2tleXN0b3JlX2pzXzEuZW5jcnlwdEtleXN0b3JlSnNvblN5bmM7IH0gfSk7XG52YXIgbW5lbW9uaWNfanNfMSA9IHJlcXVpcmUoXCIuL21uZW1vbmljLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW5lbW9uaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1uZW1vbmljX2pzXzEuTW5lbW9uaWM7IH0gfSk7XG52YXIgd2FsbGV0X2pzXzEgPSByZXF1aXJlKFwiLi93YWxsZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdhbGxldF9qc18xLldhbGxldDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wallet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decryptCrowdsaleJson = exports.isCrowdsaleJson = void 0;\nconst aes_js_1 = __webpack_require__(/*! aes-js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js\");\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/utils.js\");\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */\nfunction isCrowdsaleJson(json) {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) {\n            return true;\n        }\n    }\n    catch (error) { }\n    return false;\n}\nexports.isCrowdsaleJson = isCrowdsaleJson;\n// See: https://github.com/ethereum/pyethsaletool\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */\nfunction decryptCrowdsaleJson(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    // Ethereum Address\n    const address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, \"ethaddr:string!\"));\n    // Encrypted Seed\n    const encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, \"encseed:string!\"));\n    (0, index_js_4.assertArgument)(encseed && (encseed.length % 16) === 0, \"invalid encseed\", \"json\", json);\n    const key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n    // Decrypt the seed\n    const aesCbc = new aes_js_1.CBC(key, iv);\n    const seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n    return { address, privateKey: (0, index_js_3.id)(seedHex) };\n}\nexports.decryptCrowdsaleJson = decryptCrowdsaleJson;\n//# sourceMappingURL=json-crowdsale.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvanNvbi1jcm93ZHNhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsdUJBQXVCO0FBQ3RELGlCQUFpQixtQkFBTyxDQUFDLHFGQUFRO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvanNvbi1jcm93ZHNhbGUuanM/MzY1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3dhbGxldDpKU09OIFdhbGxldHMgIFtqc29uLXdhbGxldHNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjcnlwdENyb3dkc2FsZUpzb24gPSBleHBvcnRzLmlzQ3Jvd2RzYWxlSnNvbiA9IHZvaWQgMDtcbmNvbnN0IGFlc19qc18xID0gcmVxdWlyZShcImFlcy1qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWpzb24lJSBpcyBhIHZhbGlkIEpTT04gQ3Jvd2RzYWxlIHdhbGxldC5cbiAqL1xuZnVuY3Rpb24gaXNDcm93ZHNhbGVKc29uKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgaWYgKGRhdGEuZW5jc2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzQ3Jvd2RzYWxlSnNvbiA9IGlzQ3Jvd2RzYWxlSnNvbjtcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3B5ZXRoc2FsZXRvb2xcbi8qKlxuICogIEJlZm9yZSBFdGhlcmV1bSBsYXVuY2hlZCwgaXQgd2FzIG5lY2Vzc2FyeSB0byBjcmVhdGUgYSB3YWxsZXRcbiAqICBmb3JtYXQgZm9yIGJhY2tlcnMgdG8gdXNlLCB3aGljaCB3b3VsZCBiZSB1c2VkIHRvIHJlY2VpdmUgZXRoZXJcbiAqICBhcyBhIHJld2FyZCBmb3IgY29udHJpYnV0aW5nIHRvIHRoZSBwcm9qZWN0LlxuICpcbiAqICBUaGUgW1tsaW5rLWNyb3dkc2FsZV1dIGZvcm1hdCBpcyBub3cgb2Jzb2xldGUsIGJ1dCBpdCBpcyBzdGlsbFxuICogIHVzZWZ1bCB0byBzdXBwb3J0IGFuZCB0aGUgYWRkaXRpb25hbCBjb2RlIGlzIGZhaXJseSB0cml2aWFsIGFzXG4gKiAgYWxsIHRoZSBwcmltaXRpdmVzIHJlcXVpcmVkIGFyZSB1c2VkIHRocm91Z2ggY29yZSBwb3J0aW9ucyBvZlxuICogIHRoZSBsaWJyYXJ5LlxuICovXG5mdW5jdGlvbiBkZWNyeXB0Q3Jvd2RzYWxlSnNvbihqc29uLCBfcGFzc3dvcmQpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBwYXNzd29yZCA9ICgwLCB1dGlsc19qc18xLmdldFBhc3N3b3JkKShfcGFzc3dvcmQpO1xuICAgIC8vIEV0aGVyZXVtIEFkZHJlc3NcbiAgICBjb25zdCBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykoKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJldGhhZGRyOnN0cmluZyFcIikpO1xuICAgIC8vIEVuY3J5cHRlZCBTZWVkXG4gICAgY29uc3QgZW5jc2VlZCA9ICgwLCB1dGlsc19qc18xLmxvb3NlQXJyYXlpZnkpKCgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiZW5jc2VlZDpzdHJpbmchXCIpKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZW5jc2VlZCAmJiAoZW5jc2VlZC5sZW5ndGggJSAxNikgPT09IDAsIFwiaW52YWxpZCBlbmNzZWVkXCIsIFwianNvblwiLCBqc29uKTtcbiAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzIucGJrZGYyKShwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xuICAgIGNvbnN0IGl2ID0gZW5jc2VlZC5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgZW5jcnlwdGVkU2VlZCA9IGVuY3NlZWQuc2xpY2UoMTYpO1xuICAgIC8vIERlY3J5cHQgdGhlIHNlZWRcbiAgICBjb25zdCBhZXNDYmMgPSBuZXcgYWVzX2pzXzEuQ0JDKGtleSwgaXYpO1xuICAgIGNvbnN0IHNlZWQgPSAoMCwgYWVzX2pzXzEucGtjczdTdHJpcCkoKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKGFlc0NiYy5kZWNyeXB0KGVuY3J5cHRlZFNlZWQpKSk7XG4gICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cbiAgICBsZXQgc2VlZEhleCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgYWRkcmVzcywgcHJpdmF0ZUtleTogKDAsIGluZGV4X2pzXzMuaWQpKHNlZWRIZXgpIH07XG59XG5leHBvcnRzLmRlY3J5cHRDcm93ZHNhbGVKc29uID0gZGVjcnlwdENyb3dkc2FsZUpzb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLWNyb3dkc2FsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/json-keystore.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;\nconst aes_js_1 = __webpack_require__(/*! aes-js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js\");\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/utils.js\");\nconst _version_js_1 = __webpack_require__(/*! ../_version.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/_version.js\");\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */\nfunction isKeystoreJson(json) {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version) : 0);\n        if (version === 3) {\n            return true;\n        }\n    }\n    catch (error) { }\n    return false;\n}\nexports.isKeystoreJson = isKeystoreJson;\nfunction decrypt(data, key, ciphertext) {\n    const cipher = (0, utils_js_1.spelunk)(data, \"crypto.cipher:string\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = (0, utils_js_1.spelunk)(data, \"crypto.cipherparams.iv:data!\");\n        const aesCtr = new aes_js_1.CTR(key, iv);\n        return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));\n    }\n    (0, index_js_4.assert)(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"decrypt\"\n    });\n}\nfunction getAccount(data, _key) {\n    const key = (0, index_js_4.getBytes)(_key);\n    const ciphertext = (0, utils_js_1.spelunk)(data, \"crypto.ciphertext:data!\");\n    const computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);\n    (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, \"crypto.mac:string!\").toLowerCase(), \"incorrect password\", \"password\", \"[ REDACTED ]\");\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n    const address = (0, index_js_3.computeAddress)(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (!check.startsWith(\"0x\")) {\n            check = \"0x\" + check;\n        }\n        (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n    }\n    const account = { address, privateKey };\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    const version = (0, utils_js_1.spelunk)(data, \"x-ethers.version:string\");\n    if (version === \"0.1\") {\n        const mnemonicKey = key.slice(32, 64);\n        const mnemonicCiphertext = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCiphertext:data!\");\n        const mnemonicIv = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCounter:data!\");\n        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n        account.mnemonic = {\n            path: ((0, utils_js_1.spelunk)(data, \"x-ethers.path:string\") || defaultPath),\n            locale: ((0, utils_js_1.spelunk)(data, \"x-ethers.locale:string\") || \"en\"),\n            entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n        };\n    }\n    return account;\n}\nfunction getDecryptKdfParams(data) {\n    const kdf = (0, utils_js_1.spelunk)(data, \"crypto.kdf:string\");\n    if (kdf && typeof (kdf) === \"string\") {\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const N = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.n:int!\");\n            const r = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.r:int!\");\n            const p = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.p:int!\");\n            // Make sure N is a power of 2\n            (0, index_js_4.assertArgument)(N > 0 && (N & (N - 1)) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n            (0, index_js_4.assertArgument)(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n            const dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n            return { name: \"scrypt\", salt, N, r, p, dkLen: 64 };\n        }\n        else if (kdf.toLowerCase() === \"pbkdf2\") {\n            const salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const prf = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.prf:string!\");\n            const algorithm = prf.split(\"-\").pop();\n            (0, index_js_4.assertArgument)(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n            const count = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.c:int!\");\n            const dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\n            return { name: \"pbkdf2\", salt, count, dkLen, algorithm };\n        }\n    }\n    (0, index_js_4.assertArgument)(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */\nfunction decryptKeystoreJsonSync(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);\n        return getAccount(data, key);\n    }\n    (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params });\n    const { salt, N, r, p, dkLen } = params;\n    const key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);\n    return getAccount(data, key);\n}\nexports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */\nasync function decryptKeystoreJson(json, _password, progress) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        if (progress) {\n            progress(0);\n            await stall(0);\n        }\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);\n        if (progress) {\n            progress(1);\n            await stall(0);\n        }\n        return getAccount(data, key);\n    }\n    (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params });\n    const { salt, N, r, p, dkLen } = params;\n    const key = await (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);\n    return getAccount(data, key);\n}\nexports.decryptKeystoreJson = decryptKeystoreJson;\nfunction getEncryptKdfParams(options) {\n    // Check/generate the salt\n    const salt = (options.salt != null) ? (0, index_js_4.getBytes)(options.salt, \"options.salt\") : (0, index_js_2.randomBytes)(32);\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) {\n            N = options.scrypt.N;\n        }\n        if (options.scrypt.r) {\n            r = options.scrypt.r;\n        }\n        if (options.scrypt.p) {\n            p = options.scrypt.p;\n        }\n    }\n    (0, index_js_4.assertArgument)(typeof (N) === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n    (0, index_js_4.assertArgument)(typeof (r) === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n    (0, index_js_4.assertArgument)(typeof (p) === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n    return { name: \"scrypt\", dkLen: 32, salt, N, r, p };\n}\nfunction _encryptKeystore(key, kdf, account, options) {\n    const privateKey = (0, index_js_4.getBytes)(account.privateKey, \"privateKey\");\n    // Override initialization vector\n    const iv = (options.iv != null) ? (0, index_js_4.getBytes)(options.iv, \"options.iv\") : (0, index_js_2.randomBytes)(16);\n    (0, index_js_4.assertArgument)(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n    // Override the uuid\n    const uuidRandom = (options.uuid != null) ? (0, index_js_4.getBytes)(options.uuid, \"options.uuid\") : (0, index_js_2.randomBytes)(16);\n    (0, index_js_4.assertArgument)(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32);\n    // Encrypt the private key\n    const aesCtr = new aes_js_1.CTR(derivedKey, iv);\n    const ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));\n    // Compute the message authentication code, used to check the password\n    const mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    const data = {\n        address: account.address.substring(2).toLowerCase(),\n        id: (0, index_js_4.uuidV4)(uuidRandom),\n        version: 3,\n        Crypto: {\n            cipher: \"aes-128-ctr\",\n            cipherparams: {\n                iv: (0, index_js_4.hexlify)(iv).substring(2),\n            },\n            ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),\n            kdf: \"scrypt\",\n            kdfparams: {\n                salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),\n                n: kdf.N,\n                dklen: 32,\n                p: kdf.p,\n                r: kdf.r\n            },\n            mac: mac.substring(2)\n        }\n    };\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (account.mnemonic) {\n        const client = (options.client != null) ? options.client : `ethers/${_version_js_1.version}`;\n        const path = account.mnemonic.path || defaultPath;\n        const locale = account.mnemonic.locale || \"en\";\n        const mnemonicKey = key.slice(32, 64);\n        const entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n        const mnemonicIv = (0, index_js_2.randomBytes)(16);\n        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n        const mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));\n        const now = new Date();\n        const timestamp = (now.getUTCFullYear() + \"-\" +\n            (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + \"-\" +\n            (0, utils_js_1.zpad)(now.getUTCDate(), 2) + \"T\" +\n            (0, utils_js_1.zpad)(now.getUTCHours(), 2) + \"-\" +\n            (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + \"-\" +\n            (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + \".0Z\");\n        const gethFilename = (\"UTC--\" + timestamp + \"--\" + data.address);\n        data[\"x-ethers\"] = {\n            client, gethFilename, path, locale,\n            mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),\n            mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),\n            version: \"0.1\"\n        };\n    }\n    return JSON.stringify(data);\n}\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */\nfunction encryptKeystoreJsonSync(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0, utils_js_1.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */\nasync function encryptKeystoreJson(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0, utils_js_1.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = await (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJson = encryptKeystoreJson;\n//# sourceMappingURL=json-keystore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvanNvbi1rZXlzdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLCtCQUErQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLHNCQUFzQjtBQUN0SixpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBUTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQW9CO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLDhGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsNEVBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixRQUFRO0FBQ3JHLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHNDQUFzQyxtQkFBbUIsWUFBWSxjQUFjO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsUUFBUTtBQUNyRyxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHNCQUFzQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC9qc29uLWtleXN0b3JlLmpzP2FkYTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBUaGUgSlNPTiBXYWxsZXQgZm9ybWF0cyBhbGxvdyBhIHNpbXBsZSB3YXkgdG8gc3RvcmUgdGhlIHByaXZhdGVcbiAqICBrZXlzIG5lZWRlZCBpbiBFdGhlcmV1bSBhbG9uZyB3aXRoIHJlbGF0ZWQgaW5mb3JtYXRpb24gYW5kIGFsbG93c1xuICogIGZvciBleHRlbnNpYmxlIGZvcm1zIG9mIGVuY3J5cHRpb24uXG4gKlxuICogIFRoZXNlIHV0aWxpdGllcyBmYWNpbGl0YXRlIGRlY3J5cHRpbmcgYW5kIGVuY3J5cHRpbmcgdGhlIG1vc3QgY29tbW9uXG4gKiAgSlNPTiBXYWxsZXQgZm9ybWF0cy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkpTT04gV2FsbGV0cyAgW2pzb24td2FsbGV0c11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uID0gZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGV4cG9ydHMuZGVjcnlwdEtleXN0b3JlSnNvbiA9IGV4cG9ydHMuZGVjcnlwdEtleXN0b3JlSnNvblN5bmMgPSBleHBvcnRzLmlzS2V5c3RvcmVKc29uID0gdm9pZCAwO1xuY29uc3QgYWVzX2pzXzEgPSByZXF1aXJlKFwiYWVzLWpzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IF92ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vX3ZlcnNpb24uanNcIik7XG5jb25zdCBkZWZhdWx0UGF0aCA9IFwibS80NCcvNjAnLzAnLzAvMFwiO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlanNvbiUlIGlzIGEgdmFsaWQgSlNPTiBLZXlzdG9yZSBXYWxsZXQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5c3RvcmVKc29uKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICgoZGF0YS52ZXJzaW9uICE9IG51bGwpID8gcGFyc2VJbnQoZGF0YS52ZXJzaW9uKSA6IDApO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzS2V5c3RvcmVKc29uID0gaXNLZXlzdG9yZUpzb247XG5mdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSwgY2lwaGVydGV4dCkge1xuICAgIGNvbnN0IGNpcGhlciA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmNpcGhlcjpzdHJpbmdcIik7XG4gICAgaWYgKGNpcGhlciA9PT0gXCJhZXMtMTI4LWN0clwiKSB7XG4gICAgICAgIGNvbnN0IGl2ID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8uY2lwaGVycGFyYW1zLml2OmRhdGEhXCIpO1xuICAgICAgICBjb25zdCBhZXNDdHIgPSBuZXcgYWVzX2pzXzEuQ1RSKGtleSwgaXYpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYWVzQ3RyLmRlY3J5cHQoY2lwaGVydGV4dCkpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIGNpcGhlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJkZWNyeXB0XCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFjY291bnQoZGF0YSwgX2tleSkge1xuICAgIGNvbnN0IGtleSA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShfa2V5KTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8uY2lwaGVydGV4dDpkYXRhIVwiKTtcbiAgICBjb25zdCBjb21wdXRlZE1BQyA9ICgwLCBpbmRleF9qc180LmhleGxpZnkpKCgwLCBpbmRleF9qc18yLmtlY2NhazI1NikoKDAsIGluZGV4X2pzXzQuY29uY2F0KShba2V5LnNsaWNlKDE2LCAzMiksIGNpcGhlcnRleHRdKSkpLnN1YnN0cmluZygyKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoY29tcHV0ZWRNQUMgPT09ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLm1hYzpzdHJpbmchXCIpLnRvTG93ZXJDYXNlKCksIFwiaW5jb3JyZWN0IHBhc3N3b3JkXCIsIFwicGFzc3dvcmRcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGRlY3J5cHQoZGF0YSwga2V5LnNsaWNlKDAsIDE2KSwgY2lwaGVydGV4dCk7XG4gICAgY29uc3QgYWRkcmVzcyA9ICgwLCBpbmRleF9qc18zLmNvbXB1dGVBZGRyZXNzKShwcml2YXRlS2V5KTtcbiAgICBpZiAoZGF0YS5hZGRyZXNzKSB7XG4gICAgICAgIGxldCBjaGVjayA9IGRhdGEuYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWNoZWNrLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgY2hlY2sgPSBcIjB4XCIgKyBjaGVjaztcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykoY2hlY2spID09PSBhZGRyZXNzLCBcImtleXN0b3JlIGFkZHJlc3MvcHJpdmF0ZUtleSBtaXNtYXRjaFwiLCBcImFkZHJlc3NcIiwgZGF0YS5hZGRyZXNzKTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzcywgcHJpdmF0ZUtleSB9O1xuICAgIC8vIFZlcnNpb24gMC4xIHgtZXRoZXJzIG1ldGFkYXRhIG11c3QgY29udGFpbiBhbiBlbmNyeXB0ZWQgbW5lbW9uaWMgcGhyYXNlXG4gICAgY29uc3QgdmVyc2lvbiA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwieC1ldGhlcnMudmVyc2lvbjpzdHJpbmdcIik7XG4gICAgaWYgKHZlcnNpb24gPT09IFwiMC4xXCIpIHtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJ4LWV0aGVycy5tbmVtb25pY0NpcGhlcnRleHQ6ZGF0YSFcIik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljSXYgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcIngtZXRoZXJzLm1uZW1vbmljQ291bnRlcjpkYXRhIVwiKTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNBZXNDdHIgPSBuZXcgYWVzX2pzXzEuQ1RSKG1uZW1vbmljS2V5LCBtbmVtb25pY0l2KTtcbiAgICAgICAgYWNjb3VudC5tbmVtb25pYyA9IHtcbiAgICAgICAgICAgIHBhdGg6ICgoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcIngtZXRoZXJzLnBhdGg6c3RyaW5nXCIpIHx8IGRlZmF1bHRQYXRoKSxcbiAgICAgICAgICAgIGxvY2FsZTogKCgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwieC1ldGhlcnMubG9jYWxlOnN0cmluZ1wiKSB8fCBcImVuXCIpLFxuICAgICAgICAgICAgZW50cm9weTogKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKG1uZW1vbmljQWVzQ3RyLmRlY3J5cHQobW5lbW9uaWNDaXBoZXJ0ZXh0KSkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50O1xufVxuZnVuY3Rpb24gZ2V0RGVjcnlwdEtkZlBhcmFtcyhkYXRhKSB7XG4gICAgY29uc3Qga2RmID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmOnN0cmluZ1wiKTtcbiAgICBpZiAoa2RmICYmIHR5cGVvZiAoa2RmKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwic2NyeXB0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuc2FsdDpkYXRhIVwiKTtcbiAgICAgICAgICAgIGNvbnN0IE4gPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMubjppbnQhXCIpO1xuICAgICAgICAgICAgY29uc3QgciA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5yOmludCFcIik7XG4gICAgICAgICAgICBjb25zdCBwID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnA6aW50IVwiKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBOIGlzIGEgcG93ZXIgb2YgMlxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKE4gPiAwICYmIChOICYgKE4gLSAxKSkgPT09IDAsIFwiaW52YWxpZCBrZGYuTlwiLCBcImtkZi5OXCIsIE4pO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHIgPiAwICYmIHAgPiAwLCBcImludmFsaWQga2RmXCIsIFwia2RmXCIsIGtkZik7XG4gICAgICAgICAgICBjb25zdCBka0xlbiA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5ka2xlbjppbnQhXCIpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGRrTGVuID09PSAzMiwgXCJpbnZhbGlkIGtkZi5ka2xlblwiLCBcImtkZi5kZmxlblwiLCBka0xlbik7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcInNjcnlwdFwiLCBzYWx0LCBOLCByLCBwLCBka0xlbjogNjQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJwYmtkZjJcIikge1xuICAgICAgICAgICAgY29uc3Qgc2FsdCA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5zYWx0OmRhdGEhXCIpO1xuICAgICAgICAgICAgY29uc3QgcHJmID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnByZjpzdHJpbmchXCIpO1xuICAgICAgICAgICAgY29uc3QgYWxnb3JpdGhtID0gcHJmLnNwbGl0KFwiLVwiKS5wb3AoKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShhbGdvcml0aG0gPT09IFwic2hhMjU2XCIgfHwgYWxnb3JpdGhtID09PSBcInNoYTUxMlwiLCBcImludmFsaWQga2RmLnBkZlwiLCBcImtkZi5wZGZcIiwgcHJmKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmM6aW50IVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRrTGVuID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmRrbGVuOmludCFcIik7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZGtMZW4gPT09IDMyLCBcImludmFsaWQga2RmLmRrbGVuXCIsIFwia2RmLmRrbGVuXCIsIGRrTGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwicGJrZGYyXCIsIHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIsIFwia2RmXCIsIGtkZik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCAlJWpzb24lJVxuICogIHVzaW5nICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGRlY3J5cHRLZXlzdG9yZUpzb24pXG4gKiAgaW5zdGVhZCwgd2hpY2ggYWxsb3dzIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8ga2VlcCB0aGUgdXNlciBpbmZvcm1lZFxuICogIGFzIHRvIHRoZSBkZWNyeXB0aW9uIHN0YXR1cy5cbiAqXG4gKiAgVGhpcyBtZXRob2Qgd2lsbCBibG9jayB0aGUgZXZlbnQgbG9vcCAoZnJlZXppbmcgYWxsIFVJKSB1bnRpbCBkZWNyeXB0aW9uXG4gKiAgaXMgY29tcGxldGUsIHdoaWNoIGNhbiB0YWtlIHF1aXRlIHNvbWUgdGltZSwgZGVwZW5kaW5nIG9uIHRoZSB3YWxsZXRcbiAqICBwYXJhbXRlcnMgYW5kIHBsYXRmb3JtLlxuICovXG5mdW5jdGlvbiBkZWNyeXB0S2V5c3RvcmVKc29uU3luYyhqc29uLCBfcGFzc3dvcmQpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBwYXNzd29yZCA9ICgwLCB1dGlsc19qc18xLmdldFBhc3N3b3JkKShfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGdldERlY3J5cHRLZGZQYXJhbXMoZGF0YSk7XG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XG4gICAgICAgIGNvbnN0IHsgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0gfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIGluZGV4X2pzXzIucGJrZGYyKShwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0pO1xuICAgICAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKHBhcmFtcy5uYW1lID09PSBcInNjcnlwdFwiLCBcImNhbm5vdCBiZSByZWFjaGVkXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IHBhcmFtcyB9KTtcbiAgICBjb25zdCB7IHNhbHQsIE4sIHIsIHAsIGRrTGVuIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qga2V5ID0gKDAsIGluZGV4X2pzXzIuc2NyeXB0U3luYykocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKTtcbiAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xufVxuZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jO1xuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dCgoKSA9PiB7IHJlc29sdmUoKTsgfSwgZHVyYXRpb24pOyB9KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIHRoZSBkZWNyeXB0ZWQgSlNPTiBLZXlzdG9yZSBXYWxsZXQgJSVqc29uJSUgdXNpbmcgdGhlXG4gKiAgJSVwYXNzd29yZCUlLlxuICpcbiAqICBJZiBwcm92aWRlZCwgJSVwcm9ncmVzcyUlIHdpbGwgYmUgY2FsbGVkIHBlcmlvZGljYWxseSBkdXJpbmcgdGhlXG4gKiAgZGVjcnB5dGlvbiB0byBwcm92aWRlIGZlZWRiYWNrLCBhbmQgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqICBgYGZhbHNlYGAgd2lsbCBoYWx0IGRlY3J5cHRpb24uXG4gKlxuICogIFRoZSAlJXByb2dyZXNzQ2FsbGJhY2slJSB3aWxsICoqYWx3YXlzKiogcmVjZWl2ZSBgYDBgYCBiZWZvcmVcbiAqICBkZWNyeXB0aW9uIGJlZ2lucyBhbmQgYGAxYGAgd2hlbiBjb21wbGV0ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdEtleXN0b3JlSnNvbihqc29uLCBfcGFzc3dvcmQsIHByb2dyZXNzKSB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgY29uc3QgcGFzc3dvcmQgPSAoMCwgdXRpbHNfanNfMS5nZXRQYXNzd29yZCkoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xuICAgIGlmIChwYXJhbXMubmFtZSA9PT0gXCJwYmtkZjJcIikge1xuICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHByb2dyZXNzKDApO1xuICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfMi5wYmtkZjIpKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSk7XG4gICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgcHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICBhd2FpdCBzdGFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKHBhcmFtcy5uYW1lID09PSBcInNjcnlwdFwiLCBcImNhbm5vdCBiZSByZWFjaGVkXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IHBhcmFtcyB9KTtcbiAgICBjb25zdCB7IHNhbHQsIE4sIHIsIHAsIGRrTGVuIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgKDAsIGluZGV4X2pzXzIuc2NyeXB0KShwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzKTtcbiAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xufVxuZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uID0gZGVjcnlwdEtleXN0b3JlSnNvbjtcbmZ1bmN0aW9uIGdldEVuY3J5cHRLZGZQYXJhbXMob3B0aW9ucykge1xuICAgIC8vIENoZWNrL2dlbmVyYXRlIHRoZSBzYWx0XG4gICAgY29uc3Qgc2FsdCA9IChvcHRpb25zLnNhbHQgIT0gbnVsbCkgPyAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykob3B0aW9ucy5zYWx0LCBcIm9wdGlvbnMuc2FsdFwiKSA6ICgwLCBpbmRleF9qc18yLnJhbmRvbUJ5dGVzKSgzMik7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIHNjcnlwdCBwYXNzd29yZC1iYXNlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXG4gICAgbGV0IE4gPSAoMSA8PCAxNyksIHIgPSA4LCBwID0gMTtcbiAgICBpZiAob3B0aW9ucy5zY3J5cHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0Lk4pIHtcbiAgICAgICAgICAgIE4gPSBvcHRpb25zLnNjcnlwdC5OO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5yKSB7XG4gICAgICAgICAgICByID0gb3B0aW9ucy5zY3J5cHQucjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucCkge1xuICAgICAgICAgICAgcCA9IG9wdGlvbnMuc2NyeXB0LnA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAoTikgPT09IFwibnVtYmVyXCIgJiYgTiA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoTikgJiYgKEJpZ0ludChOKSAmIEJpZ0ludChOIC0gMSkpID09PSBCaWdJbnQoMCksIFwiaW52YWxpZCBzY3J5cHQgTiBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLk5cIiwgTik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAocikgPT09IFwibnVtYmVyXCIgJiYgciA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIociksIFwiaW52YWxpZCBzY3J5cHQgciBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLnJcIiwgcik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAocCkgPT09IFwibnVtYmVyXCIgJiYgcCA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIocCksIFwiaW52YWxpZCBzY3J5cHQgcCBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLnBcIiwgcCk7XG4gICAgcmV0dXJuIHsgbmFtZTogXCJzY3J5cHRcIiwgZGtMZW46IDMyLCBzYWx0LCBOLCByLCBwIH07XG59XG5mdW5jdGlvbiBfZW5jcnlwdEtleXN0b3JlKGtleSwga2RmLCBhY2NvdW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShhY2NvdW50LnByaXZhdGVLZXksIFwicHJpdmF0ZUtleVwiKTtcbiAgICAvLyBPdmVycmlkZSBpbml0aWFsaXphdGlvbiB2ZWN0b3JcbiAgICBjb25zdCBpdiA9IChvcHRpb25zLml2ICE9IG51bGwpID8gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKG9wdGlvbnMuaXYsIFwib3B0aW9ucy5pdlwiKSA6ICgwLCBpbmRleF9qc18yLnJhbmRvbUJ5dGVzKSgxNik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGl2Lmxlbmd0aCA9PT0gMTYsIFwiaW52YWxpZCBvcHRpb25zLml2IGxlbmd0aFwiLCBcIm9wdGlvbnMuaXZcIiwgb3B0aW9ucy5pdik7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIHV1aWRcbiAgICBjb25zdCB1dWlkUmFuZG9tID0gKG9wdGlvbnMudXVpZCAhPSBudWxsKSA/ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShvcHRpb25zLnV1aWQsIFwib3B0aW9ucy51dWlkXCIpIDogKDAsIGluZGV4X2pzXzIucmFuZG9tQnl0ZXMpKDE2KTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkodXVpZFJhbmRvbS5sZW5ndGggPT09IDE2LCBcImludmFsaWQgb3B0aW9ucy51dWlkIGxlbmd0aFwiLCBcIm9wdGlvbnMudXVpZFwiLCBvcHRpb25zLml2KTtcbiAgICAvLyBUaGlzIHdpbGwgYmUgdXNlZCB0byBlbmNyeXB0IHRoZSB3YWxsZXQgKGFzIHBlciBXZWIzIHNlY3JldCBzdG9yYWdlKVxuICAgIC8vIC0gMzIgYnl0ZXMgICBBcyBub3JtYWwgZm9yIHRoZSBXZWIzIHNlY3JldCBzdG9yYWdlIChkZXJpdmVkS2V5LCBtYWNQcmVmaXgpXG4gICAgLy8gLSAzMiBieXRlcyAgIEFFUyBrZXkgdG8gZW5jcnlwdCBtbmVtb25pYyB3aXRoIChyZXF1aXJlZCBoZXJlIHRvIGJlIEV0aGVycyBXYWxsZXQpXG4gICAgY29uc3QgZGVyaXZlZEtleSA9IGtleS5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgbWFjUHJlZml4ID0ga2V5LnNsaWNlKDE2LCAzMik7XG4gICAgLy8gRW5jcnlwdCB0aGUgcHJpdmF0ZSBrZXlcbiAgICBjb25zdCBhZXNDdHIgPSBuZXcgYWVzX2pzXzEuQ1RSKGRlcml2ZWRLZXksIGl2KTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKGFlc0N0ci5lbmNyeXB0KHByaXZhdGVLZXkpKTtcbiAgICAvLyBDb21wdXRlIHRoZSBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUsIHVzZWQgdG8gY2hlY2sgdGhlIHBhc3N3b3JkXG4gICAgY29uc3QgbWFjID0gKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfNC5jb25jYXQpKFttYWNQcmVmaXgsIGNpcGhlcnRleHRdKSk7XG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1dlYjMtU2VjcmV0LVN0b3JhZ2UtRGVmaW5pdGlvblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgaWQ6ICgwLCBpbmRleF9qc180LnV1aWRWNCkodXVpZFJhbmRvbSksXG4gICAgICAgIHZlcnNpb246IDMsXG4gICAgICAgIENyeXB0bzoge1xuICAgICAgICAgICAgY2lwaGVyOiBcImFlcy0xMjgtY3RyXCIsXG4gICAgICAgICAgICBjaXBoZXJwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBpdjogKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoaXYpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0OiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShjaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICBrZGY6IFwic2NyeXB0XCIsXG4gICAgICAgICAgICBrZGZwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBzYWx0OiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShrZGYuc2FsdCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgICAgIG46IGtkZi5OLFxuICAgICAgICAgICAgICAgIGRrbGVuOiAzMixcbiAgICAgICAgICAgICAgICBwOiBrZGYucCxcbiAgICAgICAgICAgICAgICByOiBrZGYuclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hYzogbWFjLnN1YnN0cmluZygyKVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgbW5lbW9uaWMsIGVuY3J5cHQgaXQgaW50byB0aGUgSlNPTiB3YWxsZXRcbiAgICBpZiAoYWNjb3VudC5tbmVtb25pYykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSAob3B0aW9ucy5jbGllbnQgIT0gbnVsbCkgPyBvcHRpb25zLmNsaWVudCA6IGBldGhlcnMvJHtfdmVyc2lvbl9qc18xLnZlcnNpb259YDtcbiAgICAgICAgY29uc3QgcGF0aCA9IGFjY291bnQubW5lbW9uaWMucGF0aCB8fCBkZWZhdWx0UGF0aDtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gYWNjb3VudC5tbmVtb25pYy5sb2NhbGUgfHwgXCJlblwiO1xuICAgICAgICBjb25zdCBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKGFjY291bnQubW5lbW9uaWMuZW50cm9weSwgXCJhY2NvdW50Lm1uZW1vbmljLmVudHJvcHlcIik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljSXYgPSAoMCwgaW5kZXhfanNfMi5yYW5kb21CeXRlcykoMTYpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0Flc0N0ciA9IG5ldyBhZXNfanNfMS5DVFIobW5lbW9uaWNLZXksIG1uZW1vbmljSXYpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0NpcGhlcnRleHQgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IChub3cuZ2V0VVRDRnVsbFllYXIoKSArIFwiLVwiICtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLnpwYWQpKG5vdy5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS56cGFkKShub3cuZ2V0VVRDRGF0ZSgpLCAyKSArIFwiVFwiICtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLnpwYWQpKG5vdy5nZXRVVENIb3VycygpLCAyKSArIFwiLVwiICtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLnpwYWQpKG5vdy5nZXRVVENNaW51dGVzKCksIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuenBhZCkobm93LmdldFVUQ1NlY29uZHMoKSwgMikgKyBcIi4wWlwiKTtcbiAgICAgICAgY29uc3QgZ2V0aEZpbGVuYW1lID0gKFwiVVRDLS1cIiArIHRpbWVzdGFtcCArIFwiLS1cIiArIGRhdGEuYWRkcmVzcyk7XG4gICAgICAgIGRhdGFbXCJ4LWV0aGVyc1wiXSA9IHtcbiAgICAgICAgICAgIGNsaWVudCwgZ2V0aEZpbGVuYW1lLCBwYXRoLCBsb2NhbGUsXG4gICAgICAgICAgICBtbmVtb25pY0NvdW50ZXI6ICgwLCBpbmRleF9qc180LmhleGxpZnkpKG1uZW1vbmljSXYpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIG1uZW1vbmljQ2lwaGVydGV4dDogKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkobW5lbW9uaWNDaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICB2ZXJzaW9uOiBcIjAuMVwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgSlNPTiBLZXlzdG9yZSBXYWxsZXQgZm9yICUlYWNjb3VudCUlIGVuY3J5cHRlZCB3aXRoXG4gKiAgJSVwYXNzd29yZCUlLlxuICpcbiAqICBUaGUgJSVvcHRpb25zJSUgY2FuIGJlIHVzZWQgdG8gdHVuZSB0aGUgcGFzc3dvcmQtYmFzZWQga2V5XG4gKiAgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBleHBsaWNpdGx5IHNldCB0aGUgcmFuZG9tIHZhbHVlc1xuICogIHVzZWQuIEFueSBwcm92aWRlZCBbW1Byb2dyZXNzQ2FsbGJhY2tdXSBpcyBpZ25vcmQuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jKGFjY291bnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSAoMCwgdXRpbHNfanNfMS5nZXRQYXNzd29yZCkocGFzc3dvcmQpO1xuICAgIGNvbnN0IGtkZiA9IGdldEVuY3J5cHRLZGZQYXJhbXMob3B0aW9ucyk7XG4gICAgY29uc3Qga2V5ID0gKDAsIGluZGV4X2pzXzIuc2NyeXB0U3luYykocGFzc3dvcmRCeXRlcywga2RmLnNhbHQsIGtkZi5OLCBrZGYuciwga2RmLnAsIDY0KTtcbiAgICByZXR1cm4gX2VuY3J5cHRLZXlzdG9yZSgoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoa2V5KSwga2RmLCBhY2NvdW50LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZW5jcnlwdEtleXN0b3JlSnNvblN5bmMgPSBlbmNyeXB0S2V5c3RvcmVKc29uU3luYztcbi8qKlxuICogIFJlc29sdmVkIHRvIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCBmb3IgJSVhY2NvdW50JSUgZW5jcnlwdGVkXG4gKiAgd2l0aCAlJXBhc3N3b3JkJSUuXG4gKlxuICogIFRoZSAlJW9wdGlvbnMlJSBjYW4gYmUgdXNlZCB0byB0dW5lIHRoZSBwYXNzd29yZC1iYXNlZCBrZXlcbiAqICBkZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIGV4cGxpY2l0bHkgc2V0IHRoZSByYW5kb20gdmFsdWVzXG4gKiAgdXNlZCBhbmQgcHJvdmlkZSBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIHJlY2VpdmUgcGVyaW9kaWMgdXBkYXRlc1xuICogIG9uIHRoZSBjb21wbGV0aW9uIHN0YXR1cy4uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRLZXlzdG9yZUpzb24oYWNjb3VudCwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFzc3dvcmRCeXRlcyA9ICgwLCB1dGlsc19qc18xLmdldFBhc3N3b3JkKShwYXNzd29yZCk7XG4gICAgY29uc3Qga2RmID0gZ2V0RW5jcnlwdEtkZlBhcmFtcyhvcHRpb25zKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCAoMCwgaW5kZXhfanNfMi5zY3J5cHQpKHBhc3N3b3JkQnl0ZXMsIGtkZi5zYWx0LCBrZGYuTiwga2RmLnIsIGtkZi5wLCA2NCwgb3B0aW9ucy5wcm9ncmVzc0NhbGxiYWNrKTtcbiAgICByZXR1cm4gX2VuY3J5cHRLZXlzdG9yZSgoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoa2V5KSwga2RmLCBhY2NvdW50LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZW5jcnlwdEtleXN0b3JlSnNvbiA9IGVuY3J5cHRLZXlzdG9yZUpzb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLWtleXN0b3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/mnemonic.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mnemonic = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst lang_en_js_1 = __webpack_require__(/*! ../wordlists/lang-en.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\");\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return ((1 << bits) - 1) << (8 - bits) & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return ((1 << bits) - 1) & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    (0, index_js_2.assertNormalize)(\"NFKD\");\n    if (wordlist == null) {\n        wordlist = lang_en_js_1.LangEn.wordlist();\n    }\n    const words = wordlist.split(mnemonic);\n    (0, index_js_2.assertArgument)((words.length % 3) === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        (0, index_js_2.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n    const entropyBits = 32 * words.length / 3;\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n    const checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n    (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n    return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    (0, index_js_2.assertArgument)((entropy.length % 4) === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n    if (wordlist == null) {\n        wordlist = lang_en_js_1.LangEn.wordlist();\n    }\n    const indices = [0];\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n            // This byte will complete an 11-bit index\n        }\n        else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n    return wordlist.join(indices.map((index) => wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nclass Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    phrase;\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\n     */\n    password;\n    /**\n     *  The wordlist for this mnemonic.\n     */\n    wordlist;\n    /**\n     *  The underlying entropy which the mnemonic encodes.\n     */\n    entropy;\n    /**\n     *  @private\n     */\n    constructor(guard, entropy, phrase, password, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (wordlist == null) {\n            wordlist = lang_en_js_1.LangEn.wordlist();\n        }\n        (0, index_js_2.assertPrivate)(guard, _guard, \"Mnemonic\");\n        (0, index_js_2.defineProperties)(this, { phrase, password, wordlist, entropy });\n    }\n    /**\n     *  Returns the seed for the mnemonic.\n     */\n    computeSeed() {\n        const salt = (0, index_js_2.toUtf8Bytes)(\"mnemonic\" + this.password, \"NFKD\");\n        return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromPhrase(phrase, password, wordlist) {\n        // Normalize the case and space; throws if invalid\n        const entropy = mnemonicToEntropy(phrase, wordlist);\n        phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromEntropy(_entropy, password, wordlist) {\n        const entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n        const phrase = entropyToMnemonic(entropy, wordlist);\n        return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);\n    }\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */\n    static entropyToPhrase(_entropy, wordlist) {\n        const entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n        return entropyToMnemonic(entropy, wordlist);\n    }\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */\n    static phraseToEntropy(phrase, wordlist) {\n        return mnemonicToEntropy(phrase, wordlist);\n    }\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */\n    static isValidMnemonic(phrase, wordlist) {\n        try {\n            mnemonicToEntropy(phrase, wordlist);\n            return true;\n        }\n        catch (error) { }\n        return false;\n    }\n}\nexports.Mnemonic = Mnemonic;\n//# sourceMappingURL=mnemonic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvbW5lbW9uaWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsOEZBQXlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUZBQXFGLEVBQUU7QUFDdkYsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQ0FBcUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd2FsbGV0L21uZW1vbmljLmpzPzFlN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1uZW1vbmljID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgbGFuZ19lbl9qc18xID0gcmVxdWlyZShcIi4uL3dvcmRsaXN0cy9sYW5nLWVuLmpzXCIpO1xuLy8gUmV0dXJucyBhIGJ5dGUgd2l0aCB0aGUgTVNCIGJpdHMgc2V0XG5mdW5jdGlvbiBnZXRVcHBlck1hc2soYml0cykge1xuICAgIHJldHVybiAoKDEgPDwgYml0cykgLSAxKSA8PCAoOCAtIGJpdHMpICYgMHhmZjtcbn1cbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIExTQiBiaXRzIHNldFxuZnVuY3Rpb24gZ2V0TG93ZXJNYXNrKGJpdHMpIHtcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgJiAweGZmO1xufVxuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0Tm9ybWFsaXplKShcIk5GS0RcIik7XG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgd29yZGxpc3QgPSBsYW5nX2VuX2pzXzEuTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgfVxuICAgIGNvbnN0IHdvcmRzID0gd29yZGxpc3Quc3BsaXQobW5lbW9uaWMpO1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSgod29yZHMubGVuZ3RoICUgMykgPT09IDAgJiYgd29yZHMubGVuZ3RoID49IDEyICYmIHdvcmRzLmxlbmd0aCA8PSAyNCwgXCJpbnZhbGlkIG1uZW1vbmljIGxlbmd0aFwiLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoMTEgKiB3b3Jkcy5sZW5ndGggLyA4KSk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaW5kZXggPSB3b3JkbGlzdC5nZXRXb3JkSW5kZXgod29yZHNbaV0ubm9ybWFsaXplKFwiTkZLRFwiKSk7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShpbmRleCA+PSAwLCBgaW52YWxpZCBtbmVtb25pYyB3b3JkIGF0IGluZGV4ICR7aX1gLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICBmb3IgKGxldCBiaXQgPSAwOyBiaXQgPCAxMTsgYml0KyspIHtcbiAgICAgICAgICAgIGlmIChpbmRleCAmICgxIDw8ICgxMCAtIGJpdCkpKSB7XG4gICAgICAgICAgICAgICAgZW50cm9weVtvZmZzZXQgPj4gM10gfD0gKDEgPDwgKDcgLSAob2Zmc2V0ICUgOCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVudHJvcHlCaXRzID0gMzIgKiB3b3Jkcy5sZW5ndGggLyAzO1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IHdvcmRzLmxlbmd0aCAvIDM7XG4gICAgY29uc3QgY2hlY2tzdW1NYXNrID0gZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzEuc2hhMjU2KShlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpKVswXSAmIGNoZWNrc3VtTWFzaztcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoY2hlY2tzdW0gPT09IChlbnRyb3B5W2VudHJvcHkubGVuZ3RoIC0gMV0gJiBjaGVja3N1bU1hc2spLCBcImludmFsaWQgbW5lbW9uaWMgY2hlY2tzdW1cIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuaGV4bGlmeSkoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKTtcbn1cbmZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKChlbnRyb3B5Lmxlbmd0aCAlIDQpID09PSAwICYmIGVudHJvcHkubGVuZ3RoID49IDE2ICYmIGVudHJvcHkubGVuZ3RoIDw9IDMyLCBcImludmFsaWQgZW50cm9weSBzaXplXCIsIFwiZW50cm9weVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICB3b3JkbGlzdCA9IGxhbmdfZW5fanNfMS5MYW5nRW4ud29yZGxpc3QoKTtcbiAgICB9XG4gICAgY29uc3QgaW5kaWNlcyA9IFswXTtcbiAgICBsZXQgcmVtYWluaW5nQml0cyA9IDExO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDb25zdW1lIHRoZSB3aG9sZSBieXRlICh3aXRoIHN0aWxsIG1vcmUgdG8gZ28pXG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID4gOCkge1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSA4O1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV07XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgICAgICAvLyBUaGlzIGJ5dGUgd2lsbCBjb21wbGV0ZSBhbiAxMS1iaXQgaW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gcmVtYWluaW5nQml0cztcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldID4+ICg4IC0gcmVtYWluaW5nQml0cyk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCB3b3JkXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goZW50cm9weVtpXSAmIGdldExvd2VyTWFzayg4IC0gcmVtYWluaW5nQml0cykpO1xuICAgICAgICAgICAgcmVtYWluaW5nQml0cyArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIGNoZWNrc3VtIGJpdHNcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBwYXJzZUludCgoMCwgaW5kZXhfanNfMS5zaGEyNTYpKGVudHJvcHkpLnN1YnN0cmluZygyLCA0KSwgMTYpICYgZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG4gICAgLy8gU2hpZnQgdGhlIGNoZWNrc3VtIGludG8gdGhlIHdvcmQgaW5kaWNlc1xuICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gY2hlY2tzdW1CaXRzO1xuICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSAoY2hlY2tzdW0gPj4gKDggLSBjaGVja3N1bUJpdHMpKTtcbiAgICByZXR1cm4gd29yZGxpc3Quam9pbihpbmRpY2VzLm1hcCgoaW5kZXgpID0+IHdvcmRsaXN0LmdldFdvcmQoaW5kZXgpKSk7XG59XG5jb25zdCBfZ3VhcmQgPSB7fTtcbi8qKlxuICogIEEgKipNbmVtb25pYyoqIHdyYXBzIGFsbCBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvIGNvbXB1dGUgW1tsaW5rLWJpcC0zOV1dXG4gKiAgc2VlZHMgYW5kIGNvbnZlcnQgYmV0d2VlbiBwaHJhc2VzIGFuZCBlbnRyb3B5LlxuICovXG5jbGFzcyBNbmVtb25pYyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtbmVtb25pYyBwaHJhc2Ugb2YgMTIsIDE1LCAxOCwgMjEgb3IgMjQgd29yZHMuXG4gICAgICpcbiAgICAgKiAgVXNlIHRoZSBbW3dvcmRsaXN0XV0gYGBzcGxpdGBgIG1ldGhvZCB0byBnZXQgdGhlIGluZGl2aWR1YWwgd29yZHMuXG4gICAgICovXG4gICAgcGhyYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFzc3dvcmQgdXNlZCBmb3IgdGhpcyBtbmVtb25pYy4gSWYgbm8gcGFzc3dvcmQgaXMgdXNlZCB0aGlzXG4gICAgICogIGlzIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGFzIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBwYXNzd29yZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHdvcmRsaXN0IGZvciB0aGlzIG1uZW1vbmljLlxuICAgICAqL1xuICAgIHdvcmRsaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdW5kZXJseWluZyBlbnRyb3B5IHdoaWNoIHRoZSBtbmVtb25pYyBlbmNvZGVzLlxuICAgICAqL1xuICAgIGVudHJvcHk7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGVudHJvcHksIHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbGFuZ19lbl9qc18xLkxhbmdFbi53b3JkbGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydFByaXZhdGUpKGd1YXJkLCBfZ3VhcmQsIFwiTW5lbW9uaWNcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QsIGVudHJvcHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzZWVkIGZvciB0aGUgbW5lbW9uaWMuXG4gICAgICovXG4gICAgY29tcHV0ZVNlZWQoKSB7XG4gICAgICAgIGNvbnN0IHNhbHQgPSAoMCwgaW5kZXhfanNfMi50b1V0ZjhCeXRlcykoXCJtbmVtb25pY1wiICsgdGhpcy5wYXNzd29yZCwgXCJORktEXCIpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEucGJrZGYyKSgoMCwgaW5kZXhfanNfMi50b1V0ZjhCeXRlcykodGhpcy5waHJhc2UsIFwiTkZLRFwiKSwgc2FsdCwgMjA0OCwgNjQsIFwic2hhNTEyXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBNbmVtb25pYyBmb3IgdGhlICUlcGhyYXNlJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgJSVwYXNzd29yZCUlIGlzIHRoZSBlbXB0eSBzdHJpbmcgYW5kIHRoZSBkZWZhdWx0XG4gICAgICogIHdvcmRsaXN0IGlzIHRoZSBbRW5nbGlzaCB3b3JkbGlzdHNdKExhbmdFbikuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBjYXNlIGFuZCBzcGFjZTsgdGhyb3dzIGlmIGludmFsaWRcbiAgICAgICAgY29uc3QgZW50cm9weSA9IG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgICAgICBwaHJhc2UgPSBlbnRyb3B5VG9NbmVtb25pYygoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykoZW50cm9weSksIHdvcmRsaXN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNbmVtb25pYyhfZ3VhcmQsIGVudHJvcHksIHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKk1uZW1vbmljKiogZnJvbSB0aGUgJSVlbnRyb3B5JSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgJSVwYXNzd29yZCUlIGlzIHRoZSBlbXB0eSBzdHJpbmcgYW5kIHRoZSBkZWZhdWx0XG4gICAgICogIHdvcmRsaXN0IGlzIHRoZSBbRW5nbGlzaCB3b3JkbGlzdHNdKExhbmdFbikuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21FbnRyb3B5KF9lbnRyb3B5LCBwYXNzd29yZCwgd29yZGxpc3QpIHtcbiAgICAgICAgY29uc3QgZW50cm9weSA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKShfZW50cm9weSwgXCJlbnRyb3B5XCIpO1xuICAgICAgICBjb25zdCBwaHJhc2UgPSBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCk7XG4gICAgICAgIHJldHVybiBuZXcgTW5lbW9uaWMoX2d1YXJkLCAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShlbnRyb3B5KSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcGhyYXNlIGZvciAlJW1uZW1vbmljJSUuXG4gICAgICovXG4gICAgc3RhdGljIGVudHJvcHlUb1BocmFzZShfZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICAgICAgY29uc3QgZW50cm9weSA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKShfZW50cm9weSwgXCJlbnRyb3B5XCIpO1xuICAgICAgICByZXR1cm4gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgZW50cm9weSBmb3IgJSVwaHJhc2UlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGhyYXNlVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlcGhyYXNlJSUgaXMgYSB2YWxpZCBbW2xpbmstYmlwLTM5XV0gcGhyYXNlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2hlY2tzIGFsbCB0aGUgcHJvdmlkZWQgd29yZHMgYmVsb25nIHRvIHRoZSAlJXdvcmRsaXN0JSUsXG4gICAgICogIHRoYXQgdGhlIGxlbmd0aCBpcyB2YWxpZCBhbmQgdGhlIGNoZWNrc3VtIGlzIGNvcnJlY3QuXG4gICAgICovXG4gICAgc3RhdGljIGlzVmFsaWRNbmVtb25pYyhwaHJhc2UsIHdvcmRsaXN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtbmVtb25pY1RvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk1uZW1vbmljID0gTW5lbW9uaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tbmVtb25pYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wallet/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  @_ignore\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.spelunk = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nfunction looseArrayify(hexString) {\n    if (typeof (hexString) === \"string\" && !hexString.startsWith(\"0x\")) {\n        hexString = \"0x\" + hexString;\n    }\n    return (0, index_js_1.getBytesCopy)(hexString);\n}\nexports.looseArrayify = looseArrayify;\nfunction zpad(value, length) {\n    value = String(value);\n    while (value.length < length) {\n        value = '0' + value;\n    }\n    return value;\n}\nexports.zpad = zpad;\nfunction getPassword(password) {\n    if (typeof (password) === 'string') {\n        return (0, index_js_1.toUtf8Bytes)(password, \"NFKC\");\n    }\n    return (0, index_js_1.getBytesCopy)(password);\n}\nexports.getPassword = getPassword;\nfunction spelunk(object, _path) {\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n    (0, index_js_1.assertArgument)(match != null, \"invalid path\", \"path\", _path);\n    const path = match[1];\n    const type = match[3];\n    const reqd = (match[4] === \"!\");\n    let cur = object;\n    for (const comp of path.toLowerCase().split('.')) {\n        // Search for a child object with a case-insensitive matching key\n        if (Array.isArray(cur)) {\n            if (!comp.match(/^[0-9]+$/)) {\n                break;\n            }\n            cur = cur[parseInt(comp)];\n        }\n        else if (typeof (cur) === \"object\") {\n            let found = null;\n            for (const key in cur) {\n                if (key.toLowerCase() === comp) {\n                    found = cur[key];\n                    break;\n                }\n            }\n            cur = found;\n        }\n        else {\n            cur = null;\n        }\n        if (cur == null) {\n            break;\n        }\n    }\n    (0, index_js_1.assertArgument)(!reqd || cur != null, \"missing required value\", \"path\", path);\n    if (type && cur != null) {\n        if (type === \"int\") {\n            if (typeof (cur) === \"string\" && cur.match(/^-?[0-9]+$/)) {\n                return parseInt(cur);\n            }\n            else if (Number.isSafeInteger(cur)) {\n                return cur;\n            }\n        }\n        if (type === \"number\") {\n            if (typeof (cur) === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n                return parseFloat(cur);\n            }\n        }\n        if (type === \"data\") {\n            if (typeof (cur) === \"string\") {\n                return looseArrayify(cur);\n            }\n        }\n        if (type === \"array\" && Array.isArray(cur)) {\n            return cur;\n        }\n        if (type === typeof (cur)) {\n            return cur;\n        }\n        (0, index_js_1.assertArgument)(false, `wrong type found for ${type} `, \"path\", path);\n    }\n    return cur;\n}\nexports.spelunk = spelunk;\n/*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n/*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLG1CQUFtQixHQUFHLFlBQVksR0FBRyxxQkFBcUI7QUFDNUUsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC91dGlscy5qcz9kNWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zcGVsdW5rID0gZXhwb3J0cy5nZXRQYXNzd29yZCA9IGV4cG9ydHMuenBhZCA9IGV4cG9ydHMubG9vc2VBcnJheWlmeSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBsb29zZUFycmF5aWZ5KGhleFN0cmluZykge1xuICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09IFwic3RyaW5nXCIgJiYgIWhleFN0cmluZy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgaGV4U3RyaW5nID0gXCIweFwiICsgaGV4U3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KShoZXhTdHJpbmcpO1xufVxuZXhwb3J0cy5sb29zZUFycmF5aWZ5ID0gbG9vc2VBcnJheWlmeTtcbmZ1bmN0aW9uIHpwYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gJzAnICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuenBhZCA9IHpwYWQ7XG5mdW5jdGlvbiBnZXRQYXNzd29yZChwYXNzd29yZCkge1xuICAgIGlmICh0eXBlb2YgKHBhc3N3b3JkKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnRvVXRmOEJ5dGVzKShwYXNzd29yZCwgXCJORktDXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KShwYXNzd29yZCk7XG59XG5leHBvcnRzLmdldFBhc3N3b3JkID0gZ2V0UGFzc3dvcmQ7XG5mdW5jdGlvbiBzcGVsdW5rKG9iamVjdCwgX3BhdGgpIHtcbiAgICBjb25zdCBtYXRjaCA9IF9wYXRoLm1hdGNoKC9eKFthLXowLTkkXy4tXSopKDooW2Etel0rKSk/KCEpPyQvaSk7XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKG1hdGNoICE9IG51bGwsIFwiaW52YWxpZCBwYXRoXCIsIFwicGF0aFwiLCBfcGF0aCk7XG4gICAgY29uc3QgcGF0aCA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IHR5cGUgPSBtYXRjaFszXTtcbiAgICBjb25zdCByZXFkID0gKG1hdGNoWzRdID09PSBcIiFcIik7XG4gICAgbGV0IGN1ciA9IG9iamVjdDtcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcuJykpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICAgICAgaWYgKCFjb21wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBjdXJbcGFyc2VJbnQoY29tcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gY29tcCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGN1cltrZXldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1ciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ciA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoIXJlcWQgfHwgY3VyICE9IG51bGwsIFwibWlzc2luZyByZXF1aXJlZCB2YWx1ZVwiLCBcInBhdGhcIiwgcGF0aCk7XG4gICAgaWYgKHR5cGUgJiYgY3VyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cikgPT09IFwic3RyaW5nXCIgJiYgY3VyLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKGN1cikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiICYmIGN1ci5tYXRjaCgvXi0/WzAtOS5dKiQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlQXJyYXlpZnkoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gdHlwZW9mIChjdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYHdyb25nIHR5cGUgZm91bmQgZm9yICR7dHlwZX0gYCwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xufVxuZXhwb3J0cy5zcGVsdW5rID0gc3BlbHVuaztcbi8qXG5leHBvcnQgZnVuY3Rpb24gZm9sbG93KG9iamVjdDogYW55LCBwYXRoOiBzdHJpbmcpOiBudWxsIHwgc3RyaW5nIHtcbiAgICBsZXQgY3VycmVudENoaWxkID0gb2JqZWN0O1xuXG4gICAgZm9yIChjb25zdCBjb21wIG9mIHBhdGgudG9Mb3dlckNhc2UoKS5zcGxpdCgnLycpKSB7XG5cbiAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcbiAgICAgICAgbGV0IG1hdGNoaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXApIHtcbiAgICAgICAgICAgICAgICAgbWF0Y2hpbmdDaGlsZCA9IGN1cnJlbnRDaGlsZFtrZXldO1xuICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hpbmdDaGlsZCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIGN1cnJlbnRDaGlsZCA9IG1hdGNoaW5nQ2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRDaGlsZDtcbn1cblxuLy8gXCJwYXRoL3RvL3NvbWV0aGluZzp0eXBlIVwiXG5leHBvcnQgZnVuY3Rpb24gZm9sbG93UmVxdWlyZWQoZGF0YTogYW55LCBwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhbHVlID0gZm9sbG93KGRhdGEsIHBhdGgpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBgZGF0YTokeyBwYXRoIH1gLFxuICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbn1cbiovXG4vLyBTZWU6IGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dCAoU2VjdGlvbiA0LjQpXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHV1aWRWNChyYW5kb21CeXRlczogQnl0ZXNMaWtlKTogc3RyaW5nIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHJhbmRvbUJ5dGVzLCBcInJhbmRvbUJ5dGVzXCIpO1xuXG4gICAgLy8gU2VjdGlvbjogNC4xLjM6XG4gICAgLy8gLSB0aW1lX2hpX2FuZF92ZXJzaW9uWzEyOjE2XSA9IDBiMDEwMFxuICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwO1xuXG4gICAgLy8gU2VjdGlvbiA0LjRcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbNl0gPSAwYjBcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShieXRlcyk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgIHZhbHVlLnN1YnN0cmluZygyLCAxMCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDEwLCAxNCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDE0LCAxOCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDE4LCAyMiksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDIyLCAzNCksXG4gICAgXS5qb2luKFwiLVwiKTtcbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wallet/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wallet/wallet.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/wallet.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wallet = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js\");\nconst hdwallet_js_1 = __webpack_require__(/*! ./hdwallet.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/hdwallet.js\");\nconst json_crowdsale_js_1 = __webpack_require__(/*! ./json-crowdsale.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js\");\nconst json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js\");\nconst mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js\");\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n/**\n *  A **Wallet** manages a single private key which is used to sign\n *  transactions, messages and other common payloads.\n *\n *  This class is generally the main entry point for developers\n *  that wish to use a private key directly, as it can create\n *  instances from a large variety of common sources, including\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\n *  wallets.\n */\nclass Wallet extends base_wallet_js_1.BaseWallet {\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */\n    constructor(key, provider) {\n        if (typeof (key) === \"string\" && !key.startsWith(\"0x\")) {\n            key = \"0x\" + key;\n        }\n        let signingKey = (typeof (key) === \"string\") ? new index_js_1.SigningKey(key) : key;\n        super(signingKey, provider);\n    }\n    connect(provider) {\n        return new Wallet(this.signingKey, provider);\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    async encrypt(password, progressCallback) {\n        const account = { address: this.address, privateKey: this.privateKey };\n        return await (0, json_keystore_js_1.encryptKeystoreJson)(account, password, { progressCallback });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n    encryptSync(password) {\n        const account = { address: this.address, privateKey: this.privateKey };\n        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);\n    }\n    static #fromAccount(account) {\n        (0, index_js_2.assertArgument)(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n            const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);\n            const wallet = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n                return wallet;\n            }\n            console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n        }\n        const wallet = new Wallet(account.privateKey);\n        (0, index_js_2.assertArgument)(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n        return wallet;\n    }\n    /**\n     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\n     *  with %%password%%.\n     *\n     *  If %%progress%% is provided, it is called periodically during\n     *  decryption so that any UI can be updated.\n     */\n    static async fromEncryptedJson(json, password, progress) {\n        let account = null;\n        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {\n            account = await (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress);\n        }\n        else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {\n            if (progress) {\n                progress(0);\n                await stall(0);\n            }\n            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);\n            if (progress) {\n                progress(1);\n                await stall(0);\n            }\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\n     *\n     *  The [[fromEncryptedJson]] method is preferred, as this method\n     *  will lock up and freeze the UI during decryption, which may take\n     *  some time.\n     */\n    static fromEncryptedJsonSync(json, password) {\n        let account = null;\n        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {\n            account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);\n        }\n        else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {\n            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);\n        }\n        else {\n            (0, index_js_2.assertArgument)(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a new random [[HDNodeWallet]] using the available\n     *  [cryptographic random source](randomBytes).\n     *\n     *  If there is no crytographic random source, this will throw.\n     */\n    static createRandom(provider) {\n        const wallet = hdwallet_js_1.HDNodeWallet.createRandom();\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n    /**\n     *  Creates a [[HDNodeWallet]] for %%phrase%%.\n     */\n    static fromPhrase(phrase, provider) {\n        const wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n}\nexports.Wallet = Wallet;\n//# sourceMappingURL=wallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvd2FsbGV0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzlDLHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCxzQkFBc0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUM3Qyw0QkFBNEIsbUJBQU8sQ0FBQyw4RkFBcUI7QUFDekQsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0Esc0NBQXNDLG1CQUFtQixZQUFZLGNBQWM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0ZBQXNGLGtCQUFrQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC93YWxsZXQuanM/NjQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0ID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYmFzZV93YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2Utd2FsbGV0LmpzXCIpO1xuY29uc3QgaGR3YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL2hkd2FsbGV0LmpzXCIpO1xuY29uc3QganNvbl9jcm93ZHNhbGVfanNfMSA9IHJlcXVpcmUoXCIuL2pzb24tY3Jvd2RzYWxlLmpzXCIpO1xuY29uc3QganNvbl9rZXlzdG9yZV9qc18xID0gcmVxdWlyZShcIi4vanNvbi1rZXlzdG9yZS5qc1wiKTtcbmNvbnN0IG1uZW1vbmljX2pzXzEgPSByZXF1aXJlKFwiLi9tbmVtb25pYy5qc1wiKTtcbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQoKCkgPT4geyByZXNvbHZlKCk7IH0sIGR1cmF0aW9uKTsgfSk7XG59XG4vKipcbiAqICBBICoqV2FsbGV0KiogbWFuYWdlcyBhIHNpbmdsZSBwcml2YXRlIGtleSB3aGljaCBpcyB1c2VkIHRvIHNpZ25cbiAqICB0cmFuc2FjdGlvbnMsIG1lc3NhZ2VzIGFuZCBvdGhlciBjb21tb24gcGF5bG9hZHMuXG4gKlxuICogIFRoaXMgY2xhc3MgaXMgZ2VuZXJhbGx5IHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciBkZXZlbG9wZXJzXG4gKiAgdGhhdCB3aXNoIHRvIHVzZSBhIHByaXZhdGUga2V5IGRpcmVjdGx5LCBhcyBpdCBjYW4gY3JlYXRlXG4gKiAgaW5zdGFuY2VzIGZyb20gYSBsYXJnZSB2YXJpZXR5IG9mIGNvbW1vbiBzb3VyY2VzLCBpbmNsdWRpbmdcbiAqICByYXcgcHJpdmF0ZSBrZXksIFtbbGluay1iaXAtMzldXSBtbmVtb25pY3MgYW5kIGVuY3J5cHRlIEpTT05cbiAqICB3YWxsZXRzLlxuICovXG5jbGFzcyBXYWxsZXQgZXh0ZW5kcyBiYXNlX3dhbGxldF9qc18xLkJhc2VXYWxsZXQge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgd2FsbGV0IGZvciB0aGUgcHJpdmF0ZSAlJWtleSUlLCBvcHRpb25hbGx5IGNvbm5lY3RlZFxuICAgICAqICB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcm92aWRlcikge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiICYmICFrZXkuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICBrZXkgPSBcIjB4XCIgKyBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25pbmdLZXkgPSAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiKSA/IG5ldyBpbmRleF9qc18xLlNpZ25pbmdLZXkoa2V5KSA6IGtleTtcbiAgICAgICAgc3VwZXIoc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwdGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvZ3Jlc3NDYWxsYmFjayUlIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZWNlaXZlIHBlcmlvZGljXG4gICAgICogIHVwZGF0ZXMgYXMgdGhlIGVuY3J5cHRpb24gcHJvY2VzcyBwcm9ncmVzZXMuXG4gICAgICovXG4gICAgYXN5bmMgZW5jcnlwdChwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGpzb25fa2V5c3RvcmVfanNfMS5lbmNyeXB0S2V5c3RvcmVKc29uKShhY2NvdW50LCBwYXNzd29yZCwgeyBwcm9ncmVzc0NhbGxiYWNrIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXBlZCB3aXRoXG4gICAgICogICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmVyc2lvbl0oZW5jcnlwdCkgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggYWxsb3dzIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8ga2VlcCB0aGUgdXNlciBpbmZvcm1lZC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsXG4gICAgICogIGl0IGlzIGNvbXBsZXRlLCB3aGljaCBtYXkgYmUgYSBub24tdHJpdmlhbCBkdXJhdGlvbi5cbiAgICAgKi9cbiAgICBlbmNyeXB0U3luYyhwYXNzd29yZCkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xuICAgICAgICByZXR1cm4gKDAsIGpzb25fa2V5c3RvcmVfanNfMS5lbmNyeXB0S2V5c3RvcmVKc29uU3luYykoYWNjb3VudCwgcGFzc3dvcmQpO1xuICAgIH1cbiAgICBzdGF0aWMgI2Zyb21BY2NvdW50KGFjY291bnQpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGFjY291bnQsIFwiaW52YWxpZCBKU09OIHdhbGxldFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIGlmIChcIm1uZW1vbmljXCIgaW4gYWNjb3VudCAmJiBhY2NvdW50Lm1uZW1vbmljICYmIGFjY291bnQubW5lbW9uaWMubG9jYWxlID09PSBcImVuXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljID0gbW5lbW9uaWNfanNfMS5NbmVtb25pYy5mcm9tRW50cm9weShhY2NvdW50Lm1uZW1vbmljLmVudHJvcHkpO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gaGR3YWxsZXRfanNfMS5IRE5vZGVXYWxsZXQuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBhY2NvdW50Lm1uZW1vbmljLnBhdGgpO1xuICAgICAgICAgICAgaWYgKHdhbGxldC5hZGRyZXNzID09PSBhY2NvdW50LmFkZHJlc3MgJiYgd2FsbGV0LnByaXZhdGVLZXkgPT09IGFjY291bnQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IEpTT04gbWlzbWF0Y2ggYWRkcmVzcy9wcml2YXRlS2V5ICE9IG1uZW1vbmljOyBmYWxsYmFjayBvbnRvIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXQoYWNjb3VudC5wcml2YXRlS2V5KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKHdhbGxldC5hZGRyZXNzID09PSBhY2NvdW50LmFkZHJlc3MsIFwiYWRkcmVzcy9wcml2YXRlS2V5IG1pc21hdGNoXCIsIFwianNvblwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgKGFzeW5jaHJvbm91c2x5KSBhICoqV2FsbGV0KiogYnkgZGVjcnlwdGluZyB0aGUgJSVqc29uJSVcbiAgICAgKiAgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm9ncmVzcyUlIGlzIHByb3ZpZGVkLCBpdCBpcyBjYWxsZWQgcGVyaW9kaWNhbGx5IGR1cmluZ1xuICAgICAqICBkZWNyeXB0aW9uIHNvIHRoYXQgYW55IFVJIGNhbiBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tRW5jcnlwdGVkSnNvbihqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgbGV0IGFjY291bnQgPSBudWxsO1xuICAgICAgICBpZiAoKDAsIGpzb25fa2V5c3RvcmVfanNfMS5pc0tleXN0b3JlSnNvbikoanNvbikpIHtcbiAgICAgICAgICAgIGFjY291bnQgPSBhd2FpdCAoMCwganNvbl9rZXlzdG9yZV9qc18xLmRlY3J5cHRLZXlzdG9yZUpzb24pKGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGpzb25fY3Jvd2RzYWxlX2pzXzEuaXNDcm93ZHNhbGVKc29uKShqc29uKSkge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoMCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NvdW50ID0gKDAsIGpzb25fY3Jvd2RzYWxlX2pzXzEuZGVjcnlwdENyb3dkc2FsZUpzb24pKGpzb24sIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhICoqV2FsbGV0KiogYnkgZGVjcnlwdGluZyB0aGUgJSVqc29uJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIFtbZnJvbUVuY3J5cHRlZEpzb25dXSBtZXRob2QgaXMgcHJlZmVycmVkLCBhcyB0aGlzIG1ldGhvZFxuICAgICAqICB3aWxsIGxvY2sgdXAgYW5kIGZyZWV6ZSB0aGUgVUkgZHVyaW5nIGRlY3J5cHRpb24sIHdoaWNoIG1heSB0YWtlXG4gICAgICogIHNvbWUgdGltZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVuY3J5cHRlZEpzb25TeW5jKGpzb24sIHBhc3N3b3JkKSB7XG4gICAgICAgIGxldCBhY2NvdW50ID0gbnVsbDtcbiAgICAgICAgaWYgKCgwLCBqc29uX2tleXN0b3JlX2pzXzEuaXNLZXlzdG9yZUpzb24pKGpzb24pKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gKDAsIGpzb25fa2V5c3RvcmVfanNfMS5kZWNyeXB0S2V5c3RvcmVKc29uU3luYykoanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBqc29uX2Nyb3dkc2FsZV9qc18xLmlzQ3Jvd2RzYWxlSnNvbikoanNvbikpIHtcbiAgICAgICAgICAgIGFjY291bnQgPSAoMCwganNvbl9jcm93ZHNhbGVfanNfMS5kZWNyeXB0Q3Jvd2RzYWxlSnNvbikoanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgSlNPTiB3YWxsZXRcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gW1tIRE5vZGVXYWxsZXRdXSB1c2luZyB0aGUgYXZhaWxhYmxlXG4gICAgICogIFtjcnlwdG9ncmFwaGljIHJhbmRvbSBzb3VyY2VdKHJhbmRvbUJ5dGVzKS5cbiAgICAgKlxuICAgICAqICBJZiB0aGVyZSBpcyBubyBjcnl0b2dyYXBoaWMgcmFuZG9tIHNvdXJjZSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gaGR3YWxsZXRfanNfMS5IRE5vZGVXYWxsZXQuY3JlYXRlUmFuZG9tKCk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIFtbSEROb2RlV2FsbGV0XV0gZm9yICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBoZHdhbGxldF9qc18xLkhETm9kZVdhbGxldC5mcm9tUGhyYXNlKHBocmFzZSk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0ID0gV2FsbGV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wallet/wallet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/bit-reader.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/bit-reader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeBits = void 0;\nconst Base64 = \")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\";\n/**\n *  @_ignore\n */\nfunction decodeBits(width, data) {\n    const maxValue = (1 << width) - 1;\n    const result = [];\n    let accum = 0, bits = 0, flood = 0;\n    for (let i = 0; i < data.length; i++) {\n        // Accumulate 6 bits of data\n        accum = ((accum << 6) | Base64.indexOf(data[i]));\n        bits += 6;\n        // While we have enough for a word...\n        while (bits >= width) {\n            // ...read the word\n            const value = (accum >> (bits - width));\n            accum &= (1 << (bits - width)) - 1;\n            bits -= width;\n            // A value of 0 indicates we exceeded maxValue, it\n            // floods over into the next value\n            if (value === 0) {\n                flood += maxValue;\n            }\n            else {\n                result.push(value + flood);\n                flood = 0;\n            }\n        }\n    }\n    return result;\n}\nexports.decodeBits = decodeBits;\n//# sourceMappingURL=bit-reader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvYml0LXJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvYml0LXJlYWRlci5qcz9lYWFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVCaXRzID0gdm9pZCAwO1xuY29uc3QgQmFzZTY0ID0gXCIpIUAjJCVeJiooQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5mdW5jdGlvbiBkZWNvZGVCaXRzKHdpZHRoLCBkYXRhKSB7XG4gICAgY29uc3QgbWF4VmFsdWUgPSAoMSA8PCB3aWR0aCkgLSAxO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBhY2N1bSA9IDAsIGJpdHMgPSAwLCBmbG9vZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEFjY3VtdWxhdGUgNiBiaXRzIG9mIGRhdGFcbiAgICAgICAgYWNjdW0gPSAoKGFjY3VtIDw8IDYpIHwgQmFzZTY0LmluZGV4T2YoZGF0YVtpXSkpO1xuICAgICAgICBiaXRzICs9IDY7XG4gICAgICAgIC8vIFdoaWxlIHdlIGhhdmUgZW5vdWdoIGZvciBhIHdvcmQuLi5cbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gd2lkdGgpIHtcbiAgICAgICAgICAgIC8vIC4uLnJlYWQgdGhlIHdvcmRcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGFjY3VtID4+IChiaXRzIC0gd2lkdGgpKTtcbiAgICAgICAgICAgIGFjY3VtICY9ICgxIDw8IChiaXRzIC0gd2lkdGgpKSAtIDE7XG4gICAgICAgICAgICBiaXRzIC09IHdpZHRoO1xuICAgICAgICAgICAgLy8gQSB2YWx1ZSBvZiAwIGluZGljYXRlcyB3ZSBleGNlZWRlZCBtYXhWYWx1ZSwgaXRcbiAgICAgICAgICAgIC8vIGZsb29kcyBvdmVyIGludG8gdGhlIG5leHQgdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZsb29kICs9IG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUgKyBmbG9vZCk7XG4gICAgICAgICAgICAgICAgZmxvb2QgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlY29kZUJpdHMgPSBkZWNvZGVCaXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0LXJlYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/bit-reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeOwl = exports.decode = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst subsChrs = \" !#$%&'()*+,-./<=>?@[]^_`{|}~\";\nconst Word = /^[a-z]*$/i;\nfunction unfold(words, sep) {\n    let initial = 97;\n    return words.reduce((accum, word) => {\n        if (word === sep) {\n            initial++;\n        }\n        else if (word.match(Word)) {\n            accum.push(String.fromCharCode(initial) + word);\n        }\n        else {\n            initial = 97;\n            accum.push(word);\n        }\n        return accum;\n    }, []);\n}\n/**\n *  @_ignore\n */\nfunction decode(data, subs) {\n    // Replace all the substitutions with their expanded form\n    for (let i = subsChrs.length - 1; i >= 0; i--) {\n        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));\n    }\n    // Get all tle clumps; each suffix, first-increment and second-increment\n    const clumps = [];\n    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {\n        if (semi) {\n            for (let i = parseInt(semi); i >= 0; i--) {\n                clumps.push(\";\");\n            }\n        }\n        else {\n            clumps.push(item.toLowerCase());\n        }\n        return \"\";\n    });\n    /* c8 ignore start */\n    if (leftover) {\n        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);\n    }\n    /* c8 ignore stop */\n    return unfold(unfold(clumps, \";\"), \":\");\n}\nexports.decode = decode;\n/**\n *  @_ignore\n */\nfunction decodeOwl(data) {\n    (0, index_js_1.assertArgument)(data[0] === \"0\", \"unsupported auwl data\", \"data\", data);\n    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));\n}\nexports.decodeOwl = decodeOwl;\n//# sourceMappingURL=decode-owl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvZGVjb2RlLW93bC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxjQUFjO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyw0Q0FBNEMsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvZGVjb2RlLW93bC5qcz9jODc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVPd2wgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBzdWJzQ2hycyA9IFwiICEjJCUmJygpKissLS4vPD0+P0BbXV5fYHt8fX5cIjtcbmNvbnN0IFdvcmQgPSAvXlthLXpdKiQvaTtcbmZ1bmN0aW9uIHVuZm9sZCh3b3Jkcywgc2VwKSB7XG4gICAgbGV0IGluaXRpYWwgPSA5NztcbiAgICByZXR1cm4gd29yZHMucmVkdWNlKChhY2N1bSwgd29yZCkgPT4ge1xuICAgICAgICBpZiAod29yZCA9PT0gc2VwKSB7XG4gICAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod29yZC5tYXRjaChXb3JkKSkge1xuICAgICAgICAgICAgYWNjdW0ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGluaXRpYWwpICsgd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsID0gOTc7XG4gICAgICAgICAgICBhY2N1bS5wdXNoKHdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoZGF0YSwgc3Vicykge1xuICAgIC8vIFJlcGxhY2UgYWxsIHRoZSBzdWJzdGl0dXRpb25zIHdpdGggdGhlaXIgZXhwYW5kZWQgZm9ybVxuICAgIGZvciAobGV0IGkgPSBzdWJzQ2hycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBkYXRhID0gZGF0YS5zcGxpdChzdWJzQ2hyc1tpXSkuam9pbihzdWJzLnN1YnN0cmluZygyICogaSwgMiAqIGkgKyAyKSk7XG4gICAgfVxuICAgIC8vIEdldCBhbGwgdGxlIGNsdW1wczsgZWFjaCBzdWZmaXgsIGZpcnN0LWluY3JlbWVudCBhbmQgc2Vjb25kLWluY3JlbWVudFxuICAgIGNvbnN0IGNsdW1wcyA9IFtdO1xuICAgIGNvbnN0IGxlZnRvdmVyID0gZGF0YS5yZXBsYWNlKC8oOnwoWzAtOV0pfChbQS1aXVthLXpdKikpL2csIChhbGwsIGl0ZW0sIHNlbWksIHdvcmQpID0+IHtcbiAgICAgICAgaWYgKHNlbWkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZUludChzZW1pKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjbHVtcHMucHVzaChcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbHVtcHMucHVzaChpdGVtLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH0pO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChsZWZ0b3Zlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxlZnRvdmVyczogJHtKU09OLnN0cmluZ2lmeShsZWZ0b3Zlcil9YCk7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgcmV0dXJuIHVuZm9sZCh1bmZvbGQoY2x1bXBzLCBcIjtcIiksIFwiOlwiKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlT3dsKGRhdGEpIHtcbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZGF0YVswXSA9PT0gXCIwXCIsIFwidW5zdXBwb3J0ZWQgYXV3bCBkYXRhXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEgKyAyICogc3Vic0NocnMubGVuZ3RoKSwgZGF0YS5zdWJzdHJpbmcoMSwgMSArIDIgKiBzdWJzQ2hycy5sZW5ndGgpKTtcbn1cbmV4cG9ydHMuZGVjb2RlT3dsID0gZGVjb2RlT3dsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLW93bC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/decode-owla.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/decode-owla.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeOwlA = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst bit_reader_js_1 = __webpack_require__(/*! ./bit-reader.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/bit-reader.js\");\nconst decode_owl_js_1 = __webpack_require__(/*! ./decode-owl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js\");\n/**\n *  @_ignore\n */\nfunction decodeOwlA(data, accents) {\n    let words = (0, decode_owl_js_1.decodeOwl)(data).join(\",\");\n    // Inject the accents\n    accents.split(/,/g).forEach((accent) => {\n        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);\n        (0, index_js_1.assertArgument)(match !== null, \"internal error parsing accents\", \"accents\", accents);\n        let posOffset = 0;\n        const positions = (0, bit_reader_js_1.decodeBits)(parseInt(match[3]), match[4]);\n        const charCode = parseInt(match[2]);\n        const regex = new RegExp(`([${match[1]}])`, \"g\");\n        words = words.replace(regex, (all, letter) => {\n            const rem = --positions[posOffset];\n            if (rem === 0) {\n                letter = String.fromCharCode(letter.charCodeAt(0), charCode);\n                posOffset++;\n            }\n            return letter;\n        });\n    });\n    return words.split(\",\");\n}\nexports.decodeOwlA = decodeOwlA;\n//# sourceMappingURL=decode-owla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvZGVjb2RlLW93bGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyx3QkFBd0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMseUZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2RlY29kZS1vd2xhLmpzP2ExN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZU93bEEgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYml0X3JlYWRlcl9qc18xID0gcmVxdWlyZShcIi4vYml0LXJlYWRlci5qc1wiKTtcbmNvbnN0IGRlY29kZV9vd2xfanNfMSA9IHJlcXVpcmUoXCIuL2RlY29kZS1vd2wuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5mdW5jdGlvbiBkZWNvZGVPd2xBKGRhdGEsIGFjY2VudHMpIHtcbiAgICBsZXQgd29yZHMgPSAoMCwgZGVjb2RlX293bF9qc18xLmRlY29kZU93bCkoZGF0YSkuam9pbihcIixcIik7XG4gICAgLy8gSW5qZWN0IHRoZSBhY2NlbnRzXG4gICAgYWNjZW50cy5zcGxpdCgvLC9nKS5mb3JFYWNoKChhY2NlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBhY2NlbnQubWF0Y2goL14oW2Etel0qKShbMC05XSspKFswLTldKSguKikkLyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShtYXRjaCAhPT0gbnVsbCwgXCJpbnRlcm5hbCBlcnJvciBwYXJzaW5nIGFjY2VudHNcIiwgXCJhY2NlbnRzXCIsIGFjY2VudHMpO1xuICAgICAgICBsZXQgcG9zT2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gKDAsIGJpdF9yZWFkZXJfanNfMS5kZWNvZGVCaXRzKShwYXJzZUludChtYXRjaFszXSksIG1hdGNoWzRdKTtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFske21hdGNoWzFdfV0pYCwgXCJnXCIpO1xuICAgICAgICB3b3JkcyA9IHdvcmRzLnJlcGxhY2UocmVnZXgsIChhbGwsIGxldHRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtID0gLS1wb3NpdGlvbnNbcG9zT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChyZW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXR0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxldHRlci5jaGFyQ29kZUF0KDApLCBjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgcG9zT2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGV0dGVyO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gd29yZHMuc3BsaXQoXCIsXCIpO1xufVxuZXhwb3J0cy5kZWNvZGVPd2xBID0gZGVjb2RlT3dsQTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS1vd2xhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/decode-owla.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = void 0;\n/**\n *  A Wordlist is a set of 2048 words used to encode private keys\n *  (or other binary data) that is easier for humans to write down,\n *  transcribe and dictate.\n *\n *  The [[link-bip-39]] standard includes several checksum bits,\n *  depending on the size of the mnemonic phrase.\n *\n *  A mnemonic phrase may be 12, 15, 18, 21 or 24 words long. For\n *  most purposes 12 word mnemonics should be used, as including\n *  additional words increases the difficulty and potential for\n *  mistakes and does not offer any effective improvement on security.\n *\n *  There are a variety of [[link-bip39-wordlists]] for different\n *  languages, but for maximal compatibility, the\n *  [English Wordlist](LangEn) is recommended.\n *\n *  @_section: api/wordlists:Wordlists [about-wordlists]\n */\nvar wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\nObject.defineProperty(exports, \"Wordlist\", ({ enumerable: true, get: function () { return wordlist_js_1.Wordlist; } }));\nvar lang_en_js_1 = __webpack_require__(/*! ./lang-en.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\");\nObject.defineProperty(exports, \"LangEn\", ({ enumerable: true, get: function () { return lang_en_js_1.LangEn; } }));\nvar wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nObject.defineProperty(exports, \"WordlistOwl\", ({ enumerable: true, get: function () { return wordlist_owl_js_1.WordlistOwl; } }));\nvar wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js\");\nObject.defineProperty(exports, \"WordlistOwlA\", ({ enumerable: true, get: function () { return wordlist_owla_js_1.WordlistOwlA; } }));\nvar wordlists_js_1 = __webpack_require__(/*! ./wordlists.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlists.js\");\nObject.defineProperty(exports, \"wordlists\", ({ enumerable: true, get: function () { return wordlists_js_1.wordlists; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGdCQUFnQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFlO0FBQzNDLDRDQUEyQyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUNySCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBYztBQUN6QywwQ0FBeUMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDaEgsd0JBQXdCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ25ELCtDQUE4QyxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUMvSCx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBb0I7QUFDckQsZ0RBQStDLEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ2xJLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM3Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDeEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvaW5kZXguanM/MTVmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud29yZGxpc3RzID0gZXhwb3J0cy5Xb3JkbGlzdE93bEEgPSBleHBvcnRzLldvcmRsaXN0T3dsID0gZXhwb3J0cy5MYW5nRW4gPSBleHBvcnRzLldvcmRsaXN0ID0gdm9pZCAwO1xuLyoqXG4gKiAgQSBXb3JkbGlzdCBpcyBhIHNldCBvZiAyMDQ4IHdvcmRzIHVzZWQgdG8gZW5jb2RlIHByaXZhdGUga2V5c1xuICogIChvciBvdGhlciBiaW5hcnkgZGF0YSkgdGhhdCBpcyBlYXNpZXIgZm9yIGh1bWFucyB0byB3cml0ZSBkb3duLFxuICogIHRyYW5zY3JpYmUgYW5kIGRpY3RhdGUuXG4gKlxuICogIFRoZSBbW2xpbmstYmlwLTM5XV0gc3RhbmRhcmQgaW5jbHVkZXMgc2V2ZXJhbCBjaGVja3N1bSBiaXRzLFxuICogIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiB0aGUgbW5lbW9uaWMgcGhyYXNlLlxuICpcbiAqICBBIG1uZW1vbmljIHBocmFzZSBtYXkgYmUgMTIsIDE1LCAxOCwgMjEgb3IgMjQgd29yZHMgbG9uZy4gRm9yXG4gKiAgbW9zdCBwdXJwb3NlcyAxMiB3b3JkIG1uZW1vbmljcyBzaG91bGQgYmUgdXNlZCwgYXMgaW5jbHVkaW5nXG4gKiAgYWRkaXRpb25hbCB3b3JkcyBpbmNyZWFzZXMgdGhlIGRpZmZpY3VsdHkgYW5kIHBvdGVudGlhbCBmb3JcbiAqICBtaXN0YWtlcyBhbmQgZG9lcyBub3Qgb2ZmZXIgYW55IGVmZmVjdGl2ZSBpbXByb3ZlbWVudCBvbiBzZWN1cml0eS5cbiAqXG4gKiAgVGhlcmUgYXJlIGEgdmFyaWV0eSBvZiBbW2xpbmstYmlwMzktd29yZGxpc3RzXV0gZm9yIGRpZmZlcmVudFxuICogIGxhbmd1YWdlcywgYnV0IGZvciBtYXhpbWFsIGNvbXBhdGliaWxpdHksIHRoZVxuICogIFtFbmdsaXNoIFdvcmRsaXN0XShMYW5nRW4pIGlzIHJlY29tbWVuZGVkLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS93b3JkbGlzdHM6V29yZGxpc3RzIFthYm91dC13b3JkbGlzdHNdXG4gKi9cbnZhciB3b3JkbGlzdF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3QuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JkbGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd29yZGxpc3RfanNfMS5Xb3JkbGlzdDsgfSB9KTtcbnZhciBsYW5nX2VuX2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWVuLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGFuZ0VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nX2VuX2pzXzEuTGFuZ0VuOyB9IH0pO1xudmFyIHdvcmRsaXN0X293bF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29yZGxpc3RPd2xcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdvcmRsaXN0X293bF9qc18xLldvcmRsaXN0T3dsOyB9IH0pO1xudmFyIHdvcmRsaXN0X293bGFfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LW93bGEuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JkbGlzdE93bEFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdvcmRsaXN0X293bGFfanNfMS5Xb3JkbGlzdE93bEE7IH0gfSk7XG52YXIgd29yZGxpc3RzX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdHMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3b3JkbGlzdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdvcmRsaXN0c19qc18xLndvcmRsaXN0czsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-cz.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-cz.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangCz = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst words = \"0itatkastcenaovo$taouleraeki&chor*teci%enbalodaeladet'!Chn=0Di#%E%^1Resa2Rese3CeT'#0EjKohol0Pu)%0A&sDul#Ekdo)Ke)Ti#Ul|3}aOgan%0FaltI$@tPi,%TmaTronom0LasL{i#Ol0Tobus4Yl:B#}<CilCul#D!_Ge)GrHnoKterieLa^L{#LkonLon-LvanLzaMbusNkom!R[rR{RmanRokoRvaTer#TohVl&Zal#Zili#Zu#3D&RanSe^StieTonZin#ZmocZ)k3CyklD]Ft-KinyLan%Og,fO]gTvaZon2AhobytAt*/E/aEdu+EskIk!Iz&Ok|Oud Ud2B-BrDl.D~H!(JkotJ|K<ysLe$R>R'?TaUb_U/!U^U+Ur!Xer2A^v#Ambo,An#AtrEp)Ike)KoLohOnzOskevUn{#Usin#Z^Zy2Bl.Bn|})D _D#D'aF{Jar(Kv?LdokLvaN^NkrRzaTikVolZola3D+tL.T'#0Ukot:PartRev&3DrDu+J/JnLaLerLkemLn?N.Nn(N'#NtrumNz<StopisT#2AlupaAp`]Ar aA)E/t!EmieI/otIrurgL`Le[Lub M_Mu,ObotO/olOd[O+,Om=Op Oro[OvRapotRl RtRupTiv(Ud.Utn!V!Vil#V(Y[Y$!Yt 0Bu+Gare)H_&HlaNkotRkusSter&Ta%TrusZin>Z(2O&2KolivUv!4It_N(0Dn(Ke)KrPot0Ak~AlIkRkot2Kli$a:L-oRe[T_Tum1E,1B!a}'#Cib_Fic Fla%KlKr{Mokr!PreseRbyS#T-tiv3Kob,zKt|O^P]mSkSp+jV`]Vo/2AhaOuhoUhopis1Es0BroByt-C@t}ut DnesH+dHo^H,JemJn?Kl`KolaKt<Kum@tLarLevaL.MaM.ntMluv M'Nut P`PisPln PosudPr'odPu$ Raz R(RtSahSl'St!-SudSy)TazT-Tk~Uf!Utn!Voz%Z`uZn!Z<%2Aho)AkAm!ikAv>AzeDolObn(OgerieOzdSn(T Z(2B@}'noD-HaH'#S SnoT(0Oj?Or>2Nam :9O]gOnomie0EktronIpsa0AilIseO%P!ie2Izo^O/aOpejOs2EjEn%K<)Kymo0Ike)0F<ie0Olu%1Eku%KurzePed?P]zeP<tT,kt:C#Jf#Kul)N!ikN)zieRmacieV< Zo+3De,%J{onN#3Al#Gu,ntLozofLtrNan%N)Xa%0Ord1An_IrtOtila2NdSf<T[lT#Ton2Ak%Es#On)2KarNk%3Zi#:LejeRant3N{i#O]g3Lot.2Azu,Ejt2LemLfi$aTi#2AfAmofonAnu+EpIlOgOtes#2Ma:D?DrLaL@#N[NopisRfaRpu&V,n3Bk(J#lJnoJtmanK)rLmaM!omR>R&S]Zky3St<ik2Ad'#AsivkyAvaEd!EnO^v>OhOup(T!Ub.U/o)0AtO)Yz0IsOjivoOut0Bl.Boj}DinyDl!Dno)D|Jn(KejLin#L#LubMo+N [No,%RalR^RizontRkoRliv>RmonRn.RoskopR$voSpo^St.T'(U[UfUp!Us#V<2Ad[An?Av(Az^Bo+kD.D]D(N-Ob#Oma^OtOu^Oz@St#Ub(Yz!2B@(B~D[KotMrS aSto)0Ozd2Bn(D,ntGie&M&Sterik:2Yl#3Ned2O&0Uze0Un a0F-%Fla%KasoOva%Sp-%Tern{Vali^Ve$<Zer%3Onie:Blko})Ho^Kmi+K(L'>N)rRmarkRoSanSnoT#V<Zyk3Din>D+Dn!_HlanKotL@L oMn(NomP?S{erV Zd>Zero3NakNdyNo/Sk,Sto)Trn?Zva3En|1Gurt5R):Bar{B_Bin{}&D{Did]HanJakJu)KaoKtusLam aLhotyLibrLn(Me,MkolivM&Ni[lNoeNt<Pal.P_aP olaP#P+Po)PrPu$aPy[,Ram_Rot#RtonSaTa]gTed,U%UzaVa+cZaj#Ze)Ziv(2EkolivEsi0Dlub@MpRami#3No2A%kAdivoAmApotAsi#AunEcEn[Ep!Es~IdImaIs&Ob*kO#nOpaOubUb'&Us!Uzk(0EnIt!Otr0IhaOt0Al?Ber>B#BlihaBylaC*rH=J@>KosKtejlLapsLe^LizeLoMandoMe)MikMn!aMo,MpasMun aN!N%ptNd?N>NfeseNgresN.NkursN)ktNzervaPan>PieP~Pr'#Rb_R-t<Rmid]RoptevRpusRu&RytoRz{S!>St#T_T+)T*lUk!Up_&Us-Uz]VbojZaZ<oh2Ab?A/Aj.Al|AsopisAv!aEd EjcarEs[Eve)Ik{ItikIzeKav>Me+cMivoOcanOkOni#Op OupaOv#T-Uh`]Up?Ut(Vin#Y/+Yp)Y$alYt2Dlan#FrJn(KlaLaj^Li/L#Lom{Ltu,NaPodivuRtRz<Til0Al aAsin#E$<2No]gS_.Ta,T?T#T'>V`]:B,d<})nDn(IkKom>M_aMpaN'#S?SoStu,Tin#V.3B#CkdyD@Dn?D'#Dv.G@^GieG,%H%Hk(H~KtvarNo/odNtil#P@#Pid]T`]T>TmoTokruhVhartV a%Vobok3B,}ot#DojedDsk(H'.Jav>L-M{#NieN#No+umStop`T.T|5Bi$aDivodGi#GopedKal aK{Mc|P!aPu/RdSosTrU^lUhU#Usk!V>3Tiv(1Cer&CiferMpSkSt,%0I%2RaRi#S.:DamD]Gi$rHagonJ{-J _J< aKakK'?Kr_aL[L.L|Lv?Min#Nd+NkoRn(SakrSkotSopu$T?Tri#Tur aZan>ZivoZl Zur#2Lo[0}anikD a%D'.LasaL*nNtol#TlaTo^TrZe,3G,%H~Hu+K.KrofonL@>Lim{rL(Mi#Nc'&Ni[rNom{Nul(S#StrX|2Ad(HaH'.OkS!Uv 1I/Ohem0BilCn(D_#Dl [HylaKroL-ulaM@t#Nar/aNoklN$rumNt|NzunSazSkytStTiva%T<#Ty#U/aUdr(Zai#Z-Zol2Am<Av@>KevTvolaZ{Zut(0T _1DrcF]nL!MieN?S{Ta%ZeumZi#nt3Sliv>0Da:B*r!}yt!Da%Dbyt-DhozDobroDpisHlasHn!Hodi+H,d Iv aJedn*Ji$oJm=K]n Kon>Krm LevoMaz!Mluv Nom{rOkoOpakO$roP`!PevnoPln P~Pos+dPr(oRod RubyRy/]S` S-!S+poSt!TolikV@-Vr/Vzd<yZv!3Be}!CkyDa+koDb!DuhGa%H{Ho^J@JprveKlidLib(Mil(MocO/o)On#PokojR(RvSmyslS*l`Tv<UronV.Zvyk+3Co)JakKamKdyKlKte,kTro5C+hHav?M.%RaR-S _Sn(UzeVinyVo)Zd,5DaD+G{T Tn(Trie3Mfa:0AlArv AvaDivEcEhn!Ejm=Ez aHajo[Iln?Jasn J-tK]p La$L-Li[LohaLu^NosOh! Oj-OutRaz>R&Ru[RysSahSluhaS)r!UvVazVin VodVyk+Yv!_Z<0AsElEn Hl` Ho)H,&It~0BojByt}odCiz Ebr!Esl!Evzd!EzvaH`%Hod J{JinudKazK*p LivLu#Ml#Oln(P`PisPl=P<Pu$ Pyk!Raz#S*d StupSunTokTudVahaVe)Vol!V,%tZ&k1I&Sajd1LasNiskoRa^Roz Ryz-2ApEn?Li#NoOuzl OvyRasaResRs-RuhUpantUr#Us 0Ejn.Iz|0AkE+)Ez L`.L*v!LuvaYl0Ehdy1Ak|As-E,%I%Il(Is|O,Oz?RavduRoti1B al}e$rGieL?LojT_0A^}~I#IvoLavaLep Ln L' N'aO[Ol Pa+cT@T,haTu^Ty/Voj 0Epl IskOpRh!Rl(RokRubyV<1A~ArEsLivn O%1Id1Do[:}!_Ci@tD*/H<-KtLan^L>LivoLu[Mf+tMls-N@#Ni#N&N|N$voNtof+Pri#Rke)RodieR)Ru#Ry[Se#Siv aSt_#T@tTro&V*kZnehtZ*r-3C#DagogJs-K]LotonNal)Ndr-NzeRiskopRoStr(Tar^T?Tro+jVn.Xeso3Ani$aHaJav?K+KnikL.Ln(Lul#Nze)Pe)S!_Sto+Tev&Vn?V'ar2A%n)Ak!Am@Ane)A$i#At Avid]AzE/Em@oEn)EsEtivoEv_Iv!N NoO/aOd.Om[OutUkYn2Bav Byt}odC Ctiv>D!D%n Deps!Dh+dDiv Dkl`Dman DnikDo[Dpo,D,zD$!aDvodDzimEzieHan#Hnut#H'<HromaHybIn)Ji$#Jm=Kaz K+sKojKrokKu)KynLedneLib-Lk~LohaLynomMaluMi~Ml#MocM$aMys+tNe/!N<#Nur(P`!P_Pis-Pla/Pros Ps!PudR`%R%RodRu/aRyvS` SedSilaSkokSlan>S*d SpoluS)vaSud-SypTahT#nT+skTom-T,vaTupaTvo,U#zUtoUzdroVahaVidlaVlakVozVr/V$!VykVzde/Zd,vZem-Zn!-Z<Zv!2Ac|Ah<yAkti#A+sAot>Ap<-AseAv^IncipKnoObud O%ntoOdejOfeseOh,Oj-tO]m Omi+Onik!Op`OrokOs[OtonOut-OvazS#v#St@Udk(UtV-Voh<y0An>OvodTruh0Actvo0Ber)}DlKav>Kl.Kr+LtMpaNcP@SaSin#St.T|Ty#3Rami^SkT_::C-}otDia%Dn?DonFtGbyKe)K'.M@oMp*/NdeRa/R aS'&StrTo+$Zan%Zid]3Ag|Ak%CeptDakt<Fer@tF+xJnokKlamaK<dKrutKt<Pu)%VizeVmaVolverZerva3Sk|Ziko5Boti#Dokm@H'#K+KokoMan{oP'odPu/aRejsSolStl.Tmi$rTopedTun^Ub@#U/oUpU,V.Vn?Zb<Z/odZd!Zezn!Zhod%Zin#ZjezdZ#zZ]haZmarZp`Zru/ZsahZtokZumZvod5Bri#}`]Kav?Kopis3BaBol'}l(D]P`]T.Z(:Di$aH!KoM>Mizd!Mo)N #Rdin#San#T_ Z[Z@?0Or0H|1B,n#CeseD`]Dim@tD]Hn!Jm=Ke,K)Kun^KvojeM@oNoRvisS` Sho,SkokSl!St,SuvSyp!T[T.Tk!T~Trv!VerZ&m2O^R~0FonLn?R#Rot-RupTua%1AfandrAliskoAnz@AutEptikIcaL`[L@?LoLuzO[O#nOroRip)RzUp.V(Vr&0Abi#Adid]An.A$Avn(Ed|Ep>EvaEz.IbI&Izn?OnOup-OvoU/UhaUn%Up#Za0A,gdE)&Il$voL*vaOgR`RkRt#Ut-Ysl0AdAhaOb0Bo)}aD'#KolP#TvaUbojUc Ud%UhlasUl`Um,kUp,vaUsedUtokUvis{0Al'&As _IsLavOd-Oj@>OluOnz<Orn(Ou$aR/aU$ 1An^AzD%NaN>Ovn!P@StUb1An?Ar(aAti#Av[EhnoEz#OdolaO+kOpaOrnoOup!Ra/ResRh~RomRu&Ud&Upn?VolYk0Bj-tBtropy}arD(KnoNd!N=Rik!aR'.0AhAl$voEtrAt[Az-Is+It-Obo^Odid]Or#Rab2Kav#KotN-N'>P!Pk(R'(S_T(:B+t#Bu+H*nJemnoJfunJgaJ Jn(Kti#Mh+MponNc|N>NkerPe)V@.Z!_3}ni#HdyKut.LefonMno)Nd@%Ni$aN<P])P&PrveRapieRmos#Xtil3}oSkopisTu+k1Ad+cAn.0Ap#Esk!UkotUpa0El1A+)Pin#PolRzoUhaU+c2Ad?Akt<AmpAsaAverzaEf E$Ez<Hav.Hl.O/uOj?Os#Ou[P%P _Pk(Ub>U/l Uhl?UsV!2DyH~H(Nd,Ri$aR&jZemsko0ArohOr[Rd(Rz2GrKev:0Oh(OzeR!R*s-RusYt'&0HoTiv(0Iv 3R` 1Edn!I$ M=0Az!_Lidn Lon Otv Roj 0I%I)Ov 0Yv`]0Av If<maIk~1Ad~L!n Ly~Out!Rav 1AnAz 0Ed~Il|Mrt N`n N=Oud Tl!Tr~0Ah|K!Lum O~Op@>R*s 1Al Oln Oz'#3D,v ElEn.L.N!:GonL/aL*nNaN^lNil#RanRhanyR|1ElkuHod0Ova0DroGe)%J%Lbl*dL{rhL _LmocLry[Nk'Ran^RzeS_#SkrzeSn?SpoduS)Ter.Ver#3B,%}rDeoh,D.D+LaN?S{Tal aZeZ #0Ezd0L`Us0Aj#AkAs>EvoHk(IvN'#Oup!1Uc|Uk0DaDiv(Doz&kD$voJ@skyJ&JskoLantL[L LnoSk'#Zid]Z'&0Ravo1Ab>A%tAhA)Ba}o+kH!StvaTu+0Ad T*p Tup0Ip4Bav Br!}|D!D,Fot H+d!H~Hod H,d Hub Jasn J{Jm=K]p Kon!L-!Maz!Mez Miz{Mys+tNe/!Nik!Nut P`!Pl! P,v Pu$ Raz R'n!Rv!Sl' SokoS)v Su~Syp!Tas Tes!Tr! Vi~Vol!Vrh_Zdob Zn!0AduBud }op D<Du/Dy/!E$upH+demKazLyk!NikOr-P*,TahT-::993Lofon::Br!Byd+t}|DarmoDus F*k!Hlt Hod H,^Hy~J!>J{Ji$ K+p!K*p Lep Mez Mot!Mys+tNe/!Nik!Pl! Poj Ps!Raz S)v Su~Taj Temn Tk~Ujm=Val Ve+tVin Vol!Vrt!Zvon 0Av RusuUd|Yt-1A+#ArmaAtn(IvoOb RojVihYm`]0L@.ManM.Pt!Z`uZdola2At Lt~Lubo#Ot' Ru[0MaMn?0Emn 0Lam!Oum!R!#Umav#0AtoEh#O[OmO$Ozvyk0Ap|ArAt-IjeIz{Ocn Odr!Rzl.Ut|0AkAl(Am@!Ovu0B,z Tav Ub-Ufa+0Lod Omal RavaR( Rud#Rvu1A^An C`]N (NoOv&Y/l Zav(1I/aR! 0B'.Br0Ed~EnkuEs_aOnR!Uk'odYk\";\nconst checksum = \"0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-cz]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangCz extends wordlist_owl_js_1.WordlistOwl {\n    /**\n     *  Creates a new instance of the Czech language Wordlist.\n     *\n     *  Using the constructor should be unnecessary, instead use the\n     *  [[wordlist]] singleton method.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"cz\", words, checksum); }\n    /**\n     *  Returns a singleton instance of a ``LangCz``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangCz();\n        }\n        return wordlist;\n    }\n}\nexports.LangCz = LangCz;\n//# sourceMappingURL=lang-cz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1jei5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsMEJBQTBCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3JELHVJQUF1SSxrQ0FBa0MsaUJBQWlCLDhCQUE4Qiw4QkFBOEIsdU5BQXVOLGtCQUFrQixXQUFXLG1VQUFtVSxtQkFBbUIsMkVBQTJFLHNMQUFzTCx5S0FBeUssNkZBQTZGLDRMQUE0TCwyT0FBMk8sd0JBQXdCLHFFQUFxRSxvREFBb0QsT0FBTyxHQUFHLHlZQUF5WSw2RUFBNkUsOEZBQThGLDREQUE0RCwwSEFBMEgsdUJBQXVCLDZDQUE2QyxnRkFBZ0YscUZBQXFGLDBEQUEwRCxrQkFBa0IsMklBQTJJLHdCQUF3QiwyQkFBMkIscUZBQXFGLG1GQUFtRixvQkFBb0IsZ0lBQWdJLHFLQUFxSyxnQ0FBZ0MsaU9BQWlPLGlCQUFpQixnR0FBZ0cseVNBQXlTLDJkQUEyZCxrREFBa0QsMEpBQTBKLHNIQUFzSCxtQkFBbUIsbVZBQW1WLG9EQUFvRCxnSkFBZ0osOElBQThJLHNEQUFzRCxrYUFBa2Esc0RBQXNELGdCQUFnQixxSEFBcUgsbUNBQW1DLGtDQUFrQywwQkFBMEIsc0dBQXNHLCtEQUErRCxpQ0FBaUMsa1BBQWtQO0FBQ2oyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2xhbmctY3ouanM/OWYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ0N6ID0gdm9pZCAwO1xuY29uc3Qgd29yZGxpc3Rfb3dsX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC1vd2wuanNcIik7XG5jb25zdCB3b3JkcyA9IFwiMGl0YXRrYXN0Y2VuYW92byR0YW91bGVyYWVraSZjaG9yKnRlY2klZW5iYWxvZGFlbGFkZXQnIUNobj0wRGkjJUUlXjFSZXNhMlJlc2UzQ2VUJyMwRWpLb2hvbDBQdSklMEEmc0R1bCNFa2RvKUtlKVRpI1VsfDN9YU9nYW4lMEZhbHRJJEB0UGksJVRtYVRyb25vbTBMYXNMe2kjT2wwVG9idXM0WWw6QiN9PENpbEN1bCNEIV9HZSlHckhub0t0ZXJpZUxhXkx7I0xrb25Mb24tTHZhbkx6YU1idXNOa29tIVJbclJ7Um1hblJva29SdmFUZXIjVG9oVmwmWmFsI1ppbGkjWnUjM0QmUmFuU2VeU3RpZVRvblppbiNabW9jWilrM0N5a2xEXUZ0LUtpbnlMYW4lT2csZk9dZ1R2YVpvbjJBaG9ieXRBdCovRS9hRWR1K0Vza0lrIUl6Jk9rfE91ZCBVZDJCLUJyRGwuRH5IIShKa290SnxLPHlzTGUkUj5SJz9UYVViX1UvIVVeVStVciFYZXIyQV52I0FtYm8sQW4jQXRyRXApSWtlKUtvTG9oT256T3NrZXZVbnsjVXNpbiNaXlp5MkJsLkJufH0pRCBfRCNEJ2FGe0phcihLdj9MZG9rTHZhTl5Oa3JSemFUaWtWb2xab2xhM0QrdEwuVCcjMFVrb3Q6UGFydFJldiYzRHJEdStKL0puTGFMZXJMa2VtTG4/Ti5ObihOJyNOdHJ1bU56PFN0b3Bpc1QjMkFsdXBhQXBgXUFyIGFBKUUvdCFFbWllSS9vdElydXJnTGBMZVtMdWIgTV9NdSxPYm90Ty9vbE9kW08rLE9tPU9wIE9yb1tPdlJhcG90UmwgUnRSdXBUaXYoVWQuVXRuIVYhVmlsI1YoWVtZJCFZdCAwQnUrR2FyZSlIXyZIbGFOa290Umt1c1N0ZXImVGElVHJ1c1ppbj5aKDJPJjJLb2xpdlV2ITRJdF9OKDBEbihLZSlLclBvdDBBa35BbElrUmtvdDJLbGkkYTpMLW9SZVtUX1R1bTFFLDFCIWF9JyNDaWJfRmljIEZsYSVLbEtye01va3IhUHJlc2VSYnlTI1QtdGl2M0tvYix6S3R8T15QXW1Ta1NwK2pWYF1Wby8yQWhhT3Vob1Vob3BpczFFczBCcm9CeXQtQ0B0fXV0IERuZXNIK2RIb15ILEplbUpuP0tsYEtvbGFLdDxLdW1AdExhckxldmFMLk1hTS5udE1sdXYgTSdOdXQgUGBQaXNQbG4gUG9zdWRQcidvZFB1JCBSYXogUihSdFNhaFNsJ1N0IS1TdWRTeSlUYXpULVRrflVmIVV0biFWb3olWmB1Wm4hWjwlMkFobylBa0FtIWlrQXY+QXplRG9sT2JuKE9nZXJpZU96ZFNuKFQgWigyQkB9J25vRC1IYUgnI1MgU25vVCgwT2o/T3I+Mk5hbSA6OU9dZ09ub21pZTBFa3Ryb25JcHNhMEFpbElzZU8lUCFpZTJJem9eTy9hT3Blak9zMkVqRW4lSzwpS3ltbzBJa2UpMEY8aWUwT2x1JTFFa3UlS3VyemVQZWQ/UF16ZVA8dFQsa3Q6QyNKZiNLdWwpTiFpa04pemllUm1hY2llVjwgWm8rM0RlLCVKe29uTiMzQWwjR3UsbnRMb3pvZkx0ck5hbiVOKVhhJTBPcmQxQW5fSXJ0T3RpbGEyTmRTZjxUW2xUI1RvbjJBayVFcyNPbikyS2FyTmslM1ppIzpMZWplUmFudDNOe2kjT11nM0xvdC4yQXp1LEVqdDJMZW1MZmkkYVRpIzJBZkFtb2ZvbkFudStFcElsT2dPdGVzIzJNYTpEP0RyTGFMQCNOW05vcGlzUmZhUnB1JlYsbjNCayhKI2xKbm9KdG1hbkspckxtYU0hb21SPlImU11aa3kzU3Q8aWsyQWQnI0FzaXZreUF2YUVkIUVuT152Pk9oT3VwKFQhVWIuVS9vKTBBdE8pWXowSXNPaml2b091dDBCbC5Cb2p9RGlueURsIURubylEfEpuKEtlakxpbiNMI0x1Yk1vK04gW05vLCVSYWxSXlJpem9udFJrb1JsaXY+Um1vblJuLlJvc2tvcFIkdm9TcG9eU3QuVCcoVVtVZlVwIVVzI1Y8MkFkW0FuP0F2KEF6XkJvK2tELkRdRChOLU9iI09tYV5PdE91Xk96QFN0I1ViKFl6ITJCQChCfkRbS290TXJTIGFTdG8pME96ZDJCbihELG50R2llJk0mU3RlcmlrOjJZbCMzTmVkMk8mMFV6ZTBVbiBhMEYtJUZsYSVLYXNvT3ZhJVNwLSVUZXJue1ZhbGleVmUkPFplciUzT25pZTpCbGtvfSlIb15LbWkrSyhMJz5OKXJSbWFya1JvU2FuU25vVCNWPFp5azNEaW4+RCtEbiFfSGxhbktvdExATCBvTW4oTm9tUD9Te2VyViBaZD5aZXJvM05ha05keU5vL1NrLFN0bylUcm4/WnZhM0VufDFHdXJ0NVIpOkJhcntCX0Jpbnt9JkR7RGlkXUhhbkpha0p1KUthb0t0dXNMYW0gYUxob3R5TGlickxuKE1lLE1rb2xpdk0mTmlbbE5vZU50PFBhbC5QX2FQIG9sYVAjUCtQbylQclB1JGFQeVssUmFtX1JvdCNSdG9uU2FUYV1nVGVkLFUlVXphVmErY1phaiNaZSlaaXYoMkVrb2xpdkVzaTBEbHViQE1wUmFtaSMzTm8yQSVrQWRpdm9BbUFwb3RBc2kjQXVuRWNFbltFcCFFc35JZEltYUlzJk9iKmtPI25PcGFPdWJVYicmVXMhVXprKDBFbkl0IU90cjBJaGFPdDBBbD9CZXI+QiNCbGloYUJ5bGFDKnJIPUpAPktvc0t0ZWpsTGFwc0xlXkxpemVMb01hbmRvTWUpTWlrTW4hYU1vLE1wYXNNdW4gYU4hTiVwdE5kP04+TmZlc2VOZ3Jlc04uTmt1cnNOKWt0TnplcnZhUGFuPlBpZVB+UHInI1JiX1ItdDxSbWlkXVJvcHRldlJwdXNSdSZSeXRvUnp7UyE+U3QjVF9UKylUKmxVayFVcF8mVXMtVXpdVmJvalphWjxvaDJBYj9BL0FqLkFsfEFzb3Bpc0F2IWFFZCBFamNhckVzW0V2ZSlJa3tJdGlrSXplS2F2Pk1lK2NNaXZvT2Nhbk9rT25pI09wIE91cGFPdiNULVVoYF1VcD9VdChWaW4jWS8rWXApWSRhbFl0MkRsYW4jRnJKbihLbGFMYWpeTGkvTCNMb217THR1LE5hUG9kaXZ1UnRSejxUaWwwQWwgYUFzaW4jRSQ8Mk5vXWdTXy5UYSxUP1QjVCc+VmBdOkIsZDx9KW5EbihJa0tvbT5NX2FNcGFOJyNTP1NvU3R1LFRpbiNWLjNCI0NrZHlEQERuP0QnI0R2LkdAXkdpZUcsJUglSGsoSH5LdHZhck5vL29kTnRpbCNQQCNQaWRdVGBdVD5UbW9Ub2tydWhWaGFydFYgYSVWb2JvazNCLH1vdCNEb2plZERzayhIJy5KYXY+TC1NeyNOaWVOI05vK3VtU3RvcGBULlR8NUJpJGFEaXZvZEdpI0dvcGVkS2FsIGFLe01jfFAhYVB1L1JkU29zVHJVXmxVaFUjVXNrIVY+M1RpdigxQ2VyJkNpZmVyTXBTa1N0LCUwSSUyUmFSaSNTLjpEYW1EXUdpJHJIYWdvbkp7LUogX0o8IGFLYWtLJz9Lcl9hTFtMLkx8THY/TWluI05kK05rb1JuKFNha3JTa290U29wdSRUP1RyaSNUdXIgYVphbj5aaXZvWmwgWnVyIzJMb1swfWFuaWtEIGElRCcuTGFzYUwqbk50b2wjVGxhVG9eVHJaZSwzRywlSH5IdStLLktyb2ZvbkxAPkxpbXtyTChNaSNOYycmTmlbck5vbXtOdWwoUyNTdHJYfDJBZChIYUgnLk9rUyFVdiAxSS9PaGVtMEJpbENuKERfI0RsIFtIeWxhS3JvTC11bGFNQHQjTmFyL2FOb2tsTiRydW1OdHxOenVuU2F6U2t5dFN0VGl2YSVUPCNUeSNVL2FVZHIoWmFpI1otWm9sMkFtPEF2QD5LZXZUdm9sYVp7WnV0KDBUIF8xRHJjRl1uTCFNaWVOP1N7VGElWmV1bVppI250M1NsaXY+MERhOkIqciF9eXQhRGElRGJ5dC1EaG96RG9icm9EcGlzSGxhc0huIUhvZGkrSCxkIEl2IGFKZWRuKkppJG9KbT1LXW4gS29uPktybSBMZXZvTWF6IU1sdXYgTm9te3JPa29PcGFrTyRyb1BgIVBldm5vUGxuIFB+UG9zK2RQcihvUm9kIFJ1YnlSeS9dU2AgUy0hUytwb1N0IVRvbGlrVkAtVnIvVnpkPHladiEzQmV9IUNreURhK2tvRGIhRHVoR2ElSHtIb15KQEpwcnZlS2xpZExpYihNaWwoTW9jTy9vKU9uI1Bva29qUihSdlNteXNsUypsYFR2PFVyb25WLlp2eWsrM0NvKUpha0thbUtkeUtsS3RlLGtUcm81QytoSGF2P00uJVJhUi1TIF9TbihVemVWaW55Vm8pWmQsNURhRCtHe1QgVG4oVHJpZTNNZmE6MEFsQXJ2IEF2YURpdkVjRWhuIUVqbT1FeiBhSGFqb1tJbG4/SmFzbiBKLXRLXXAgTGEkTC1MaVtMb2hhTHVeTm9zT2ghIE9qLU91dFJhej5SJlJ1W1J5c1NhaFNsdWhhUylyIVV2VmF6VmluIFZvZFZ5aytZdiFfWjwwQXNFbEVuIEhsYCBIbylILCZJdH4wQm9qQnl0fW9kQ2l6IEViciFFc2whRXZ6ZCFFenZhSGAlSG9kIEp7SmludWRLYXpLKnAgTGl2THUjTWwjT2xuKFBgUGlzUGw9UDxQdSQgUHlrIVJheiNTKmQgU3R1cFN1blRva1R1ZFZhaGFWZSlWb2whViwldFomazFJJlNhamQxTGFzTmlza29SYV5Sb3ogUnl6LTJBcEVuP0xpI05vT3V6bCBPdnlSYXNhUmVzUnMtUnVoVXBhbnRVciNVcyAwRWpuLkl6fDBBa0UrKUV6IExgLkwqdiFMdXZhWWwwRWhkeTFBa3xBcy1FLCVJJUlsKElzfE8sT3o/UmF2ZHVSb3RpMUIgYWx9ZSRyR2llTD9Mb2pUXzBBXn1+SSNJdm9MYXZhTGVwIExuIEwnIE4nYU9bT2wgUGErY1RAVCxoYVR1XlR5L1ZvaiAwRXBsIElza09wUmghUmwoUm9rUnVieVY8MUF+QXJFc0xpdm4gTyUxSWQxRG9bOn0hX0NpQHREKi9IPC1LdExhbl5MPkxpdm9MdVtNZit0TWxzLU5AI05pI04mTnxOJHZvTnRvZitQcmkjUmtlKVJvZGllUilSdSNSeVtTZSNTaXYgYVN0XyNUQHRUcm8mViprWm5laHRaKnItM0MjRGFnb2dKcy1LXUxvdG9uTmFsKU5kci1OemVSaXNrb3BSb1N0cihUYXJeVD9Ucm8ralZuLlhlc28zQW5pJGFIYUphdj9LK0tuaWtMLkxuKEx1bCNOemUpUGUpUyFfU3RvK1RldiZWbj9WJ2FyMkElbilBayFBbUBBbmUpQSRpI0F0IEF2aWRdQXpFL0VtQG9FbilFc0V0aXZvRXZfSXYhTiBOb08vYU9kLk9tW091dFVrWW4yQmF2IEJ5dH1vZEMgQ3Rpdj5EIUQlbiBEZXBzIURoK2REaXYgRGtsYERtYW4gRG5pa0RvW0RwbyxELHpEJCFhRHZvZER6aW1FemllSGFuI0hudXQjSCc8SHJvbWFIeWJJbilKaSQjSm09S2F6IEsrc0tvaktyb2tLdSlLeW5MZWRuZUxpYi1Ma35Mb2hhTHlub21NYWx1TWl+TWwjTW9jTSRhTXlzK3ROZS8hTjwjTnVyKFBgIVBfUGlzLVBsYS9Qcm9zIFBzIVB1ZFJgJVIlUm9kUnUvYVJ5dlNgIFNlZFNpbGFTa29rU2xhbj5TKmQgU3BvbHVTKXZhU3VkLVN5cFRhaFQjblQrc2tUb20tVCx2YVR1cGFUdm8sVSN6VXRvVXpkcm9WYWhhVmlkbGFWbGFrVm96VnIvViQhVnlrVnpkZS9aZCx2WmVtLVpuIS1aPFp2ITJBY3xBaDx5QWt0aSNBK3NBb3Q+QXA8LUFzZUF2XkluY2lwS25vT2J1ZCBPJW50b09kZWpPZmVzZU9oLE9qLXRPXW0gT21pK09uaWshT3BgT3Jva09zW090b25PdXQtT3ZhelMjdiNTdEBVZGsoVXRWLVZvaDx5MEFuPk92b2RUcnVoMEFjdHZvMEJlcil9RGxLYXY+S2wuS3IrTHRNcGFOY1BAU2FTaW4jU3QuVHxUeSMzUmFtaV5Ta1RfOjpDLX1vdERpYSVEbj9Eb25GdEdieUtlKUsnLk1Ab01wKi9OZGVSYS9SIGFTJyZTdHJUbyskWmFuJVppZF0zQWd8QWslQ2VwdERha3Q8RmVyQHRGK3hKbm9rS2xhbWFLPGRLcnV0S3Q8UHUpJVZpemVWbWFWb2x2ZXJaZXJ2YTNTa3xaaWtvNUJvdGkjRG9rbUBIJyNLK0tva29NYW57b1Anb2RQdS9hUmVqc1NvbFN0bC5UbWkkclRvcGVkVHVuXlViQCNVL29VcFUsVi5Wbj9aYjxaL29kWmQhWmV6biFaaG9kJVppbiNaamV6ZFojelpdaGFabWFyWnBgWnJ1L1pzYWhadG9rWnVtWnZvZDVCcmkjfWBdS2F2P0tvcGlzM0JhQm9sJ31sKERdUGBdVC5aKDpEaSRhSCFLb00+TWl6ZCFNbylOICNSZGluI1NhbiNUXyBaW1pAPzBPcjBIfDFCLG4jQ2VzZURgXURpbUB0RF1IbiFKbT1LZSxLKUt1bl5Ldm9qZU1Ab05vUnZpc1NgIFNobyxTa29rU2whU3QsU3V2U3lwIVRbVC5UayFUflRydiFWZXJaJm0yT15SfjBGb25Mbj9SI1JvdC1SdXBUdWElMUFmYW5kckFsaXNrb0FuekBBdXRFcHRpa0ljYUxgW0xAP0xvTHV6T1tPI25Pcm9SaXApUnpVcC5WKFZyJjBBYmkjQWRpZF1Bbi5BJEF2bihFZHxFcD5FdmFFei5JYkkmSXpuP09uT3VwLU92b1UvVWhhVW4lVXAjWmEwQSxnZEUpJklsJHZvTCp2YU9nUmBSa1J0I1V0LVlzbDBBZEFoYU9iMEJvKX1hRCcjS29sUCNUdmFVYm9qVWMgVWQlVWhsYXNVbGBVbSxrVXAsdmFVc2VkVXRva1V2aXN7MEFsJyZBcyBfSXNMYXZPZC1PakA+T2x1T256PE9ybihPdSRhUi9hVSQgMUFuXkF6RCVOYU4+T3ZuIVBAU3RVYjFBbj9BcihhQXRpI0F2W0Vobm9FeiNPZG9sYU8ra09wYU9ybm9PdXAhUmEvUmVzUmh+Um9tUnUmVWQmVXBuP1ZvbFlrMEJqLXRCdHJvcHl9YXJEKEtub05kIU49UmlrIWFSJy4wQWhBbCR2b0V0ckF0W0F6LUlzK0l0LU9ib15PZGlkXU9yI1JhYjJLYXYjS290Ti1OJz5QIVBrKFInKFNfVCg6Qit0I0J1K0gqbkplbW5vSmZ1bkpnYUogSm4oS3RpI01oK01wb25OY3xOPk5rZXJQZSlWQC5aIV8zfW5pI0hkeUt1dC5MZWZvbk1ubylOZEAlTmkkYU48UF0pUCZQcnZlUmFwaWVSbW9zI1h0aWwzfW9Ta29waXNUdStrMUFkK2NBbi4wQXAjRXNrIVVrb3RVcGEwRWwxQSspUGluI1BvbFJ6b1VoYVUrYzJBZD9Ba3Q8QW1wQXNhQXZlcnphRWYgRSRFejxIYXYuSGwuTy91T2o/T3MjT3VbUCVQIF9QayhVYj5VL2wgVWhsP1VzViEyRHlIfkgoTmQsUmkkYVImalplbXNrbzBBcm9oT3JbUmQoUnoyR3JLZXY6ME9oKE96ZVIhUipzLVJ1c1l0JyYwSG9UaXYoMEl2IDNSYCAxRWRuIUkkIE09MEF6IV9MaWRuIExvbiBPdHYgUm9qIDBJJUkpT3YgMFl2YF0wQXYgSWY8bWFJa34xQWR+TCFuIEx5fk91dCFSYXYgMUFuQXogMEVkfklsfE1ydCBOYG4gTj1PdWQgVGwhVHJ+MEFofEshTHVtIE9+T3BAPlIqcyAxQWwgT2xuIE96JyMzRCx2IEVsRW4uTC5OITpHb25ML2FMKm5OYU5ebE5pbCNSYW5SaGFueVJ8MUVsa3VIb2QwT3ZhMERyb0dlKSVKJUxibCpkTHtyaEwgX0xtb2NMcnlbTmsnUmFuXlJ6ZVNfI1NrcnplU24/U3BvZHVTKVRlci5WZXIjM0IsJX1yRGVvaCxELkQrTGFOP1N7VGFsIGFaZVogIzBFemQwTGBVczBBaiNBa0FzPkV2b0hrKEl2TicjT3VwITFVY3xVazBEYURpdihEb3oma0Qkdm9KQHNreUomSnNrb0xhbnRMW0wgTG5vU2snI1ppZF1aJyYwUmF2bzFBYj5BJXRBaEEpQmF9bytrSCFTdHZhVHUrMEFkIFQqcCBUdXAwSXA0QmF2IEJyIX18RCFELEZvdCBIK2QhSH5Ib2QgSCxkIEh1YiBKYXNuIEp7Sm09S11wIEtvbiFMLSFNYXohTWV6IE1pentNeXMrdE5lLyFOaWshTnV0IFBgIVBsISBQLHYgUHUkIFJheiBSJ24hUnYhU2wnIFNva29TKXYgU3V+U3lwIVRhcyBUZXMhVHIhIFZpflZvbCFWcmhfWmRvYiBabiEwQWR1QnVkIH1vcCBEPER1L0R5LyFFJHVwSCtkZW1LYXpMeWshTmlrT3ItUCosVGFoVC06Ojk5M0xvZm9uOjpCciFCeWQrdH18RGFybW9EdXMgRiprIUhsdCBIb2QgSCxeSHl+SiE+SntKaSQgSytwIUsqcCBMZXAgTWV6IE1vdCFNeXMrdE5lLyFOaWshUGwhIFBvaiBQcyFSYXogUyl2IFN1flRhaiBUZW1uIFRrflVqbT1WYWwgVmUrdFZpbiBWb2whVnJ0IVp2b24gMEF2IFJ1c3VVZHxZdC0xQSsjQXJtYUF0bihJdm9PYiBSb2pWaWhZbWBdMExALk1hbk0uUHQhWmB1WmRvbGEyQXQgTHR+THVibyNPdCcgUnVbME1hTW4/MEVtbiAwTGFtIU91bSFSISNVbWF2IzBBdG9FaCNPW09tTyRPenZ5azBBcHxBckF0LUlqZUl6e09jbiBPZHIhUnpsLlV0fDBBa0FsKEFtQCFPdnUwQix6IFRhdiBVYi1VZmErMExvZCBPbWFsIFJhdmFSKCBSdWQjUnZ1MUFeQW4gQ2BdTiAoTm9PdiZZL2wgWmF2KDFJL2FSISAwQicuQnIwRWR+RW5rdUVzX2FPblIhVWsnb2RZa1wiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4MjVmNDQ1NTVmNGFmMjViNTFhNzExMTM2ZTFjN2Q2ZTUwY2U5Zjg5MTdkMzlkNmIxZjA3NmIyYmI0ZDJmYWMxYVwiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktY3pdXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ0N6IGV4dGVuZHMgd29yZGxpc3Rfb3dsX2pzXzEuV29yZGxpc3RPd2wge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBDemVjaCBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBVc2luZyB0aGUgY29uc3RydWN0b3Igc2hvdWxkIGJlIHVubmVjZXNzYXJ5LCBpbnN0ZWFkIHVzZSB0aGVcbiAgICAgKiAgW1t3b3JkbGlzdF1dIHNpbmdsZXRvbiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFwiY3pcIiwgd29yZHMsIGNoZWNrc3VtKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nQ3pgYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0N6KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ0N6ID0gTGFuZ0N6O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1jei5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-cz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-en.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangEn = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst words = \"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\";\nconst checksum = \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangEn extends wordlist_owl_js_1.WordlistOwl {\n    /**\n     *  Creates a new instance of the English language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEn]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"en\", words, checksum); }\n    /**\n     *  Returns a singleton instance of a ``LangEn``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangEn();\n        }\n        return wordlist;\n    }\n}\nexports.LangEn = LangEn;\n//# sourceMappingURL=lang-en.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1lbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsMEJBQTBCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3JELGtQQUFrUCxnTUFBZ00sOE1BQThNLGlGQUFpRixvQkFBb0IseVFBQXlRLGFBQWEsVUFBVSxZQUFZLG1EQUFtRCxlQUFlLHdGQUF3Riw0REFBNEQsVUFBVSx5QkFBeUIsaTRCQUFpNEIsNEJBQTRCLDJDQUEyQywwZEFBMGQsY0FBYyxvTEFBb0wsd0NBQXdDLDZCQUE2Qix1TkFBdU4seWpCQUF5akIsZ0hBQWdILG9DQUFvQyxjQUFjLGdCQUFnQiwwT0FBME8sc1VBQXNVLHlEQUF5RCxzSUFBc0ksT0FBTyxpSkFBaUosbU1BQW1NLFFBQVEsTUFBTSx3WEFBd1gsMENBQTBDLGtCQUFrQiw0QkFBNEIsOEZBQThGLHNVQUFzVSw2QkFBNkI7QUFDOTFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1lbi5qcz9lYWJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nRW4gPSB2b2lkIDA7XG5jb25zdCB3b3JkbGlzdF9vd2xfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LW93bC5qc1wiKTtcbmNvbnN0IHdvcmRzID0gXCIwZXJsZW9uYWxvcmVuc2VpbmNlcmVnZXN0aWNpdFN0YW52ZXRlYXJjdHNzaSNjaDJBdGhjayZ0bmVMbDBBbmQjSWwueUxlT3V0Tz1TfFMlYi9yYUBTdXJkVScwQ2VbQ2lkfENvdW50Q3UnSGllPUlkT3UsLVF1aSpSb1tUVF1UJVQqW1R1JDBBcHRERC10RCpbSnUsTS5VbHRWPClWaSkwUm9iLTBGYWlyRiVkUmFpZDBBKEVFbnRSZWUwRWFkME1SUnAldFMhX3JtQnVtQ29ob2xFcnRJJkxMZXlMb3dNbyxPfVBoYVJlYWR5U29UIFdheXMwQT51ckF6KGdPbmdPdW50VSdkMEFseSxDaCVDaXxHIEchR3J5SW0kSyFOb3VuKU51JE9gIFN3IFQmbmFUaXF1ZVhpZXR5WTFBcnRPbG9neVBlP1AhUHJvPVJpbDFDaEN0LUVhRW5hR3VlTU1lZE0lTXlPdW5kUjwrUmUsUmk9Um93VFRlZmFAVGksVHclazBLUGVAU2F1bHRTZXRTaSxTdW1lVGhtYTBIIT5PbVRhe1QmZFQudWRlVHJhQDBDdF1ELkd1LE50VGglVG9UdW1uMEVyYStPY2Fkb09pZDBBa2VBKkF5RXNvbWVGdWxLdz9kMElzOkJ5Q2hlbCVDI0QrR0w8KUxjI3l+TWJvb048YU5uIFJSZWx5UmdhKFIqbFNlUy1Ta2V0VHQhM0FeQW5BdXR5Q2F1J0NvbWVFZkYlZUcoSGE9SChkTGllPUxvd0x0Tl5OZWYuL1RyYXlUdCBUd2UmWSNkM0N5YyFES2VOZE9sb2d5UmRSYFR0IF97QWRlQW1lQW5rZXRBLEVha0VbSW5kT29kT1tvbU91J1VlVXJVc2hfcmRBdER5SWxNYk5lTnVzT2tPLFJkIFIoZ1Jyb3dTc1R0b21VbilYWV97ZXRBKEFuZEFbQT1FYWRFZXplSXtJZCtJZWZJZ2h0SW5nSXNrT2Njb2xpT2smT256ZU9vbU9gIE93blVzaDJCYiFEZHlEK3RGZiRvSWxkTGJMa0whdE5kIU5rIFJkJlJnIFIsU1MoZVtTeVR0IFkgWno6QmJhK0IoQiFDdHVzR2VLZX5MbU0gYU1wTk4kTilsTmR5Tm4jTm9lTnZhc055I1BhYiFQLiRQdGEoUlJiI1JkUmdvUnBldFJyeVJ0U2VTaFMoby8hU3UkVFQkb2dUXlRlZyV5VHQhVWdodFUnVXRdVmUzSWwoZ0wgeU18TnN1c050dXJ5UmUkUnRhKF9pckFsa0FtcF1BbitBb3NBcHQgQXIrQSdBdEVhcEV7RWUnRWZFcnJ5RSxJeyZJZWZJbGRJbX15T2kpT28nUiMtVXshVW5rVXJuMEc/Tm5hbSNSYyFUaXomVHlWaWxfaW1BcEFyaWZ5QXdBeUU8RXJrRXYgSXtJfElmZkltYkluLUlwT3tPZ08nT2BPdWRPd25VYlVtcFUsIFV0Xl9eQSxDI3V0RGVGZmVlSWxJbkwhQEwlTHVtbk1iKGVNZU1mJXRNLU1tI01wPHlOYyB0TmR1QE5maXJtTmcqW059QE5zaWQgTnRyb2xOdigpT2tPbFBwIFB5UiRSZVJuUipAL1R0I1VeVW50cnlVcCFVcidVcyhWIFlvPl97QWQhQWZ0QW1BfUFzaEF0IEF3bEF6eUVhbUVkLkVla0V3SXtldEltZUlzcEl0LU9wT1tPdV5Pd2RVY2kkVWVsVWknVW1iIVVuXlVzaFlZLCQyQmVMdHUqUFBibz9kUmlvdXNScnxSdGEoUj1TaF0vb21UZTNDITpETWErTXBOKU5nIFIoZ1NoVWdodCBXblkzQWxCYT5CcmlzQ2FkZUNlbWIgQ2lkZUNsKGVDJWE+QyphJ0VyRiYnRihlRnlHKmVMYXlMaXYgTTxkTWknTmkkTnRpLE55UD90UCZkUG9zLlBgUHV0eVJpPVNjcmliZVMgdFNpZ25Ta1NwYWlyL3JveVRhaWxUZUBWZWxvcFZpKVZvPjNBZ3JhbUFsQW0jZEFyeUNlRSdsRXRGZiBHLiRHbi55TGVtbWFObiBOb3NhdXJSZUBSdFNhZyplU2NvdiBTZWEnU2hTbWlbUyVkIFNwbGF5LzwpViB0VmlkZVYlKVp6eTVDdCVDdW18R35McGgoTWEoTmE+TmtleU4lT3JTZVViIVZlX2Z0QWcjQW1hQSwtQXdFYW1FW0lmdElsbElua0lwST1PcFVtWTJDa01iTmVSKGcvVF5UeTFBcmYxTmFtLTpHIEchUmx5Um5SYFNpbHkvU3kxSG9PbG9neU9ub215MEdlSXRVY2E+MUYldDBHMUdodFRoIDJCb3dEIEVAci1FZzx0RW18RXBoPHRFdmF0JUk+U2UwQj9rQm9keUJyYSlFcitPdF1QbG95UG93IFB0eTBBYiFBQEREIVtEJSdFbXlFcmd5RiUpR2ErRyhlSDwpSm95TGksT3VnaFItaFJvbGxTdSpUIFRpKlRyeVZlbG9wZTFJc29kZTBVJFVpcDBBQSdPZGVPc11SJVVwdDBDYXBlU2F5UyYpVGE+MEVybiRILXMxSWQmKUlsT2tlT2w9MUFAQW1wIUNlW0NoPCtDLmVDbHVkZUN1J0VjdT5FcmNpJ0hhdSxIaWIuSSFJLEl0T3QtUDxkUGVAUGkqUGxhKFBvJ1AqW1QmZFRyYTBFRWJyb3c6QnItQ2VDdWx0eURlSW50SWB+TCdNZU1pbHlNb3VzTk5jeU50YXN5Um1TaF1UVCRUaCBUaWd1ZVVsdFYlLmUzQXR1KkJydT95RCAkRUVkRWxNYSFOKS9pdiRUXlYgVzNCIEN0XUVsZEd1KkxlTG1MdCBOJE5kTmVOZyBOaXNoUmVSbVIsU2MkU2hUVH1bWF9nQW1lQXNoQXRBdiVFZUlnaHRJcE9hdE97TyVPdyBVaWRVc2hZX21DdXNHSWxMZH5vd09kT3RSKVJlLFIrdFJrUnR1fVJ1bVJ3P2RTc2lsLyBVbmRYX2dpIUFtZUVxdXxFc2hJJmRJbitPZ09udE8sT3duT3omVS4yRWxOTm55Um5hKVJ5VHUqOkQrdEluTGF4eX4geU1lUFJhK1JiYStSZCZSbC1SbXxTU3BUZVRoIFUrWmUzTiAkTml1c04qTnQhTnUoZS91KjJPLDBBbnRGdEdnIU5nIFJhZmZlUmxWZV9kQW4pQSpBW0lkZUltcCdPYmVPb21PcnlPPU93VWVfdERkZVtMZE9kTydSaWxsYVNwZWxTc2lwViBuV25fYkEpQShBbnRBcGVBW0F2LnlFYXRFJklkSWVmSXRPYyB5T3VwT3dVbnRfcmRFW0lkZUlsdEl0P04zTTpCLklyTGZNbSBNLCBOZFBweVJiJVJkUnNoUj0sVFZlV2taP2QzQWRBbGBBcnRBdnlEK2hvZ0lnaHR+b0xtZXRMcE5SbzNEZCZHaH5OdFBSZS8leTVCYnlDa2V5TGRMZUxpZGF5fm93TWVOZXlPZFBlUm5SciVSJ1NwLiQvVGVsVXJWIDVCR2VNPE1iIU0lTmQqZE5ncnlOdFJkIVJyeVJ0U2I8ZDNCcmlkOjFFT24wRWFFbnRpZnlMZTJOJWU0TExlZyRMfVswQStJdGE+TSYnTXV9UGFAUG8nUHJvPVB1bCcwQ2hDbHVkZUNvbWVDKmEnRGV4RC1hPkRvJUR1LHJ5Rjx0RmwtdEYlbUhhIUggLkl0aSRKZUBKdXJ5TWE+TiBOb2N8UHV0UXVpcnlTPGVTZUBTaWRlU3BpKi8kbFRhQFQgZSxUb1ZlLFYuZVZvbD0zT24wTDxkT2xhPlN1ZTBFbTFPcnk6Q2tldEd1P1JaejNBbG91c0Fuc355V2VsOUJJbktlVXJ9eVk1RCtJKU1wTmchTmklTmsvOk5nP29vM0VuRXBUXnVwWTNDa0REfXlOZE5nZG9tU3NUVF4mVGVUdCZXaTRFZUlmZU97T3c6QkJlbEIlRGQgRHlLZU1wTmd1YStQdG9wUitUIFQoVWdoVW5kcnlWYVdXbldzdS5ZIFp5M0FkIEFmQXJuQT1DdHUqRnRHRyRHJmRJc3UqTSNOZE5nYE5zT3A/ZFNzI1R0IFZlbDNBckIgdHlCcj95QyYnRmVGdEdodEtlTWJNLk5rT25RdWlkL1R0IVZlWj9kNUFkQW5CLCBDJENrRy1OZWx5TmdPcFR0IHlVZFVuK1ZlWSQ1Q2t5R2dhK01iIE4/Tl5YdXJ5M1ItczpDaChlREctR310SWRJbEluSiVLZU1tJE5OYStOZGE+TmdvTnNdTnUkUCFSYiFSXlJnKFIoZVJrZXRScmlhK1NrU3MvIFReVCBpJFRoVHJpeFR0IFhpbXVtWmUzQWRvd0FuQXN1KkF0Q2g8LUQkRGlhTG9keUx0TWIgTSV5TnRdTnVSY3lSK1IuUnJ5U2hTc2ErVCRUaG9kM0RkIURuaWdodExrfl1NLU5kTmltdW1OJU51PlJhYyFSciVTIHlTcy9ha2VYWGVkWHR1KjVCaSFEZWxEaWZ5TU18Ti4lTmtleU4sIE5gT25SJFJlUm4oZ1NxdS5vVGggVF1UJVVudGEoVSdWZVZpZTVDaEZmKExlTHRpcGx5U2MhU2V1bVNocm9vbVMtL1R1JDNTZWxmLyB5VGg6ST1NZVBrKFJyb3cveVRdVHUqM0FyQ2tFZEdhdGk9RyFASWAgUGhld1I9L1RUdyVrVXRyJFYgV3NYdDNDZUdodDVCIUknTShlZU9kIVJtJFJgU2VUYWIhVGVUaChnVGkpVmVsVzVDIT9NYiBSJ1Q6SzBFeUplQExpK1NjdSpTID1UYShWaW91czBDdXJFPFRvYiAwT3IxRkYgRmkpVCYyTDFBeTBEST1ZbXAtMEl0MENlRUkjTChlTHkxRW5FcmFJbl1QbydUXTFBbitCLkNoP2REIEQoP3lHPEl8SWcoJFBoPDBUci1oMEggMFRkbyVUIFRwdXRUc2lkZTBBbEVuRXIwTk4gMFlnJjAvIDBPfTpDdERkIUdlSXJMYSlMbU5kYU5lbE4tTmAgUCBSYWRlUnxSa1Jyb3RSdHlTc1ReVGhUaXxUcm9sVHQgblUnVmVZbXwzQSlBbnV0QXJBczx0TC08Tk4kdHlOY2lsT3AhUHAgUmZlQFJtLlJzI1QyT31PdG9SYSdZcy0kMEFub0NuLUN0dSpFKUdHZSN+TG90TmtPfSBQZS9vbFReWnphXylBfXRBLC1BPkF5RWEnRWQrVXtVZ1VuKzJFbUV0SW50TD9MZUxpKU5kTnlPbFB1bD9SdF1TLl1Tc2liIS9UYXRvVHQgeVYgdHlXZCBXIF9AaSlBaSdFZC10RWYgRXBhKkVzfEV0dHlFdnxJKUlkZUltP3lJbnRJJS55SXMjSXZhPkl6ZU9iIW1PKVtPZHUpT2YuT2dyYW1PamVAT21vPk9vZk9wIHR5T3NwIE8+QE91ZE92aWRlMkJsLURkKGd+THBMJ01wayhOXlBpbFBweVJeYSdSLnlScG8nUidTaFRaeiEzUmFtaWQ6OTlBbC55QW50dW1BcnQgRSxdSXtJdEl6Tz46QmIuQ2NvI0NlQ2tEP0Rpb0lsSW5JJ355TXBOXk5kb21OK1BpZFJlVGVUaCBWJldaJTNBZHlBbEFzI0JlbEJ1aWxkQyRsQ2VpPUNpcGVDJWRDeWMhRHUpRiFARiVtRnUnR11HKnRHdWw/SmVATGF4TGVhJ0xpZWZMeU1hKE1lbWIgTShkTW89TmQgTmV3TnRPcCZQYWlyUGVhdFBsYSlQJXRRdWkqU2N1ZVNlbWIhU2ksU291cilTcCMnU3VsdFRpKlQqYXRUdXJuVW5dVmUkVmlld1c/ZDJZYG0wQkJiI0NlQ2hEZUQrRiFHaHRHaWROZ090UHAhU2tUdSRWJFYgNUFkQSxCb3RCdSxDa2V0TTwpT2ZPa2llT21TZVRhPlVnaFVuZFU+WSQ1QmIgRGVHTGVOTndheVIkOkREZCFEfVtGZUlsTGFkTG0jTCNMdEx1Pk1lTXAhTmRUaXNmeVRvc2hpVSlVc2ErVmVZMUEhQW5BKkF0dCBFfUhlbWVIb29sSSYpSVslc09ycF1PdXRSYXBSZSZSaXB0UnViMUFBcl5BcyNBdEMjZEMqdEN0XUN1ci55RWRFa0dtfExlQH5NKD9OaSVOJ050JilSaWVzUnZpKVNzXVR0IVR1cFYmX2Rvd0FmdEFsbG93QSpFZEVsbEVyaWZmSWVsZElmdEl9SXBJdiBPe09lT290T3BPcnRPdWxkIE89UmltcFJ1Z1VmZiFZMEJsKGdDa0RlRStHaHRHbkx8TGt+eUx2IE1pbD9NcCFOKU5nUiYvIFR1YT5YWmUxQT5FdF5JSWxsSW5JcnRVbGwwQWJBbUVlcEVuZCBJKUlkZUlnaHRJbU9nPE90T3dVc2gwQWxsQXJ0SSFPa2VPb2AwQXtBa2VBcElmZk93MEFwQ2MgQ2kkQ2tEYUZ0TD9MZGkgTGlkTHV0XUw9TWUjZU5nT25ScnlSdFVsVW5kVXBVcilVYDBBKUEqQXRpJEF3bkVha0VjaSRFZWRFbGxFbmRIIGVJKUlkIElrZUluSXIuTC5PaWxPbnMlTyNPcnRPdFJheVJlYWRSKGdZMFVhKlVlZXplVWlyKmxfYiFBZGl1bUFmZkErQWlyc0FtcEFuZEFydEE+QXlFYWtFZWxFbUVwRSpvSXtJbGxJbmdPe09tYV5PfU9vbE9yeU89UmE+Z3lSZWV0UmlrZVIjZ1J1Z2chVWR8VWZmVW1iIVkhMEJqZUBCbS5Cd2F5QylbQ2hEZCZGZiBHP0crLEl0TW0gTk5ueU4ndFAgUHBseVAqbWVSZVJmYSlSK1JwcmknUnJvdW5kUj15U3BlQC9hKDFBbGxvd0FtcEFwQXJtRT9FZXRJZnRJbUluZ0l0Xk9yZDFNYm9sTXB0b21SdXAvZW06QiFDayFHSWxMfExrTmtQZVIrdFNrL2VUdG9vWGkzQV5BbX5OTjx0Tm5pc050Um0vWHRfbmtBdEVtZUVuRSV5RSpFeUluZ0lzT3VnaHRSZWVSaT1Sb3dVbWJVbmQgMENrZXREZUcgTHRNYiBNZU55UFJlZFNzdWVUITVBLEJhY2NvRGF5RGRsIEVHZWAgSSF0SyZNYXRvTSVyb3dOZU5ndWVOaWdodE9sT2BQUC1QcCFSXlJuYWRvUnRvaSdTc1QkVXJpLFc/ZFcgV25ZX3tBZGVBZmYtQWctQShBbnNmIEFwQXNoQT1sQXlFYXRFZUVuZEkkSWJlSXtJZ2cgSW1JcE9waHlPdWIhVXtVZVVseVVtcGV0VSxVYFkyQmVJdF1NYiFOYU59bFJrZXlSblJ0ITFFbD1FbnR5SSlJbkksTzFQZVAtJDo1THk1QipsbGEwQWIhQXdhKkMhQ292IEQgRG9GYWlyRm9sZEhhcHB5SWYlbUlxdWVJdEl2ICdLbm93bkxve1RpbFVzdSRWZWlsMURhPkdyYWRlSG9sZE9uUCBTZXQxQjxHZTBBK0VFZEVmdWxFIVtVJDBJbC55OkM8dEN1dW1HdWVMaWRMIXlMPU5OaXNoUCVSaW91cy9VbHQzSC0hTD10TmQlTnR1Kk51ZVJiUmlmeVJzXVJ5UydsVCA8M0FiIUJyPHRDaW91c0N0JXlEZW9Fd35hK050YStPbChSdHUkUnVzU2FTLlN1JFQkVmlkNUMkSSlJZExjPG9MdW1lVGVZYSs6R2VHI0l0TGt+TG51dE50UmZhKlJtUnJpJVNoU3AvZVQgVmVZM0FsYEFwI0FyQSdsQWAgQkRkKGdFayZkSXJkTGNvbWUvVF8hQXRFYXRFZWxFbkUqSXBJc3AgMERlRGBGZUxkfk5OZG93TmVOZ05rTm4gTnQgUmVTZG9tU2VTaFR9WzVMZk08TmQgT2RPbFJkUmtSbGRScnlSYF9wRXtFLCFJLEk+T25nOjpSZDNBcn5vdzlVVW5nVWA6M0JyYVJvOU5lT1wiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktZW5dXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ0VuIGV4dGVuZHMgd29yZGxpc3Rfb3dsX2pzXzEuV29yZGxpc3RPd2wge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBFbmdsaXNoIGxhbmd1YWdlIFdvcmRsaXN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IG1vc3Qgb2YgdGhlIHRpbWUgYXMgdGhlIGV4cG9ydGVkXG4gICAgICogIFtbbGFuZ0VuXV0gc2hvdWxkIHN1ZmZpY2UuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFwiZW5cIiwgd29yZHMsIGNoZWNrc3VtKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nRW5gYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ0VuID0gTGFuZ0VuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1lbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-es.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangEs = void 0;\nconst wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js\");\nconst words = \"0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&\";\nconst accents = \"aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M\";\nconst checksum = \"0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-es]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangEs extends wordlist_owla_js_1.WordlistOwlA {\n    /**\n     *  Creates a new instance of the Spanish language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEs]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"es\", words, accents, checksum); }\n    /**\n     *  Returns a singleton instance of a ``LangEs``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangEs();\n        }\n        return wordlist;\n    }\n}\nexports.LangEs = LangEs;\n//# sourceMappingURL=lang-es.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1lcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsMkJBQTJCLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3ZELCtxQkFBK3FCLHlKQUF5SixNQUFNLHFCQUFxQiw2REFBNkQsd0RBQXdELHFCQUFxQiwwQkFBMEIsMEZBQTBGLGlKQUFpSiwyRkFBMkYsYUFBYSxVQUFVLDZHQUE2RyxpRUFBaUUsNEVBQTRFLG9GQUFvRiw4UEFBOFAsNkdBQTZHLHdSQUF3UixrQ0FBa0MsbUVBQW1FLHdLQUF3SyxnQ0FBZ0MsY0FBYywwV0FBMFcsOENBQThDLHdFQUF3RSxhQUFhLHVDQUF1QyxvQ0FBb0MsNkpBQTZKLEdBQUcsR0FBRyxxTUFBcU0scU5BQXFOLHNSQUFzUixtSEFBbUgsdUZBQXVGLGtCQUFrQixpTkFBaU4saUNBQWlDLGtHQUFrRyxxRUFBcUUsbUVBQW1FLHdCQUF3QixvRkFBb0YsR0FBRyx5SkFBeUosSUFBSSxrQkFBa0Isa0lBQWtJLGdKQUFnSixvQkFBb0IsMENBQTBDLG1NQUFtTSx5TEFBeUwsK0ZBQStGO0FBQzV2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1lcy5qcz8yZjI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nRXMgPSB2b2lkIDA7XG5jb25zdCB3b3JkbGlzdF9vd2xhX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC1vd2xhLmpzXCIpO1xuY29uc3Qgd29yZHMgPSBcIjBhcmVydG9pb3RhZG9ub2FSdGVpcnJvZW5hTm9uYUxzb2xvY29pbGlhcmFsYW9ycmVuYWRhQ2hvTiRuMEE+RG9tLEVqYUkhI09nYSZPJ09yI1Jhem9SKlVlPVU8MEFiIEFkZW1AQ2U8Q35FaSlFbGdhRW4jRXB0IEkmTCAgTmVPZyFPPFRpdm9Ub1RyaXpUdSBVZCpVISZVcyAwSWMjTWl0Kk9wdCBPcidVYWBVbCMwUmVvMEVjdCBJY35JbiBJcm0gMElsSXQgT25AT3MjT3QgUmVnIFIkVWFVJlU/YVVqYTBPZ29PciswUmVTbCAwRWRfekUnVXMpMUFjW25BbWJfQXJtYUJhQnVtQ2FsZGVEZWFFZ19FaiBFciVFJUY/IUdhR28mbklhJkksI0l2JE1hTWVqYU1pYiBUIFRlemFUaXZvVG9UdVtVbSdaIDBBYmxlQW4pQXBvXUFyZ29BcyBCIEJpI0UnSWdvSXMlZE9yUCBvUGwkMHxvQ0AnQ11EIEQsRW1AR3U9SWw9SW1vSXNPdCBULGFUaWd1b1Rvam9VYWxVbCBVbmMkQWQqRWpvTzFBZyBBWyNFdGkjSW9MaWMgTyZPcilPeW9SLGQhUm9iIFVlcyVVKzFBJkFgQXJCaXQrQm9sQnVzI3xpdm9Db0QhRD9dRHVvRWFJJkllc00uaS1lc09tYVBhUC5SZWc9Um96UnVnYVRlVGlzJTBBQSZBbCNDLDxFZ3VyIEVvRTxySSwjST1Jc3QqTm9PbWIrUCFvVD9dVCtUdSNVbSpVbiMwQWpvQXF1ZUFyRW4jRW9JPkxlJU9tb1JhIVJvelVuMERhekQkR2VMYU0sI1MsKVReMEFsQW5jZUErRUVsXWBFYEVzdHJ1ekkuSTwyRXJVe1UnMEFmW25Bck8pVWMgVWZfVWw6QmFCXnxlSEBJbGVKIExhbnovYy5MZGVNYnVOPk5kLW9SYig+Um5pelIrU2N1XVMjblN1W1RhbF1UIUBUKlR1JVVsWiAzQmVCaWQvPVMgU29TdEAzfG9Fbk5nbzJBbj5PcXVlVXNhMkFCaWBCb0NhQ2lgRGFEZWdhSW4vLyFvTHNhTWIte2ROaSNOfXNhaVJkZVJyIFNxdWVUZVRpblZle1phbDJBdm9Bem9FY2hhRXZlSWw9SW4+SXNhT2NhT21hT25jZU8pVWphVXM+VSMyQ2VvQ2xlRSdFeUZhbntGLkhvSXRfTCNSYnVqKGwoK1NjIFRhY2FaLjpCYWw9QmV6YUJpYEJbQ2FvRGF2IUQsYUVyRmVJe0ltYW5KYUouTExhbSBMYyRMJkxpe2RMbGVMbS9eTHZvTWFNYiRNZWw9TWknTXB9YyFOZD9OZWwtZ3UrTmljLSNOLS5PYmFPc1BhelBpJW5QbylQdCBQdWNoKChiLlJjZWxSZSVSZyhpJ1JuZVJwZSVSK1IlU2FTPlMhb1NwYVMjclReY2VUX1V7bFVzYVpvM0JvbF1EIUQrTGQvZWJfTG88THVdTSwjTml6LXQrUmMoJlJleihvUnIgUil6YVNwZWRUKzJBY2FsQWxlPkFtcHVBbmNdQXBhQXJdST5JcylJdm9PcXVlT3phVWxlJVVwIDBDbC5FZ29FPUVuRXIjRltHICtNLT5OZU4lUF9zUj5SdWVdU25lVGFVe2QyQW1eQW5BK0FzZUF2ZUksKUltYUluaWNhMkJfQ2N+fGknQ2lgQ29EaWdvRG9GX0chSGUpSmluSm9ML2NoL2VnJExnIExpbi9sIExtb0x1bWBNYmEpTSFNaXtNbyZNcHItZGVOZWp9Zy1vYyFOc2VqfXQgUGFQaShhei5SYmElUmNob1ImblIuKHIhUyFTbW9zUyUyQW5lb0F0IUUgRWMhRWkmRW1hSWFJbSxJcCVJc2lzT21vT25pY2FPcXVlJVUmVXoyQWQrQXIjQXQrQm9Ccip8IGFFbD1FbiNFcntFcyVFdmFJZCBMZWJyL3AvI01iX01wbCpOLWUlTyVQLlB1bCggUiQ8UjxSdmFUaXM6TS16KFImVD8zQiFCP0Nhe0MqRG9GLHNhRmluKkogTGZpbkxnYSZMaSNNXi08TiVsUF4pUmVjaG9SKyVTYXl1J1Nlb1NmP2VTbnUmU3RpJ1N2JFRhbGxlVCwhVXszQUFiPUFkZW1hQW1hbilBYEFyJEJ1am9DdCBFbilFJUV6RmljP0cnTGVtL3UqTiFvUmVjI1JpZypTPlNlJ1NmW3pWYVZpJzVCbGVDZUxeTWluZ31OIFJhJlJtKlI8U1NpczJBZy5PZ2EyfGFEYUU9RSdMY2VPUXVlUiBSZXoobzowQSdSJDBIIE9VYSZyMEFkSWN+SWZpYyRJI3JVYyAxRWMjSWNhejNFRW1wPTFFZmFuKUVnKkVtLCNFdiBJcHNlSSlJeCpPZyRVZCowQnUmSXQqT2N+UGEpUGUnUGxlb1Bfc2EwQSdDIGdvfHVmZUNARW1pZ29FK0ZhJkYhbW9HYSdJZ20vYWNlT3JtZVJlJlNheW9TLCBUIW9UciBWYXNlViQxT2NhMFVpcG8wSXpvMENhXUMsYUNvbCBDcmliKkN1JkVuY0BGIWFGdSF6b1Bhe1Blam9QQFBvc2FQdW1hUXVpVCBUZVRpPVR1ZmEwQXBhRXInSWMtQDFBZCpBbHUgRW4jSXQgMUFjI0FtLENlPEN1c2FFbiNJZypJbCRJc3QqSSNQISNQbGljIFAuIVRfbW86QnJpY2FCdV18YXtDP0MjckVgSi9kLz1MPEx0IE1hTT9ATW88UmEuUm1hY2kob2xSc2FTZVRpZ2FVYFZeWDNCciFvfC9pek9SaShvelJ0P1J2XlN0aW4zQWJsZUFuemFBckJbQ2N+fGFEZW9FYl9FbEVbRXMlR3VbSiBKb0wvZSlMQGxMdCtOTmMtZypOaSNSbWEyQT5BdSVFY2hhT3JPJVUqVWpvVV4yQkBDYUdhJUcuTCRMbGUjTiZSbSgrUnR1bih6IFNhVG8yQWNhPEFnP0FuamFBc2VBdWRlRSpFJ0VzYUlvSSNVJTJFZ29FbilFcnphR2FNIE5jfk5kKGcuUkBTP1Rib2xUdSs6Q2VdRmFzSSVKb0wvIWkvPU1iLSBOY2h9Zy08UmFqZVJ6YVNvbGlgU3QgVG9WP2FuM01lPU0qTk4hfSROKVJhbiRSLClSbSxTIzNHYW4pTWBzJFIgUm8yQWNpIE9ib09yQDJMTGZvTG88THBlTSgmUj8oW1RhVGVvWiAyQXtBZmk+QSdBc2FBdGlzQXZlSWUlSWw9SXBlSXNJI088clVhVWU8VW1vVXBvMkFuKUFwb0FyZEBFcltJYUknSS5JPEl0IFtTYSdTdCA6QiFCP0JsIEMhfGFEL2wgTWFjKGlgWlphYDNCP11CW3xvTGEmTCRNYnIoKlJtYSdSb2VSdiozRT1FcitHYSZHaSxlSm9NJ1MjckA1Q2k+RyBHdSFhSmFNYl9OZ31eTnIoKG1pZygnU3Q/WW81RT5FbGdhRXIlRTxFdm9Je0lyTWEnTWUmTT9kZU19ZCpSYWNhblIjOjFPJzBFYWxJb21hTz0yTGVzaS91VWFsNEVnYWxVc34wQWcsQW5JdCBQIFAhJFAuIVB1bDwwQ2FwYXpEaWNlRXIpRmllbEZebWVHLCRJYyRNLDxNdW5lTmEjU2VjI1MlbilUIWVzVGltb1R1KlV0P1ZpISczQUlzT25AMEwvbyk6QmFsaUIuTS5SYWJlUmRpblJbVV1abWluM0ZlUmluZ2EzTmUpNVJgZChvYmFWLFlhNUVyZ2FFdmVzRXpHYSZyR29HdWUpSWMkTj5OZ2wtJE50IFBpdCFSIFMjViw/WmcgOjdMbzVBXTpCJEMkQ1tEb0QrbkcgI0dyaW1hR3VgST5NIU1pYE1wIC0tY2gtZ29zJU56YVBpelJnb1J2YVN0aW1hVGFUZXhUKlVfbFYgWm8zQWxDY358ZUMjckVyR35HdW1iX0phJ05ndS0jTmFPbk9wICZTflRhbFRbVmVZLHszQiElZEIrQ15EIURpIEVuem9HYUchb01hTWkpTS5NcCROY2VOJk5lLWdvKU59dCFgUXVpJlNvUyVUIWFUJFQrMkFnYUFtYUFuI0F2ZUVnIEVuIEV2IE9yIE92IVV2QDJCb0N+Q29DdVtHaWNhRytNYnJpek19amFUZTV8YUMqRyBKfS1lc1BhU3QrVG9aOkNlJXxvRCFhRF9EdStFc3QrRkBHQEdvSXpMe2RMZSVMbC9vTWFNYm9NdXROPk4mTmVqIE5nLWlxdWlOaiBOfTxOJU5hYFBhUXVpbihSPlJlKGY/UmcsUmkmUm1vbFIrblIpc1J6b1NhU2MgYVNpdm9UIFQhQFRpelRyaXpYaW1vWV5aXmNhM3xhRGFsXUQkRHVdSj9dSl5MLC8uTV5pLV5Oc2FqZU4pTnVSY2EmUixndWVSaSNTUy5UYVQhVG8mVCtaY10zRSZFbEVtYitHL0xhZytMaXQgTGwuTX0tIX1pbX11I09wZVIgU2FTIUBTP1Ntb1RhZFRvNXw/YUN+RGFEZT1Ib0ogTGRlTCFMaSdNLCNNaS0gYy1lZC1qLSNOb1JhZChkIVJlJ1IqUitScyglbFNjYVN0ciBUaXZvViFWP1pvNXxvRCBFYmxlRV1FcilFc3RbR19KIUwvZSVMJU4mTmVjKGFsUm9TY3U9U2VvU2dvU2ljYVM9OkMgQ35EIElwZVJhbmooaXpSciBTYWxUYWxUaXZvVHVbbFVzZWFWYWxWZVZpe2QzQyRDdCBHIEdvYyRHK09uUnYkVG9VdCtWIFYhYTN8b0RvRWJdRSNOZXpOb1RpJlZlbDVCbGV6YXxlTWluKGkobSgpVGFUaWNAVmEjVmVdViQ1QmVDYUNsZW9EPz1Eb0VbRXZlRXpMb00hb1RyQDpTaXMwRTxJc3BvSmUjUighb1MhdiBULCFWJDBBQTxFYSdILCVIb0lvUmVUYXZvVHViX1VsI1VwIFVyciowSSBJb0lzZWEwUykwRW5zYUVyJUljJFJlYyEwUm8xRG9SME8xQUVhe0ZhI0l2b0xhTW9PclZpJjBCbGlnbzBEYVphMUE+Q35FW0luIE9uIVQgVGljYVVlcyMxQWN+QSZyQWxCaSVDYUQsRWphR2EnR0BHdWw9SSwpSWcsSWxdT1F1ZXMlVWdhMEFkQEN1K0V6J09UWzBPJ1JvMUVqYVU9MUkmSWdlJzBFbikwTyc6QyNEX0VsXUdpYEdvSXNKIG9MYWJyLz5MZSVMaSZMbS9vbS9wIE5OYWxOaT5OdCEtdWU9UGFQZWxQP11RdWUpUiBSY2VsKGVkUipSb1JwYSZScXVlUltmb1IpUyBTZW9TflNvUyVUYVQkVHJAVXNhVSVWb1lhPDNBI25DYSZDIWF8b0RhbEQqRyBJbmVMIEx7J0xlL2lnK0xsZWpvTG9MdWMtLXMgTi5Pbk9yUGknUXVlJ1IoY2goZCFSZXooZj9SaT5SbChtaTxSK1JzLmFTYVNjYVNpbW9TJWBUYT1UK2xlb1padWAzQyB8LkVFZFtFcmBFemFKYW0vIExvI01pLCVOfSNyTnotYU9qb1AoYSVTIFNjaWBTb1MlVC5aY2EyQWNhQW5BJUF5YUF6YUVpI0UnT21vVW1hVVtsMkJfQ29EIUQkRW1hRXNARSVMLExpY2kvPUx2b01he01lPU1vTXAtIVJjflIlbFNhe1NlIVNpYmxlUylULGNAVCtabzJBJkU+ekVndW4lRW0kRW5zYUU8RXYkSW1vSW5jaXBlSXN+SXYgT2FPYiBPY2U8T2R1YyNPZXphT2ZlPHJPZ1ttYU9sZU9tZXNhT24jT3AkT3hpbW9VZWJhMkJsaT58IW9EXkViPUVyJUVzI0xnLypMbS5McG9MPE0tI05hbE5vUGFQPyhlOjk5RWQgRWphRW0gRXIhRTxJZSNJbWljYUluY2VJdCA6QmEnQkBCb0N+RGljYWxJek1hTXAtY2h9Z29QYXpQaSZQI1Nnb1NwYVRvWW9aYVouM0FjY35BbGl7ZEJhJ0JvKUNhIUNlJXxhem9Db2chQ19vQyNDdXI8REQuJkR1YypGbGVqb0ZebWFGW25GdWckR2E9RypHXUdfPEgsSSdJckovYSNMZXZvTGlldmVMbGUnTG9qTSBNZWQkTX0+ck5kKk4lUCAjUGV0KlBvPFB0P1NTY2EpU2lgU3BlI1MjU3VtLFQqb1ReJ1RbI1VuKlZlc1ZpcyVZWiAzQ29FZ29FbntFc2dvRmFHaSZHXk5jLk4uT1F1ZXphU2FUbW9Ub1pvNUJsZUNlQ2kgRCBEZW9EP11Fckppem9Kb00hb01wIU5OPk57UGFQIW9TYVNjYVN0K1QgNUJpQl5Eb0V7RypJJkluL2UlTG9NYm9NXlB0dVtUYVRpYDpCYSZCIUIkQmxlQyBHYXpHWyZMLyZMIW9MKkxtLkwuTHMvI0x1ZEx2IE1iLWN+TmRpLWUgTmdfTml7ZE59I1BvUXVlUmRpbigpblN0X1RhblVgWG9mLjNDY35Db0NfI0MlREd1KklzTD1MdmFNYWBNP2wtZC08ck5hbE5eUCAgUEBRdWkoUmllUm0uUnYqUywlU35UYVQsJVYhb1hvWCMzRFtFcyVFKUc9RydMYWIvYiBMLGMkTF1NYm89TSRSLGFTKW1hVCRUdSA1Ql9DJEQkTExhcC97Jkxle2RMaSZMdCBMdWN+TWJyLWRlfWkmTm8rTnJpc2FQYVBsIFBeKVImUnBfcygpb1MpblRhJzVBdmVCKkNlPEReRWdbRT1FJ0VyKUZyKkplI0wlbk0gUCEgUGwqUC4hUF9tb1JSPlJlJ1JnKlMjVD86QmE+QmlxdWVCXUJ1Q29DI0pvTCBMPkwsI0xsLy5NYSdNYl5OZ31xdWVQYVBlKVBAUC5RdT9sKGRlUmUoaWYoamUlUm90UitSJVR1YWplVStaYVouM0F0K3xvQ11DbmljYUphJkohSmkmTC9lZm8nTWFNXk1wPU5hek5kIU4hTmlzTjxPcmkoYXBpKD5SbWknUm51cigrclNpc1NvK1N0aWdvVCFhWCNaM0IkQnUrbkVtcG9FbntFcltFPEdfSiEvZGVNYl9NaSZNfSVPUGk+UG9SKC5UYW5UIWVUdT1aYTVBbF1CPz1DIENpJ0RvRy8mTSBOfSNQIFBlUXVlUmF4UiFvUm0sJVJuZW9Sb1JwZSZSX1I8UnR1Z2FTUz5TIVhpPjJBYmFqb0FjI3JBIUFmaT5BZ29BamVBbW9BbmNlQSNBdW1hQXogRWJvbEVndWFFaW4lRW5FcCBFc0lidUlnb0lwYUlzKUl1bmZvT2Zlb09tcGFPbj5PcGFPKU96b1U+VWUnVWZhMkIhQEJvRXIjTWJhTV5OZWxOaWMoYmluKGlzbW9SJ1ReOjBJYyA5QyFhMEJbbDBJe2RJckl2ITxPVCBBM0JhJ0JlRywpTmEwQXJVICQwSWxPcEAxQTpDYUMkQ3VgRyBHb0lgSj9sL2VMaSZMbGVMXkx2dV1NcCpvUihpIFIuU28zQ2knQyNySGljdT1JbilKZXpMLyFvTG96Ti1jIU5kLWUnTmcgTipOJU51c1JSYSdSYm9SZGVSZWQoaig8UnQhM0FBamVCciBDJEN0aW1hRGFEZW9EciRFam9Fcm5lc0deTExsLWFnX059ZSZPbGluUmFsUmdvUnR1ZFNeU3AhYVMlVGFtaWBVJlZhelYhb1YqVm81TGNhbkx1bSxMdiFSYXpUIFRvWjVFPUxnIDo6OkMhVGUzR3VhTSgnU285RG9HYUd1cjpGKn1qYVBhI1J6YTkzTigrNU1vUiZcIjtcbmNvbnN0IGFjY2VudHMgPSBcImFlaW91NzY5NUBAQlpXV2F2d1VKa09AWS1LbikpWUVHcSNFQE8pY0lAI1prTUh2JGUqKSlNISEpRCoqJEdXIW9LbSpBY29oXmsmSXQtcGleU1lXKSRebiFHKWJPIVdremFtKGpTI1gpT2cqXmxeUlchYlEjUXlnQktYZnpFKSlodGkhUW0pQ25nJSVjKW1KaUkqSEpXYm1ZbmlDTHdOZFl5WSVXS09eYm5UJFB1R09yIUl2SHUmRyhHS2J0QnVoaVcmIWVPQFhNZW9ZUWVDYSMhTXJUSkNxIU9XJkNIRyhXQ2NXJSUpJHJmckllZ3UkKXchRylKR21XV3cpTW5EJVNYWFdJVF5MV0FadVZXQl5XKWVUTF54JiRXR0hXKG5LV0VNQSkjJEYkeCRXYWVrcXMsbjc3MTUpVypITS0kV0FjQ2l1KGEpKVZDWilHRyUoKkNXV2RXJSREIVVDTyRNXCI7XG5jb25zdCBjaGVja3N1bSA9IFwiMHhmNzRmYjcwOTJhZWFjZGZiZjg5NTk1NTdkZTIyMDk4ZGE1MTIyMDdmYjlmMTA5Y2I1MjY5OTQ5MzhjZjQwMzAwXCI7XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS1lc11dIGZvciBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nRXMgZXh0ZW5kcyB3b3JkbGlzdF9vd2xhX2pzXzEuV29yZGxpc3RPd2xBIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgU3BhbmlzaCBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdFc11dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImVzXCIsIHdvcmRzLCBhY2NlbnRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0VzYGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdFcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdFcyA9IExhbmdFcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-fr.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-fr.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangFr = void 0;\nconst wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js\");\nconst words = \"0erreleontiteurinueiriet cegeanseali medenel q)eniluxaus ch0Ais}And$Diqu E`#Ol*Ord Ou%rOy RasifReuv Ri,Rog RuptS_-SoluS'@UsifYss=0A@m+AjouAr+nCab]Cep,Clam Cola@Cro~eCu}ErbeHatHe,Idu]I Omp&Qu *R$y?Te'TifT)l0Ep&EquatHesifJec%fJug Mett!M* Op,Or Ouc*Res<RoitUl&V be0R R$ef0Fai!Fec,Fi~eF!{Fub]0Ac Enc I#I,Raf Reab#Ru?1D Gu`#L>Mab#S/-0Ou,Us,1Arm Chim+Er&Geb!G)I_ I?ntLeg Lia.Lou Lum O'd*PagaTes<Veo#0A&'BiguB!Enag Ertu?Id$Ir=Orc O'Ovib#Phib+P#'Us/t0Aly<Apho!Ar~+Atom+C+nE/%rG#Gois<Gu#{Im=Nex N$-N)lOd(Om=+Ony?Orm=T_[Tido&X+{1Ai}Eri%fL/*Olog+Pa!`Pe]Por,Puy 0UariumUeduc0Bit!Bus&De'Doi<G_tLequ(Matu!Me?ntMoi!Mu!P_,Ra~ Riv Ro}S_icT +lTic#0PectPh=&P* S|tS v*S+t&Soc>S' TicotT!Tu-0El>O?RiumRo-Ta^T_%fT* Trap 0Ba(eB .Da-Dib#G' Ro!Tom[Tru~e0A]Anc Ari-En*Er<Eug#Ia&'I@I$I}O(eOu R`1I=Io?:D.Fou Ga.G)t&Igna@L/c Lc$Le(eLisa.Mb(Ncai!Nda.Nl+)Nn>eNqu>Rb>R`R$R^Rra.Ss(S%$Ta`#Te|T,+Udr>Vard 3Let&L>Lo&Nefi-R-|Rg Rl(eRmudaSa-Sog[Ta`Ur!3B $Cyc#Du#JouL/L(g)LlardNai!Olog+Ops+OtypeScuitS$Sto'iTu?Zar!2AfardAg)An~*Ess/tInd OndOqu Ous$2BardB(eI!I}Li@Nb$Nd*Nhe'Nif>NusRdu!R[T&Uc#Ue{Ug+Ul$Uqu(Ur<Usso#U%^Xe'2An~eAs>AveEbisE~eEuva.Ico]Iga@Ill/tIo~eI^O~u!Od Onz Ous<Oye'U?Us^Ut=Uy/t2Ff#Iss$L#%nRe|R(S% T( To*Vab#Vet&:B/$B(eChet&De|D!Fe(eIllouIss$Lcu]Lep(Lib!Lm Lomn+Lvai!Mara@M aMi$Mpag[N=Net$N$N%[NularPab#Por=Pri-Psu#P,Pu~eRab(eRb$eRes}RibouRna.Rot&R!|Rt$Sca@S>S^Ssu!U}U%$V=>V [Viar3D`#Intu!Les&Llu#Ndr>Ns' Ntr=Rc#Rebr=Ri<Rn Rve|S}2Agr(Ai<A#'Amb!An-Apit!Arb$As<'At$Auss$Av* Emi<En`#Equ>Er~ Ev=I_Iff!Ign$Im eIotLoru!OcolatOis*O<O)t&Ro?U&0Ga!Gog[M_,NemaNtr Rcu]R R^T [Toy_Tr$V`2A*$A?'Aqu As<Av>I_tIgn ImatIva.O~eOna.Opor&2B=tBraCas<Co% D Dif>Ff!Gn Hesi$Iff Inc L eLibriLl(eLma,L$elMbatMed+Mm/@MpactNc tNdui!Nf>N.]Nno,Ns$[NtactNvexePa(P+Ra`Rbe|Rda.Rni~eRpusR!ctR&.Smi^Stu?T$U@Upu!Ura.U&|Uvr*Yo&2AbeA(&Ava&Ay$Eatu!Edi,E?{Eu}Evet&Ib]I Ist=I,eOi!Oqu Ota#Uci=UelYp,2Bi^E`l*Il]eIs(eIv!Lm( L%v Mu]Pi@Ra%fR<'3Anu!C#L(d!Ni^:Ign M>Ng N<'Uph(3Batt!Bi,Bord Brid But/tC= Cemb!Ch* Cid Clar Cor Cri!Cup]Da#Duc%fEs<F_sifFi]Fray Gag Givr Glu%rGraf Jeun Li-Log M/d Me' Mol*Ni~ Nou N&l#Nud PartP_}Pha}Plac Po}R/g Rob Sast!S-n&S tSign Sobe*Ss( Str>Ta~ Tes,To' T!s<V/c V_*V( Vo*3Ab#Alog)Am/tC,Ff  G  Git=G[Lu M/~eM(u Oxy@Rec%fRig Scu,Spo}Ssip St/-V %rVi}5Ci#C&'G?IgtMa(eMici#Mp,Na&'Nj$Nn Pam(eRto*Ru!Sa.Se'Ss>Ta%$U/>Ub#U-'U,Y_2Ag$Ap Es}Ibb]Oitu!2P +P#xeRab#Rc*3Nas%e:0Lou*0Ar,HarpeHel#La* Lip<Lo!Lu<O#Onom+Or-Ou,Ra}Rem Riva(RouU?U!u`0If>Uqu 1Fac Fec%fFig+FortFray Fusi$0Ali}Ar 2Ec,1Abor Arg*Ectr$Eg/tEph/tEveIgib#I%s?O.Ucid Ud 0B=]Bell*Bry$Er|@Issi$M_ O%$Ouvo*P e'Ploy Por,Pri<Ulsi$0Cadr Ch eClaveCo~eDigu Dos}DroitDui!Erg+F/-F m Fou*Gag G(Glob Ig?Jamb JeuLev NemiNuye{Ri~*Roba.Seig[Tas}T_d!T>To' Trav Um  Vah*Viab#Voy Zy?0L+n0Aiss*Arg[At/tAu#Ic +I@m+I Ilog)I[Iso@ItapheO^ReuveRouv Uis/t0U !Uipe0Ig Osi$Re'Up%$0C=>Pad$Pe-P+g#Po*PritQuiv Say S_-S+uSor Ti?TomacTra@0Ag eA]An~eA%^E(d!Endo*Er[lH/olHi^Hn+Ir Off Oi#Onn/tO'd*R/.RoitU@0Phor+0Alu Asi$Enta`I@n-I,Olu%fOqu 1ActAg  Auc Cel]Cit/tClusifCu<Ecu,Emp#Erc H= Hor,I.n-I]Is,O%^Ped>Plor Po}Prim QuisT_sifTrai!Ul,:B#Bu#{Cet&Ci#Ctu!Ibl*Lai<Me{M`#R-'RfeluR(eRou~eSc( T=Tig)Uc$U%fVe'Vori3Bri#C$d D  L(M?M'Ndo*Od=Rm Ro-Rve'S%v=U`#Ut!Vr>3AscoCe]C%fDe#Gu!Latu!Leta.L>eL#ulLm LouLtr N/c N*O#R?Ssu!X 2A* Am?As^At&'E|E~eE'Exi$Oc$O!Uctu Ui@Uvi=2L+Nd +Ngib#Nta(eRc Rg $Rmu]Rtu[Ssi#Ud!Ug eU`]Ulu!Urmi2Agi#Ai<An~*App Aye'Ega&E( El$Em*E[s+E!Iab#Ic%$Iss$Ivo#OidOma.Ont=Ot,Uit2Gi%fI&Re'R+{R%fSi$T':Gn Lax+L +Mbad R/%rRd+nRn*Rrig)Zel#Z$3AntLa%[Lu#Ndar?N =N+NouN%lOlog+O?t!R/iumR?St)lY}3B>C]RafeV!2A-AiveIs}ObeOi!Or+{2Lfe'M?Nf]R.R`#Udr$Uff!UlotUp`#Urm/dUt&2Ad)lAffi%A(eAndApp(AtuitAv*EnatIffu!Il]Imp Ogn Ond Ot&OupeUg U% Uy e2EpardErr>I@Im|veIta!Sta%f3Mnas&Rostat:Bitu@Cho*L&Me|NgarN[t$RicotRm$+Rp$Sard3LiumMato?RbeRiss$Rm(eR$Si,U!{3B n BouLar/tStoi!V 5MardMma.Mo.[N['Nor N&{R@Riz$Rlo.Rm$eRrib#U#{Us<5BlotI#{Ma(Mb#Mi@Mo'R]3Dro?lG+[M[Pno<:2Yl#2Nor U/e4Lici&Lusi$0A.Bib I,M_<Mobi#Muab#PactP i=Plor Po}Prim Pu,0Carn C_d+Ci@ntCl( Colo!Dex Di-Duc%fEditEp%eExactF(iFlig Form Fusi$G  H= Hib Jec,Ju!No-ntOcu]Ond Scri!Sec&Sig[Soli&Sp* S%nctSul,TactT_<Ti?Trig)Tui%fU%#Vasi$V_,Vi,Voqu 3Oni^Rad>ReelRi,0O]2Oi!Res<:GuarIll*MbeNv>Rd(Ug U[Velot3Tab#T$UdiU[s<9Ind!N~ Ng]Ue'UissifUrn=Vi=Y|Ye{5Bi]Ge?ntNiorP$Ris&S%-Te{V_i#:Yak7M$oOs^:BelBi=Bo' C  Cto<Gu[I[Is}I% Mbe|Mel#MpeN-'Nga.N,[P(R.'R?Ur>VaboVo*3Ctu!G=G Gu?SsiveTt!V>Xi^Zard3As<B  B!C_-Cor[E.Ev!Gatu!Go,G)M Mi&M$a@Mpi@Neai!NgotOn-|Qui@S>eS,ThiumTi.Ttor=V!'5Gi^Inta(Is*MbricT +U UrdUt!UveY=5B+Ci@Cra%fE'Gub!Is/tM>eNai!NdiR$T,X){:Ch(eGas(G_taGi^Ig!Ill$In%_Ir+Is$Jor Lax Lefi-Lhe'Li-L#t&MmouthNda,Niab#Nqu/tN&|N)lRath$Rb!R~/dRdiRi%?R^'Rr$R&]Scot&SsifT +lT>eTra^Udi!Ussa@UveXim=3Ch/tC$nuDa`#Dec(Di,Du<Il#'L/.Lod+Mb!Moi!Nac N Nh*Ns$.NtorRc!diRi&R#Ssag Su!T=Teo!Tho@T>Ub#3Au]CrobeEt&Gn$Gr L+uLli$Mi^N-N =Nim=Nor Nu&Rac#Roi,Ssi#X&5Bi#D [El#{Ndi=Ni&'Nna+Not$eNst!Ntag[Nu?ntQ)'R-|Rsu!R% Te'TifU~eUf#Ul(Uss$Ut$Uv/t5L%p#Ni%$Ra`#Re[Rmu!Sc#SeumSic+nTa%$T T)l3Ria@R%l#S,eThi^:Ge'PpeRquoisRr Ta%$Ti$Tu!Ufra.U%^Vi!3Bu#{CtarFas&Ga%$Glig Goc>I.Rve{Ttoy Ur$eUtr$Veu3CheCkelTra&Ve|5B#CifCt'[Ir-'I<t&Ma@Mb!{Mm Rma%fTab#Tif>Toi!Urr*Uve|Va&'Vemb!Vi-5A.Anc I!Isib#M oP%=Q)Tri%f:0E*Jec%fLig Sc'S v Stac#T_*T' 0Casi$Cup E/Tob!Troy Tup]Ulai!0E'Or/t1F_}Fic>Fr*0Ive1Se|S`l$2Fac%fIv>0Bra.Ett!0Ct){Du]E!{Iri^1A#A^Er Ini$PortunPrim T Ti^1A.{An.Bi&D$n E`#G/eG)`Ifi-Ne?ntQ)T+0C`]Mo<Satu!0Ar+0Rag/Rs$T`Trag Vra.0A%$1Y@Y.[1O[:Isib#La-Lma!sLo'@Lp Na~eNdaNgol(Niqu N[|NoramaNt=$PayeP>Po,PyrusRadoxeR-l#Res<Rfum R]Ro#Rra(R<m Rtag Ru!Rv_*Ssi$S&^T [lT+n-Tr$V`l$Voi}Y Ysa.3Ig[Int!La.Lic/L#Lou<Lu~eNdu#Netr Nib#NsifN'+Pi&PlumRdrixRfor Rio@Rmu,Rp#xeRs`R&S Ta#TitTr*Up#2Ara$Ob+O^Ot$Ra<Ysi^0AnoCt'=E-Er!Euv!Lo&N-|Pet&Qu Rog)Sc(eSt$Vo,XelZza2AcardAf$dAis*An A^Astr$A&|E' ExusIa.OmbOng U+Uma.2Chet&Es+E&In&Ir>Iss$Iv!Lai!Lic>L#nLyg$eMma@Mp>Nct)lNd  NeyR%^Si%$S<d Stu!Tag Te|Ti$U-Ula(Um$Urp!Uss(Uvo*2A*+A%^Ec+{Edi!EfixeElu@EnomE<n-E&x&Evo*Imi%fIn-Is$Iv Ob#?O-d Odi.Of$dOg!sO+Oje,Olog)O?n Op!Osp eO&g O)s<Ov beU@n-U[|0Y~o<1BlicC $I}LpeLsarNai<Ni%fPit!Rif>Zz#3Rami@:99AsarE!l#Es%$Ietu@It,O%_t:C(eC$,D+{G$d(I@'Is(L_%rLl$.Mas}Pi@Sa.Tis}Vag V(Y$n 3Ac%fAg*Ali}Anim Cevo*Ci,Clam Col,Cru,Cu]Cyc]Dig Dou,Fai!F#xeForm Fra(Fu.G=+nGi$Gla.Gul>I, Je,Jou La%fLev L+fMar^Me@Mi<M$,Mpl*Mu NardNfortNif]N$c Ntr NvoiPl>Por,Pri<P%#Qu(S veS(e{Soud!SpectS,SultatTabl*T_*Ticu#Tomb Trac Uni$Uss*V/~eViv!Vol&Vulsif3Ches<De|E'Gi@Go]Nc Pos,Sib#S^T)lV=V>e5Che{M/-Mp!N-Nd(Se|S>Ta%fTorTu#U.U`#U#|U%[Y|?5B/BisCheEl#G){In Is<|S S%^3Th?:B]Bo,B!Co~eFariGes<Is*La@LiveL$Lu MediNc%$Ngl>Rcas?Rd(eT' Ug!nuUm$U,Uva.V/tV$n 1AlpelAnda#E]atEnarioEpt!HemaI_-Ind O!Ru%nUlp,1An-Cab#Ch Cou C!,Da%fDui!Ig['Jo'Lec%fMa(eMb]M_-M(=Na&'Nsib#N&n-Par Q)n-Re(R.ntR+{Rru!RumRvi-Sa?V*Vra.Xtup#3D =Ec#Eg Ff]G#Gn=L_-LiciumMp#Nc eNist!Ph$RopSmi^Tu 1I 3Ci=C#DiumIg[{LdatLe`Litu@Lub#Mb!M?`Mno]N@N.'N[t&No!Rc>R%rS+T%<Uc+{Udu!Uff#U#v UpapeUr-U%r Uv_*0Ac+{A%=Eci=H eIr=3Ab#A%$ErnumImulusIpu]RictUd+{Upe'Ylis&0Bli?BstratB%lBv_*C-sC!FfixeGg  Ive'Lfa&P bePpl>Rfa-Rica&R?n Rpri<Rs|tRv+Spect3LlabeMbo#Metr+Nap<NtaxeS&?:BacBl>C%#Il]L_tLism/L$n Mbo'Mi}Ngib#PisQu( Rd RifR%[S<TamiToua.UpeU!|X 3Mo(Mpo!lNa`#Nd!Ne'N*Nsi$Rm( R[Rrib#T(eX&2E?Eor+Erap+Orax0BiaE@Mi@Reli!Ro*SsuT/eT!Tub 5Bogg/L /tMa&Ni^N[|P$y?R~eRd!Rna@Rp`#R!ntR<Rt)TemU~ Urna.Us}X(e2Ac%$AficAgi^Ah*A(An~ Ava`Ef#Emp EsorEu`Ia.Ibun=Ico,Ilog+IompheIp]It' Ivi=Omb$eOncOpic=Oupe|2I#LipeMul&N[lRb(eTe'Toy Y|3Mp/Ph$Pi^R/:0Ues^9Ti?Tras$1Ani?If>I$I^Itai!Iv s3AniumBa(Tic/t0A.I[UelU!0I#Op+:Car?Cc(Gab$dG)Ill/tInc!Is<|Lab#Li<Ll$LveMpi!N`#Pe'R>Se{Ss=S&3C&'Det&Get=Hicu#InardLo-Nd!diN  Ng Ni?{Ntou<Rdu!R(Rn*RrouR}RtuSt$T /Tus&X/tX 3AducAn@Ctoi!D/.DeoG[t&G)'La(Lla.Naig!Ol$P eRe?ntRtuo<RusSa.Se'Si$S^{S)lT=Tes<Tico#Tr(eVa-Vipa!5Ca%$Gu I#Is(Itu!La`#Lc/L%g Lu?Ra-R&xT Ulo*Ya.Yel#:G$:3N$:Cht:3B!NithS&9Olog+\";\nconst accents = \"e7693&)U*o&)Ry^)*)W))))#X^))))@@)#Wf)m%)#!))AG)&IIAQIIIBIIHJNAgBIILIDJGo)))HIQIIIIA(IGgJHH(BIIxX#)Ou)@*IAAPIIIJHQJ)&QIQPYI(HYAQC%)!))QHJJ@)#)^f*^AXCJ))$%CP))%&m)u)@e^A#G#))W@!(IKK%!(I%))O@QA))@GG#e))))WHJIWh))my@IIBT^)!)HAYGETHI*))!QnUDG)))nBoKAC*HwyQh))$&)G&)UGO)G)))(BX#v**)%O,e7686)I))@)&)gdMP()))ud)p#L))I^FIHYdWG))D@DFV)QA)o%MyTh%*)Z)%)n(XANc^R)YS\";\nconst checksum = \"0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-fr]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangFr extends wordlist_owla_js_1.WordlistOwlA {\n    /**\n     *  Creates a new instance of the French language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langFr]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"fr\", words, accents, checksum); }\n    /**\n     *  Returns a singleton instance of a ``LangFr``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangFr();\n        }\n        return wordlist;\n    }\n}\nexports.LangFr = LangFr;\n//# sourceMappingURL=lang-fr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1mci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsMkJBQTJCLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3ZELCtFQUErRSx3R0FBd0csb0hBQW9ILG1NQUFtTSx1Q0FBdUMsSUFBSSwrRkFBK0YsNklBQTZJLHFRQUFxUSxrQ0FBa0MsNlBBQTZQLGlDQUFpQyw4REFBOEQsa1lBQWtZLEdBQUcsZ1FBQWdRLElBQUksUUFBUSwrSEFBK0gsZ0JBQWdCLGtGQUFrRiwrRUFBK0UsMkRBQTJELHdJQUF3SSwyREFBMkQsa0JBQWtCLDZWQUE2Viw2QkFBNkIsc0JBQXNCLDJVQUEyVSwrRkFBK0YscUJBQXFCLFVBQVUsdU5BQXVOLDJDQUEyQyxzQkFBc0IsV0FBVywyRkFBMkYsb1JBQW9SLHlCQUF5Qix5Q0FBeUMsK05BQStOLG1UQUFtVCx5S0FBeUssMkJBQTJCLHdEQUF3RCwySUFBMkksMENBQTBDLE1BQU0sb0NBQW9DLHVOQUF1TixnVkFBZ1YseUhBQXlILHFFQUFxRSxzQkFBc0IsVUFBVSxzQkFBc0IsdUtBQXVLLDhHQUE4Ryx1REFBdUQsZ09BQWdPLDhGQUE4RixxREFBcUQsaUNBQWlDLDJDQUEyQyxrSkFBa0osMExBQTBMLGdRQUFnUSw2Q0FBNkMsb0JBQW9CLHVGQUF1RjtBQUM3M087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2xhbmctZnIuanM/ODY3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ0ZyID0gdm9pZCAwO1xuY29uc3Qgd29yZGxpc3Rfb3dsYV9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsYS5qc1wiKTtcbmNvbnN0IHdvcmRzID0gXCIwZXJyZWxlb250aXRldXJpbnVlaXJpZXQgY2VnZWFuc2VhbGkgbWVkZW5lbCBxKWVuaWx1eGF1cyBjaDBBaXN9QW5kJERpcXUgRWAjT2wqT3JkIE91JXJPeSBSYXNpZlJldXYgUmksUm9nIFJ1cHRTXy1Tb2x1UydAVXNpZllzcz0wQUBtK0Fqb3VBcituQ2FiXUNlcCxDbGFtIENvbGFAQ3JvfmVDdX1FcmJlSGF0SGUsSWR1XUkgT21wJlF1ICpSJHk/VGUnVGlmVClsMEVwJkVxdWF0SGVzaWZKZWMlZkp1ZyBNZXR0IU0qIE9wLE9yIE91YypSZXM8Um9pdFVsJlYgYmUwUiBSJGVmMEZhaSFGZWMsRml+ZUYhe0Z1Yl0wQWMgRW5jIEkjSSxSYWYgUmVhYiNSdT8xRCBHdWAjTD5NYWIjUy8tME91LFVzLDFBcm0gQ2hpbStFciZHZWIhRylJXyBJP250TGVnIExpYS5Mb3UgTHVtIE8nZCpQYWdhVGVzPFZlbyMwQSYnQmlndUIhRW5hZyBFcnR1P0lkJElyPU9yYyBPJ092aWIjUGhpYitQIydVcy90MEFseTxBcGhvIUFyfitBdG9tK0MrbkUvJXJHI0dvaXM8R3Uje0ltPU5leCBOJC1OKWxPZChPbT0rT255P09ybT1UX1tUaWRvJlgrezFBaX1FcmklZkwvKk9sb2crUGEhYFBlXVBvcixQdXkgMFVhcml1bVVlZHVjMEJpdCFCdXMmRGUnRG9pPEdfdExlcXUoTWF0dSFNZT9udE1vaSFNdSFQXyxSYX4gUml2IFJvfVNfaWNUICtsVGljIzBQZWN0UGg9JlAqIFN8dFMgdipTK3QmU29jPlMnIFRpY290VCFUdS0wRWw+Tz9SaXVtUm8tVGFeVF8lZlQqIFRyYXAgMEJhKGVCIC5EYS1EaWIjRycgUm8hVG9tW1RydX5lMEFdQW5jIEFyaS1FbipFcjxFdWcjSWEmJ0lASSRJfU8oZU91IFJgMUk9SW8/OkQuRm91IEdhLkcpdCZJZ25hQEwvYyBMYyRMZShlTGlzYS5NYihOY2FpIU5kYS5ObCspTm4+ZU5xdT5SYj5SYFIkUl5ScmEuU3MoUyUkVGFgI1RlfFQsK1Vkcj5WYXJkIDNMZXQmTD5MbyZOZWZpLVItfFJnIFJsKGVSbXVkYVNhLVNvZ1tUYWBVciEzQiAkQ3ljI0R1I0pvdUwvTChnKUxsYXJkTmFpIU9sb2crT3BzK090eXBlU2N1aXRTJFN0bydpVHU/WmFyITJBZmFyZEFnKUFufipFc3MvdEluZCBPbmRPcXUgT3VzJDJCYXJkQihlSSFJfUxpQE5iJE5kKk5oZSdOaWY+TnVzUmR1IVJbVCZVYyNVZXtVZytVbCRVcXUoVXI8VXNzbyNVJV5YZScyQW5+ZUFzPkF2ZUViaXNFfmVFdXZhLkljb11JZ2FASWxsL3RJb35lSV5PfnUhT2QgT256IE91czxPeWUnVT9Vc15VdD1VeS90MkZmI0lzcyRMIyVuUmV8UihTJSBUKCBUbypWYWIjVmV0JjpCLyRCKGVDaGV0JkRlfEQhRmUoZUlsbG91SXNzJExjdV1MZXAoTGliIUxtIExvbW4rTHZhaSFNYXJhQE0gYU1pJE1wYWdbTj1OZXQkTiROJVtOdWxhclBhYiNQb3I9UHJpLVBzdSNQLFB1fmVSYWIoZVJiJGVSZXN9Umlib3VSbmEuUm90JlIhfFJ0JFNjYUBTPlNeU3N1IVV9VSUkVj0+ViBbVmlhcjNEYCNJbnR1IUxlcyZMbHUjTmRyPk5zJyBOdHI9UmMjUmVicj1SaTxSbiBSdmV8U30yQWdyKEFpPEEjJ0FtYiFBbi1BcGl0IUFyYiRBczwnQXQkQXVzcyRBdiogRW1pPEVuYCNFcXU+RXJ+IEV2PUlfSWZmIUlnbiRJbSBlSW90TG9ydSFPY29sYXRPaXMqTzxPKXQmUm8/VSYwR2EhR29nW01fLE5lbWFOdHIgUmN1XVIgUl5UIFtUb3lfVHIkVmAyQSokQT8nQXF1IEFzPEF2PklfdElnbiBJbWF0SXZhLk9+ZU9uYS5PcG9yJjJCPXRCcmFDYXM8Q28lIEQgRGlmPkZmIUduIEhlc2kkSWZmIEluYyBMIGVMaWJyaUxsKGVMbWEsTCRlbE1iYXRNZWQrTW0vQE1wYWN0TmMgdE5kdWkhTmY+Ti5dTm5vLE5zJFtOdGFjdE52ZXhlUGEoUCtSYWBSYmV8UmRhLlJuaX5lUnB1c1IhY3RSJi5TbWleU3R1P1QkVUBVcHUhVXJhLlUmfFV2cipZbyYyQWJlQSgmQXZhJkF5JEVhdHUhRWRpLEU/e0V1fUV2ZXQmSWJdSSBJc3Q9SSxlT2khT3F1IE90YSNVY2k9VWVsWXAsMkJpXkVgbCpJbF1lSXMoZUl2IUxtKCBMJXYgTXVdUGlAUmElZlI8JzNBbnUhQyNMKGQhTmleOklnbiBNPk5nIE48J1VwaCgzQmF0dCFCaSxCb3JkIEJyaWQgQnV0L3RDPSBDZW1iIUNoKiBDaWQgQ2xhciBDb3IgQ3JpIUN1cF1EYSNEdWMlZkVzPEZfc2lmRmldRnJheSBHYWcgR2l2ciBHbHUlckdyYWYgSmV1biBMaS1Mb2cgTS9kIE1lJyBNb2wqTml+IE5vdSBOJmwjTnVkIFBhcnRQX31QaGF9UGxhYyBQb31SL2cgUm9iIFNhc3QhUy1uJlMgdFNpZ24gU29iZSpTcyggU3RyPlRhfiBUZXMsVG8nIFQhczxWL2MgVl8qViggVm8qM0FiI0Fsb2cpQW0vdEMsRmYgIEcgIEdpdD1HW0x1IE0vfmVNKHUgT3h5QFJlYyVmUmlnIFNjdSxTcG99U3NpcCBTdC8tViAlclZpfTVDaSNDJidHP0lndE1hKGVNaWNpI01wLE5hJidOaiRObiBQYW0oZVJ0bypSdSFTYS5TZSdTcz5UYSUkVS8+VWIjVS0nVSxZXzJBZyRBcCBFc31JYmJdT2l0dSEyUCArUCN4ZVJhYiNSYyozTmFzJWU6MExvdSowQXIsSGFycGVIZWwjTGEqIExpcDxMbyFMdTxPI09ub20rT3ItT3UsUmF9UmVtIFJpdmEoUm91VT9VIXVgMElmPlVxdSAxRmFjIEZlYyVmRmlnK0ZvcnRGcmF5IEZ1c2kkMEFsaX1BciAyRWMsMUFib3IgQXJnKkVjdHIkRWcvdEVwaC90RXZlSWdpYiNJJXM/Ty5VY2lkIFVkIDBCPV1CZWxsKkJyeSRFcnxASXNzaSRNXyBPJSRPdXZvKlAgZSdQbG95IFBvcixQcmk8VWxzaSQwQ2FkciBDaCBlQ2xhdmVDb35lRGlndSBEb3N9RHJvaXREdWkhRXJnK0YvLUYgbSBGb3UqR2FnIEcoR2xvYiBJZz9KYW1iIEpldUxldiBOZW1pTnV5ZXtSaX4qUm9iYS5TZWlnW1Rhc31UX2QhVD5UbycgVHJhdiBVbSAgVmFoKlZpYWIjVm95IFp5PzBMK24wQWlzcypBcmdbQXQvdEF1I0ljICtJQG0rSSBJbG9nKUlbSXNvQEl0YXBoZU9eUmV1dmVSb3V2IFVpcy90MFUgIVVpcGUwSWcgT3NpJFJlJ1VwJSQwQz0+UGFkJFBlLVArZyNQbypQcml0UXVpdiBTYXkgU18tUyt1U29yIFRpP1RvbWFjVHJhQDBBZyBlQV1Bbn5lQSVeRShkIUVuZG8qRXJbbEgvb2xIaV5IbitJciBPZmYgT2kjT25uL3RPJ2QqUi8uUm9pdFVAMFBob3IrMEFsdSBBc2kkRW50YWBJQG4tSSxPbHUlZk9xdSAxQWN0QWcgIEF1YyBDZWxdQ2l0L3RDbHVzaWZDdTxFY3UsRW1wI0VyYyBIPSBIb3IsSS5uLUldSXMsTyVeUGVkPlBsb3IgUG99UHJpbSBRdWlzVF9zaWZUcmFpIVVsLDpCI0J1I3tDZXQmQ2kjQ3R1IUlibCpMYWk8TWV7TWAjUi0nUmZlbHVSKGVSb3V+ZVNjKCBUPVRpZylVYyRVJWZWZSdWb3JpM0JyaSNDJGQgRCAgTChNP00nTmRvKk9kPVJtIFJvLVJ2ZSdTJXY9VWAjVXQhVnI+M0FzY29DZV1DJWZEZSNHdSFMYXR1IUxldGEuTD5lTCN1bExtIExvdUx0ciBOL2MgTipPI1I/U3N1IVggMkEqIEFtP0FzXkF0JidFfEV+ZUUnRXhpJE9jJE8hVWN0dSBVaUBVdmk9MkwrTmQgK05naWIjTnRhKGVSYyBSZyAkUm11XVJ0dVtTc2kjVWQhVWcgZVVgXVVsdSFVcm1pMkFnaSNBaTxBbn4qQXBwIEF5ZSdFZ2EmRSggRWwkRW0qRVtzK0UhSWFiI0ljJSRJc3MkSXZvI09pZE9tYS5PbnQ9T3QsVWl0MkdpJWZJJlJlJ1Ire1IlZlNpJFQnOkduIExheCtMICtNYmFkIFIvJXJSZCtuUm4qUnJpZylaZWwjWiQzQW50TGElW0x1I05kYXI/TiA9TitOb3VOJWxPbG9nK08/dCFSL2l1bVI/U3QpbFl9M0I+Q11SYWZlViEyQS1BaXZlSXN9T2JlT2khT3IrezJMZmUnTT9OZl1SLlJgI1VkciRVZmYhVWxvdFVwYCNVcm0vZFV0JjJBZClsQWZmaSVBKGVBbmRBcHAoQXR1aXRBdipFbmF0SWZmdSFJbF1JbXAgT2duIE9uZCBPdCZPdXBlVWcgVSUgVXkgZTJFcGFyZEVycj5JQEltfHZlSXRhIVN0YSVmM01uYXMmUm9zdGF0OkJpdHVAQ2hvKkwmTWV8Tmdhck5bdCRSaWNvdFJtJCtScCRTYXJkM0xpdW1NYXRvP1JiZVJpc3MkUm0oZVIkU2ksVSF7M0IgbiBCb3VMYXIvdFN0b2khViA1TWFyZE1tYS5Nby5bTlsnTm9yIE4me1JAUml6JFJsby5SbSRlUnJpYiNVI3tVczw1QmxvdEkje01hKE1iI01pQE1vJ1JdM0Rybz9sRytbTVtQbm88OjJZbCMyTm9yIFUvZTRMaWNpJkx1c2kkMEEuQmliIEksTV88TW9iaSNNdWFiI1BhY3RQIGk9UGxvciBQb31QcmltIFB1LDBDYXJuIENfZCtDaUBudENsKCBDb2xvIURleCBEaS1EdWMlZkVkaXRFcCVlRXhhY3RGKGlGbGlnIEZvcm0gRnVzaSRHICBIPSBIaWIgSmVjLEp1IU5vLW50T2N1XU9uZCBTY3JpIVNlYyZTaWdbU29saSZTcCogUyVuY3RTdWwsVGFjdFRfPFRpP1RyaWcpVHVpJWZVJSNWYXNpJFZfLFZpLFZvcXUgM09uaV5SYWQ+UmVlbFJpLDBPXTJPaSFSZXM8Okd1YXJJbGwqTWJlTnY+UmQoVWcgVVtWZWxvdDNUYWIjVCRVZGlVW3M8OUluZCFOfiBOZ11VZSdVaXNzaWZVcm49Vmk9WXxZZXs1QmldR2U/bnROaW9yUCRSaXMmUyUtVGV7Vl9pIzpZYWs3TSRvT3NeOkJlbEJpPUJvJyBDICBDdG88R3VbSVtJc31JJSBNYmV8TWVsI01wZU4tJ05nYS5OLFtQKFIuJ1I/VXI+VmFib1ZvKjNDdHUhRz1HIEd1P1NzaXZlVHQhVj5YaV5aYXJkM0FzPEIgIEIhQ18tQ29yW0UuRXYhR2F0dSFHbyxHKU0gTWkmTSRhQE1waUBOZWFpIU5nb3RPbi18UXVpQFM+ZVMsVGhpdW1UaS5UdG9yPVYhJzVHaV5JbnRhKElzKk1icmljVCArVSBVcmRVdCFVdmVZPTVCK0NpQENyYSVmRSdHdWIhSXMvdE0+ZU5haSFOZGlSJFQsWCl7OkNoKGVHYXMoR190YUdpXklnIUlsbCRJbiVfSXIrSXMkSm9yIExheCBMZWZpLUxoZSdMaS1MI3QmTW1vdXRoTmRhLE5pYWIjTnF1L3ROJnxOKWxSYXRoJFJiIVJ+L2RSZGlSaSU/Ul4nUnIkUiZdU2NvdCZTc2lmVCArbFQ+ZVRyYV5VZGkhVXNzYUBVdmVYaW09M0NoL3RDJG51RGFgI0RlYyhEaSxEdTxJbCMnTC8uTG9kK01iIU1vaSFOYWMgTiBOaCpOcyQuTnRvclJjIWRpUmkmUiNTc2FnIFN1IVQ9VGVvIVRob0BUPlViIzNBdV1Dcm9iZUV0JkduJEdyIEwrdUxsaSRNaV5OLU4gPU5pbT1Ob3IgTnUmUmFjI1JvaSxTc2kjWCY1QmkjRCBbRWwje05kaT1OaSYnTm5hK05vdCRlTnN0IU50YWdbTnU/bnRRKSdSLXxSc3UhUiUgVGUnVGlmVX5lVWYjVWwoVXNzJFV0JFV2L3Q1TCVwI05pJSRSYWAjUmVbUm11IVNjI1NldW1TaWMrblRhJSRUIFQpbDNSaWFAUiVsI1MsZVRoaV46R2UnUHBlUnF1b2lzUnIgVGElJFRpJFR1IVVmcmEuVSVeVmkhM0J1I3tDdGFyRmFzJkdhJSRHbGlnIEdvYz5JLlJ2ZXtUdG95IFVyJGVVdHIkVmV1M0NoZUNrZWxUcmEmVmV8NUIjQ2lmQ3QnW0lyLSdJPHQmTWFATWIhe01tIFJtYSVmVGFiI1RpZj5Ub2khVXJyKlV2ZXxWYSYnVmVtYiFWaS01QS5BbmMgSSFJc2liI00gb1AlPVEpVHJpJWY6MEUqSmVjJWZMaWcgU2MnUyB2IFN0YWMjVF8qVCcgMENhc2kkQ3VwIEUvVG9iIVRyb3kgVHVwXVVsYWkhMEUnT3IvdDFGX31GaWM+RnIqMEl2ZTFTZXxTYGwkMkZhYyVmSXY+MEJyYS5FdHQhMEN0KXtEdV1FIXtJcmleMUEjQV5FciBJbmkkUG9ydHVuUHJpbSBUIFRpXjFBLntBbi5CaSZEJG4gRWAjRy9lRylgSWZpLU5lP250USlUKzBDYF1NbzxTYXR1ITBBciswUmFnL1JzJFRgVHJhZyBWcmEuMEElJDFZQFkuWzFPWzpJc2liI0xhLUxtYSFzTG8nQExwIE5hfmVOZGFOZ29sKE5pcXUgTlt8Tm9yYW1hTnQ9JFBheWVQPlBvLFB5cnVzUmFkb3hlUi1sI1JlczxSZnVtIFJdUm8jUnJhKFI8bSBSdGFnIFJ1IVJ2XypTc2kkUyZeVCBbbFQrbi1UciRWYGwkVm9pfVkgWXNhLjNJZ1tJbnQhTGEuTGljL0wjTG91PEx1fmVOZHUjTmV0ciBOaWIjTnNpZk4nK1BpJlBsdW1SZHJpeFJmb3IgUmlvQFJtdSxScCN4ZVJzYFImUyBUYSNUaXRUcipVcCMyQXJhJE9iK09eT3QkUmE8WXNpXjBBbm9DdCc9RS1FciFFdXYhTG8mTi18UGV0JlF1IFJvZylTYyhlU3QkVm8sWGVsWnphMkFjYXJkQWYkZEFpcypBbiBBXkFzdHIkQSZ8RScgRXh1c0lhLk9tYk9uZyBVK1VtYS4yQ2hldCZFcytFJkluJklyPklzcyRJdiFMYWkhTGljPkwjbkx5ZyRlTW1hQE1wPk5jdClsTmQgIE5leVIlXlNpJSRTPGQgU3R1IVRhZyBUZXxUaSRVLVVsYShVbSRVcnAhVXNzKFV2byoyQSorQSVeRWMre0VkaSFFZml4ZUVsdUBFbm9tRTxuLUUmeCZFdm8qSW1pJWZJbi1JcyRJdiBPYiM/Ty1kIE9kaS5PZiRkT2chc08rT2plLE9sb2cpTz9uIE9wIU9zcCBlTyZnIE8pczxPdiBiZVVAbi1VW3wwWX5vPDFCbGljQyAkSX1McGVMc2FyTmFpPE5pJWZQaXQhUmlmPlp6IzNSYW1pQDo5OUFzYXJFIWwjRXMlJElldHVASXQsTyVfdDpDKGVDJCxEK3tHJGQoSUAnSXMoTF8lckxsJC5NYXN9UGlAU2EuVGlzfVZhZyBWKFkkbiAzQWMlZkFnKkFsaX1BbmltIENldm8qQ2ksQ2xhbSBDb2wsQ3J1LEN1XUN5Y11EaWcgRG91LEZhaSFGI3hlRm9ybSBGcmEoRnUuRz0rbkdpJEdsYS5HdWw+SSwgSmUsSm91IExhJWZMZXYgTCtmTWFyXk1lQE1pPE0kLE1wbCpNdSBOYXJkTmZvcnROaWZdTiRjIE50ciBOdm9pUGw+UG9yLFByaTxQJSNRdShTIHZlUyhle1NvdWQhU3BlY3RTLFN1bHRhdFRhYmwqVF8qVGljdSNUb21iIFRyYWMgVW5pJFVzcypWL35lVml2IVZvbCZWdWxzaWYzQ2hlczxEZXxFJ0dpQEdvXU5jIFBvcyxTaWIjU15UKWxWPVY+ZTVDaGV7TS8tTXAhTi1OZChTZXxTPlRhJWZUb3JUdSNVLlVgI1UjfFUlW1l8PzVCL0Jpc0NoZUVsI0cpe0luIElzPHxTIFMlXjNUaD86Ql1CbyxCIUNvfmVGYXJpR2VzPElzKkxhQExpdmVMJEx1IE1lZGlOYyUkTmdsPlJjYXM/UmQoZVQnIFVnIW51VW0kVSxVdmEuVi90ViRuIDFBbHBlbEFuZGEjRV1hdEVuYXJpb0VwdCFIZW1hSV8tSW5kIE8hUnUlblVscCwxQW4tQ2FiI0NoIENvdSBDISxEYSVmRHVpIUlnWydKbydMZWMlZk1hKGVNYl1NXy1NKD1OYSYnTnNpYiNOJm4tUGFyIFEpbi1SZShSLm50Uit7UnJ1IVJ1bVJ2aS1TYT9WKlZyYS5YdHVwIzNEID1FYyNFZyBGZl1HI0duPUxfLUxpY2l1bU1wI05jIGVOaXN0IVBoJFJvcFNtaV5UdSAxSSAzQ2k9QyNEaXVtSWdbe0xkYXRMZWBMaXR1QEx1YiNNYiFNP2BNbm9dTkBOLidOW3QmTm8hUmM+UiVyUytUJTxVYyt7VWR1IVVmZiNVI3YgVXBhcGVVci1VJXIgVXZfKjBBYyt7QSU9RWNpPUggZUlyPTNBYiNBJSRFcm51bUltdWx1c0lwdV1SaWN0VWQre1VwZSdZbGlzJjBCbGk/QnN0cmF0QiVsQnZfKkMtc0MhRmZpeGVHZyAgSXZlJ0xmYSZQIGJlUHBsPlJmYS1SaWNhJlI/biBScHJpPFJzfHRSditTcGVjdDNMbGFiZU1ibyNNZXRyK05hcDxOdGF4ZVMmPzpCYWNCbD5DJSNJbF1MX3RMaXNtL0wkbiBNYm8nTWl9TmdpYiNQaXNRdSggUmQgUmlmUiVbUzxUYW1pVG91YS5VcGVVIXxYIDNNbyhNcG8hbE5hYCNOZCFOZSdOKk5zaSRSbSggUltScmliI1QoZVgmMkU/RW9yK0VyYXArT3JheDBCaWFFQE1pQFJlbGkhUm8qU3N1VC9lVCFUdWIgNUJvZ2cvTCAvdE1hJk5pXk5bfFAkeT9SfmVSZCFSbmFAUnBgI1IhbnRSPFJ0KVRlbVV+IFVybmEuVXN9WChlMkFjJSRBZmljQWdpXkFoKkEoQW5+IEF2YWBFZiNFbXAgRXNvckV1YElhLklidW49SWNvLElsb2crSW9tcGhlSXBdSXQnIEl2aT1PbWIkZU9uY09waWM9T3VwZXwySSNMaXBlTXVsJk5bbFJiKGVUZSdUb3kgWXwzTXAvUGgkUGleUi86MFVlc145VGk/VHJhcyQxQW5pP0lmPkkkSV5JdGFpIUl2IHMzQW5pdW1CYShUaWMvdDBBLklbVWVsVSEwSSNPcCs6Q2FyP0NjKEdhYiRkRylJbGwvdEluYyFJczx8TGFiI0xpPExsJEx2ZU1waSFOYCNQZSdSPlNle1NzPVMmM0MmJ0RldCZHZXQ9SGljdSNJbmFyZExvLU5kIWRpTiAgTmcgTmk/e050b3U8UmR1IVIoUm4qUnJvdVJ9UnR1U3QkVCAvVHVzJlgvdFggM0FkdWNBbkBDdG9pIUQvLkRlb0dbdCZHKSdMYShMbGEuTmFpZyFPbCRQIGVSZT9udFJ0dW88UnVzU2EuU2UnU2kkU157UylsVD1UZXM8VGljbyNUcihlVmEtVmlwYSE1Q2ElJEd1IEkjSXMoSXR1IUxhYCNMYy9MJWcgTHU/UmEtUiZ4VCBVbG8qWWEuWWVsIzpHJDozTiQ6Q2h0OjNCIU5pdGhTJjlPbG9nK1wiO1xuY29uc3QgYWNjZW50cyA9IFwiZTc2OTMmKVUqbyYpUnleKSopVykpKSkjWF4pKSkpQEApI1dmKW0lKSMhKSlBRykmSUlBUUlJSUJJSUhKTkFnQklJTElESkdvKSkpSElRSUlJSUEoSUdnSkhIKEJJSXhYIylPdSlAKklBQVBJSUlKSFFKKSZRSVFQWUkoSFlBUUMlKSEpKVFISkpAKSMpXmYqXkFYQ0opKSQlQ1ApKSUmbSl1KUBlXkEjRyMpKVdAIShJS0slIShJJSkpT0BRQSkpQEdHI2UpKSkpV0hKSVdoKSlteUBJSUJUXikhKUhBWUdFVEhJKikpIVFuVURHKSkpbkJvS0FDKkh3eVFoKSkkJilHJilVR08pRykpKShCWCN2KiopJU8sZTc2ODYpSSkpQCkmKWdkTVAoKSkpdWQpcCNMKSlJXkZJSFlkV0cpKURAREZWKVFBKW8lTXlUaCUqKVopJSluKFhBTmNeUilZU1wiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4NTFkZWI3YWUwMDkxNDlkYzYxYTZiZDE4YTkxOGViN2FjNzhkMjc3NTcyNmM2OGU1OThiOTJkMDAyNTE5YjA0NVwiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktZnJdXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ0ZyIGV4dGVuZHMgd29yZGxpc3Rfb3dsYV9qc18xLldvcmRsaXN0T3dsQSB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEZyZW5jaCBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdGcl1dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImZyXCIsIHdvcmRzLCBhY2NlbnRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0ZyYGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdGcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdGciA9IExhbmdGcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctZnIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-fr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-it.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-it.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangIt = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst words = \"0torea noica!iosorolotaleratelanena%oiadoencotivomai t ca%a0A]Bagl'Bin#E.Is(Oli!Rasi_Rog#0Cade!C[$Cus#E <Hil,I@QuaReRil>Roba+U 0Ag'Deb{DomeEgu#Eri!IpeOtt&Ul&1Fabi,Fe|Fis(F-n Oris`O(R~$0AveEn.E_,Ganc'I!It&OnismoR>*Rume Uzzo4AbardaA Bat)Ber#BoBumeCeCol>E|<FaGeb-Ian.IbiIm[ Lag#Leg)Lie_Lo@/Lusi_Me$Oge$Pa}Pest!Ta,=Ter$T%c'T)veUn$Veo*Z&0Alga`Ani+A!=B{Br#EbaEr~E^s+I]Mas(M[daMir&Mon{O!P'Pli&U, 0A}r@Ag-feAlis+Arch?At-CaCel/Co-D&D!aEl*Ge*Gol&Gus I`Neg&Nid#NoNunc'OnimoT%ipoZi1At>Ertu-OdePari!Pe^ Pogg'P)@Pun Ri,1Ab~AchideAgos+Ald~Anc'Atu-AzzoBit)Chiv'D{Eni,G[ Gi<Gu IaMon?NeseRed#RingaRos S[>SoTef%eZil*0Ciu|Col EpsiEtt>Fal I$O/Pir#P)Sagg'SeSolu Sur@TaT[u T%eT-|0Av>EismoOm>O$TesaTiv&Tor$Tr{Tua,0Sil'Str?Tis+To$moTun$0Anz#E!V[i!Vi(Volge!3Io<O ZimoZur):Be,C}$Ci$CoDessaDi/+Gn#I+L]<L@Le=L/+Lza$Mbi$Ndi!RaondaRba)R}R{$RlumeRoc]Sil>S(Tos+Ttu U,VaVosa3C]FfaLg'LvaNdaNe_,Nig$Nzi=ReRli=Ta3Bi+CiDo<Fi@GaLanc?MboNo]*O*goPedePol&Rban.R-S]|Ses S$n$Son.SturiZzar)2An@At+2Ll{Nif>R@S]Tan>T^$Zzo*2Acc'AdipoA`An}Avu-E.l/Eve|EzzaIgl?Il/n.Ind&Oc]*O@Onzi=Ul*U$2Bbo<CaDi$Ffo<IoLboO$R*<R-s}S(/S+:De|Du]La`)L]*LesseLib)LmoLor?MbusaMe-+M%?Mmi$Mo/Mpa,NapaNde/NeNi$No|N^=PacePel*P{*Pogi)Ppe)P-Psu/RapaceR}ssaR@Ris`Rova=R!|R li=Sacc'S}+Ser`SoS(<S.l*Sua,Tas+Te=T-meU Vil*3Dibi,D-+Fa*Leb!Llul&NaNo<N.simoRam~Rc&R RumeRvel*So?SpoTo2E/Ia)Ic}Iede!Ime-I=IrurgoI+r-0AoClismoFr&G$Lind)O|*R}R)siTr>T+di$UffoVet+Vi,2Ass>In~O)2C]Dar@D%eE!n.G$meLl&Lm#Lo!Lpo(L^v#LzaMaMe+M`n@Mo@Mpu.rMu<Nci(Ndur!Nfer`Ngel&NiugeN<s(Nosce!NsumoN^nuoNveg$Per P'<Pp?Pr~poRazzaRda+R%#Rn%eRol/RpoR!@Rs?R.seSm>S+n.Ttu-V#2A.!Avat+E#Ede!Emo(Esci+E+Ice I=,IsiIt>OceO=}Os++Uc?,Us}2Ci!Cu*Gi$Ll#Po/R#!R(!R_Sci$S de:DoI$L`+Meri$Nie/N$(Nz&T#Van^Vve)3Bu|C[n'Ci(Cli$Col*C! D%#Fin{FormeG$Leg&Lfi$Lir'L+M[zaNot#Nt)Pos{Rapa+Riv&RogaScri|Ser Sider'Sume!Tersi_Vo 3Amet)Cemb!Ed)Fe(Ffu(Geri!Gi+,Luv'Nam>N=nziPin P*`Po*Rad&ReRo|RupoSag'Sc! Sf&Sge*Spos S+nzaSu`$ToVa$Vel Vide!Vor#5B*<C[.Ga=,G`LceM#M[~Min&N@*NoRmi!TeT !Vu Zzi=2AgoUi@2Bb'Bit&Ca,NaOmoPl%eRatu):0A$0Ces(CoLissiO$m?0E-I]/I,I r?Uc&2Emon?LiOismoReg'4Abor#Argi!Egan.Enc#E|Ev&F>I}MoSaU(0An#B,`Es(I)O^_Oz'<Pir>U*0Dem>Du)Erg?FasiO.}Tr&Zi`1A^.I*goI(d'O},Pu!0U#!0Ar'BaBo(EdeEmi+Ige!Met>OeOsi_Ran.0Ago$AmeAnimeAudi!CaEmp'Erc{Ib{Ig[.Is.!I OfagoOrt#O(Pan(P!s(S[zaSoTe(Tim&Ton?T)(Ult&0Il>N>Rus]To0ClideoRopa0A(Id[zaIt#Olu Viva:Bbr~Cc[daChi)L]Migl?Na,Nfa-NgoN+s`ReRfal/Ri$(R`]Sc?S (Sul*T%&ToVo*(3Bb!Co/DeG#LpaLt)Mmi=Nde!Nome$Rm[ R)R^,Ssu-S^_T+U@3AbaDuc?FaGur#LoNanzaNest-Ni!O!S},S>Ume2A]<Am[]EboEm`Ori@U[.Uo)2B>Cacc?Co(Der#Gl'La+Lc*!Lgo!Nd[.Net>N?N+=Rb{Rchet+Res+Rm~R='RoR.zzaRz&Sf#S(2A}s(A=Assi$A.l*Eccet+E=+Es]IgoOlli$OndeUga,Ut+2Ci/+Cs?Gg[.Lmi<L_Man.Me|Mo(NeNz'<O]RboRgo<Ro!SoTi,:Bb?$FfeLa.oLli=LoppoMbe)M`Ranz?RboRofa$Rzo<S@|Sol'Str>T Ud'ZeboZzel/3CoLa^=L(Mel*Mm#NeN{!N='No^poRgo2Epar@Iacc'Isa0Al*LdaNep)Oc&Oiel*Or$OveR#Ro<T++Udiz'Ur#Us 2Obu*U^<1Omo0BbaLfM{Mmo<Nf'N=Ver$2Aci,A@Af>AmmoAndeAtt&A_(Az?E}EggeIfo<Ig'InzaOt+Uppo2Adag$A'An Ard&FoId&::0Ern#0O=0Ent>Ill'O*RaR>Roge$2Ie<Na)Nor#4A!Le(Log>Lude!0Bal*Bevu Boc]Bu Ma<Mer(Mol#Pac]Pe PiegoPor P)n+0Al&Arc&At^_Can C[d'Chi$Cisi_Clu(Cont)C)c'CuboDagi<D?Do,Ed{Fat^Fil&Fli|Gagg'Geg$G,seGor@G)s(Nes]O@!Oltr&Ond#Sa$Se|SiemeSonn?Suli=Tas#Te)To=]Tu{Umidi!Vali@VeceV{1Erbo,Not>O.siP~1IdeLandaOn>Rig#Ror&0Ol#O poTer>Titu Tr%e0Al?Er&:::Bb)Birin C}Cer#Cri`Cu=D@veGoMpoNcet+N.r=R@(RgaRingeSt-T[zaTi$TtugaVag=Vo)3Ga,Gge)MboN.zzaNzaO<P!Si_Ss#S T.-,VaVig#3Be)DoEv{L/Matu-Mit&Mpi@Ne&NguaQui@RaR~S}TeTig'V!a5CandaDeG~Mb&Nd-Nge_QuaceR[zoToT.r?5CeCid#Ma}Mi$(NgoPoPpo*SingaS(T :Cab)Cchi=Ce)Cin#Da`G>Gl?G<.G)Iol~LafedeLg-@Lin.(Lsa$L Lumo!NaNc?N@r/Ngi&Nifes N=)Nov-NsardaN^deNubr'PpaR#=Rci!Ret+RmoRsup'Sche-Ssa?S^$Te-s(Tr>/T <Tu)Zur}3And)C}n>Ce=.DesimoDit&GaLassaLisLod?NingeNoN(/Rcur'R[daR*Schi$SeSse!S *Tal*To@T.!3Agol&CaCel'Che,C)boDol*E,Gl'!La$Li.MosaNe-,NiNo!Ri$R^l*Sce/SsivaS Sur&TezzaTig&T-T.n.4Emon>0Del*Dif~Du*Ga$G'LeLos(Nas.)N]Ndi=Ne+r'Ni,No $N(<Nt#Nvi(RaRde!Rs%#St)Tiv#TosegaT V[zaVim[ Zzo5C}CosaFfaGhe|G='La|Li<l*L^p*Mm?N Ove!Ra,SaS]*S~Te_,To:BabboF+Nomet)Rci(R%eRr#Sce!Str&Tu-,Ut~Vigl'3Bu*saC)siGa^_Goz'Mme$Ofi+Re|R_Ssu$Ttu$Ut-,VeV)t>3Cch?NfaTi@5Bi,Ci_DoMeMi=Rd>R`,RvegeseSt-$T&Tiz?Ttur$Vel/5C,oL/Me)O_Tri!Vo/Z?,:Si0Bedi!BligoElis]L'O*So, 0Cas'<Ch'Cid[.Cor!!Cult&RaUl#0Ier$Or&1Fer+Fri!Fusc#0Ge|GiNu$4AndeseFa|I#IvaOg-m`T!0Agg'Bel>B-EgaIss'<0Do(E!IceNi_)O!_,Ta1Er#In'<Pos 1A]*AfoDi<Ecchi$Ef%eFa$Gan>Igi<Izzon.MaMegg'Na^_O*g'R[@Ribi,T[s?T~Za+Zo0A!Cur&MosiPeda,Pi.SaSid&Ta]*Te0I.ReTago$TimoTob!1A,EstI$Ipa)Oc{UnqueVi&3Io:Cche|CeCif>Del/D)<EseGaGi=Lazzi=Les&Lli@LoLudeN@)N<l*O*O=zzoPr~Rabo/Rcel/Re!Rgo*RiRl#Ro/R^!Rv[zaRz?,Ssi_St%}Tac}To*g?TtumeVo<3Cc#Dal&Do=,Gg'Lo(N&Nd%eNi(/Nnu Nomb-Ns&N /PePi+Rbe<R]r(R@n#Rfor&Rgame=R'@Rmes(R$Rp,s(Rsua(Rtug'Rva(S#!Sis+SoS^fe)Ta*T^<Tu/n.Zzo3Ace!An+At^$Cci$CozzaEgaEt-Ffe)G?`Gol'G)LaLife)L*/Lo+Mpan.Ne+N=No*Ogg?OmboRamideRet>Ri.RolisiTo<Zz>2AceboAn&As`A+$E=r'2ChezzaDe)(DismoEs?Ggi&L[+Ligo$Ll%eLmoni.Lpet+L(Lt)=Lve!M%eMo@)N.Po*(Rfi@Ro(Rpo-R!R++SaSi^_Sses(Stul#Tass'Te!2AnzoAssiAt~Eclu(Ed~Efis(Egi#Elie_Eme!E$t&Epar#Es[zaE.s Eval(I`IncipeIv#Ob,`Ocu-Odur!OfumoOge|OlungaOmessaO$meOpos+O)gaO.(OvaUd[.Ug=Ur{0Iche1Bbl>D~Gil#G$LceL{Lsan.Nt&PazzoPil/Ro:99Ad)Al]saAsiE!/O+:C]l D@pp'D~,Dun#Ff~GazzoG'<G$Mar)MingoMoNdag'N l&P#Pi=Pp!(Satu-Schi#S[.Sseg=St!l*TaVvedu 3A,Cepi!Cin Clu+Cond{Cupe)Dd{Dime!Gal#Gist)Go/G!s(Laz'<M&Mo N=Pl~Prime!Put&SaSid[.Spon(S+u)TeTi=Tor~T^f~Voc#3Assun Badi!Bel,B!zzoCar~C]Ceve!C%l#Cor@C!du D>*Dur!Fas&F,s(For`Fug'G&Gett#Ghel*Lass#Lev#Ma<!MbalzoMed'Morch'Nasci+N})NforzoN$_Nom#Nsav{N c]Nunc?Nv[i!Par#Petu Pie$Port&P!saPuli!Sa+Sch'ServaSibi,SoSpe|S )Sult#S_l Tar@Teg$Tm>T)_Un'<VaVer(Vinci+Vol Zo`5BaBot>Bus Cc?CoDagg'De!D{!G{Ll'Mant>Mpe!Nz'Sol&SpoTan.Ton@Tu/Vesc'5BizzoBr~GaLli$Mi<Mo)(O*PeSs&St>:B#Bbi&Bot#Go`Las(Ldatu-Lgem`Liv&Lmo<Lo<Lt&Lu L_Pe!Pi@Por{Race$R}smoR S((Telli.Ti-Tol*Tur$Va=V'Zi#0Adigl'AlzoAnc#Ar-At.!Av&End&Irci&Locc#Occi#Rin&Ruffo<Uff&0Ab)(Ad[zaA/Ambi&Anda*Apo/Ar(A.n&Av#El En>Ett)HedaHie=IarpaI[zaInde!IppoI)ppoI_*Ler&Odel/Olp{Ompar Onfor Opri!Or+Os(<OzzeseRibaRoll&Ru^n'Uder?Ul !Uo/U)Us&0Ebit&Ogan&0C}tu-Con@Da$Gg'/G=l#G!g#Gu{Lci#Let^_L/Lvagg'Mafo)Mbr&MeMin#Mp!N(N^!Pol Qu[zaRa+Rb#Re$R'Rp[.R-gl'Rvi!S^=To/T^`=0Ace*Ald&Am#Arzo(At%#E-IdaIl#IngeOc#Oder&OgoOl^!Orz#Ra|Rutt#Ugg{Um&U(0Abel*Arb#Onfi&Orb'Rass#Uar@1Bi*C]meEr-G/G$!L[z'L/baMbo*Mpat>Mul#Nfon?Ngo*Nist)NoN.siNu(idePar'S`S ,Tu#2It+Ogatu-Ove$0Arr{Emor#En^ E-l@IlzoOnt&Ott#Uss#0Elli!Erv#O@0BbalzoBr'C]r(C?,Da,Ffi|G$Ld#L[<Li@L/zzoLoLubi,Lv[.Mat>M`NdaNe|Nnife)Pi!Ppe(P-Rge!Rpas(Rri(R(R.gg'R_l#Spi)S+T^,0AdaAl/Arge!A /Av[ Azzo/EcieEdi!Eg<!E/tu-E-nzaEs(!Ett-,Ezz#IaIgo*(Ill#I$(I-,L[di@Or^_O(RangaRec&Ron#RuzzoUn^$0Uil*0Ad%&O l#1Abi,Ac]AffaAgn&Amp#Ant'Arnu Ase-Atu E*EppaErzoI,|I`IrpeIva,Izzo(On#Or>RappoReg#Ridu*Rozz&Ru|Ucc&UfoUp[@0B[t)C](Do!Gger{GoL+$On&PerboPpor Rgel#R)g#Ssur)Tu-0Ag&EdeseEgl'El&Enu Ez?IluppoIs+Izze-Ol+Uot&:Bac]Bul#Cci&Citur$LeLis`$Mpo<Nni$RaRdi_Rg#RiffaRp&R+rugaS Tt>Ver=Vo/+Zza3CaCn>Lefo$Me-r'MpoMu N@<Ne)Ns'<N+]*O!`RmeR-zzoRze|SiSser#St#T)T ?3F&Gel/Mb)N P>Pog-foRagg'RoTan'To*Tuban.Z'Zzo<5Cc&L,r&L Mbo/MoNfoNsil/Paz'Po*g?PpaRbaRn&R)<R -S}$Ssi!S+tu-Ta$2Aboc]AcheaAfi/Aged?Alc'Amon Ans{Apa$Ar!As*]Att#AveEcc?Emol'Espo*Ibu Iche]Ifogl'Il*InceaIoIs.zzaItur#Ivel/OmbaO$OppoO|/Ov&Ucc#2Batu-Ff#Lipa$Mul Nis?Rb&Rchi$TaTe/:0Ic#0Cel*Ci(!0I!I^_1FaF%'0Ua,4IsseTim#0A$I,Orismo0Ci<|Ge!Ghe!seI]r$If%#I($I+r'Te0Vo0Upa1Aga$G[zaLo0AnzaA C{Ig$*U-'0Ensi,IlizzoOp?:Can.Ccin#Gabon@Gli#LangaLgoL>L,t+Lo)(Lut&L_/Mpa+Ng&N{(NoN+gg'Nve-Po!Ra$Rc#R?n.S}3Det+DovaDu Ge+,I]*Lc)Li=Llu LoceN#Ndemm?N RaceRba,Rgog=Rif~RoRru}Rt~,Sc~Ssil*S+,Te-$Tri=Tus 3Andan.B-n.C[daChingoCi=nzaDim&Gil?G< Go!LeL/$MiniNc{!O/Pe-Rgo/Ro*goRu,n S](S'<SpoSsu Su-TaTel*T^`VandaVi@Zi&5CeGaLa^,Le!LpeRagi<5L}$::::Mpog=N=Pp#T.-Vor-3Fi)Lan.LoNze)Rbi$3Be|N]R]<T 5L/T>5Cche)Fo*LuPpa\";\nconst checksum = \"0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-it]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangIt extends wordlist_owl_js_1.WordlistOwl {\n    /**\n     *  Creates a new instance of the Italian language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langIt]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"it\", words, checksum); }\n    /**\n     *  Returns a singleton instance of a ``LangIt``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangIt();\n        }\n        return wordlist;\n    }\n}\nexports.LangIt = LangIt;\n//# sourceMappingURL=lang-it.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsMEJBQTBCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3JELHNKQUFzSix1S0FBdUssNkNBQTZDLCtCQUErQixjQUFjLDJKQUEySiwwSUFBMEksa0VBQWtFLHVEQUF1RCxFQUFFLG9KQUFvSixrQ0FBa0MseUVBQXlFLHVGQUF1Rix3QkFBd0IsNkJBQTZCLHNHQUFzRyw2Q0FBNkMsc1BBQXNQLFdBQVcsOEZBQThGLG9DQUFvQywwVEFBMFQsa0RBQWtELG9CQUFvQixzRUFBc0UsR0FBRyxzUEFBc1AsMkVBQTJFLGtDQUFrQyx3TEFBd0wsMEZBQTBGLDJDQUEyQyw2TUFBNk0sb0ZBQW9GLGlCQUFpQiw4RUFBOEUsZ0hBQWdILGdDQUFnQyxzREFBc0QsZ0xBQWdMLE9BQU8sdVFBQXVRLG9nQkFBb2dCLHdIQUF3SCxJQUFJLHVmQUF1Zix1QkFBdUIscUpBQXFKLFFBQVEsb01BQW9NLG1CQUFtQiwySUFBMkksR0FBRyxnSUFBZ0ksT0FBTyx3TEFBd0wsMkVBQTJFLHlCQUF5QixtSkFBbUosK0hBQStILDJZQUEyWSwwVEFBMFQsOENBQThDLDRPQUE0Tyw0RUFBNEUsMkJBQTJCLGtFQUFrRSxnRkFBZ0YsK0VBQStFO0FBQ2o3TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2xhbmctaXQuanM/ZDcyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ0l0ID0gdm9pZCAwO1xuY29uc3Qgd29yZGxpc3Rfb3dsX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC1vd2wuanNcIik7XG5jb25zdCB3b3JkcyA9IFwiMHRvcmVhIG5vaWNhIWlvc29yb2xvdGFsZXJhdGVsYW5lbmElb2lhZG9lbmNvdGl2b21haSB0IGNhJWEwQV1CYWdsJ0JpbiNFLklzKE9saSFSYXNpX1JvZyMwQ2FkZSFDWyRDdXMjRSA8SGlsLElAUXVhUmVSaWw+Um9iYStVIDBBZydEZWJ7RG9tZUVndSNFcmkhSXBlT3R0JlVsJjFGYWJpLEZlfEZpcyhGLW4gT3Jpc2BPKFJ+JDBBdmVFbi5FXyxHYW5jJ0khSXQmT25pc21vUj4qUnVtZSBVenpvNEFiYXJkYUEgQmF0KUJlciNCb0J1bWVDZUNvbD5FfDxGYUdlYi1JYW4uSWJpSW1bIExhZyNMZWcpTGllX0xvQC9MdXNpX01lJE9nZSRQYX1QZXN0IVRhLD1UZXIkVCVjJ1QpdmVVbiRWZW8qWiYwQWxnYWBBbmkrQSE9QntCciNFYmFFcn5FXnMrSV1NYXMoTVtkYU1pciZNb257TyFQJ1BsaSZVLCAwQX1yQEFnLWZlQWxpcytBcmNoP0F0LUNhQ2VsL0NvLUQmRCFhRWwqR2UqR29sJkd1cyBJYE5lZyZOaWQjTm9OdW5jJ09uaW1vVCVpcG9aaTFBdD5FcnR1LU9kZVBhcmkhUGVeIFBvZ2cnUClAUHVuIFJpLDFBYn5BY2hpZGVBZ29zK0FsZH5BbmMnQXR1LUF6em9CaXQpQ2hpdidEe0VuaSxHWyBHaTxHdSBJYU1vbj9OZXNlUmVkI1JpbmdhUm9zIFNbPlNvVGVmJWVaaWwqMENpdXxDb2wgRXBzaUV0dD5GYWwgSSRPL1BpciNQKVNhZ2cnU2VTb2x1IFN1ckBUYVRbdSBUJWVULXwwQXY+RWlzbW9PbT5PJFRlc2FUaXYmVG9yJFRye1R1YSwwU2lsJ1N0cj9UaXMrVG8kbW9UdW4kMEFueiNFIVZbaSFWaShWb2xnZSEzSW88TyBaaW1vWnVyKTpCZSxDfSRDaSRDb0Rlc3NhRGkvK0duI0krTF08TEBMZT1MLytMemEkTWJpJE5kaSFSYW9uZGFSYmEpUn1SeyRSbHVtZVJvY11TaWw+UyhUb3MrVHR1IFUsVmFWb3NhM0NdRmZhTGcnTHZhTmRhTmVfLE5pZyROemk9UmVSbGk9VGEzQmkrQ2lEbzxGaUBHYUxhbmM/TWJvTm9dKk8qZ29QZWRlUG9sJlJiYW4uUi1TXXxTZXMgUyRuJFNvbi5TdHVyaVp6YXIpMkFuQEF0KzJMbHtOaWY+UkBTXVRhbj5UXiRaem8qMkFjYydBZGlwb0FgQW59QXZ1LUUubC9FdmV8RXp6YUlnbD9JbC9uLkluZCZPY10qT0BPbnppPVVsKlUkMkJibzxDYURpJEZmbzxJb0xib08kUio8Ui1zfVMoL1MrOkRlfER1XUxhYClMXSpMZXNzZUxpYilMbW9Mb3I/TWJ1c2FNZS0rTSU/TW1pJE1vL01wYSxOYXBhTmRlL05lTmkkTm98Tl49UGFjZVBlbCpQeypQb2dpKVBwZSlQLVBzdS9SYXBhY2VSfXNzYVJAUmlzYFJvdmE9UiF8UiBsaT1TYWNjJ1N9K1NlcmBTb1MoPFMubCpTdWEsVGFzK1RlPVQtbWVVIFZpbCozRGliaSxELStGYSpMZWIhTGx1bCZOYU5vPE4uc2ltb1JhbX5SYyZSIFJ1bWVSdmVsKlNvP1Nwb1RvMkUvSWEpSWN9SWVkZSFJbWUtST1JcnVyZ29JK3ItMEFvQ2xpc21vRnImRyRMaW5kKU98KlJ9UilzaVRyPlQrZGkkVWZmb1ZldCtWaSwyQXNzPklufk8pMkNdRGFyQEQlZUUhbi5HJG1lTGwmTG0jTG8hTHBvKExediNMemFNYU1lK01gbkBNb0BNcHUuck11PE5jaShOZHVyIU5mZXJgTmdlbCZOaXVnZU48cyhOb3NjZSFOc3Vtb05ebnVvTnZlZyRQZXIgUCc8UHA/UHJ+cG9SYXp6YVJkYStSJSNSbiVlUm9sL1Jwb1IhQFJzP1Iuc2VTbT5TK24uVHR1LVYjMkEuIUF2YXQrRSNFZGUhRW1vKEVzY2krRStJY2UgST0sSXNpSXQ+T2NlTz19T3MrK1VjPyxVc30yQ2khQ3UqR2kkTGwjUG8vUiMhUighUl9TY2kkUyBkZTpEb0kkTGArTWVyaSROaWUvTiQoTnomVCNWYW5eVnZlKTNCdXxDW24nQ2koQ2xpJENvbCpDISBEJSNGaW57Rm9ybWVHJExlZyZMZmkkTGlyJ0wrTVt6YU5vdCNOdClQb3N7UmFwYStSaXYmUm9nYVNjcml8U2VyIFNpZGVyJ1N1bWUhVGVyc2lfVm8gM0FtZXQpQ2VtYiFFZClGZShGZnUoR2VyaSFHaSssTHV2J05hbT5OPW56aVBpbiBQKmBQbypSYWQmUmVSb3xSdXBvU2FnJ1NjISBTZiZTZ2UqU3BvcyBTK256YVN1YCRUb1ZhJFZlbCBWaWRlIVZvciM1Qio8Q1suR2E9LEdgTGNlTSNNW35NaW4mTkAqTm9SbWkhVGVUICFWdSBaemk9MkFnb1VpQDJCYidCaXQmQ2EsTmFPbW9QbCVlUmF0dSk6MEEkMENlcyhDb0xpc3NpTyRtPzBFLUldL0ksSSByP1VjJjJFbW9uP0xpT2lzbW9SZWcnNEFib3IjQXJnaSFFZ2FuLkVuYyNFfEV2JkY+SX1Nb1NhVSgwQW4jQixgRXMoSSlPXl9Peic8UGlyPlUqMERlbT5EdSlFcmc/RmFzaU8ufVRyJlppYDFBXi5JKmdvSShkJ099LFB1ITBVIyEwQXInQmFCbyhFZGVFbWkrSWdlIU1ldD5PZU9zaV9SYW4uMEFnbyRBbWVBbmltZUF1ZGkhQ2FFbXAnRXJje0lie0lnWy5Jcy4hSSBPZmFnb09ydCNPKFBhbihQIXMoU1t6YVNvVGUoVGltJlRvbj9UKShVbHQmMElsPk4+UnVzXVRvMENsaWRlb1JvcGEwQShJZFt6YUl0I09sdSBWaXZhOkJicn5DY1tkYUNoaSlMXU1pZ2w/TmEsTmZhLU5nb04rc2BSZVJmYWwvUmkkKFJgXVNjP1MgKFN1bCpUJSZUb1ZvKigzQmIhQ28vRGVHI0xwYUx0KU1taT1OZGUhTm9tZSRSbVsgUilSXixTc3UtU15fVCtVQDNBYmFEdWM/RmFHdXIjTG9OYW56YU5lc3QtTmkhTyFTfSxTPlVtZTJBXTxBbVtdRWJvRW1gT3JpQFVbLlVvKTJCPkNhY2M/Q28oRGVyI0dsJ0xhK0xjKiFMZ28hTmRbLk5ldD5OP04rPVJie1JjaGV0K1JlcytSbX5SPSdSb1IuenphUnomU2YjUygyQX1zKEE9QXNzaSRBLmwqRWNjZXQrRT0rRXNdSWdvT2xsaSRPbmRlVWdhLFV0KzJDaS8rQ3M/R2dbLkxtaTxMX01hbi5NZXxNbyhOZU56JzxPXVJib1JnbzxSbyFTb1RpLDpCYj8kRmZlTGEub0xsaT1Mb3Bwb01iZSlNYFJhbno/UmJvUm9mYSRSem88U0B8U29sJ1N0cj5UIFVkJ1plYm9aemVsLzNDb0xhXj1MKE1lbCpNbSNOZU57IU49J05vXnBvUmdvMkVwYXJASWFjYydJc2EwQWwqTGRhTmVwKU9jJk9pZWwqT3IkT3ZlUiNSbzxUKytVZGl6J1VyI1VzIDJPYnUqVV48MU9tbzBCYmFMZk17TW1vPE5mJ049VmVyJDJBY2ksQUBBZj5BbW1vQW5kZUF0dCZBXyhBej9FfUVnZ2VJZm88SWcnSW56YU90K1VwcG8yQWRhZyRBJ0FuIEFyZCZGb0lkJjo6MEVybiMwTz0wRW50PklsbCdPKlJhUj5Sb2dlJDJJZTxOYSlOb3IjNEEhTGUoTG9nPkx1ZGUhMEJhbCpCZXZ1IEJvY11CdSBNYTxNZXIoTW9sI1BhY11QZSBQaWVnb1BvciBQKW4rMEFsJkFyYyZBdF5fQ2FuIENbZCdDaGkkQ2lzaV9DbHUoQ29udClDKWMnQ3Vib0RhZ2k8RD9EbyxFZHtGYXReRmlsJkZsaXxHYWdnJ0dlZyRHLHNlR29yQEcpcyhOZXNdT0AhT2x0ciZPbmQjU2EkU2V8U2llbWVTb25uP1N1bGk9VGFzI1RlKVRvPV1UdXtVbWlkaSFWYWxpQFZlY2VWezFFcmJvLE5vdD5PLnNpUH4xSWRlTGFuZGFPbj5SaWcjUm9yJjBPbCNPIHBvVGVyPlRpdHUgVHIlZTBBbD9FciY6OjpCYilCaXJpbiBDfUNlciNDcmlgQ3U9REB2ZUdvTXBvTmNldCtOLnI9UkAoUmdhUmluZ2VTdC1UW3phVGkkVHR1Z2FWYWc9Vm8pM0dhLEdnZSlNYm9OLnp6YU56YU88UCFTaV9TcyNTIFQuLSxWYVZpZyMzQmUpRG9FdntML01hdHUtTWl0Jk1waUBOZSZOZ3VhUXVpQFJhUn5TfVRlVGlnJ1YhYTVDYW5kYURlR35NYiZOZC1OZ2VfUXVhY2VSW3pvVG9ULnI/NUNlQ2lkI01hfU1pJChOZ29Qb1BwbypTaW5nYVMoVCA6Q2FiKUNjaGk9Q2UpQ2luI0RhYEc+R2w/RzwuRylJb2x+TGFmZWRlTGctQExpbi4oTHNhJEwgTHVtbyFOYU5jP05Aci9OZ2kmTmlmZXMgTj0pTm92LU5zYXJkYU5eZGVOdWJyJ1BwYVIjPVJjaSFSZXQrUm1vUnN1cCdTY2hlLVNzYT9TXiRUZS1zKFRyPi9UIDxUdSladXJ9M0FuZClDfW4+Q2U9LkRlc2ltb0RpdCZHYUxhc3NhTGlzTG9kP05pbmdlTm9OKC9SY3VyJ1JbZGFSKlNjaGkkU2VTc2UhUyAqVGFsKlRvQFQuITNBZ29sJkNhQ2VsJ0NoZSxDKWJvRG9sKkUsR2wnIUxhJExpLk1vc2FOZS0sTmlObyFSaSRSXmwqU2NlL1NzaXZhUyBTdXImVGV6emFUaWcmVC1ULm4uNEVtb24+MERlbCpEaWZ+RHUqR2EkRydMZUxvcyhOYXMuKU5dTmRpPU5lK3InTmksTm8gJE4oPE50I052aShSYVJkZSFScyUjU3QpVGl2I1Rvc2VnYVQgVlt6YVZpbVsgWnpvNUN9Q29zYUZmYUdoZXxHPSdMYXxMaTxsKkxecCpNbT9OIE92ZSFSYSxTYVNdKlN+VGVfLFRvOkJhYmJvRitOb21ldClSY2koUiVlUnIjU2NlIVN0ciZUdS0sVXR+VmlnbCczQnUqc2FDKXNpR2FeX0dveidNbWUkT2ZpK1JlfFJfU3N1JFR0dSRVdC0sVmVWKXQ+M0NjaD9OZmFUaUA1QmksQ2lfRG9NZU1pPVJkPlJgLFJ2ZWdlc2VTdC0kVCZUaXo/VHR1ciRWZWwvNUMsb0wvTWUpT19UcmkhVm8vWj8sOlNpMEJlZGkhQmxpZ29FbGlzXUwnTypTbywgMENhcyc8Q2gnQ2lkWy5Db3IhIUN1bHQmUmFVbCMwSWVyJE9yJjFGZXIrRnJpIUZ1c2MjMEdlfEdpTnUkNEFuZGVzZUZhfEkjSXZhT2ctbWBUITBBZ2cnQmVsPkItRWdhSXNzJzwwRG8oRSFJY2VOaV8pTyFfLFRhMUVyI0luJzxQb3MgMUFdKkFmb0RpPEVjY2hpJEVmJWVGYSRHYW4+SWdpPEl6em9uLk1hTWVnZydOYV5fTypnJ1JbQFJpYmksVFtzP1R+WmErWm8wQSFDdXImTW9zaVBlZGEsUGkuU2FTaWQmVGFdKlRlMEkuUmVUYWdvJFRpbW9Ub2IhMUEsRXN0SSRJcGEpT2N7VW5xdWVWaSYzSW86Q2NoZXxDZUNpZj5EZWwvRCk8RXNlR2FHaT1MYXp6aT1MZXMmTGxpQExvTHVkZU5AKU48bCpPKk89enpvUHJ+UmFiby9SY2VsL1JlIVJnbypSaVJsI1JvL1JeIVJ2W3phUno/LFNzaV9TdCV9VGFjfVRvKmc/VHR1bWVWbzwzQ2MjRGFsJkRvPSxHZydMbyhOJk5kJWVOaSgvTm51IE5vbWItTnMmTiAvUGVQaStSYmU8Ul1yKFJAbiNSZm9yJlJnYW1lPVInQFJtZXMoUiRScCxzKFJzdWEoUnR1ZydSdmEoUyMhU2lzK1NvU15mZSlUYSpUXjxUdS9uLlp6bzNBY2UhQW4rQXReJENjaSRDb3p6YUVnYUV0LUZmZSlHP2BHb2wnRylMYUxpZmUpTCovTG8rTXBhbi5OZStOPU5vKk9nZz9PbWJvUmFtaWRlUmV0PlJpLlJvbGlzaVRvPFp6PjJBY2Vib0FuJkFzYEErJEU9cicyQ2hlenphRGUpKERpc21vRXM/R2dpJkxbK0xpZ28kTGwlZUxtb25pLkxwZXQrTChMdCk9THZlIU0lZU1vQClOLlBvKihSZmlAUm8oUnBvLVIhUisrU2FTaV5fU3NlcyhTdHVsI1Rhc3MnVGUhMkFuem9Bc3NpQXR+RWNsdShFZH5FZmlzKEVnaSNFbGllX0VtZSFFJHQmRXBhciNFc1t6YUUucyBFdmFsKElgSW5jaXBlSXYjT2IsYE9jdS1PZHVyIU9mdW1vT2dlfE9sdW5nYU9tZXNzYU8kbWVPcG9zK08pZ2FPLihPdmFVZFsuVWc9VXJ7MEljaGUxQmJsPkR+R2lsI0ckTGNlTHtMc2FuLk50JlBhenpvUGlsL1JvOjk5QWQpQWxdc2FBc2lFIS9PKzpDXWwgREBwcCdEfixEdW4jRmZ+R2F6em9HJzxHJE1hcilNaW5nb01vTmRhZydOIGwmUCNQaT1QcCEoU2F0dS1TY2hpI1NbLlNzZWc9U3QhbCpUYVZ2ZWR1IDNBLENlcGkhQ2luIENsdStDb25ke0N1cGUpRGR7RGltZSFHYWwjR2lzdClHby9HIXMoTGF6JzxNJk1vIE49UGx+UHJpbWUhUHV0JlNhU2lkWy5TcG9uKFMrdSlUZVRpPVRvcn5UXmZ+Vm9jIzNBc3N1biBCYWRpIUJlbCxCIXp6b0Nhcn5DXUNldmUhQyVsI0NvckBDIWR1IEQ+KkR1ciFGYXMmRixzKEZvcmBGdWcnRyZHZXR0I0doZWwqTGFzcyNMZXYjTWE8IU1iYWx6b01lZCdNb3JjaCdOYXNjaStOfSlOZm9yem9OJF9Ob20jTnNhdntOIGNdTnVuYz9OdltpIVBhciNQZXR1IFBpZSRQb3J0JlAhc2FQdWxpIVNhK1NjaCdTZXJ2YVNpYmksU29TcGV8UyApU3VsdCNTX2wgVGFyQFRlZyRUbT5UKV9Vbic8VmFWZXIoVmluY2krVm9sIFpvYDVCYUJvdD5CdXMgQ2M/Q29EYWdnJ0RlIUR7IUd7TGwnTWFudD5NcGUhTnonU29sJlNwb1Rhbi5Ub25AVHUvVmVzYyc1Qml6em9Ccn5HYUxsaSRNaTxNbykoTypQZVNzJlN0PjpCI0JiaSZCb3QjR29gTGFzKExkYXR1LUxnZW1gTGl2JkxtbzxMbzxMdCZMdSBMX1BlIVBpQFBvcntSYWNlJFJ9c21vUiBTKChUZWxsaS5UaS1Ub2wqVHVyJFZhPVYnWmkjMEFkaWdsJ0Fsem9BbmMjQXItQXQuIUF2JkVuZCZJcmNpJkxvY2MjT2NjaSNSaW4mUnVmZm88VWZmJjBBYikoQWRbemFBL0FtYmkmQW5kYSpBcG8vQXIoQS5uJkF2I0VsIEVuPkV0dClIZWRhSGllPUlhcnBhSVt6YUluZGUhSXBwb0kpcHBvSV8qTGVyJk9kZWwvT2xwe09tcGFyIE9uZm9yIE9wcmkhT3IrT3MoPE96emVzZVJpYmFSb2xsJlJ1Xm4nVWRlcj9VbCAhVW8vVSlVcyYwRWJpdCZPZ2FuJjBDfXR1LUNvbkBEYSRHZycvRz1sI0chZyNHdXtMY2kjTGV0Xl9ML0x2YWdnJ01hZm8pTWJyJk1lTWluI01wIU4oTl4hUG9sIFF1W3phUmErUmIjUmUkUidScFsuUi1nbCdSdmkhU149VG8vVF5gPTBBY2UqQWxkJkFtI0Fyem8oQXQlI0UtSWRhSWwjSW5nZU9jI09kZXImT2dvT2xeIU9yeiNSYXxSdXR0I1VnZ3tVbSZVKDBBYmVsKkFyYiNPbmZpJk9yYidSYXNzI1VhckAxQmkqQ11tZUVyLUcvRyQhTFt6J0wvYmFNYm8qTXBhdD5NdWwjTmZvbj9OZ28qTmlzdClOb04uc2lOdShpZGVQYXInU2BTICxUdSMySXQrT2dhdHUtT3ZlJDBBcnJ7RW1vciNFbl4gRS1sQElsem9PbnQmT3R0I1VzcyMwRWxsaSFFcnYjT0AwQmJhbHpvQnInQ11yKEM/LERhLEZmaXxHJExkI0xbPExpQEwvenpvTG9MdWJpLEx2Wy5NYXQ+TWBOZGFOZXxObmlmZSlQaSFQcGUoUC1SZ2UhUnBhcyhScmkoUihSLmdnJ1JfbCNTcGkpUytUXiwwQWRhQWwvQXJnZSFBIC9BdlsgQXp6by9FY2llRWRpIUVnPCFFL3R1LUUtbnphRXMoIUV0dC0sRXp6I0lhSWdvKihJbGwjSSQoSS0sTFtkaUBPcl5fTyhSYW5nYVJlYyZSb24jUnV6em9Vbl4kMFVpbCowQWQlJk8gbCMxQWJpLEFjXUFmZmFBZ24mQW1wI0FudCdBcm51IEFzZS1BdHUgRSpFcHBhRXJ6b0ksfElgSXJwZUl2YSxJenpvKE9uI09yPlJhcHBvUmVnI1JpZHUqUm96eiZSdXxVY2MmVWZvVXBbQDBCW3QpQ10oRG8hR2dlcntHb0wrJE9uJlBlcmJvUHBvciBSZ2VsI1IpZyNTc3VyKVR1LTBBZyZFZGVzZUVnbCdFbCZFbnUgRXo/SWx1cHBvSXMrSXp6ZS1PbCtVb3QmOkJhY11CdWwjQ2NpJkNpdHVyJExlTGlzYCRNcG88Tm5pJFJhUmRpX1JnI1JpZmZhUnAmUitydWdhUyBUdD5WZXI9Vm8vK1p6YTNDYUNuPkxlZm8kTWUtcidNcG9NdSBOQDxOZSlOcyc8TitdKk8hYFJtZVItenpvUnplfFNpU3NlciNTdCNUKVQgPzNGJkdlbC9NYilOIFA+UG9nLWZvUmFnZydSb1RhbidUbypUdWJhbi5aJ1p6bzw1Q2MmTCxyJkwgTWJvL01vTmZvTnNpbC9QYXonUG8qZz9QcGFSYmFSbiZSKTxSIC1TfSRTc2khUyt0dS1UYSQyQWJvY11BY2hlYUFmaS9BZ2VkP0FsYydBbW9uIEFuc3tBcGEkQXIhQXMqXUF0dCNBdmVFY2M/RW1vbCdFc3BvKklidSBJY2hlXUlmb2dsJ0lsKkluY2VhSW9Jcy56emFJdHVyI0l2ZWwvT21iYU8kT3Bwb098L092JlVjYyMyQmF0dS1GZiNMaXBhJE11bCBOaXM/UmImUmNoaSRUYVRlLzowSWMjMENlbCpDaSghMEkhSV5fMUZhRiUnMFVhLDRJc3NlVGltIzBBJEksT3Jpc21vMENpPHxHZSFHaGUhc2VJXXIkSWYlI0koJEkrcidUZTBWbzBVcGExQWdhJEdbemFMbzBBbnphQSBDe0lnJCpVLScwRW5zaSxJbGl6em9PcD86Q2FuLkNjaW4jR2Fib25AR2xpI0xhbmdhTGdvTD5MLHQrTG8pKEx1dCZMXy9NcGErTmcmTnsoTm9OK2dnJ052ZS1QbyFSYSRSYyNSP24uU30zRGV0K0RvdmFEdSBHZSssSV0qTGMpTGk9TGx1IExvY2VOI05kZW1tP04gUmFjZVJiYSxSZ29nPVJpZn5Sb1JydX1SdH4sU2N+U3NpbCpTKyxUZS0kVHJpPVR1cyAzQW5kYW4uQi1uLkNbZGFDaGluZ29DaT1uemFEaW0mR2lsP0c8IEdvIUxlTC8kTWluaU5jeyFPL1BlLVJnby9Sbypnb1J1LG4gU10oUyc8U3BvU3N1IFN1LVRhVGVsKlReYFZhbmRhVmlAWmkmNUNlR2FMYV4sTGUhTHBlUmFnaTw1TH0kOjo6Ok1wb2c9Tj1QcCNULi1Wb3ItM0ZpKUxhbi5Mb056ZSlSYmkkM0JlfE5dUl08VCA1TC9UPjVDY2hlKUZvKkx1UHBhXCI7XG5jb25zdCBjaGVja3N1bSA9IFwiMHg1YzEzNjJkODhmZDRjZjYxNGE5NmYzMjM0OTQxZDI5ZjdkMzdjMDhjNTI5MmZkZTAzYmY2MmMyZGI2ZmY3NjIwXCI7XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS1pdF1dIGZvciBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nSXQgZXh0ZW5kcyB3b3JkbGlzdF9vd2xfanNfMS5Xb3JkbGlzdE93bCB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEl0YWxpYW4gbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nSXRdXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoXCJpdFwiLCB3b3JkcywgY2hlY2tzdW0pOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdJdGBgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nSXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nSXQgPSBMYW5nSXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWl0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-it.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-ja.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-ja.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangJa = void 0;\nconst index_js_1 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\nconst data = [\n    // 4-kana words\n    \"AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR\",\n    // 5-kana words\n    \"ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR\",\n    // 6-kana words\n    \"AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm\",\n    // 7-kana words\n    \"ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC\",\n    // 8-kana words\n    \"BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD\",\n    // 9-kana words\n    \"QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD\",\n    // 10-kana words\n    \"IJBEJqXZJ\"\n];\n// Maps each character into its kana value (the index)\nconst mapping = \"~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt\";\nlet _wordlist = null;\nfunction hex(word) {\n    return (0, index_js_2.hexlify)((0, index_js_2.toUtf8Bytes)(word));\n}\nconst KiYoKu = \"0xe3818de38284e3818f\";\nconst KyoKu = \"0xe3818de38283e3818f\";\nfunction toString(data) {\n    return (0, index_js_2.toUtf8String)(new Uint8Array(data));\n}\nfunction loadWords() {\n    if (_wordlist !== null) {\n        return _wordlist;\n    }\n    const wordlist = [];\n    // Transforms for normalizing (sort is a not quite UTF-8)\n    const transform = {};\n    // Delete the diacritic marks\n    transform[toString([227, 130, 154])] = false;\n    transform[toString([227, 130, 153])] = false;\n    // Some simple transforms that sort out most of the order\n    transform[toString([227, 130, 133])] = toString([227, 130, 134]);\n    transform[toString([227, 129, 163])] = toString([227, 129, 164]);\n    transform[toString([227, 130, 131])] = toString([227, 130, 132]);\n    transform[toString([227, 130, 135])] = toString([227, 130, 136]);\n    // Normalize words using the transform\n    function normalize(word) {\n        let result = \"\";\n        for (let i = 0; i < word.length; i++) {\n            let kana = word[i];\n            const target = transform[kana];\n            if (target === false) {\n                continue;\n            }\n            if (target) {\n                kana = target;\n            }\n            result += kana;\n        }\n        return result;\n    }\n    // Sort how the Japanese list is sorted\n    function sortJapanese(a, b) {\n        a = normalize(a);\n        b = normalize(b);\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    // Load all the words\n    for (let length = 3; length <= 9; length++) {\n        const d = data[length - 3];\n        for (let offset = 0; offset < d.length; offset += length) {\n            const word = [];\n            for (let i = 0; i < length; i++) {\n                const k = mapping.indexOf(d[offset + i]);\n                word.push(227);\n                word.push((k & 0x40) ? 130 : 129);\n                word.push((k & 0x3f) + 128);\n            }\n            wordlist.push(toString(word));\n        }\n    }\n    wordlist.sort(sortJapanese);\n    // For some reason kyoku and kiyoku are flipped in node (!!).\n    // The order SHOULD be:\n    //   - kyoku\n    //   - kiyoku\n    // This should ignore \"if\", but that doesn't work here??\n    /* c8 ignore start */\n    if (hex(wordlist[442]) === KiYoKu && hex(wordlist[443]) === KyoKu) {\n        const tmp = wordlist[442];\n        wordlist[442] = wordlist[443];\n        wordlist[443] = tmp;\n    }\n    /* c8 ignore stop */\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    const checksum = (0, index_js_1.id)(wordlist.join(\"\\n\") + \"\\n\");\n    /* c8 ignore start */\n    if (checksum !== \"0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600\") {\n        throw new Error(\"BIP39 Wordlist for ja (Japanese) FAILED\");\n    }\n    /* c8 ignore stop */\n    _wordlist = wordlist;\n    return wordlist;\n}\nlet wordlist = null;\n/**\n *  The [[link-bip39-ja]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangJa extends wordlist_js_1.Wordlist {\n    /**\n     *  Creates a new instance of the Japanese language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langJa]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"ja\"); }\n    getWord(index) {\n        const words = loadWords();\n        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return loadWords().indexOf(word);\n    }\n    split(phrase) {\n        //logger.assertNormalize();\n        return phrase.split(/(?:\\u3000| )+/g);\n    }\n    join(words) {\n        return words.join(\"\\u3000\");\n    }\n    /**\n     *  Returns a singleton instance of a ``LangJa``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangJa();\n        }\n        return wordlist;\n    }\n}\nexports.LangJa = LangJa;\n//# sourceMappingURL=lang-ja.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1qYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esa0dBQWtHLE1BQU07QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9sYW5nLWphLmpzPzliYjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdKYSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCB3b3JkbGlzdF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3QuanNcIik7XG5jb25zdCBkYXRhID0gW1xuICAgIC8vIDQta2FuYSB3b3Jkc1xuICAgIFwiQVFSQVNSQUdCQUdVQUlSQUhCQWdoQVVSQWRCQWRjQW5vQU1FQUZCQUZDQktGQlFSQlNGQkNYQkNEQkNIQkdGQkVRQnBCQnBRQklrQkhOQmVPQmdGQlZDQmhCQmhOQm1PQm1SQmlIQmlGQlVGQlpEQnZGQnNYQmtGQmxjQmpZQndEQk1CQlRCQlRSQldCQldYWGFRWGFSWFFXWFNSWENGWFlCWHBIWE9RWEhSWGhSWHVSWG1YWGJSWGxYWHdEWFRSWHJDWFdRWFdHYUJXYUtjYVlnYXNGYWRRYWxtYU1CYWNBS2FSS0tCS0tYS0tqS1FSS0RSS0NZS0NSS0lES2VWS0hjS2xYS2pIS3JZTkFITkJXTmFSTktjTklCTklPTm1YTnNYTmRYTm5CTk1CTlJCTnJYTldETldNTkZPUUFCUUFIUUJyUVhCUVhGUWFSUUtYUUtEUUtPUUtGUU5CUU5EUVFnUUNYUUNEUUdCUUdEUUdkUVlYUXBCUXBRUXBIUUxYUUh1UWdCUWhCUWhDUXVGUW1YUWlEUVVGUVpEUXNGUWRSUWtIUWJSUWxPUWxtUVBEUWpEUXdYUU1CUU1EUWNGUVRCUVRIUXJERFhRRE5GREdCREdRREdSRHBGRGhGRG1YRFpYRGJSRE1ZRFJkRFRSRHJYU0FoU0JDU0JyU0dRU0VRU0hCU1ZSU2hZU2hrU3lRU3VGU2lCU2RjU29FU29jU2xtU01CU0ZCU0ZLU0ZOU0ZkU0ZjQ0J5Q2FSQ0tjQ1NCQ1NSQ0NyQ0diQ0VIQ1lYQ3BCQ3BRQ0lCQ0lIQ2VOQ2dCQ2dGQ1ZFQ1ZjQ21rQ213Q1pYQ1pGQ2RSQ2xPQ2xtQ2xGQ2pEQ2pkQ25YQ3dCQ3dYQ2NSQ0ZRQ0ZqR1hoR05oR0RFR0RNR0NER0NIR0lGR2dCR1ZYR1ZFR1ZSR21YR3NYR2RZR29TR2JSR25YR3dYR3dER1dSR0ZOR0ZMR0ZPR0ZkR0ZrRUFCRUJERUJGRVhPRWFCRUtTRU5CRU5ERVlYRUlnRUlrRWdCRWdRRWdIRWhGRXVkRXVGRWlCRWlIRWlGRVpERXZCRXNYRXNGRWRYRWRSRWtGRWJCRWJSRWxGRVBDRWZrRUZOWUFFWUFoWUJOWVFkWURYWVNSWUNFWVlvWWdRWWdSWXVSWW1DWVpUWWRCWWJFWWxYWWpRWVJiWVdScEtYcFFvcFFucFNGcENYcElCcElTcGhOcGRCcGRScGJScGNacEZCcEZOcEZEcEZvcEZyTEFETEJ1TFhRTFhjTGFGTENYTEVoTHBCTHBGTEhYTGVWTGhJTGRITGRSTG9ETGJSTHJYSUFCSUJRSUJDSUJzSUJvSUJNSUJSSVhhSWFSSUtZSUtSSU5CSU51SUNESUdCSUlESUlrSWdSSXhGSXlRSWlISWRSSWJZSWJSSWxISXdSSU1ZSWNSSVJWSVRSSUZCSUZOSUZRT0FCT0FGT0JRT2FGT05CT05NT1FGT1NGT0NET0dCT0VRT3BCT0xYT0lCT0lGT2dRT2dGT3lRT3ljT21YT3NYT2RJT2tIT01FT01rT1dXSEJOSFhOSFhXSE5YSER1SERSSFN1SFNSSEhvSGhrSG1SSGRSSGtRSGxjSGxSSHdCSFdjZ0FFZ0FnZ0FrZ0JOZ0JRZ0JFZ1hPZ1ljZ0xYZ0hqZ3lRZ2lCZ3NGZ2RhZ01ZZ1dTZ0ZRZ0ZFVkJUVlhFVktCVktOVktEVktZVktSVk5CVk5ZVkRCVkR4VlNCVlNSVkNqVkdOVkxYVklGVmhCVmhjVnNYVmRSVmJSVmxSaEJZaEtZaERZaEdTaHhXaG1OaGRhaGRraGJSaGpvaE1YaFRSeEFYeFhTeEtCeE5CeEVReGVOeGVReGhYeHNGeGRieGxIeGpjeEZCeEZOeEZReEZPeEZveU5ZeVlveWJjeU1ZdUJRdUJSdUJydURNdUNvdUhCdWRRdWtrdW9CdWxWdU1YdUZFbUNZbUNSbXBSbWVEbWlNbWpkbVRGbUZRaUFEaUJPaWFSaUtSaU5CaU5SaVNGaUdraUdGaUVSaXBSaUxGaUlGaWhZaWJIaWpCaWpFaU1YaVdCaUZCaUZDVUJRVVhGVWFSVU5EVU5jVU5SVU5GVURCVVNIVUNEVUdCVUdGVUVxVUxOVUxvVUlSVWVFVWVZVWdCVWhGVXVSVWlGVXNYVWRGVWtIVWJCVWpTVWpZVXdYVU1EVWNIVVJkVVRCVXJCVXJYVXJRWkFGWlhaWmFSWktGWk5CWlFGWkNYWkdCWllkWnBCWkxEWklGWkhYWkhOWmVRWlZSWlZGWm1YWmlCWnZGWmRGWmtGWmJIWmJGWndYWmNDWmNSWlJCdkJRdkJHdkJMdkJXdkNvdk1Zc0FGc0JEc2FSc0tGc05Gc0Ryc1NIc1NGc0NYc0NSc0VCc0VIc0Vmc3BCc0xCc0xEc0lnc0lSc2VHc2JSc0ZCc0ZRc0ZTZE5CZFNSZENWZEdIZFlEZEhjZFZiZHlTZHVEZHNYZGxSZHdYZFdZZFdjZFdSa0JNa1hPa2FSa05Ja05Ga1NGa0NGa1lCa3BSa2VOa2dCa2hWa21Ya3NGa2xWa01Ca1dEa0ZOb0JOb2FRb2FGb05Cb05Yb05hb05Fb1NSb0Vyb1lYb1lDb1lib3BSb3BGb21Yb2prb3dYb3JGYkJFYkVJYmRCYmpZbGFSbERFbE1YbEZEaktqalNSakdCallCallranBSakxYaklCak9GamVWamJSandCblhRblNIbnBGbkxYbklObk1CblRSd1hCd1hOd1hZd05Gd1FGd1NCd0dGd0xYd0xEd2VOd2dCd3VId2pEd25YTUJYTXBGTUlCTWVOTVRIY2FRY05CY0RIY1NGY0NYY3BCY0xYY0xEY2dGY3VGY25YY3dYY2NEY1RRY3JGVFFFclhOckNIcnBGcmdGcmJGclRIckZjV05ZV05iV0VIV01YV1RSXCIsXG4gICAgLy8gNS1rYW5hIHdvcmRzXG4gICAgXCJBQkdIQUJJSkFFQVZBWUpRQUxaSkFJYVJBSE5YQUhkY0FIYlJBWkpNQVpKUkFaVFJBZFZKQWtsbUFiY05BamRSQU1uUkFNV1lBV3BSQVdnUkFGZ0JBRmhCQUZkY0JOSkJCTkpEQlFLQkJRaGNCUWxtQkRFSkJZSmtCWUpUQnBOQkJwSkZCSUpCQklKREJJY0FCT0tYQk9FSkJPVkpCT2lKQk9aSkJlcEJCZUxYQmVJRkJlZ0JCZ0dKQlZKWEJ1b2NCaUpSQlVKUUJsWFZCbElUQndORkJNWVZCY3FYQlRsbUJXTkZCV2lKQlduUkJGR0hCRndYWEtHSlhOSkJYTlpKWERUVFhTSFNYU1ZSWFNsSFhDSkRYR1FKWEVoWFhZUUpYWWJSWE9mWFhlTmNYVkpGWGhRSlhoRUpYZFRSWGpkWFhNaEJYY1FUWFJHQlhURUJYVG5RWEZDWFhGT0ZYRmdGYUJhRmFCTkphQkNKYUJwQmFCd1hhTkpLYU5KRGFRSUJhRHBSYUVQRGFITUZhbURKYWxFSmFNWkphRmFGYUZOQmFGUUphRkxEYUZWSEtCQ1lLQkVCS0JIREtYYUZLWEdkS1hFSktYcEhLWElCS1haREtYd1hLS3dMS05hY0tOWUpLTkpvS05XY0tER2RLRFRSS0NoWEtHYVJLR2hCS0diUktFQlRLRWFSS0VQVEtMTURLTFdSS09IREtWSmNLZEJjS2xJQktsT1BLRlNCS0ZFUEtGcEZOQk5KTkpCUU5CR0hOQkVQTkJIWE5CZ0ZOQlZYTkJaRE5Cc1hOQndYTk5hUk5OSkROTkpFTk5Ka05EQ0pORFZETkdKUk5KaUROWkpOTnNDSk5KRk5ORlNCTkZDWE5GRVBORkxYTkZJRlFKQkZRQ2FSUUpFUVFMSkRRTEpGUUlhUlFPcVhRSGFGUUhIUVFWSlhRVkpEUWhOSlFtRUlRWkpGUXNKWFFKckZRV2JSREpBQkRCWUpEWE5GRFhDWERYTFhEWFpERFhzSkRRcVhEU0pGREpDWERFUGtERXFYRFltUURwU0pET0NrRE9HUURIRUlEVkpERHVEdURXRUJESkZnU0JORFNCU0ZTQkdIU0JJQlNCVFFTS1ZZU0pRTlNKUWlTSkNYU0VxWFNKWVZTSWlKU09NWVNIQUhTSGFRU2VDRlNlcFFTZWdCU0hkSFNIckZTaFNKU0p1SFNKVUZTa05SU3JTclNXRUJTRmFIU0pGUVNGQ1hTRkdEU0ZZWFNGT0RTRmdCU0ZWWFNGaEJTRnhGU0ZrRlNGYkJTRk1GQ0FEZENKWEJDWGFGQ1hLRkNYTkZDWENYQ1hHQkNYRUpDWFlCQ1hMRENYSUJDWE9QQ1hIWENYZ0JDWGhCQ1hpQkNYbERDWGNIQ0pOQkNKTkZDRENKQ0RHQkNEVlhDRGhCQ0RpRENESmRDQ21OQ3BKRkNJYVJDT3FYQ0hDSENIWkpDVmlKQ3VDdUNtZGRDSmlGQ2ROQkNkSGhDbEVKQ25VSkNyZVNDV2xnQ1dUUkNGQkZDRk5CQ0ZZQkNGVkZDRmhGQ0ZkU0NGVEJDRldER0JOQkdCUUZHSkJDR0JFcUdCcEJHQmdRR05CRUdOSllHTmtPR05KUkdEVUZHSnBRR0hhQkdKZU5HSmVFR1ZCbEdWS2pHaUpER3ZKSEdzVkpHa0VCR01JSkdXak5HRkJGR0ZDWEdGR0JHRllYR0ZwQkdGTUZFQVNKRUFXcEVKTkZFQ0pWRUlYU0VJUUpFT3FYRU9jRkVlTmNFSEVKRUhsRkVKZ0ZFaGxtRW1ESkVtWkpFaU1CRVVxWEVvU1JFUEJGRVBYRkVQS0ZFUFNGRVBFRkVQcEZFUExYRVBJQkVKUGRFUGNGRVBUQkVKblhFcWxIRU1wUkVGQ1hFRk9ERUZjRllBU0pZSkFGWUJhQllCVlhZWHBGWURoQllDSkJZSkdGWVliUlllTmNZSmVWWWlJSllaSmNZdkpnWXZKUllKc1hZc0pGWU1ZTVlyZVZwQk5IcEJFSnBCd1hwUXhGcFlFSnBlTkRwSmVEcGVTRnBlQ0hwSFVKcEhiQnBIY0hwbVVKcGlpSnBVSnJwc0p1cGxJVHBGYUJwRlFxcEZHQnBGRWZwRllCcEZwQnBGTEpwRklEcEZnQnBGVlhwRnlRcEZ1RnBGbEZwRmpEcEZuWHBGd1hwSkZNcEZUQkxYQ0pMWEVGTFhoRkxYVUpMWGJGTGFsbUxOSkJMU0pRTENMQ0xHSkJMTERKTEhhRkxlTkZMZVNITGVDWExlcEZMaGFSTFpzSkxzSkRMc0pyTG9jYUxsTGxMTWRiTEZOQkxGU0JMRkVITEZrRklCQkZJQlhGSUJhUUlCS1hJQlNGSUJwSElCTFhJQmdCSUJoQklCdUhJQm1YSUJpRklCWlhJQnZGSUJiRklCalFJQndYSUJXRklLVFJJUVVKSURHRklDalFJWVNSSUlOWElKZUNJVmFSSW1Fa0laSkZJdkpSSXNKWElkQ0pJSm9SSWJCUUlqWUJJY3FYSVRGVklyZVZJRktGSUZTRklGQ0pJRkdGSUZMRElGSUJJSkZPSUZnQklGVlhJSkZoSUZ4RklGbVhJRmRISUZiQklKRnJJSkZXT0JHQk9RZlhPT0tqT1VxWE9mWEJPcVhFT2NxWE9SVkpPRklCT0ZsREhCSU9IWGlGSE5UUkhDSlhISWFSSEhKREhIRUpIVmJSSFpKWUhiSUJIUnNKSFJrREhXbG1nQktGZ0JTQmdCQ0RnQkdIZ0JwQmdCSUJnQlZKZ0J1QmdCdkZnS0RUZ1FWWGdEVUpnR1NKZ09xWGdtVU1nWklKZ1RVSmdXSUVnRkJGZ0ZOQmdGREpnRlNGZ0ZHQmdGWVhnSkZPZ0ZnUWdGVlhnRmhCZ0ZiSGdKRldWSkFCVlFLY1ZEZ0ZWT2ZYVmVERlZoYVJWbUdkVmlKWVZNYVJWRk5IaEJORGhCQ1hoQkVxaEJwRmhCTFhoTkpCaFNKUmhlVlhoaEtFaHhsbWhaSUpoZEJRaGtJSmhiTU5oTVVKaE1aSnhOSmd4UVVKeERFa3hEZEZ4U0pSeHBsbXhlU0J4ZUNYeGVHRnhlWVh4ZXBReGVnQnhXVmN4RkVReEZMWHhGSUJ4RmdCeEZ4RHhGWnR4RmRjeEZiQnhGd1h5REpYeURsY3VBU0p1REpwdURJQnVDcEp1R1NKdUlKRnVlRUZ1WklKdXNKWHVkV0V1b0lCdVdHSnVGQmN1RktFdUZORnVGUUZ1RkRKdUZHSnVGVkp1RlV0dUZkSHVGVEJtQllKbU5KWW1RaGttTEpEbUxKb21JZFhtaUpZbXZKUm1zSlJta2xtbU1CeW1NdUNtY2xtbWNuUWlKQUJpSkJOaUpCRGlCU0ZpQkNKaUJFRmlCWUJpQnBGaUJMWGlCVEhpSk5jaURFZmlDWkppRUNKaUpFcWlPa0hpSEtGaWVORGlISlFpZVFjaWVESGllU0ZpZUNYaWVHRmllRUZpZUlIaWVnRmloVUppeE5vaW9OWGlGYUJpRktGaUZORGlGRVBpRllYaXRGT2l0RkhpRmdCaUZWRWlGbVhpRml0aUZiQmlGTUZpRnJGVUNYUVVJb1FVSUpjVUhRSlVlQ0VVSHdYVVVKRFVVcVhVZFdjVWNxWFVyblFVRk5EVUZTSFVGQ0ZVRkVmVUZMWFV0Rk9aQlhPWlhTQlpYcEZaWFZYWkVRSlpFSmtacERKWk9xWFplTkhaZUNEWlVxWFpGQlFaRkVIWkZMWHZCQUZ2QktGdkJDWHZCRVB2QnBIdkJJRHZCZ0Z2QnVIdlFOSnZGTkZ2RkdCdkZJQnZKRmNzWENEc1hMWHNYc1hzWGxGc1hjSHNRcVhzSlFGc0VxWHNlSUZzRkVIc0ZqRGRCeE9kTnBSZE5KUmRFSmJkcEpSZGhaSmRuU0pkcmpOZEZOSmRGUUhkRmhOa05KRGtZYVJrSE5Sa0hTUmtWYlJrdU1Sa2pTSmtjcURvU0pGb0VpSm9ZWkpvT2ZYb2hFQm9NR1FvY3FYYkJBRmJCWEZiQmFGYkJORGJCR0JiQkxYYkJUQmJCV0RiR0pZYklKSGJGUXFiRnBRbERnUWxPckZsVkpSakdFQmpaSlJuWHZKblhiQm5FZkhuT1BEbmdKUm54ZlhuVUpXd1hFSndOcEp3RHBCd0VmWHdyRUJNRENKTURHSE1ESUpNTEpEY1FHRGNRcEhjcVhjY3FORmNxQ1hjRkNKUkJTQlJCR0JSQkVKUkJwUVRCTkZUQlFKVEJwQlRCVlhURkFCVEZTQlRGQ0ZURkdCVEZNRHJYQ0pyWExEckROSnJFZkhyRlFKckZpdFdOamRXTlRSXCIsXG4gICAgLy8gNi1rYW5hIHdvcmRzXG4gICAgXCJBS0xKTUFOT1BGQVNOSklBRUpXWEFZSk5SQUlJYlJBSWNkYUFlRWZEQWdpZFJBZGpOWUFNWUVKQU1JYlJBRk5KQkFGcEpGQkJJSllCRFpKRkJTaUpoQkdkRUJCRUpmWEJFSnFYQkVKV1JCcGFVSkJMWHJYQklZSk1CT2NmWEJlRWZGQmVzdFhCak5KUkJjREpPQkZFcVhYTnZKUlhETUJoWENKTllYT0FXcFhPTkpXWEhERUJYZUlhUlhoWUpEWFpKU0pYTURKT1hjQVNKWEZWSlhhQlFxWGFCWkpGYXNYZFFhRlNKUWFGRWZYYUZwSkhhRk9xWEtCTlNSS1h2SkJLUUpoWEtFSlFKS0VKR0ZLSU5KQktJSmpOS2dKTlNLVkVsbUtWaEVCS2lKR0ZLbEJnSktqblVKS3dzSllLTUZJSktGTkpES0ZJSkZLRk9mWE5KQlNGTkpCQ1hOQnBKRk5KQnZRTkpCTUJOSkxKWE5KT3FYTkplQ1hOSmVHRk5kc0pDTmJUS0ZOd1hVSlFORkVQUURpSmNRRE1TSlFTRnBCUUdNUUpRSmVPY1F5Q0pFUVVKRUJRSkZCclFGRUpxRFhESkZESlhwQkRKWElNREdpSmhESUpHUkRKZVljREhyREpEVlhnRkRrQVdwRGtJZ1JEakRFcURNdkpSREpGTkZESkZJQlNLY2xtU0pRT0ZTSlFWSFNKUWpEU0pHSkJTSkdKRlNFQ0pvU0hFSnFTSkhUQlNKVkpEU1ZpSllTWkpOQlNKc0pEU0ZTSkZTRkVmWFNKRkxYQ0JVSlZDSlhTQkNKWHBCQ1hWSlhDSlhzWENKWGRGQ0pOSkhDTElKZ0NIaUpGQ1ZOSk1DaENKaENVSEVKQ3NKVFJDSmRZY0NvUUpDQ0ZFZlhDRklKZ0NGVUp4Q0ZzdEZHSkJhUUdKQklER1FKcVhHWUpOUkdKSEtGR2VRcURHSEVKRkdKZUxYR0hJaUpHSGRCbEdVSkVCR2tJSlRHRlFQREdKRkVxRUFHZWdFSklKQkVKVkpYRWhRSlRFaUpOY0VKWkpGRUpvRXFFakRFcUVQRHNYRVBHSkJFUE9xWEVQZVFGRWZEaURFSmZFRkVmZXBRRWZNaUpFcVhOQkVxRElERXFlU0ZFcVZKWEVNdkpSWVhOSkRZWEVKSFlLVkpjWVlKRUJZSmVFY1lKVXFYWUZwSkZZRnN0WHBBWkpNcEJTSkZwTkJORnBlUVBEcEhMSkRwSElKRnBIZ0pGcGVpdEZwSFpKRnBKRkFEcEZTSkZwSkZDSnBGT3FYcEZpdEJwSkZaSkxYSUpGTElKZ1JMVk5KV0xWSEpNTHdOcEpMRkdKQkxGTEpETEZPcVhMSkZVSklCREpYSUJHSkJJSkJZUUlKQklCSUJPcVhJQmNxRElFR0pGSUxOSlRJSUpFQklPaUpoSUplTkJJSmVJQkloaUpJSVdvVFJJSkZBSElKRnBCSUpGdUhJRlV0RklKRlRIT1NCWUpPRWNxWE9IRUpxT3ZCcEZPa1ZKck9iQlZKT25jcURPY05Ka0hoTkpSSHVISnVIZE1oQmdCVXFYZ0JzSlhnT05KQmdITkpEZ0hISlFnSmVpdGdIc0pYZ0p5TmFneURKQmdaSkRyZ3NWSlFna0VKTmdralNKZ0pGQUhnRkNKRGdGWnRNVkpYTkZWWFFmWFZKWERKVlhvUUpWUVZKUVZERWZYVkR2SkhWRXFORlZlUWZYVkhwSkZWSHhmWFZWSlNSVlZtYVJWbElKT2hDWFZKaEhqWWtoeENKVmhXVlVKaFdpSmN4Qk5KSXhlRXFEeGZYQkZ4Y0ZFUHhGU0pGeEZZSlh5QkRRSnlkYVVKeUZPUER1WUNKWXVMdkpSdUhMSlh1WkpMRHVGT1BEdUZaSkh1RmNxWG1LSEpkbUNRSmNtT3NWSmlKQUdGaXRMQ0ZpZU9mWGllc3RYaVpKTUVpa05KUWlyWHpGaUZRcVhpRklKRmlGWkpGaUZ2dEZVSHBKRlV0ZUljVXRlT2NVVkNKa1VoZEhjVWJFSkVVSnFYUVVNTkpoVVJqWWtVRml0RlpER0pIWkpJeERaSlZKWFpKRkRKWkpGcFF2Qk5KQnZCU0pGdkp4QnJzZVFxRHNWRlZKZEZMSkRrRUpOQmttTkpZa0ZMSkRvUUpPUG9Hc0pSb0VBSEJvRUpmRmJCUXFEYkJaSkhiRlZKWGxGSUpCallJclhqZWl0Y2pqQ0VCaldNTkJ3WFFmWHdYT2FGd0RzSlh3Q0pUUndyQ1pKTUROSlFjRERKRmNxRE9QUllpSkZUQnNKWFRRSUpCVEZFZlhURkxKRHJYRUpGckVKWE1yRlpKRldFSmRFV1lUbG1cIixcbiAgICAvLyA3LWthbmEgd29yZHNcbiAgICBcIkFCQ0RFRkFDTkpUUkFNQkRKZEFjTkpWWEJMTkpFQlhTSWRXUlhFck5Ka1hZREpNQlhaSkNKYVhNTkphWUtLVkpLY0tERUpxWEtEY05KaEtWSnJOWUtiZ0pWWEtGVkpTQk5CWUJ3RE5KZVFmWE5KZUVxWE5oR0pXRU5KRmlKUlFsSUpiRVFKZlh4RFFxWGNmWFFGTkRFSlFGd1hVSkRZY25VSkRKSUJnUURJVUpUUkRKRkVxRFNKUVNKRlNKUUlKRlNPUGVadFNKRlpKSENKWFFmWENUREVxRkdKQlNKRkdKQk9mWEdKQmNxWEdKSE5KREdKUkxpSkVKZlhFcUVKRkVKUEVGcEJFSllKQlpKRllCd1hVSllpSk1FQllKWkp5VFlUT05KWHBRTUZYRnBlR0lEZHBKRnN0WHBKRmNQRExCVlNKUkxIUUpxWExKRlpKRklKQk5KRElKQlVxWElCa0ZESklKRUpQVElZSkdXUklKZVFQRElKZUVmSElKRnNKWE9xR0RTRkhYRUpxWGdKQ3NKQ2dHUUpxWGdkUVlKRWdGTUZOQmdKRmNxRFZKd1hVSlZKRlpKY2hJZ0pDQ3hPRUpxWHhPd1hVSnlESkJWUnVzY2lzY2lKQmlKQmllVXRxWGlKRkRKa2lGc0pYUVVHRVpKY1VKRnNKWFp0WElyWFpEWkpEclpKRk5KRFpKRnN0WHZKRlFxWHZKRkNKRXNKWFFKcWtoa05HQmJESmRUUmJZSk1FQmxEd1hVSk1FRmlKRmNmWE5KRFJjTkpXTVRCTEpYQ1wiLFxuICAgIC8vIDgta2FuYSB3b3Jkc1xuICAgIFwiQnJhRlV0SEJGU0pGZGJOQkxKWFZKUW9ZSk5FQlNKQkVKZkhTSkh3WFVKQ0pkQVpKTUdqYUZWSlhFSlBOSkJsRUpmRmlKRnBGYkZFSnFJSkJWSkNySUJkSGlKaE9QRkNodkpWSlpKTkpXeEdGTklGTHVlSUJRSnFVSEVKZlVGc3RPWkpEcmxYRUFTSlJsWFZKWFNGd1ZKTkpXRFwiLFxuICAgIC8vIDkta2FuYSB3b3Jkc1xuICAgIFwiUUpFSk5OSkRRSkVKSUJTRlFKRUp4ZWdCUUpFSmZIRVBTSkJtWEVKRlNKQ0RFSnFYTFhOSkZRcVhJY1FzRk5KRklGRUpxWFVKZ0ZzSlhJSkJVSkVKZkhORnZKeEVxWE5KblhVSkZRcURcIixcbiAgICAvLyAxMC1rYW5hIHdvcmRzXG4gICAgXCJJSkJFSnFYWkpcIlxuXTtcbi8vIE1hcHMgZWFjaCBjaGFyYWN0ZXIgaW50byBpdHMga2FuYSB2YWx1ZSAodGhlIGluZGV4KVxuY29uc3QgbWFwcGluZyA9IFwifn5BekJ+WH5hfktOflF+RH5TfkN+R35Ffll+cH5Mfkl+T35lSH5nflZ+aHh5dW1pfn5Vfn5afn52fn5zfn5ka29ibFBqZm5xd01jUlRyfld+fn5Gfn5+fn5KdFwiO1xubGV0IF93b3JkbGlzdCA9IG51bGw7XG5mdW5jdGlvbiBoZXgod29yZCkge1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMi50b1V0ZjhCeXRlcykod29yZCkpO1xufVxuY29uc3QgS2lZb0t1ID0gXCIweGUzODE4ZGUzODI4NGUzODE4ZlwiO1xuY29uc3QgS3lvS3UgPSBcIjB4ZTM4MThkZTM4MjgzZTM4MThmXCI7XG5mdW5jdGlvbiB0b1N0cmluZyhkYXRhKSB7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLnRvVXRmOFN0cmluZykobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xufVxuZnVuY3Rpb24gbG9hZFdvcmRzKCkge1xuICAgIGlmIChfd29yZGxpc3QgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF93b3JkbGlzdDtcbiAgICB9XG4gICAgY29uc3Qgd29yZGxpc3QgPSBbXTtcbiAgICAvLyBUcmFuc2Zvcm1zIGZvciBub3JtYWxpemluZyAoc29ydCBpcyBhIG5vdCBxdWl0ZSBVVEYtOClcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB7fTtcbiAgICAvLyBEZWxldGUgdGhlIGRpYWNyaXRpYyBtYXJrc1xuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMzAsIDE1NF0pXSA9IGZhbHNlO1xuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMzAsIDE1M10pXSA9IGZhbHNlO1xuICAgIC8vIFNvbWUgc2ltcGxlIHRyYW5zZm9ybXMgdGhhdCBzb3J0IG91dCBtb3N0IG9mIHRoZSBvcmRlclxuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMzAsIDEzM10pXSA9IHRvU3RyaW5nKFsyMjcsIDEzMCwgMTM0XSk7XG4gICAgdHJhbnNmb3JtW3RvU3RyaW5nKFsyMjcsIDEyOSwgMTYzXSldID0gdG9TdHJpbmcoWzIyNywgMTI5LCAxNjRdKTtcbiAgICB0cmFuc2Zvcm1bdG9TdHJpbmcoWzIyNywgMTMwLCAxMzFdKV0gPSB0b1N0cmluZyhbMjI3LCAxMzAsIDEzMl0pO1xuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMzAsIDEzNV0pXSA9IHRvU3RyaW5nKFsyMjcsIDEzMCwgMTM2XSk7XG4gICAgLy8gTm9ybWFsaXplIHdvcmRzIHVzaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICBmdW5jdGlvbiBub3JtYWxpemUod29yZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQga2FuYSA9IHdvcmRbaV07XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0cmFuc2Zvcm1ba2FuYV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGthbmEgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0ga2FuYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBTb3J0IGhvdyB0aGUgSmFwYW5lc2UgbGlzdCBpcyBzb3J0ZWRcbiAgICBmdW5jdGlvbiBzb3J0SmFwYW5lc2UoYSwgYikge1xuICAgICAgICBhID0gbm9ybWFsaXplKGEpO1xuICAgICAgICBiID0gbm9ybWFsaXplKGIpO1xuICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBMb2FkIGFsbCB0aGUgd29yZHNcbiAgICBmb3IgKGxldCBsZW5ndGggPSAzOyBsZW5ndGggPD0gOTsgbGVuZ3RoKyspIHtcbiAgICAgICAgY29uc3QgZCA9IGRhdGFbbGVuZ3RoIC0gM107XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGQubGVuZ3RoOyBvZmZzZXQgKz0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IG1hcHBpbmcuaW5kZXhPZihkW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICB3b3JkLnB1c2goMjI3KTtcbiAgICAgICAgICAgICAgICB3b3JkLnB1c2goKGsgJiAweDQwKSA/IDEzMCA6IDEyOSk7XG4gICAgICAgICAgICAgICAgd29yZC5wdXNoKChrICYgMHgzZikgKyAxMjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29yZGxpc3QucHVzaCh0b1N0cmluZyh3b3JkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd29yZGxpc3Quc29ydChzb3J0SmFwYW5lc2UpO1xuICAgIC8vIEZvciBzb21lIHJlYXNvbiBreW9rdSBhbmQga2l5b2t1IGFyZSBmbGlwcGVkIGluIG5vZGUgKCEhKS5cbiAgICAvLyBUaGUgb3JkZXIgU0hPVUxEIGJlOlxuICAgIC8vICAgLSBreW9rdVxuICAgIC8vICAgLSBraXlva3VcbiAgICAvLyBUaGlzIHNob3VsZCBpZ25vcmUgXCJpZlwiLCBidXQgdGhhdCBkb2Vzbid0IHdvcmsgaGVyZT8/XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGhleCh3b3JkbGlzdFs0NDJdKSA9PT0gS2lZb0t1ICYmIGhleCh3b3JkbGlzdFs0NDNdKSA9PT0gS3lvS3UpIHtcbiAgICAgICAgY29uc3QgdG1wID0gd29yZGxpc3RbNDQyXTtcbiAgICAgICAgd29yZGxpc3RbNDQyXSA9IHdvcmRsaXN0WzQ0M107XG4gICAgICAgIHdvcmRsaXN0WzQ0M10gPSB0bXA7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3RcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBpbmRleF9qc18xLmlkKSh3b3JkbGlzdC5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGNoZWNrc3VtICE9PSBcIjB4Y2IzNmIwOWU2YmFhOTM1Nzg3ZmQ3NjJjZTY1ZTgwYjBjNmE4ZGFiZGZiYzNhN2Y4NmFjMGUyYzRmZDExMTYwMFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBqYSAoSmFwYW5lc2UpIEZBSUxFRFwiKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBfd29yZGxpc3QgPSB3b3JkbGlzdDtcbiAgICByZXR1cm4gd29yZGxpc3Q7XG59XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS1qYV1dIGZvciBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nSmEgZXh0ZW5kcyB3b3JkbGlzdF9qc18xLldvcmRsaXN0IHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgSmFwYW5lc2UgbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nSmFdXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoXCJqYVwiKTsgfVxuICAgIGdldFdvcmQoaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBsb2FkV29yZHMoKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAgJiYgaW5kZXggPCB3b3Jkcy5sZW5ndGgsIGBpbnZhbGlkIHdvcmQgaW5kZXg6ICR7aW5kZXh9YCwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB3b3Jkc1tpbmRleF07XG4gICAgfVxuICAgIGdldFdvcmRJbmRleCh3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb2FkV29yZHMoKS5pbmRleE9mKHdvcmQpO1xuICAgIH1cbiAgICBzcGxpdChwaHJhc2UpIHtcbiAgICAgICAgLy9sb2dnZXIuYXNzZXJ0Tm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBwaHJhc2Uuc3BsaXQoLyg/OlxcdTMwMDB8ICkrL2cpO1xuICAgIH1cbiAgICBqb2luKHdvcmRzKSB7XG4gICAgICAgIHJldHVybiB3b3Jkcy5qb2luKFwiXFx1MzAwMFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdKYWBgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nSmEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nSmEgPSBMYW5nSmE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWphLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-ja.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-ko.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-ko.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangKo = void 0;\nconst index_js_1 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\nconst data = [\n    \"OYAa\",\n    \"ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8\",\n    \"ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6\",\n    \"ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv\",\n    \"AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo\",\n    \"AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg\",\n    \"HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb\",\n    \"AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl\"\n];\nconst codes = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*\";\nfunction getHangul(code) {\n    if (code >= 40) {\n        code = code + 168 - 40;\n    }\n    else if (code >= 19) {\n        code = code + 97 - 19;\n    }\n    return (0, index_js_2.toUtf8String)(new Uint8Array([225, (code >> 6) + 132, (code & 0x3f) + 128]));\n}\nlet _wordlist = null;\nfunction loadWords() {\n    if (_wordlist != null) {\n        return _wordlist;\n    }\n    const wordlist = [];\n    data.forEach((data, length) => {\n        length += 4;\n        for (let i = 0; i < data.length; i += length) {\n            let word = \"\";\n            for (let j = 0; j < length; j++) {\n                word += getHangul(codes.indexOf(data[i + j]));\n            }\n            wordlist.push(word);\n        }\n    });\n    wordlist.sort();\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    const checksum = (0, index_js_1.id)(wordlist.join(\"\\n\") + \"\\n\");\n    /* c8 ignore start */\n    if (checksum !== \"0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a\") {\n        throw new Error(\"BIP39 Wordlist for ko (Korean) FAILED\");\n    }\n    /* c8 ignore stop */\n    _wordlist = wordlist;\n    return wordlist;\n}\nlet wordlist = null;\n/**\n *  The [[link-bip39-ko]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangKo extends wordlist_js_1.Wordlist {\n    /**\n     *  Creates a new instance of the Korean language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langKo]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() {\n        super(\"ko\");\n    }\n    getWord(index) {\n        const words = loadWords();\n        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return loadWords().indexOf(word);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangKo``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangKo();\n        }\n        return wordlist;\n    }\n}\nexports.LangKo = LangKo;\n//# sourceMappingURL=lang-ko.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1rby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLE1BQU07QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1rby5qcz9hOGNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nS28gPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgd29yZGxpc3RfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LmpzXCIpO1xuY29uc3QgZGF0YSA9IFtcbiAgICBcIk9ZQWFcIixcbiAgICBcIkFUQVpvQVRCbDNBVENUckFUQ2w4QVREbG9BVEdnM0FUSFQ4QVRKVDhBVEpsM0FUTGx2QVRMbjRBVE1UOEFUTVg4QVRNYm9BVE1nb0FUb0xiQVRvTVRBVHJIZ0FUdkhuQVQzQW5BVDNKYkFUM01UQVQ4RGJBVDhKVEFUOExtQVQ4TVlBVDhNYkFUI0xuQVVIVDhBVUhadkFVSlhyQVVKWDhBVUxuckFYSm52QVhMVW9BWExndkFYTW42QVhSZzNBWHJNYkFYM0pUQVgzUWJBWUxuM0FaTGd2QVpyU1VBWnZBY0FaOEFhQVo4QWJBWjhBbkFaOEhuQVo4TGdBWjhNWUFaOE1nQVo4T25BYUFib0FhRFRyQWFGVHJBYUpUckFhSmJvQWFMVm9BYU1YdkFhT2w4QWFTZW9BYkFVb0FiQWc4QWJBbDRBYkduckFiTVQ4QWJNWHJBYk1uNEFiUWI4QWJTVjhBYnZSbEFiOEFVQWI4QW5BYjhIZ0FiOEpUQWI4TlRBYjhSYkFjR2JvQWNMbnZBY01UOEFjTVg4QWNTVG9BY3JBYUFjckZuQWM4QWJBYzhNZ0FmR2dyQWZIYm9BZkpudkFmTFY4QWZMa29BZk1UOEFmTW5vQWZRYjhBZlNjckFmU2dyQWdBWjhBZ0ZsM0FnR1g4QWdIWnZBZ0hnckFnSlhvQWdKWDhBZ0pib0FnTFpvQWdMbjRBZ09YOEFnb0FUQWdvQW5BZ29DVUFnb0pnQWdvTFhBZ29NWUFnb1NlQWdyRFVBZ3JKVEFockZuQWhyTGpBaHJRZ0FqQWdvQWpKbnJBa01YOEFrT25vQWxDVHZBbENWOEFsQ2x2QWxGZzRBbEZsNkFsRm4zQWxvU25BbHJBWEFsckFmQWxyRlVBbHJGYkFsckdnQWxyT1hBbHZLbkFsdk1UQWwzQWJBbDNNbkFuQVRyQW5BY3JBbkNaM0FuQ2w4QW5EZzhBbkZib0FuRmwzQW5IWDRBbkhickFuSGdyQW5JbDNBbkpndkFuTFhvQW5MWDRBbkxickFuTGdyQW5MaHJBbk1Yb0FuTWdyQW5PbjNBblNickFuU2VvQW52TG5BbjNPbkNUR2d2Q1RTbHZDVHZBVUNUdktuQ1R2TlRDVDNDWkNUM0dVQ1QzTVRDVDhIbkNVQ1pyQ1VMZjhDVUxudkNVM0huQ1UzSlVDWTZOVUNiRGI4Q2JGWm9DYkxuckNib09UQ2JvU2NDYnJGbkNidkxuQ2I4QWdDYjhIZ0NiJExuQ2tMZm9DbEJuM0Nsb0RVRFRIVDhEVExsM0RUU1U4RFRyQWFEVHJMWERUckxqRFRyT1lEVHJPZ0RUdkZYRFR2Rm5EVDNIVURUM0xmRFVDVDlEVURUNERVRlZvRFVGVjhEVUZrb0RVR2dyRFVKbnJEVUxsOERVTVQ4RFVNWHJEVU1YNERVTWc4RFVPVW9EVU9ndkRVT2c4RFVTVG9EVVNaOERiRFhvRGJEZ29EYkdUOERiSm4zRGJMZzNEYkxuNERiTVhyRGJNZzhEYk9Ub0Rib0pYR1RDbHZHVERUOEdURlpyR1RMVm9HVExsdkdUTGwzR1RNZzhHVE9UdkdUU2xyR1RvQ1VHVHJEZ0dUckpZR1RyU2NHVHRMbkdUdkFuR1R2UWdHVUNackdVRFR2R1VGWm9HVUhYckdVTG52R1VNVDhHVW9NZ0dYb0xuR1hyTVhHWHJNbkdYdkZuR1lMbnZHWk9udkdadk9uR1o4TGFHWjhMbUdiQWwzR2JEWXZHYkRsckdiSFgzR2JKbDRHYkxWOEdiTG4zR2JNbjRHYm9KVEdib1JmR2J2RlVHYjNHVUdiNEpuR2dEWDNHZ0ZsJEdnSmxyR2dMWDZHZ0xab0dnTGY4R2dPWG9HZ3JBZ0dnckpYR2dyTVlHZ3JTY0dndkFUR2d2T1lHbkFnb0duSmd2R25MWm9HbkxnM0duTG5yR25RbjhHblNickduck1nSFRDbHZIVERUb0hURlQzSFRRVDhIVG9KVEhUb0pnSFRyRFVIVHJNbkhUdkZZSFR2UmZIVDhNbkhUOFNVSFVBWjhIVUJiNEhVRFR2SFVvTVlIWEZsNkhYSlg2SFhRbHJIWHJBVUhYck1uSFhyU2JIWHZGWUhYdktYSFgzTGpIWDNNZUhZdlFsSFpyU2NIWnZEYkhiQWNySGJGVDNIYkZsM0hiSlQ4SGJMVHJIYk1UOEhiTVhySGJNYnJIYlFiOEhiU1gzSGJvRGJIYm9KVEhickZVSGJySGdIYnJKVEhiOEpUSGI4TW5IYjhRZ0hnQWxySGdEVDNIZ0dnckhnSGdySGdKVHJIZ0pUOEhnTFhASGdMbnJIZ01UOEhnTVg4SGdNYm9IZ09uckhnUVRvSGdSZzNIZ29IZ0hnckNiSGdyRm5IZ3JMVkhndkFjSGd2QWZIbkFsb0huQ1RySG5DbnZIbkdUckhuR1o4SG5HbnZIbkpUOEhuTGY4SG5Ma3ZIbk1nOEhuUlRySVR2RlVJVHZGbkpUQVhySlRDVjhKVEZUM0pURlQ4SlRGbjRKVEdndkpUSFQ4SlRKVDhKVEpYdkpUSmwzSlRKbnZKVExYNEpUTGY4SlRMaHZKVE1UOEpUTVhySlRNbnJKVE9ickpUUVQ4SlRTbHZKVDhEVUpUOEZrSlQ4TVRKVDhPWEpUOE9nSlQ4UVVKVDhSZkpVSFpvSlhGVDRKWEZsckpYR1o4SlhHbnJKWExWOEpYTGd2SlhNWG9KWE1YM0pYTmJvSlhQbHZKWG9KVEpYb0xrSlhyQVhKWHJIVUpYckpnSlh2SlRKWHZPbkpYNEtuSllBbDNKWUpUOEpZTGh2SllRVG9KWXJRWEpZNk5VSmJBbDNKYkNackpiRGxvSmJHVDhKYkdnckpiSlh2SmJKYm9KYkxmOEpiTGhySmJMbDNKYk1udkpiUmc4SmJTWjhKYm9EYkpickNaSmJyU1VKYjNLbkpiOExuSmZSbjhKZ0FYckpnQ1pySmdEVHJKZ0dackpnR1o4SmdIVG9KZ0pUOEpnSlhvSmdKZ3ZKZ0xYNEpnTFozSmdMWjhKZ0xuNEpnTWdySmdNbjRKZ09ndkpnUFg2SmdSbnZKZ1NUb0pnb0NaSmdvSmJKZ29NWUpnckpYSmdySmdKZ3JMakpnNk1USmxDbjNKbEdndkpsSmw4Smw0QW5KbDhGbkpsOEhnSm5BVG9KbkFUckpuQWJ2Sm5EVW9KbkduckpuSlhySm5KWHZKbkxodkpuTG5ySm5MbnZKbk1Ub0puTVQ4Sm5NWHZKbk1YM0puTWc4Sm5NbHJKbk1uNEpuT1g4Sm5TVDRKblNYM0pub0FnSm5vQW5Kbm9KVEpub09iSm5yQWJKbnJBa0puckhuSm5ySlRKbnJKWUpuck9ZSm5yU2NKbnZDVUpudkZhSm52SmdKbnZKbkpudk9ZSm52UVVKbnZSVUpuM0ZuSm4zSlRLbkZsM0tuTFQ2TFREbHZMVE1ub0xUT24zTFRSbDNMVFNiNExUU2xyTFRvQW5MVG9KZ0xUckFVTFRyQWNMVHJDVUxUckhnTFRyTWdMVDNKbkxVTG5yTFVNWDhMVW9KZ0xWQVRyTFZEVHJMVkxiOExWb0pnTFY4TWdMVjhSVExYRGczTFhGbHJMWHJDbkxYckxYTFgzR1RMWDRHZ0xYNE9ZTFpBWHJMWkFjckxaQWdyTFpBaHJMWkRYeUxaRGxyTFpGYnJMWkZsM0xaSlg2TFpKWDhMWkxjOExaTG5yTFpTVThMWm9KVExab0puTFpyQWdMWnJBbkxackpZTFpyTFVMWnJNZ0xaclNrTFp2QW5MWnZHVUxadkplTFp2T1RMWjNGWkxaNEpYTFo4U1RMWjhTY0xhQVQzTGFBbDNMYUhUOExhSlRyTGFKVDhMYUpYckxhSmd2TGFKbDRMYUxWb0xhTVhyTGFNWHZMYU1YOExiQ2x2TGJGVG9MYkhsckxiSm40TGJMWjNMYkxodkxiTVhyTGJNbm9MYnZTVUxjTG5yTGM4SG5MYzhNVExkck1uTGVBZ29MZU9ndkxlT24zTGZBbDNMZkxudkxmTWwzTGZPWDhMZjhBbkxmOEpYTGY4TFhMZ0pUckxnSlhyTGdKbDhMZ01YOExnUlpyTGhDVG9MaHJBYkxockZVTGhySlhMaHZKWUxqSFRyTGpIWDRMakpYOExqTGhyTGpTWDNMalNaNExrRlg0TGtHWjhMa0dndkxrSlRyTGtNWG9Ma1NUb0xrU1U4TGtTWjhMa29PWUxsM0ZmTGwzTWdMbUFackxtQ2JyTG1HZ3JMbUhib0xtSm5vTG1KbjNMbUxmb0xtTGhyTG1TVG9MbkFYNkxuQWI2TG5DWjNMbkNiM0xuRFR2TG5EYjhMbkZsM0xuR25yTG5IWnZMbkhndkxuSVR2TG5KVDhMbkpYOExuSmx2TG5MZjhMbkxnNkxuTGh2TG5Mbm9Mbk1YckxuTWc4TG5RbHZMblNickxuckFnTG5yQW5MbnJEYkxuckZrTG5ySmRMbnJNVUxuck9ZTG5yU1RMbnZBbkxudkRVTG52SGdMbnZPWUxudk9uTG4zR2dMbjREVUxuNEpUTG40Sm5NVEFab01UQWxvTVREYjhNVEZUOE1USm5vTVRKbnJNVExack1UTGhyTVRMa3ZNVE1YOE1UUlRyTVRvQVRNVHJEbk1Uck9uTVQzSm5NVDRNbk1UOEZVTVQ4RmFNVDhGbE1UOEdUTVQ4R2JNVDhHbk1UOEhuTVQ4SlRNVDhKYk1UOE9UTVVDbDhNVUpUck1VSlU4TVVNWDhNVVJUck1VU1RvTVhBWDZNWEFiNk1YQ1pvTVhGWHJNWEhYck1YTGd2TVhPZ29NWHJBVU1YckFuTVhySGdNWHJKWU1YckpuTVhyTVRNWHJNZ01Yck9ZTVhyU1pNWHJTZ01YdkRVTVh2T1RNWDNKZ01YM09UTVg0Sm5NWDhEYk1YOEZuTVg4SGJNWDhIZ01YOEhuTVg4TGJNWDhNbk1YOE9uTVlBYjhNWUdib01ZSFR2TVlIWDRNWUxUck1ZTG52TVlNVG9NWU9ndk1ZUmczTVlTVHJNYkFUb01iQVhyTWJBbDNNYkFuOE1iR1o4TWJKVDhNYkpYck1iTVh2TWJNWDhNYk1ub01ick1VTWI4QWZNYjhGYk1iOEZrTWNKWG9NZUxuck1nRmwzTWdHVHZNZ0dYb01nR2dyTWdHbnJNZ0hUOE1nSFpyTWdKbm9NZ0xuck1nTG52TWdNVDhNZ1FVb01nckhuTWd2QW5NZzhIZ01nOEpZTWc4TGZNbG9Kbk1sOEFUTWw4QVhNbDhKWU1uQVRvTW5BVDRNbkFaOE1uQWwzTW5BbDRNbkNsOE1uSFQ4TW5IZzhNbkpub01uTFpvTW5MaHJNbk1Yb01uTVgzTW5NbnJNbk9ndk1uckZiTW5yRmZNbnJGbk1uck5UTW52SlhOVE1sOE9UQ1QzT1RGVjhPVEZuM09USFp2T1RKWHJPVE9sM09UM0FUT1QzSlVPVDNMWk9UM0xlT1QzTWJPVDhBVE9UOEFiT1Q4QWdPVDhNYk9VQ1h2T1VNWDNPWEhYdk9YTGwzT1hyTVVPWHZEYk9YNk5VT1g4SmJPWUZab09ZTGJyT1lMa29PWU1nOE9ZU1gzT2JIVHJPYkhUNE9iSmdyT2JMaHJPYk1YM09iT1g4T2I4Rm5PZUFsck9lSlQ4T2VKWHJPZUpuck9lTFRvT2VNYjhPZ0pYb09nTFhvT2dNbnJPZ09Yck9nT2xvT2dvQWdPZ29KYk9nb01ZT2dvU1RPZzhBYk9qTFg0T2pNbm9PalNWOE9uTFZvT25yQWdPbjNEVVBYUWxyUFh2RlhQYnZGVFBkQVQzUGxGbjNQbnZGYlFUTG40UVRvQWdRVG9NVFFVTFY4UVVSZzhRVW9KblFYQ1h2UWJGYnJRYjhBYVFiOEFjUWI4RmJRYjhNWVFiOFNjUWVBbHJRZUxoclFqQW4zUWxGWG9RbG9KZ1Fsb1NuUlRMbnZSVHJHVVJUckpUUlVKWnJSVW9KbFJVclFuUlpyTG1SWnJNblJaclNuUlo4QVRSWjhKYlJaOFNjUmJNVDhSYlNUM1JmR1pyUmZNWDhSZk1nclJmU1pyUm5BYnJSbkdUOFJudkpnUm52TGZSbnZNVFJuOEFhU1RDbHZTVEpnclNUT1hyU1RSZzNTVFJudlNUb0FjU1RvQWZTVG9BblNUb0huU1RvTGpTVG9NVFNUckFhU1RyRVVTVDNCWVNUOEFnU1Q4TG1TVUFadlNVQWdyU1VEVDRTVURUOFNVR2d2U1VKWG9TVUpYdlNVTFRyU1U4SlRTVThMalNWOEFuU1Y4SmdTWEZUb1NYTGY4U1l2QW5TWnJEVVNack1VU1pyTW5TWjhIZ1NaOEpUU1o4SmdTWjhNWVNaOFFVU2FRVW9TYkNUM1NiSFRvU2JRWXZTYlNsNFNib0puU2J2RmJTYjhIYlNiOEpnU2I4T1RTY0daclNjSGdyU2NKVHZTY01UOFNjU1RvU2NvSGJTY3JNVFNjdkFuU2VBWnJTZUFjclNlSGJvU2VKVW9TZUxoclNlTVQ4U2VNWHJTZTZKZ1NnSFRyU2tKbm9Ta0xudlNrOENVU2xGbDNTbHJTblNsOEduU21BYm9TbUdUOFNtSlU4XCIsXG4gICAgXCJBVExuRGxBVHJBWm9BVHJKWDRBVHJNVDhBVHJNWDRBVHJSVHJBVHZEbDhBVHZKVW9BVHZNbDhBVDNBVG9BVDNNWDhBVDhDVDNBVDhEVDhBVDhIWnJBVDhIZ29BVUFnRm5BVUNURm5BWG9NWDhBWHJBVDhBWHJHZ3ZBWHJKWHZBWHJPZ29BWHZMbDNBWnZBZ29BWnZGYnJBWnZKWG9BWnZKbDhBWnZKbjNBWnZNWDhBWnZTYnJBWjhGWm9BWjhMWjhBWjhNVThBWjhPVHZBWjhTVjhBWjhTWDNBYkFnRlpBYm9Kbm9BYnZHYm9BYjhBVHJBYjhBWm9BYjhBZ3JBYjhBbDRBYjhEYjhBYjhKbm9BYjhMWDRBYjhMWnJBYjhMaHJBYjhNVDhBYjhPVW9BYjhRYjhBYjhTVDhBY3JBVW9BY3JBYzhBY3JDWjNBY3JGVDNBY3JGWnJBY3JKbDRBY3JKbjNBY3JNWDNBY3JPVHZBYzhBWjhBYzhNVDhBZkFjSlhBZ29GbjRBZ29HZ3ZBZ29HbnJBZ29MYzhBZ29NWG9BZ3JMbnJBa3JTWjhBbEZYQ1RBbG9IYm9BbHJIYnJBbHJMaHJBbHJMa29BbDNDWnJBbDNMVW9BbDNMWnJBbnJBbDRBbnJNVDhBbjNIVDRCVDNJVG9CWDRNbnZCYiFMbiRDVEdYTW5DVG9MWjRDVHJIVDhDVDNKVHJDVDNSWnJDVCNHVHZDVTZHZ3ZDVThEYjhDVThHWnJDVThIVDhDYm9MbDNDYnJHZ3JDYnJNVThDYjhEVDNDYjhHbnJDYjhMWDRDYjhNVDhDYjhPYnJDZ3JHZ3ZDZ3JLWDRDbDhGWm9EVHJBYnZEVHJEYm9EVHJHVDZEVHJKZ3JEVHJNWDNEVHJSWnJEVHJSZzhEVHZBVnZEVHZGWm9EVDNEVDhEVDNMbjNEVDRIWnJEVDRNVDhEVDhBbHJEVDhNVDhEVUFrR2JEVURiSm5EWUxuUWxEYkRVT1lEYk1UQW5EYk1YU25EYm9BVDNEYm9GbjREYm9MbnZEajZKVHJHVENnRlRHVEdnRm5HVEpUTW5HVExuUGxHVG9KVDhHVHJDVDNHVHJMVm9HVHJMbnZHVHJNWDNHVHJNYm9HVHZLbDNHWkNsRm5HWnJEVDNHWjhEVHJHWjhGWjhHWjhNWHZHWjhPbjhHWjhTVDNHYkNuUVhHYk1iRm5HYm9GYm9HYm9KZzNHYm9NWG9HYjNKVHZHYjNKYm9HYjNNbjZHYjNRYjhHZ0RYTGpHZ01uQVVHZ3JEbG9HZ3JIWDRHZ3JTVG9HZ3ZBWHJHZ3ZBWnZHZ3ZGYnJHZ3ZMbDNHZ3ZNbnZHbkRuTFhHbnJBVHJHbnJNYm9HbnVMbDNIVEFUTW5IVEFnQ25IVENUQ1RIVHJHVHZIVHJIVHZIVHJKWDhIVHJMbDhIVHJNVDhIVHJNZ29IVHJPVHJIVHVPbjNIVHZBWnJIVHZEVHZIVHZHYm9IVHZKVThIVHZMbDNIVHZNWHJIVHZRYjRIVDRHVDZIVDRKVDhIVDRKYiNIVDhBbDNIVDhHWnJIVDhHZ3JIVDhIWDRIVDhKYjhIVDhKbm9IVDhMVHJIVDhMZ3ZIVDhTVG9IVDhTVjhIVW9KVW9IVW9KWDhIVW9MbnJIWHJMWm9IWHZBbDNIWDNMbnJIWDRGa3ZIWDRMaHJIWDRNWG9IWDRPbm9IWnJBWjhIWnJEYjhIWnJHWjhIWnJKbnJIWnZHWjhIWnZMbnZIWjhKbnZIWjhMaHJIYkNYSmxIYk1UQW5IYm9KbDRIYnBMbDNIYnJKWDhIYnJMbnJIYnJNbnZIYnZSWXJIZ29TVHJIZ3JGVjhIZ3JHWjhIZ3JKWG9IZ3JSbnZIZ3ZCYiFIZ3ZHVHJIZ3ZIWDRIZ3ZIbiFIZ3ZMVHJIZ3ZTVThIbkRuTGJIbkZiSmJIbnZEbjhIbjZHZ3ZIbiFCVHZKVENUTG5KVFFnRm5KVHJBbnZKVHJMWDRKVHJPVW9KVHZGbjNKVHZMbnJKVHZOVG9KVDNBZ29KVDNKbjRKVDNMaHZKVDNPYnJKVDhBY3JKVDhBbDNKVDhKVDhKVDhKbm9KVDhMWDRKVDhMbnJKVDhNWDNKVDhSZzNKVDhTYzhKVW9CVHZKVThBVG9KVThHWjhKVThHZ3ZKVThKVHJKVThKWHJKVThKbnJKVThMbnZKVThTY3ZKWEhuSmxKWHJHZ3ZKWHJKVThKWHJMaHJKWHJNVDhKWHJNWHJKWHJRVW9KWHZDVHZKWHZHWjhKWHZHZ3JKWHZRVDhKWDhBYjhKWDhEVDhKWDhHWjhKWDhIWnZKWDhMbnJKWDhNVDhKWDhNWG9KWDhNbnZKWDhTVDNKWUduQ1RKYkFrR2JKYkNUQW5KYkxUQWNKYm9EVDNKYm9MYjZKYnJBbnZKYnJDbjNKYnJEbDhKYnJHYm9KYnJJWm9KYnJKbnZKYnJNbnZKYnJRYjRKYjhSWnJKZUFiQW5KZ0puRmJKZ1NjQW5KZ3JBVHJKZ3ZIWjhKZ3ZNbjRKbEpsRmJKbExpUVhKbExqT25KbFJiT2xKbHZOWG9KbHZSbDNKbDRBY3JKbDhBVW9KbDhNbnJKbkZuTWxKbkhnR2JKbm9EVDhKbm9GVjhKbm9HZ3ZKbm9JVDhKbm9RVG9Kbm9SZzNKbnJDWjNKbnJHZ3JKbnJIVHZKbnJMZjhKbnJPWDhKbnZBVDNKbnZGWm9KbnZHVDhKbnZKbDRKbnZNVDhKbnZNWDhKbnZPWHJKbnZQWDZKbnZTWDNKbnZTWnJKbjNNVDhKbjNNWDhKbjNSVHJMVEFUS25MVEpuTFRMVE1YS25MVFJUUWxMVG9HYjhMVHJBWjhMVHJDWjhMVHJEYjhMVHJIVDhMVDNQWDZMVDRGWm9MVCRDVHZMVCRHZ3JMVXZIWDNMVm9BVHJMVm9BZ29MVm9KYm9MVm9NWDNMVm9SZzNMVjhDWjNMVjhGWm9MVjhHVHZMWHJEWG9MWHJGYnJMWHZBZ3ZMWHZGbHJMWHZMbDNMWHZSbjZMWDRNYjhMWDhHVDhMWUNYTW5MWXJNbnJMWm9TVHZMWnJBWnZMWnJBbG9MWnJGVG9MWnJKWHZMWnJKYm9MWnJKbDRMWnJMbnJMWnJNVDhMWnJPZ3ZMWnJSbnZMWnJTVDRMWnZNWDhMWnZTbHZMWjhBZ29MWjhDVDNMWjhKVDhMWjhMVjhMWjhMWm9MWjhMZzhMWjhTVjhMWjhTYnJMWiRIVDhMWiRNbjRMYTZDVHZMYkZiTW5MYlJZRlRMYlNuRlpMYm9KVDhMYnJBVDlMYnJHYjNMYnJRYjhMY3JKWDhMY3JNWHJMZXJIVHZMZXJKYnJMZXJOYm9MZ3JEYjhMZ3JHWjhMZ3JIVHJMZ3JNWHJMZ3JTVThMZ3ZKVHJMZ3ZMbDNMZzZMbDNMaHJMbnJMaHJNVDhMaHZBbDRMaUxuUVhMa29BZ3JMa29KVDhMa29KbjRMbHJTVThMbDNGWm9MbDNIVHJMbDNKWDhMbDNKbm9MbDNMVG9MbUxlRmJMbkRVRmJMbkxWQW5MbnJBVHJMbnJBWm9MbnJBYjhMbnJBbHJMbnJHZ3ZMbnJKVThMbnJMWnJMbnJMaHJMbnJNYjhMbnJPWHJMbnJTWjhMbnZBYjRMbnZEVHJMbnZEbDhMbnZIVHJMbnZIYnJMbnZKVDhMbnZKVThMbnZKYnJMbnZMaHZMbnZNWDhMbnZNYjhMbnZObm9MbnZTVThMbjNBbDNMbjRGWm9MbjRHVDZMbjRKZ3ZMbjRMaHJMbjRNVDhMbjRTVG9NVG9DWnJNVG9KWDhNVG9MWDRNVG9MZjhNVG9SZzNNVHJFbG9NVHZHYjZNVDNCVHJNVDNMYjZNVDhBY3JNVDhBZ3JNVDhHWnJNVDhKbm9NVDhMbnJNVDhNWDNNVU9VQW5NWEFiRm5NWG9BbG9NWG9KWDhNWG9MZjhNWG9MbDhNWHJBYjhNWHJEVHZNWHJHVDhNWHJHZ3JNWHJIVHJNWHJMZjhNWHJNVThNWHJPWHZNWHJRYjhNWHZHVDhNWHZIVHJNWHZMVm9NWDNBWDNNWDNKbjNNWDNMaHJNWDNNWDNNWDRBbHJNWDRPYm9NWDhHVHZNWDhHWnJNWDhHZ3JNWDhKVDhNWDhKWDhNWDhMaHJNWDhNVDhNWURVRmJNWU1nRGJNYkduRmZNYnZMWDRNYnZMbDNNYjhNYjhNYjhTVDRNZ0dYQ25NZzhBVHJNZzhBZ29NZzhDWnJNZzhEVHJNZzhEYm9NZzhIVHJNZzhKZ3JNZzhMVDhNbG9KWG9NbDhBaHJNbDhKVDhNbkxnQVVNbm9KWHJNbm9MWDRNbm9MaHJNbm9NVDhNbnJBbDRNbnJEYjhNbnJPVHZNbnJPZ3ZNbnJRYjhNbnJTVThNbnZHZ3JNbnZIWjhNbjNNVG9NbjREVHJNbjRMVHJNbjRNZzhObkJYQW5PVEZURm5PVG9BVG9PVHJHZ3ZPVHJKWDhPVDNKWG9PVDZNVHJPVDhHZ3JPVDhIVHBPVDhNVG9PVW9IVDhPVW9KVDhPVW9MbjNPWHJBZ29PWHJEZzhPWHJNVDhPWHZTVG9PWDZDVHZPWDhDWnJPWDhPZ3JPYjZIZ3ZPYjhBVG9PYjhNVDhPY3ZMWjhPZ3ZBbHJPZ3ZIVHZPZ3ZKVHJPZ3ZKbnJPZ3ZMWnJPZ3ZMbjRPZ3ZNVDhPZ3ZSVHJPZzhBWm9PZzhEYnZPbnJPWG9PbnZKbjRPbnZMaHZPbnZSVHJPbjNHZ29PbjNKbnZPbjZKYnZPbjhPVHJQVEdZRlRQYkJuRm5QYkduRG5QZ0RZUVRQbHJBbnZQbHJFVHZQbHJMbnZQbHJNWHZQbHZGWDRRVE1UQW5RVHJKVThRWUNuSmxRWUpsUWxRYkdUUWJRYjhKbnJRYjhMWm9RYjhMbnZRYjhNVDhRYjhNbDhRYjhTVDRRbG9BbDRRbG9IWnZRbG9KWDhRbG9NbjhRbkpaT2xSVHJBWnZSVHJEVHJSVHZKbjRSVHZMaHZSVDRKYjhSWnJBWnJSWjhBa3JSWjhKVThSWjhMVjhSWjhMbnZSYkpsUVhSZzNHYm9SZzNNbnZSZzhBWjhSZzhKYm9SZzhKbDRSbkxUQ2JSbnZGbDNSbnZRYjhTVG9BbDRTVG9DWnJTVG9GWm9TVG9IWHJTVG9KVThTVG9KZ3ZTVG9KbDRTVG9MaHJTVG9NWDNTVHJBbHZTVHJDVDlTVHJDZ3JTVHJHZ3JTVHJIWHJTVHJIYm9TVHJKbm9TVHJOYm9TVHZMbnJTVDRBWm9TVDhBYjhTVDhKVDhTVW9KbjNTVTZIWiNTVTZKVHZTVThEYjhTVThIYm9TVThMZ3JTVjhKVDhTWnJBY3JTWnJBbDNTWnJKVDhTWnJKbnZTWnJNVDhTWnZMVW9TWjRGWm9TWjhKbm9TWjhSWnJTY29MbnJTY29NVDhTY29NWDhTY3JBVDRTY3JBWjhTY3JMWjhTY3JMa3ZTY3ZEYjhTY3ZMZjhTY3ZOVG9TZ3JGWnJTaHZLbnJTbG9IVW9TbG9MbnJTbHJNWG9TbDhIZ3JTbXJKVW9TbjNCWDZcIixcbiAgICBcIkFURmxPbjNBVExnckRZQVQ0TVRBbkFUOExUTW5BWUpuUlRyQWJHZ0puckFiTFY4TG5BYnZOVEFuQWVGYkxnM0FnT1lNWG9BbFFiRmJvQW5EYm9BZkFuSmdvSlRCVG9EZ0FuQlVKYkFsM0Jib0RVQW5DVERsdkxuQ1RGVHJTbkNZb1FUTG5EVHdBYkFuRFVEVHJTbkRVSGdIZ3JEWDhMWEZuRGJKWEFjckVUdkxUTG5HVEZUUWJyR1RNbkdUb0dUM0RVRmJHVUpsUFgzR2JRZzhMbkdib0piRm5HYjNHZ0FZR2dBZzhTY0dnTWJBWHJHZ3ZBYkFuR25KVExudkdudkFURmdIVERUNkFUSFRyRGxKbkhZTG5NbjhIWnJTYkpUSFo4TFRGbkhiRlRKVW9IZ1NlTVQ4SGdyTGpBbkhndkFiQW5IbEZVckRsSG5EZ3ZBbkhuSFRGVDNIblFUR25ySlRBYU1YdkpUR2JDbjNKVE9nckFuSlh2QVhNbkpiTWc4U25KYk1uUmczSmI4TFRNbkpuQWwzT25KbkdZclFsSm5KbFFZM0xURGxDbjNMVEpqTGczTFRMZ3ZGWExUTWczR1RMVjhIVU9nTFhGWkxnM0xYTlhyTW5MWDhRWEZuTFg5QWxNWUxZTFhQWHJMWkFiSlU4TFpEVUpVOExaTVhyU25MWiRBZ0ZuTGFQWHJEVUxiRllyTW5MYk1uOExYTGJvSmdKZ0xlRmJMZzNMZ0xaclNuTGdPWUFnb0xoclJuSmxMa0NUclNuTGtPbkxockxuRlglQVlMbkZab0pYTG5IVHZKYkxuTGxvQWJNVEFUTGY4TVRIZ0puM01UTVhyQVhNVDNNVEZuTVVJVHZGbk1YRlglQVlNWE1YdkZiTVhyRlREYk1ZQWNNWDNNYkxmOFNuTWI4SmJGbk1nTVhyTVRNZ3ZBWEZuTWd2R2dDbU1uQWxvU25NbkZuSlRyT1h2TVhTbk9YOEhUTW5PYkpUOFNjT2JMWkZsM09iTVhDWm9QVExnclFYUFVGbm9RWFBVM1JYSmxQWDNSa1FYUGJySlhRbFBsckpiRm5RVUFockRiUVhHbkNYdlFZTG5IbHZRYkxmTG52UlRPZ3ZKYlJYSllyUWxSWUxuclFsUmJMbnJRbFJsRlQ4SmxSbEZuclFYU1RDbENuM1NUSFRyQW5TVExaUWxyU1RNbkdUclNUb0hnR2JTVHJHVERuU1R2R1hDblNUM0hnRmJTVTNIWEFYU2JBbkpuM1NiRlQ4TG5TY0xmTG52XCIsXG4gICAgXCJBVDNKZ0pYOEFUOEZab1NuQVQ4SmdGVjhBVDhMaHJEYkFaOEpUOERiQWI4R2dMaHJBYjhTa0xudkFlOE1UOFNuQWxNWUpYTFZBbDNHWURUdkFsM0xmTG52QlVEVHZMbDNDVE9uM0hUckNUM0RVR2dyQ1U4TVQ4QWJDYkZUckpVb0NnckRiOE1URFRMVjhKWDhEVExuTFhRbERUOExaclNuRFVRYjhGWjhEVVNUNEpudkRiOFNjT1VvRGo2R2JKbDRHVExmQ1lNbEdUb0FYdkZuR2JvQVh2TG5HZ0FjckpuM0dndkZuU1RvR25MZjhKbnZHbiNIVERUb0hUTG5GWEpsSFR2QVRGVG9IVHZIVERUb0hUdk1UQWdvSFQzU1RDbHZIVDRBbEZsNkhUOEhURFRvSFVvRGdKVHJIVW9TY01YM0hiUlpyTVhvSGJvSmc4TFRIZ0RiOEpUckhnTVRvTGY4SGd2TG5Mbm9IbkhuM0hUNEhuNk1ndkFuSlRKVThTY3ZKVDNBYVFUOEpUOEhUckFuSlhyUmc4QW5KYkFsb01Yb0pickFURlRvSmJ2TW5vU25KZ0RiNkdndkpnRGI4TVhvSmdTWDNKVThKZ3VBVEZUb0psUFlMblFsSmxRa0RuTGJKbFFsRllKbEpsOExmOE9USm5DVEZuTGJKbkxUSFhNbkpuTFhHWENuSm5vRmZSZzNKbnJNWVJnM0puM0hnRmwzS1Q4RGc4TG5MVFJsRm5QVExUdlBiTGJ2TFZvU2JyQ1pMWE1ZNkhUM0xYTlU3RGxyTFhOWERUQVRMWDhEWDhMbkxaRGI4SlU4TFpNbm9MaHJMWlNUb0pVOExackxhTG5yTFp2Sm4zU25MWjhMaHJTbkxhSm5vTVQ4TGJGbHJIVHZMYnJGVExuckxidkFUTGx2TGI2T1RGbjNMY0xuSlpPbExlQVQ2TW40TGVKVDNPYnJMZzZMWEZsckxockpnOExuTGh2RGxQWDRMaHZMZkxudkxqNkpURlQzTG5GYnJNWG9MblFsdUNUdkxuclFYQ1k2TG52TGZMbnZMbnZNZ0xudkxudlNlTGY4TVRNYnJKbjNNVDNKZ1NUM01UOEFuQVRyTVQ4TFVMbnJNVU1Ub0Nack1VU2N2TGY4TVhvRFQ4U25NWDZBVEZUb01YOEFYTVQ4TVg4RmtNVDhNWDhIVHJEVU1YOFNjb1NuTVlKVDZDVHZNZ0Fjck1Yb01nOFNUb0FmTWx2QVhMZzNNbkZsM0Fudk9UM0FuRmwzT1VvQVRIVDhPVTNSbkxYck9Yck9YclNuT2JQYnZGbjZPZzhIZ3JTbk9nOE9YOERiUFR2QWdvSmdQVTNSWUxuclBYckRuSlpyUGI4Q1RHZ3ZQbHJMVERsdlBsdkZVSm5vUVV2RlhyUWxRZU1ub0FsM1FsclFsclNuUlRGVHJKVW9TVERsTGlMWFNURmc2SFQzU1RKZ29NbjRTVHJGVEpUclNUckxaRmwzU1Q0Rm5NWG9TVXJEbEhVb1NjdkhUdlNuU2ZMa3ZNWG9cIixcbiAgICBcIkFVb0Fjck1Yb0FaOEhib0FnOEFiT2c2QVRGZ0FnOEFsb01Yb0FsM0FUOEpUckFsOE1YOE1Yb0NUM1NUb0pVOENsOERiOE1Yb0RUOEhnckFUckRib09UOE1Yb0dUT1RyQVRNbkdUOExockFaOEdudkZuR25RWEhUb0dndkFjckhUdkFYdkxsM0hickFab01Yb0hnQmxGWExnM0hnTW5GWHJTbkhnclNiOEpVb0huNkhUOExndklUdkFUckpVb0pVb0xaclJudkpVOEhUOEpiOEpYdkZYOFFUOEpYdkxUb0pUckpZclFuR25RWEpnckpub0FUckpub0pVOFNjdkpudk1udk1Yb0xUQ1RMZ3JKWExUSmxSVHZRbExiUm5KbFFZdkxick1iOExudkxidkZuM1Jub0xkQ1ZTVEdackxlU1R2R1hDbkxnM01ub0xuM01Ub0xsckVUdk1UOFNUb0FsM01ickRVNkdUdk1iOExYNExoclBsckxYR1hDblNUb0xmOFJnM1NUckRiOExUclNUdkxUSFhNblNiM1JZTG5NblNnT2c2QVRGZ1wiLFxuICAgIFwiSFVEbEduclFYckpUckhnTG5yQWNKWU1iOERVTGM4TFR2RmdHbkNrM01nOEpiQW5MWDRRWXZGWUhuTVhyUlVvSm5HbnZGblJsdkZUSmxRbm9TVHJCWEhYckxZU1VKZ0xmb01UOFNlOERUckhiRGJcIixcbiAgICBcIkFiRGw4U1RvSlU4QW4zUmJBYjhTVDhEVVNUckduckFnb0xiRlU2RGI4TFRyTWc4QWFIVDhKYjhPYkRsOFNUb0pVOFBiM1JsdkZZb0psXCJcbl07XG5jb25zdCBjb2RlcyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkhQCMkJV4mKlwiO1xuZnVuY3Rpb24gZ2V0SGFuZ3VsKGNvZGUpIHtcbiAgICBpZiAoY29kZSA+PSA0MCkge1xuICAgICAgICBjb2RlID0gY29kZSArIDE2OCAtIDQwO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID49IDE5KSB7XG4gICAgICAgIGNvZGUgPSBjb2RlICsgOTcgLSAxOTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLnRvVXRmOFN0cmluZykobmV3IFVpbnQ4QXJyYXkoWzIyNSwgKGNvZGUgPj4gNikgKyAxMzIsIChjb2RlICYgMHgzZikgKyAxMjhdKSk7XG59XG5sZXQgX3dvcmRsaXN0ID0gbnVsbDtcbmZ1bmN0aW9uIGxvYWRXb3JkcygpIHtcbiAgICBpZiAoX3dvcmRsaXN0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF93b3JkbGlzdDtcbiAgICB9XG4gICAgY29uc3Qgd29yZGxpc3QgPSBbXTtcbiAgICBkYXRhLmZvckVhY2goKGRhdGEsIGxlbmd0aCkgPT4ge1xuICAgICAgICBsZW5ndGggKz0gNDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB3b3JkID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB3b3JkICs9IGdldEhhbmd1bChjb2Rlcy5pbmRleE9mKGRhdGFbaSArIGpdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JkbGlzdC5wdXNoKHdvcmQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgd29yZGxpc3Quc29ydCgpO1xuICAgIC8vIFZlcmlmeSB0aGUgY29tcHV0ZWQgbGlzdCBtYXRjaGVzIHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgaW5kZXhfanNfMS5pZCkod29yZGxpc3Quam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChjaGVja3N1bSAhPT0gXCIweGY5ZWRkZWFjZTljNWQzZGE5YzkzY2Y3ZDNjZDM4ZjZhMTNlZDNhZmZiOTMzMjU5YWU4NjU3MTRlOGEzYWU3MWFcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3Iga28gKEtvcmVhbikgRkFJTEVEXCIpO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIF93b3JkbGlzdCA9IHdvcmRsaXN0O1xuICAgIHJldHVybiB3b3JkbGlzdDtcbn1cbmxldCB3b3JkbGlzdCA9IG51bGw7XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWtvXV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmNsYXNzIExhbmdLbyBleHRlbmRzIHdvcmRsaXN0X2pzXzEuV29yZGxpc3Qge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBLb3JlYW4gbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nS29dXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJrb1wiKTtcbiAgICB9XG4gICAgZ2V0V29yZChpbmRleCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IGxvYWRXb3JkcygpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCAmJiBpbmRleCA8IHdvcmRzLmxlbmd0aCwgYGludmFsaWQgd29yZCBpbmRleDogJHtpbmRleH1gLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHdvcmRzW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0V29yZEluZGV4KHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRXb3JkcygpLmluZGV4T2Yod29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nS29gYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0tvKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ0tvID0gTGFuZ0tvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1rby5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-ko.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-pt.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-pt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangPt = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst words = \"0arad!ototealirertainrasoent hoandoaR#riareha!aroele'oronul0Aca%AixoAl A%rDuz'El]Er$IsmoO$ R<g(Revi Rig Rup$S*$Solu$Sur=Ut[0Ab#Alm Amp Anh A,Ei.El( En ErvoEss E$naHa.IdezImaI}#Irr Lam LiveOlhidaOmod Opl Ord Um~ Us?0Ap.EgaEnt_Ep$Equ Er-%EsivoEusI<%ItivoJetivoJun$M' Or Qu''UboV(,Vog#0R}ave0As.Er'EtivoIn?Iv` Li$Lu-%R}.0Ach Arr As&/Enci Iliz Io)It#O+R! Res%Rup U d Ul]2O`h Ud Us.1AmedaArmeAstr Av<caB(gueB*oCat+De@EcrimEgr@Er.FaceF*e%GumHeioI Ica%I- Inh Ivi Mof^Oc Pis%T( TitudeUc* Ug UnoUsivoVo0Aci A=rA[loAss BasBi-%EixaEniz I=Is$,Iz!eOl?On$ O_,Ost+P  Pli Pola0Ag+maAlis Arqu@A$m@DaimeElExoG~ Im JoOm&@Ot#Sio,T(i|Uid!eUnci Zol1Ag?Alp Anh#EgoEli=Ert^Es Eti%I$Lau,Lic^OioOn.Os)R-dizRov 0Uec(0AmeAn]A+C^D-%E@Ej Eni$Es)Gilo,GolaMaQuivoRai&Reba%Risc Rob>um S-&T(i&TigoVo[=0F&.Il#P' S?S* So&/Sun$Tr&0Ac#Adu+Al/A[f E End(Er_EuIng'Ir?IvoOl{oRac Revi=RizU&Um0Di$rM-.R>o+TismoT|@Tu 0Ali An%Ar@Ent&Es,I?Is Ul,1Ila1Ar E=Ei%Ulejo:B BosaC&]uCh `C@GagemI<oIl I}e)Ir_Ixis)J~ Le@LizaLsaN&Nd{aN/N'Nque%Ra$Rb#R}es>+c>~/Se#S)n%Ta)Te=rTidaTomTuc Unil]3B(IjoIr^IsebolLd!eLezaLgaLisc Ndi$Ng&aNz(RimbauRl*d>_Sou_XigaZ(_3CoCu=En&Foc&Furc G|naLhe%Mest[Mo$rOlog@OmboOsf(aPol Rr-$Scoi$Sne$SpoSsex$TolaZ _2Ind#OcoOque 2A$BagemC#CejoChec]Ico.L^LetimL]LoMb{oNdeNecoNi)Rb~h>d>e&R+c]V*oXe?2AncoAsaAvezaEuIgaIl/Inc OaOchu+Onze O$Uxo2C]DismoF LeRacoScaS$Z*a:B<aB`oBideBoBri$CauCet^C/r_CiqueDast_De#Fez&IaqueIp'aIxo%J#JuLafrioLc~ Ld{aLibr Lm<%Lo)M^Mbis)MisaMomilaMp<]Mufl Navi&Nc` Ne)NguruN/$Nive%NoaNs#N.Nu=Pac/P`aP* Po.Pric/Pt?PuzRacolRb}oRde&Rec>imb Rn{oRpe%R['>)zRv&/SacoScaSeb[S%loS~oT a)Tiv UleUs?U%l V&oV(na3BolaDil]G}]Lebr L~ Nou+N,N%ioRc Rr#R%'oRvejaTimV^2Aco)Al{aAm#Ap^ArmeAticeAveEfeEg^E'oEqueIco%If[In`oOc&/Ov(UmboU.Uva0CatrizCl}eD!eD['aEn%G<aM-$N$Nz><d>cui$Rurg@T 2A[zaE_Ic OneUbe2A=Ag'Ba@B($rBr C^El/Ent_E,Gum`oIb'IfaIo%L L{aLh(Lid'Lme@L}oLunaM<=Mb* M-.MitivaMov(MplexoMumNc]N=rNec.Nfu,Ng` Nhec(Njug Nsum'Nt+$Nvi%Op( P{oPi?PoQue%lRagemRdi&Rne)R}h>p|&R[ioR%joRuj>voSs-oS%laT}e%U_UveVilZ*]2A%+AvoEcheE=rEmeErEspoI^Im*&Io~oIseItic Os)UaUz{o2B<oEcaId#JoLat+Lm* Lp Ltu+Mpr'Nh#Pi=RativoRr&Rs R$Sp'S% T`o:MascoT 3Ba%rBi.BocheB~h C&queCim&CliveCo%C[.D&Dic#Duz'FesaFum G`oG+uGus.It#Ix La$rLeg#L*e L}gaM<daMit'Moli=Ntis)P-#Pil PoisP[ssaPur Riv>+m SafioSbo.Sc<,S-/Sfi#Sgas%Sigu&SlizeSmam SovaSpesaS)queSvi T&h T-$rT} Tri$UsaV(Vi=Vot#Z-a3Ag+maAle$Da)Fu,Gi.Lat#Lu-%M*u'Nast@Nh{oOceseRe$Sc[)Sf ceSp oSque%Ssip S)n%T?UrnoV(,Vi,rV~g Z(5Br?L|i=M?M*#NativoNz`>m-%Rs&SagemUr#U$r2EnagemIbleOg @2El EndeE$PloQues><%Vi=,:1Lod'O Olog@0Ific It&Uc#1Ei$Etiv 3E.1Ab| Eg(Ei$rEncoEv?Im* Ogi 0B goBol#Br~/Buti=EndaErg'Is,rPat@P-/P*#Polg P[goPurr Ul?0CaixeC-#Ch-%C}t_Deus Doss Faix Fei%FimGaj#G-/Glob Gom#G+x Gu@Jo La.Qu<$Raiz Rol#Rug SaioSe^S*oSop#T<$Te#Tid!eT|.Tr^T~/V(g Vi#Volv(XameX($Xof[Xu$1Id(me0Uip 0E$Gui=Ra)VaVil]0B<j B`$CamaColaCri)Cu)F*geFol F[g Fum#GrimaM&%P<$P`/PigaP}jaP[i)Pum Qu(daTacaT{aTic Tof#T[laTu=Vazi 0AnolIque)0F|i>opeu0Acu Ap| AsivoEntu&Id-%Olu'1Ag(oAl Am* A$Aus$Ces,Ci.Clam Ecu.EmploIb'Ig-%On( P<d'P`'P' Pl< Pos$P[s,P~s T(noT*$T+$:Bric B~o,Ce)Ci&DaDigaIxaL L)Mili Nd<goNf +N$cheRd#R`oR*h>of>p>tu+T@T|V|i)X*aZ-da3Ch#Ijo^I+n%L*oM**oNdaNoR>i#RrugemRv(S%j T&Ud&3ApoB_seC Ch{oGur#L{aL/LmeLtr RmezaSg^Ssu+TaV`aX?Xo2AcidezAm*goAn`aEch^O+Utu Uxo2C&C*/Foc GoGue%IceLg#Lhe$Rj Rmig>noR%ScoSsa2Aga)AldaAngoAscoA%rnoE'aEn%E.IezaI,Itu+On]Ustr U%'a2G'L<oLigemNd NgoNilR?Rio,Tebol:B i$B*e%DoIa$IolaIvo)LegaL/L*]Loc]Nh RagemRfoRg&oRimpoRoup>+faSodu$S$TaTil/Ve)Z`a3L#Le@LoM^M(Mi=N(o,NgivaNi&NomaN_Ologi>?Rm* S,S$r3Nas)Nc<aNg#Raf>*o2Aci&IcoseOb&Orio,2ElaIabaLfeLpe Rdu+Rje)R_S$,T{aV(n 2AcejoAdu&Afi%Al]AmpoAn^Atui$Ave$AxaEgoElh EveIloIs&/I.@Os,O%scoUd#Unhi=U)2AcheA+niAx*imEr[ I Inc/Is#LaLo,Ru:Bi.Rm}@S%V(3C.eRd Res@Si.3A$B(n D+.EnaNoPismoPnosePo%ca5JeLofo%MemNes$Nr#Rm}&Sped 5M|#:Te2E@O,2N|#RejaU<a4E,HaUdi=Um* Ustr 0AgemEd@$En,ErsivoIn-%It?Ort&Pac$Ped'Pl<%P|Pr-saPuneUniz 0Al?Ap$AtivoC-,Ch Cid'Clu'Col|Deci,D'e$Du$rEficazEr-%F<tilFes.F*i$Flam F|m&F+$rG('Ibi=Ici&ImigoJe.Oc-%O=_Ov?OxQuie$Scri$Se$Sist'Spe$rSt& S~$Tac$Tegr&Tim Toc#TrigaVa,rV(noVic$Voc 0Gur%2Ani<oOniz Re&Rit#0CaEn$Ol#Qu{o0Ali<o:N{oNg^N)R ac>dimR_SmimToV&iZida3Jum9An*]Elh^G?I>n&Rr Vem5BaDeuDocaIzLg?L/R#Ris)RoS)::B edaB|&C[C)n%Dril/G )GoaJeMb(M-.M* MpejoNchePid P,R<j>{>gu+S<]St_T(&Ti=V<daVou+Vr?X<%Z(3Ald!eB[G#G-d Gis)IgoIlo Itu+Mb[%MeNh?Ntil]OaSmaS%TivoT['oV VezaVi.3B(&Bi=D( G G{oMi.Mo{oMp?NdaNe N]gemQuidezS)gemSu+T|&V_XaX{a5C?Cu$rJis)MboNaNgeNt+RdeT#T(@Ucu+UsaUv 5ArCidezC_Ne)St[T?Va:CacoCe%Ch#CioD{aDr*]Gna)G[zaI|IsL<d_L]Lo%LucoMiloMo{oMu%N^Nc]Nda$NequimN/,Niv`aNobr NsaN%rNuse Pe#Qu* Rc?Resi>fimRgemR*/Rmi)Ro$RquiseR[coR%loRujoSco%Sm|+SsagemStig Tag&T(noT*&Tu.Xil 3D&]DidaDusaGaf}eIgaL<c@L/rMb_M|i&N*oNosNsagemNt&Rec(Rg~/S^Scl SmoSqui)St[T!eTeo_T+gemX(Xic<o3C_G&]Gr Lag[L- Lh M#N( N/caNist_N|@OloR<%RtiloStur 5Cid!eD(noD~ EdaErIn/I)Ldu+LezaL/L*e%LuscoN)n]Quec><goRcegoR=moR-aSaicoSque%S.daT`TimToTriz5DaI$La)Lh(L.Ndi&Ni=R&h>c/Sc~ SeuSic&:Ci}&D?JaMo_R*>r#Sc(TivaTu[zaV&]Veg Vio3Bl*aB~o,GativaGoci Gri$Rvo,TaUr&VascaVo{o3N N/TidezV` 5B[zaI%IvaMe M*&Rdes%R% T Tici TurnoV`oVil/Vo5Bl#DezM(&Pci&Tr'Vem:0Cec#Edec(JetivoRig#Scu_S%t+T(Tur 0Id-%Io,Orr(Ulis)Up#2Eg<%EnsivaEr-daIc*aUsc#0Iva4Ar@Eo,H Iv{a0B_Ele%Is,It'0D~#E_,Tem1Ci}&Er?On-%OrtunoOs$1ArBi.DemD*&F<a$GasmoG~/I-t&IgemIun=LaTo=xoV&/0Cil S^SoT-.0Imismo0S!@T}oTub_Vi=0El]Ul 1Id Ig- :Ca$Ci-%Co%Ctu D @Dr*/G GodeIn`Ir IsagemLav+Lest+Lhe)Li$Lm^Lpi.Nc^N`aNfle$NquecaN)n&PagaioP`^P'oRaf*>ci&Rd&RedeRtidaSmoSs#S%lTam T-%T* T_noUl^Us 3C~i D& Dest[D@t+D+G^I$r&IxeLeLic<oNcaNdur N{aN]scoNs?N%Rceb(Rfei$Rgun)Ri$Rmit'Rn>plexoRsi<>%nceRucaSc#SquisaS,aTisc 3AdaC#Ed!eGm-$Last+Lh#Lo.M-)Nc`NguimN]No%N.On{oPocaQue%R<h>esRue)Sc S$laT<gaVe%2An)Aque)At*aEbeuUmagemUvi&1Eu0DaE'aEtisaLeg^Lici Lu-%Lvil/M MbaNd( N.@P~o,R)Ssu'St&TeUp U,Vo 2A@Anc]A$AxeEceEd?Efei$Emi Ens Ep  Esil]E%x$Ev-'Ez Ima)IncesaIsmaIv#Oces,Odu$Ofe)Oibi=Oje$Ome%rOpag OsaO%$rOv?2Blic DimL Lm} Ls{aNh&N'PiloRezaX?:99Ad+Ant@Ar$AseEbr EdaEijoEn%Eri=Im}oInaIosque:B<^BiscoCh Ci} Di&I In]IoIvaJ^L#M&Ng(Nhu+P!u+P`PidezPosaQue%Rid!eS<%Scun/Sg Sp?S%'aSur Taz<aTo{a3AlezaAnim Av(Baix B`deBol C#C-%CheioCiboC|d Cru.Cu DeDim'D}daDuzidaEnvioF* Flet'Fog F[scoFugi G&@GimeG+In#I$rJei.LativoM?M-=M|,Nov#P oP`'Ple$Pol/P[saPudi Qu((S-]Sfri Sga.Sid'Solv(Spei$SsacaS)n%Sum'T&/T(T' Tom^T+.V` Vi,rVol)3Ac/CaGidezGo_,M NgueS^ScoS}/5B&oChe=D^DeioDov@E=rLe)M<oNc S#S{aS$TaT{oT*aT~ UcoUpaXo5B_Gi=Go,IvoMoPest[S,:B|Ci ColaCud'DioF'aGaGr^Ib_L^L{oLg#LivaLpic Lsic]L.Lv?Mb Mu+iN Nf}aNgueNid!ePa$Rd>g-$Rje)Tur Ud!eXof}eZ}&3C C~ DaD-$Di#Do,Du$rGm-$G[=Gun=IvaLe$LvagemM<&M-%N?N/rNsu&Nt#P #Rei>*g>+RvoTemb_T|3GiloLhue)Lic}eMetr@Mpat@M~ N&Nc(oNg~ NopseN$ni>-eRiTu#5B(<oB+C|_G_JaLdaLetr L%'oMbrioNa)Nd Neg Nh?NoP+noQue%Rr'R%ioSsegoTaqueT(r V#Z*/5Aviz BidaBm(,B,loBt+'Ca)Ces,CoDes%FixoG?G('Jei$Lfa$M'OrP(i|Plic Pos$Prim'Rd*>fis)Rp[s>[&Rt'Sp'oS%n$:B`aBle%Bu^C/G `aLh(LoLvezM</Mb|imMpaNg-%N$P Pioc>dioRef>j>+xaTuagemUr*oXativoXis)3Atr&C(Ci=Cl#Dio,IaIm Lef}eLh#Mp(oN-%N,rN.Rm&RnoRr-oSeSou+St#ToXtu+Xugo3A+G`aJoloMbr MidezNgi=N%'oRagemT~ 5Al]C]L( LiceM^Mil/N`Ntu+Pe%R>ci=RneioRqueRr!>$S.UcaUp{aX*a2Ab&/Acej Adu$rAfeg Aje$AmaAnc ApoAs{oAt?Av E*oEm(Epid EvoIagemIboIcicloId-%Ilog@Ind!eIploItur Iunf&Oc Ombe)OvaUnfoUque2B~ C<oDoLipaPiRboRm>quesaT` T|i&:7V 3Bigo0HaId!eIf|me3Olog@SoTigaUbu0A=InaUfru':C*aDi G o,I=,LaL-%Lid!eLo[sN)gemQu{oR<d>e)Rr(Sc~ Sil]S,u+Z Zio3A=D Ge.Ic~ L{oLhiceLu=Nce=rNdav&N( Nt[Rb&Rd!eRe?Rg}h>m`/RnizRs R%n%SpaSti=T|i&3Adu$AgemAj Atu+Br?D{aDr @ElaGaG-%Gi G| L ejoNcoNhe)NilOle)R!>tudeSi.S$Tr&V{oZ*/5A=rArG&L<%LeibolL)gemLumo,Nt!e5L$Vuz`a::D[zRope3QueRe.Rife3Ng ::Ng#Rp 3BuL?9Mb Olog@5Mbi=\";\nconst checksum = \"0x2219000926df7b50d8aa0a3d495826b988287df4657fbd100e6fe596c8f737ac\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-pt]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangPt extends wordlist_owl_js_1.WordlistOwl {\n    /**\n     *  Creates a new instance of the Portuguese language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langPt]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"pt\", words, checksum); }\n    /**\n     *  Returns a singleton instance of a ``LangPt``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangPt();\n        }\n        return wordlist;\n    }\n}\nexports.LangPt = LangPt;\n//# sourceMappingURL=lang-pt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1wdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsMEJBQTBCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3JELDhMQUE4TCw4R0FBOEcsK0JBQStCLG9nQkFBb2dCLGtIQUFrSCw0QkFBNEIsa0JBQWtCLDBPQUEwTywyS0FBMkssMkdBQTJHLGdCQUFnQixxRUFBcUUsK0NBQStDLHFFQUFxRSxpR0FBaUcsY0FBYyxpRkFBaUYsMEJBQTBCLDZCQUE2Qiw4REFBOEQsMEpBQTBKLG9IQUFvSCwwREFBMEQsOFFBQThRLHdOQUF3TixxQkFBcUIscVNBQXFTLE9BQU8sZ1lBQWdZLHdIQUF3SCxzRUFBc0UsNlRBQTZULFVBQVUsMklBQTJJLGlIQUFpSCxPQUFPLHNDQUFzQyw2RUFBNkUscUNBQXFDLGtKQUFrSixxUUFBcVEsNEVBQTRFLDhLQUE4Syw0QkFBNEIsd0ZBQXdGLHFOQUFxTixzSEFBc0gsNFBBQTRQLEdBQUcscURBQXFELDBCQUEwQixnRkFBZ0YsNkRBQTZELGdNQUFnTSxtQ0FBbUMsT0FBTyxvRUFBb0UsbUNBQW1DLG1DQUFtQyxHQUFHLGtHQUFrRyx5VUFBeVUsdUlBQXVJLHlDQUF5QyxzTUFBc00seUNBQXlDLHNDQUFzQyxnREFBZ0QsdURBQXVEO0FBQ3J2TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2xhbmctcHQuanM/NTE1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ1B0ID0gdm9pZCAwO1xuY29uc3Qgd29yZGxpc3Rfb3dsX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC1vd2wuanNcIik7XG5jb25zdCB3b3JkcyA9IFwiMGFyYWQhb3RvdGVhbGlyZXJ0YWlucmFzb2VudCBob2FuZG9hUiNyaWFyZWhhIWFyb2VsZSdvcm9udWwwQWNhJUFpeG9BbCBBJXJEdXonRWxdRXIkSXNtb08kIFI8ZyhSZXZpIFJpZyBSdXAkUyokU29sdSRTdXI9VXRbMEFiI0FsbSBBbXAgQW5oIEEsRWkuRWwoIEVuIEVydm9Fc3MgRSRuYUhhLklkZXpJbWFJfSNJcnIgTGFtIExpdmVPbGhpZGFPbW9kIE9wbCBPcmQgVW1+IFVzPzBBcC5FZ2FFbnRfRXAkRXF1IEVyLSVFc2l2b0V1c0k8JUl0aXZvSmV0aXZvSnVuJE0nIE9yIFF1JydVYm9WKCxWb2cjMFJ9YXZlMEFzLkVyJ0V0aXZvSW4/SXZgIExpJEx1LSVSfS4wQWNoIEFyciBBcyYvRW5jaSBJbGl6IElvKUl0I08rUiEgUmVzJVJ1cCBVIGQgVWxdMk9gaCBVZCBVcy4xQW1lZGFBcm1lQXN0ciBBdjxjYUIoZ3VlQipvQ2F0K0RlQEVjcmltRWdyQEVyLkZhY2VGKmUlR3VtSGVpb0kgSWNhJUktIEluaCBJdmkgTW9mXk9jIFBpcyVUKCBUaXR1ZGVVYyogVWcgVW5vVXNpdm9WbzBBY2kgQT1yQVtsb0FzcyBCYXNCaS0lRWl4YUVuaXogST1JcyQsSXohZU9sP09uJCBPXyxPc3QrUCAgUGxpIFBvbGEwQWcrbWFBbGlzIEFycXVAQSRtQERhaW1lRWxFeG9HfiBJbSBKb09tJkBPdCNTaW8sVChpfFVpZCFlVW5jaSBab2wxQWc/QWxwIEFuaCNFZ29FbGk9RXJ0XkVzIEV0aSVJJExhdSxMaWNeT2lvT24uT3MpUi1kaXpSb3YgMFVlYygwQW1lQW5dQStDXkQtJUVARWogRW5pJEVzKUdpbG8sR29sYU1hUXVpdm9SYWkmUmViYSVSaXNjIFJvYj51bSBTLSZUKGkmVGlnb1ZvWz0wRiYuSWwjUCcgUz9TKiBTbyYvU3VuJFRyJjBBYyNBZHUrQWwvQVtmIEUgRW5kKEVyX0V1SW5nJ0lyP0l2b09se29SYWMgUmV2aT1SaXpVJlVtMERpJHJNLS5SPm8rVGlzbW9UfEBUdSAwQWxpIEFuJUFyQEVudCZFcyxJP0lzIFVsLDFJbGExQXIgRT1FaSVVbGVqbzpCIEJvc2FDJl11Q2ggYENAR2FnZW1JPG9JbCBJfWUpSXJfSXhpcylKfiBMZUBMaXphTHNhTiZOZHthTi9OJ05xdWUlUmEkUmIjUn1lcz4rYz5+L1NlI1MpbiVUYSlUZT1yVGlkYVRvbVR1YyBVbmlsXTNCKElqb0lyXklzZWJvbExkIWVMZXphTGdhTGlzYyBOZGkkTmcmYU56KFJpbWJhdVJsKmQ+X1NvdV9YaWdhWihfM0NvQ3U9RW4mRm9jJkZ1cmMgR3xuYUxoZSVNZXN0W01vJHJPbG9nQE9tYm9Pc2YoYVBvbCBSci0kU2NvaSRTbmUkU3BvU3NleCRUb2xhWiBfMkluZCNPY29PcXVlIDJBJEJhZ2VtQyNDZWpvQ2hlY11JY28uTF5MZXRpbUxdTG9NYntvTmRlTmVjb05pKVJifmg+ZD5lJlIrY11WKm9YZT8yQW5jb0FzYUF2ZXphRXVJZ2FJbC9JbmMgT2FPY2h1K09uemUgTyRVeG8yQ11EaXNtb0YgTGVSYWNvU2NhUyRaKmE6QjxhQmBvQmlkZUJvQnJpJENhdUNldF5DL3JfQ2lxdWVEYXN0X0RlI0ZleiZJYXF1ZUlwJ2FJeG8lSiNKdUxhZnJpb0xjfiBMZHthTGliciBMbTwlTG8pTV5NYmlzKU1pc2FNb21pbGFNcDxdTXVmbCBOYXZpJk5jYCBOZSlOZ3VydU4vJE5pdmUlTm9hTnMjTi5OdT1QYWMvUGBhUCogUG8uUHJpYy9QdD9QdXpSYWNvbFJifW9SZGUmUmVjPmltYiBSbntvUnBlJVJbJz4pelJ2Ji9TYWNvU2NhU2ViW1MlbG9Tfm9UIGEpVGl2IFVsZVVzP1UlbCBWJm9WKG5hM0JvbGFEaWxdR31dTGViciBMfiBOb3UrTixOJWlvUmMgUnIjUiUnb1J2ZWphVGltVl4yQWNvKUFse2FBbSNBcF5Bcm1lQXRpY2VBdmVFZmVFZ15FJ29FcXVlSWNvJUlmW0luYG9PYyYvT3YoVW1ib1UuVXZhMENhdHJpekNsfWVEIWVEWydhRW4lRzxhTS0kTiROej48ZD5jdWkkUnVyZ0BUIDJBW3phRV9JYyBPbmVVYmUyQT1BZydCYUBCKCRyQnIgQ15FbC9FbnRfRSxHdW1gb0liJ0lmYUlvJUwgTHthTGgoTGlkJ0xtZUBMfW9MdW5hTTw9TWIqIE0tLk1pdGl2YU1vdihNcGxleG9NdW1OY11OPXJOZWMuTmZ1LE5nYCBOaGVjKE5qdWcgTnN1bSdOdCskTnZpJU9wKCBQe29QaT9Qb1F1ZSVsUmFnZW1SZGkmUm5lKVJ9aD5wfCZSW2lvUiVqb1J1aj52b1NzLW9TJWxhVH1lJVVfVXZlVmlsWipdMkElK0F2b0VjaGVFPXJFbWVFckVzcG9JXkltKiZJb35vSXNlSXRpYyBPcylVYVV6e28yQjxvRWNhSWQjSm9MYXQrTG0qIExwIEx0dStNcHInTmgjUGk9UmF0aXZvUnImUnMgUiRTcCdTJSBUYG86TWFzY29UIDNCYSVyQmkuQm9jaGVCfmggQyZxdWVDaW0mQ2xpdmVDbyVDWy5EJkRpYyNEdXonRmVzYUZ1bSBHYG9HK3VHdXMuSXQjSXggTGEkckxlZyNMKmUgTH1nYU08ZGFNaXQnTW9saT1OdGlzKVAtI1BpbCBQb2lzUFtzc2FQdXIgUml2PittIFNhZmlvU2JvLlNjPCxTLS9TZmkjU2dhcyVTaWd1JlNsaXplU21hbSBTb3ZhU3Blc2FTKXF1ZVN2aSBUJmggVC0kclR9IFRyaSRVc2FWKFZpPVZvdCNaLWEzQWcrbWFBbGUkRGEpRnUsR2kuTGF0I0x1LSVNKnUnTmFzdEBOaHtvT2Nlc2VSZSRTY1spU2YgY2VTcCBvU3F1ZSVTc2lwIFMpbiVUP1Vybm9WKCxWaSxyVn5nIFooNUJyP0x8aT1NP00qI05hdGl2b056YD5tLSVScyZTYWdlbVVyI1UkcjJFbmFnZW1JYmxlT2cgQDJFbCBFbmRlRSRQbG9RdWVzPjwlVmk9LDoxTG9kJ08gT2xvZ0AwSWZpYyBJdCZVYyMxRWkkRXRpdiAzRS4xQWJ8IEVnKEVpJHJFbmNvRXY/SW0qIE9naSAwQiBnb0JvbCNCcn4vQnV0aT1FbmRhRXJnJ0lzLHJQYXRAUC0vUCojUG9sZyBQW2dvUHVyciBVbD8wQ2FpeGVDLSNDaC0lQ310X0RldXMgRG9zcyBGYWl4IEZlaSVGaW1HYWojRy0vR2xvYiBHb20jRyt4IEd1QEpvIExhLlF1PCRSYWl6IFJvbCNSdWcgU2Fpb1NlXlMqb1NvcCNUPCRUZSNUaWQhZVR8LlRyXlR+L1YoZyBWaSNWb2x2KFhhbWVYKCRYb2ZbWHUkMUlkKG1lMFVpcCAwRSRHdWk9UmEpVmFWaWxdMEI8aiBCYCRDYW1hQ29sYUNyaSlDdSlGKmdlRm9sIEZbZyBGdW0jR3JpbWFNJiVQPCRQYC9QaWdhUH1qYVBbaSlQdW0gUXUoZGFUYWNhVHthVGljIFRvZiNUW2xhVHU9VmF6aSAwQW5vbElxdWUpMEZ8aT5vcGV1MEFjdSBBcHwgQXNpdm9FbnR1JklkLSVPbHUnMUFnKG9BbCBBbSogQSRBdXMkQ2VzLENpLkNsYW0gRWN1LkVtcGxvSWInSWctJU9uKCBQPGQnUGAnUCcgUGw8IFBvcyRQW3MsUH5zIFQobm9UKiRUKyQ6QnJpYyBCfm8sQ2UpQ2kmRGFEaWdhSXhhTCBMKU1pbGkgTmQ8Z29OZiArTiRjaGVSZCNSYG9SKmg+b2Y+cD50dStUQFR8VnxpKVgqYVotZGEzQ2gjSWpvXkkrbiVMKm9NKipvTmRhTm9SPmkjUnJ1Z2VtUnYoUyVqIFQmVWQmM0Fwb0Jfc2VDIENoe29HdXIjTHthTC9MbWVMdHIgUm1lemFTZ15Tc3UrVGFWYGFYP1hvMkFjaWRlekFtKmdvQW5gYUVjaF5PK1V0dSBVeG8yQyZDKi9Gb2MgR29HdWUlSWNlTGcjTGhlJFJqIFJtaWc+bm9SJVNjb1NzYTJBZ2EpQWxkYUFuZ29Bc2NvQSVybm9FJ2FFbiVFLkllemFJLEl0dStPbl1Vc3RyIFUlJ2EyRydMPG9MaWdlbU5kIE5nb05pbFI/UmlvLFRlYm9sOkIgaSRCKmUlRG9JYSRJb2xhSXZvKUxlZ2FML0wqXUxvY11OaCBSYWdlbVJmb1JnJm9SaW1wb1JvdXA+K2ZhU29kdSRTJFRhVGlsL1ZlKVpgYTNMI0xlQExvTV5NKE1pPU4obyxOZ2l2YU5pJk5vbWFOX09sb2dpPj9SbSogUyxTJHIzTmFzKU5jPGFOZyNSYWY+Km8yQWNpJkljb3NlT2ImT3JpbywyRWxhSWFiYUxmZUxwZSBSZHUrUmplKVJfUyQsVHthVihuIDJBY2Vqb0FkdSZBZmklQWxdQW1wb0FuXkF0dWkkQXZlJEF4YUVnb0VsaCBFdmVJbG9JcyYvSS5AT3MsTyVzY29VZCNVbmhpPVUpMkFjaGVBK25pQXgqaW1FclsgSSBJbmMvSXMjTGFMbyxSdTpCaS5SbX1AUyVWKDNDLmVSZCBSZXNAU2kuM0EkQihuIEQrLkVuYU5vUGlzbW9Qbm9zZVBvJWNhNUplTG9mbyVNZW1OZXMkTnIjUm19JlNwZWQgNU18IzpUZTJFQE8sMk58I1JlamFVPGE0RSxIYVVkaT1VbSogVXN0ciAwQWdlbUVkQCRFbixFcnNpdm9Jbi0lSXQ/T3J0JlBhYyRQZWQnUGw8JVB8UHItc2FQdW5lVW5peiAwQWw/QXAkQXRpdm9DLSxDaCBDaWQnQ2x1J0NvbHxEZWNpLEQnZSREdSRyRWZpY2F6RXItJUY8dGlsRmVzLkYqaSRGbGFtIEZ8bSZGKyRyRygnSWJpPUljaSZJbWlnb0plLk9jLSVPPV9Pdj9PeFF1aWUkU2NyaSRTZSRTaXN0J1NwZSRyU3QmIFN+JFRhYyRUZWdyJlRpbSBUb2MjVHJpZ2FWYSxyVihub1ZpYyRWb2MgMEd1ciUyQW5pPG9Pbml6IFJlJlJpdCMwQ2FFbiRPbCNRdXtvMEFsaTxvOk57b05nXk4pUiBhYz5kaW1SX1NtaW1Ub1YmaVppZGEzSnVtOUFuKl1FbGheRz9JPm4mUnIgVmVtNUJhRGV1RG9jYUl6TGc/TC9SI1JpcylSb1MpOjpCIGVkYUJ8JkNbQyluJURyaWwvRyApR29hSmVNYihNLS5NKiBNcGVqb05jaGVQaWQgUCxSPGo+ez5ndStTPF1TdF9UKCZUaT1WPGRhVm91K1ZyP1g8JVooM0FsZCFlQltHI0ctZCBHaXMpSWdvSWxvIEl0dStNYlslTWVOaD9OdGlsXU9hU21hUyVUaXZvVFsnb1YgVmV6YVZpLjNCKCZCaT1EKCBHIEd7b01pLk1ve29NcD9OZGFOZSBOXWdlbVF1aWRlelMpZ2VtU3UrVHwmVl9YYVh7YTVDP0N1JHJKaXMpTWJvTmFOZ2VOdCtSZGVUI1QoQFVjdStVc2FVdiA1QXJDaWRlekNfTmUpU3RbVD9WYTpDYWNvQ2UlQ2gjQ2lvRHthRHIqXUduYSlHW3phSXxJc0w8ZF9MXUxvJUx1Y29NaWxvTW97b011JU5eTmNdTmRhJE5lcXVpbU4vLE5pdmBhTm9iciBOc2FOJXJOdXNlIFBlI1F1KiBSYz9SZXNpPmZpbVJnZW1SKi9SbWkpUm8kUnF1aXNlUltjb1IlbG9SdWpvU2NvJVNtfCtTc2FnZW1TdGlnIFRhZyZUKG5vVComVHUuWGlsIDNEJl1EaWRhRHVzYUdhZn1lSWdhTDxjQEwvck1iX018aSZOKm9Ob3NOc2FnZW1OdCZSZWMoUmd+L1NeU2NsIFNtb1NxdWkpU3RbVCFlVGVvX1QrZ2VtWChYaWM8bzNDX0cmXUdyIExhZ1tMLSBMaCBNI04oIE4vY2FOaXN0X058QE9sb1I8JVJ0aWxvU3R1ciA1Q2lkIWVEKG5vRH4gRWRhRXJJbi9JKUxkdStMZXphTC9MKmUlTHVzY29OKW5dUXVlYz48Z29SY2Vnb1I9bW9SLWFTYWljb1NxdWUlUy5kYVRgVGltVG9Ucml6NURhSSRMYSlMaChMLk5kaSZOaT1SJmg+Yy9TY34gU2V1U2ljJjpDaX0mRD9KYU1vX1IqPnIjU2MoVGl2YVR1W3phViZdVmVnIFZpbzNCbCphQn5vLEdhdGl2YUdvY2kgR3JpJFJ2byxUYVVyJlZhc2NhVm97bzNOIE4vVGlkZXpWYCA1Qlt6YUklSXZhTWUgTSomUmRlcyVSJSBUIFRpY2kgVHVybm9WYG9WaWwvVm81QmwjRGV6TSgmUGNpJlRyJ1ZlbTowQ2VjI0VkZWMoSmV0aXZvUmlnI1NjdV9TJXQrVChUdXIgMElkLSVJbyxPcnIoVWxpcylVcCMyRWc8JUVuc2l2YUVyLWRhSWMqYVVzYyMwSXZhNEFyQEVvLEggSXZ7YTBCX0VsZSVJcyxJdCcwRH4jRV8sVGVtMUNpfSZFcj9Pbi0lT3J0dW5vT3MkMUFyQmkuRGVtRComRjxhJEdhc21vR34vSS10JklnZW1JdW49TGFUbz14b1YmLzBDaWwgU15Tb1QtLjBJbWlzbW8wUyFAVH1vVHViX1ZpPTBFbF1VbCAxSWQgSWctIDpDYSRDaS0lQ28lQ3R1IEQgQERyKi9HIEdvZGVJbmBJciBJc2FnZW1MYXYrTGVzdCtMaGUpTGkkTG1eTHBpLk5jXk5gYU5mbGUkTnF1ZWNhTiluJlBhZ2Fpb1BgXlAnb1JhZio+Y2kmUmQmUmVkZVJ0aWRhU21vU3MjUyVsVGFtIFQtJVQqIFRfbm9VbF5VcyAzQ35pIEQmIERlc3RbREB0K0QrR15JJHImSXhlTGVMaWM8b05jYU5kdXIgTnthTl1zY29Ocz9OJVJjZWIoUmZlaSRSZ3VuKVJpJFJtaXQnUm4+cGxleG9Sc2k8PiVuY2VSdWNhU2MjU3F1aXNhUyxhVGlzYyAzQWRhQyNFZCFlR20tJExhc3QrTGgjTG8uTS0pTmNgTmd1aW1OXU5vJU4uT257b1BvY2FRdWUlUjxoPmVzUnVlKVNjIFMkbGFUPGdhVmUlMkFuKUFxdWUpQXQqYUViZXVVbWFnZW1VdmkmMUV1MERhRSdhRXRpc2FMZWdeTGljaSBMdS0lTHZpbC9NIE1iYU5kKCBOLkBQfm8sUilTc3UnU3QmVGVVcCBVLFZvIDJBQEFuY11BJEF4ZUVjZUVkP0VmZWkkRW1pIEVucyBFcCAgRXNpbF1FJXgkRXYtJ0V6IEltYSlJbmNlc2FJc21hSXYjT2NlcyxPZHUkT2ZlKU9pYmk9T2plJE9tZSVyT3BhZyBPc2FPJSRyT3Y/MkJsaWMgRGltTCBMbX0gTHN7YU5oJk4nUGlsb1JlemFYPzo5OUFkK0FudEBBciRBc2VFYnIgRWRhRWlqb0VuJUVyaT1JbX1vSW5hSW9zcXVlOkI8XkJpc2NvQ2ggQ2l9IERpJkkgSW5dSW9JdmFKXkwjTSZOZyhOaHUrUCF1K1BgUGlkZXpQb3NhUXVlJVJpZCFlUzwlU2N1bi9TZyBTcD9TJSdhU3VyIFRhejxhVG97YTNBbGV6YUFuaW0gQXYoQmFpeCBCYGRlQm9sIEMjQy0lQ2hlaW9DaWJvQ3xkIENydS5DdSBEZURpbSdEfWRhRHV6aWRhRW52aW9GKiBGbGV0J0ZvZyBGW3Njb0Z1Z2kgRyZAR2ltZUcrSW4jSSRySmVpLkxhdGl2b00/TS09TXwsTm92I1Agb1BgJ1BsZSRQb2wvUFtzYVB1ZGkgUXUoKFMtXVNmcmkgU2dhLlNpZCdTb2x2KFNwZWkkU3NhY2FTKW4lU3VtJ1QmL1QoVCcgVG9tXlQrLlZgIFZpLHJWb2wpM0FjL0NhR2lkZXpHb18sTSBOZ3VlU15TY29TfS81QiZvQ2hlPUReRGVpb0RvdkBFPXJMZSlNPG9OYyBTI1N7YVMkVGFUe29UKmFUfiBVY29VcGFYbzVCX0dpPUdvLEl2b01vUGVzdFtTLDpCfENpIENvbGFDdWQnRGlvRidhR2FHcl5JYl9MXkx7b0xnI0xpdmFMcGljIExzaWNdTC5Mdj9NYiBNdStpTiBOZn1hTmd1ZU5pZCFlUGEkUmQ+Zy0kUmplKVR1ciBVZCFlWG9mfWVafSYzQyBDfiBEYUQtJERpI0RvLER1JHJHbS0kR1s9R3VuPUl2YUxlJEx2YWdlbU08Jk0tJU4/Ti9yTnN1Jk50I1AgI1JlaT4qZz4rUnZvVGVtYl9UfDNHaWxvTGh1ZSlMaWN9ZU1ldHJATXBhdEBNfiBOJk5jKG9OZ34gTm9wc2VOJG5pPi1lUmlUdSM1Qig8b0IrQ3xfR19KYUxkYUxldHIgTCUnb01icmlvTmEpTmQgTmVnIE5oP05vUCtub1F1ZSVScidSJWlvU3NlZ29UYXF1ZVQociBWI1oqLzVBdml6IEJpZGFCbSgsQixsb0J0KydDYSlDZXMsQ29EZXMlRml4b0c/RygnSmVpJExmYSRNJ09yUChpfFBsaWMgUG9zJFByaW0nUmQqPmZpcylScFtzPlsmUnQnU3Anb1MlbiQ6QmBhQmxlJUJ1XkMvRyBgYUxoKExvTHZlek08L01ifGltTXBhTmctJU4kUCBQaW9jPmRpb1JlZj5qPit4YVR1YWdlbVVyKm9YYXRpdm9YaXMpM0F0ciZDKENpPUNsI0RpbyxJYUltIExlZn1lTGgjTXAob04tJU4sck4uUm0mUm5vUnItb1NlU291K1N0I1RvWHR1K1h1Z28zQStHYGFKb2xvTWJyIE1pZGV6TmdpPU4lJ29SYWdlbVR+IDVBbF1DXUwoIExpY2VNXk1pbC9OYE50dStQZSVSPmNpPVJuZWlvUnF1ZVJyIT4kUy5VY2FVcHthWCphMkFiJi9BY2VqIEFkdSRyQWZlZyBBamUkQW1hQW5jIEFwb0Fze29BdD9BdiBFKm9FbShFcGlkIEV2b0lhZ2VtSWJvSWNpY2xvSWQtJUlsb2dASW5kIWVJcGxvSXR1ciBJdW5mJk9jIE9tYmUpT3ZhVW5mb1VxdWUyQn4gQzxvRG9MaXBhUGlSYm9SbT5xdWVzYVRgIFR8aSY6N1YgM0JpZ28wSGFJZCFlSWZ8bWUzT2xvZ0BTb1RpZ2FVYnUwQT1JbmFVZnJ1JzpDKmFEaSBHIG8sST0sTGFMLSVMaWQhZUxvW3NOKWdlbVF1e29SPGQ+ZSlScihTY34gU2lsXVMsdStaIFppbzNBPUQgR2UuSWN+IEx7b0xoaWNlTHU9TmNlPXJOZGF2Jk4oIE50W1JiJlJkIWVSZT9SZ31oPm1gL1JuaXpScyBSJW4lU3BhU3RpPVR8aSYzQWR1JEFnZW1BaiBBdHUrQnI/RHthRHIgQEVsYUdhRy0lR2kgR3wgTCBlam9OY29OaGUpTmlsT2xlKVIhPnR1ZGVTaS5TJFRyJlZ7b1oqLzVBPXJBckcmTDwlTGVpYm9sTClnZW1MdW1vLE50IWU1TCRWdXpgYTo6RFt6Um9wZTNRdWVSZS5SaWZlM05nIDo6TmcjUnAgM0J1TD85TWIgT2xvZ0A1TWJpPVwiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4MjIxOTAwMDkyNmRmN2I1MGQ4YWEwYTNkNDk1ODI2Yjk4ODI4N2RmNDY1N2ZiZDEwMGU2ZmU1OTZjOGY3MzdhY1wiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktcHRdXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ1B0IGV4dGVuZHMgd29yZGxpc3Rfb3dsX2pzXzEuV29yZGxpc3RPd2wge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBQb3J0dWd1ZXNlIGxhbmd1YWdlIFdvcmRsaXN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IG1vc3Qgb2YgdGhlIHRpbWUgYXMgdGhlIGV4cG9ydGVkXG4gICAgICogIFtbbGFuZ1B0XV0gc2hvdWxkIHN1ZmZpY2UuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFwicHRcIiwgd29yZHMsIGNoZWNrc3VtKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nUHRgYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ1B0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ1B0ID0gTGFuZ1B0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1wdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-pt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-zh.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-zh.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangZh = void 0;\nconst index_js_1 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\nconst data = \"}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH\";\nconst deltaData = \"FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL\";\nconst _wordlist = {\n    zh_cn: null,\n    zh_tw: null\n};\nconst Checks = {\n    zh_cn: \"0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1\",\n    zh_tw: \"0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d\"\n};\nconst codes = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst style = \"~!@#$%^&*_-=[]{}|;:,.()<>?\";\nfunction loadWords(locale) {\n    if (_wordlist[locale] != null) {\n        return _wordlist[locale];\n    }\n    const wordlist = [];\n    let deltaOffset = 0;\n    for (let i = 0; i < 2048; i++) {\n        const s = style.indexOf(data[i * 3]);\n        const bytes = [\n            228 + (s >> 2),\n            128 + codes.indexOf(data[i * 3 + 1]),\n            128 + codes.indexOf(data[i * 3 + 2]),\n        ];\n        if (locale === \"zh_tw\") {\n            const common = s % 4;\n            for (let i = common; i < 3; i++) {\n                bytes[i] = codes.indexOf(deltaData[deltaOffset++]) + ((i == 0) ? 228 : 128);\n            }\n        }\n        wordlist.push((0, index_js_2.toUtf8String)(new Uint8Array(bytes)));\n    }\n    // Verify the computed list matches the official list\n    const checksum = (0, index_js_1.id)(wordlist.join(\"\\n\") + \"\\n\");\n    /* c8 ignore start */\n    if (checksum !== Checks[locale]) {\n        throw new Error(`BIP39 Wordlist for ${locale} (Chinese) FAILED`);\n    }\n    /* c8 ignore stop */\n    _wordlist[locale] = wordlist;\n    return wordlist;\n}\nconst wordlists = {};\n/**\n *  The [[link-bip39-zh_cn]] and [[link-bip39-zh_tw]] for\n *  [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangZh extends wordlist_js_1.Wordlist {\n    /**\n     *  Creates a new instance of the Chinese language Wordlist for\n     *  the %%dialect%%, either ``\"cn\"`` or ``\"tw\"`` for simplified\n     *  or traditional, respectively.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langZhCn]] and [[langZhTw]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor(dialect) { super(\"zh_\" + dialect); }\n    getWord(index) {\n        const words = loadWords(this.locale);\n        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return loadWords(this.locale).indexOf(word);\n    }\n    split(phrase) {\n        phrase = phrase.replace(/(?:\\u3000| )+/g, \"\");\n        return phrase.split(\"\");\n    }\n    /**\n     *  Returns a singleton instance of a ``LangZh`` for %%dialect%%,\n     *  creating it if this is the first time being called.\n     *\n     *  Use the %%dialect%% ``\"cn\"`` or ``\"tw\"`` for simplified or\n     *  traditional, respectively.\n     */\n    static wordlist(dialect) {\n        if (wordlists[dialect] == null) {\n            wordlists[dialect] = new LangZh(dialect);\n        }\n        return wordlists[dialect];\n    }\n}\nexports.LangZh = LangZh;\n//# sourceMappingURL=lang-zh.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy16aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUM3QyxlQUFlLGtFQUFrRSxNQUFNLHFFQUFxRSwrREFBK0QsdUNBQXVDLFNBQVMsOEVBQThFLFNBQVMsd0JBQXdCLGVBQWUsc0RBQXNELHdCQUF3QixNQUFNLG1EQUFtRCxrQkFBa0IscUJBQXFCLFNBQVMsbURBQW1ELE1BQU0sR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsU0FBUyxHQUFHLHFCQUFxQixzR0FBc0csR0FBRywyRUFBMkUsZUFBZSxTQUFTLDJCQUEyQix3QkFBd0IsTUFBTSxlQUFlLGVBQWUsR0FBRyxvQ0FBb0MsZUFBZSxHQUFHLE1BQU0sd0JBQXdCLE1BQU0sTUFBTSxHQUFHLFNBQVMsR0FBRyxrQkFBa0Isa0JBQWtCLHdFQUF3RSxrQkFBa0IsMkVBQTJFLFNBQVMsc0RBQXNELEdBQUcsZUFBZSxTQUFTLHdCQUF3QixlQUFlLE1BQU0sWUFBWSxrQkFBa0IsOEJBQThCLEdBQUcsWUFBWSxrQkFBa0IsR0FBRyxHQUFHLEdBQUcsb0NBQW9DLDhCQUE4QixHQUFHLHVGQUF1RixNQUFNLFlBQVksZUFBZSxNQUFNLDBDQUEwQyxTQUFTLEdBQUcsMkJBQTJCLGlDQUFpQyxlQUFlLCtEQUErRCxrQkFBa0IsU0FBUyxHQUFHLEdBQUcsc0RBQXNELHFCQUFxQixZQUFZLGVBQWUsU0FBUyxNQUFNLE1BQU0sb0NBQW9DLG9DQUFvQyxrQkFBa0IsR0FBRyxpQ0FBaUMsMENBQTBDLHdCQUF3Qix3QkFBd0IsdUNBQXVDLHdCQUF3Qix3QkFBd0IsR0FBRyxpQ0FBaUMsZUFBZSw4QkFBOEIsR0FBRyxHQUFHLE1BQU0sTUFBTSxHQUFHLFNBQVMsU0FBUyxNQUFNLEdBQUcsR0FBRyw2Q0FBNkMsTUFBTSxNQUFNLGVBQWUsU0FBUyxrQkFBa0IscUJBQXFCLE1BQU0sR0FBRyxTQUFTLEdBQUcsR0FBRyxNQUFNLDhCQUE4QixZQUFZLHdCQUF3QixlQUFlLHVDQUF1QyxrQkFBa0IsMENBQTBDLEdBQUcsWUFBWSw2RkFBNkYsZUFBZSxTQUFTLGVBQWUsMkJBQTJCLFNBQVMsR0FBRyx3QkFBd0IsR0FBRyxHQUFHLE1BQU0sTUFBTSw0REFBNEQsa0JBQWtCLHFCQUFxQiw4QkFBOEIsMkJBQTJCLE1BQU0sa0JBQWtCLDhCQUE4QixTQUFTLGVBQWUsWUFBWSxHQUFHLFNBQVMsOEJBQThCLEdBQUcsU0FBUyxNQUFNLE1BQU0sR0FBRyxZQUFZLE1BQU0sZUFBZSxTQUFTLDJCQUEyQixnREFBZ0QsR0FBRyxNQUFNLEdBQUcscUJBQXFCLCtEQUErRCxNQUFNLEdBQUcsU0FBUyxZQUFZLDJCQUEyQixnREFBZ0QsU0FBUyxHQUFHLGlDQUFpQyxTQUFTLEdBQUcsTUFBTSxNQUFNLDZDQUE2QyxNQUFNLEdBQUcsdUNBQXVDLHFCQUFxQixxQkFBcUIsTUFBTSxHQUFHLHFCQUFxQixNQUFNLE1BQU0sb0NBQW9DLFNBQVMsd0JBQXdCLHdCQUF3QixZQUFZLGVBQWUsU0FBUyx3QkFBd0IsWUFBWSxpQ0FBaUMsR0FBRyxlQUFlLHFCQUFxQixHQUFHLCtEQUErRCxTQUFTLGtCQUFrQixZQUFZLDJCQUEyQixlQUFlLEdBQUcsTUFBTSxlQUFlLDhCQUE4QixTQUFTLEdBQUcsc0RBQXNELEdBQUcscUJBQXFCLEdBQUcsR0FBRyxHQUFHLFlBQVksTUFBTSxTQUFTLG9DQUFvQyxTQUFTLE1BQU0sd0JBQXdCLEdBQUcsd0JBQXdCLGtCQUFrQixHQUFHLDZDQUE2QyxNQUFNLE1BQU0sWUFBWSxlQUFlLEdBQUcsR0FBRyxHQUFHLEdBQUcsTUFBTSxHQUFHLFNBQVMsTUFBTSxNQUFNLFNBQVMsWUFBWSxTQUFTLEdBQUcscUJBQXFCLFlBQVksTUFBTSxHQUFHLE1BQU0sTUFBTSxHQUFHLDhCQUE4QixHQUFHLEdBQUcsTUFBTSxNQUFNLDJCQUEyQixrQkFBa0IsR0FBRyxNQUFNLFNBQVMsTUFBTSxNQUFNLFlBQVkscUJBQXFCLGVBQWUsTUFBTSxHQUFHLHdCQUF3QixHQUFHLFNBQVMsR0FBRyxxQkFBcUIsTUFBTSxvQ0FBb0MsTUFBTSwyQkFBMkIsd0JBQXdCLDBDQUEwQyxHQUFHLDZGQUE2RixZQUFZLEdBQUcsR0FBRyxxQkFBcUIsTUFBTSxHQUFHLE1BQU0sa0JBQWtCLGVBQWUsR0FBRyxZQUFZLDhCQUE4QixlQUFlLHdCQUF3QiwyQkFBMkIsWUFBWSwrREFBK0QsbURBQW1ELFlBQVksWUFBWSwrREFBK0QsaUNBQWlDLEdBQUcsa0JBQWtCLE1BQU0sU0FBUyxZQUFZLHFFQUFxRSxHQUFHLFNBQVMsU0FBUyxHQUFHLFlBQVksZUFBZSxxQkFBcUIsTUFBTSx3QkFBd0IsTUFBTSxlQUFlLGVBQWUsZUFBZSxZQUFZLE1BQU0sTUFBTSxrQkFBa0Isb0NBQW9DO0FBQ3pnTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxrR0FBa0csTUFBTTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2xhbmctemguanM/ZGVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ1poID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHdvcmRsaXN0X2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC5qc1wiKTtcbmNvbnN0IGRhdGEgPSBcIn1hRSM0QT1ZdiZjbyM0TiM2Rz1jSiZTTSM2NnwvWiM0dCZrbn40NiM0S340cSViOT1JUiM3bCxtQiM3V19YMipkbH1Vb343c31VZiZJdyM5YyZjd342TyZINiZ3eCZJRyV2NT1JUX44YSZQdiM0NyRQUiY1MCVLbyZRTSYzbCM1ZixEOSM0THwvSCZ0UTt2MH42bl1uTjxkaSxBTT1XNSVRTyZrYSZ1YSxoTV50bT16Vj1KQT13UiYrWF03UCZOQiM0SiM1THwvYltkQX10SjxEbyY2bSZ1MltVMSZLYi5ITSZtQz13MCZNVzxyWSxIcSM2TX1RRywxMyZ3UH1KcF1PdyV1ZSZLZzxIUDxEOX40a345VCZJMl9jNiQ5VCM5L1tDNX43T340YT1jcyZPNz1LSz1BbiZsOSQ2VSQ4QSZ1RCZRSXwvWSZiZ31VeCZGMiM2Yn1FMiZKTiZrVyZrcD1VLyZiYj1YbDxDan1rK341SiM2TCY1eiY5aX1iNCZGbyxobyhYMF9nM340TyRGeiZRRTxITj1Xd102LyVHRi1Wdz10aiYvRCZQTiM5Zz1ZT31jTCZPZiZQSX41SSZJcD12VT1JVyM5Rzswby13VX1zcyZRUjxCVCZSOT10ayRQWV9kaCZQcS15aF03VCxuai5YdT1FUCY3Nj1jSSZGcypYZ316NyRHYiYrST1ERixBRj1jQX1yTCM3aj1EeiYzeTxBYSQ1Mj1QUX1iMChpWSRGYX1vTCZ4ViM2VT1lYz1XWix4aCVSWTxkcCM5TiZGbCY0ND1XSCpBNz1zaCZUQiY4UD0wNzt1KyZQS311aH1KNSM3MilWLz14QyxBQiRrMCZmNjsxRXwrNT0xQiwzdl02biZ3UiViKyZ4eF03Zj1PbH1mbDsrRF53R103RTtuQjt1aF5JciZsNT1KTCxuUz1jZj1nNTt1NnwvUSRHYz1NSCVIZyM1ZCVNNl44Nj1VKyRHeixsLyxpcl41eSZCYSYvRi1JWSZGSSZiZSVJWiM3NyZQV19OdSRrRShZZiZOWF03WixKeSZGSihYbyZOeiMvZD15NyZNWDxBZ31aKztuRV1EdChpRyM0RD0xMyZQan40YyV2OCZabyVPTCYvWCM0VzxIUiZpZX42Sl8xTyhZMj15NT1BZCpjdl9lQiM2ayZQWDpCVSM3QTt1ayZGdCZGeF9kRD1VMjt2Qj1VNT00Rn0rTyZHTi5ISDo5cz1iMCVOVihqTyZJSD1KVH1aOT1WWjxBZixLeF40bSZ1SiVjNiw2cjs5bSMrTH1jZiVLaCZGM340SD12UH1idSxIenwrKywxd11udn1rNjt1dSRqdypLbCpXWCZ1TVt4NyZGclttNyROTyZRTl1odT1KTn1uUl44ZyMvaChwc3xLQzt2ZH14ej1WMH1wNiZGRCRHMSM3SzxiR180cH44ZyZjZjt1ND10bH0rayU1L31mejt1dzxjQT11MX1nVX1WTT1MSj1lWCYrTCZQciM0VX1wMjpuQywyS103SDpqRiY5eH11WCM5Tz1NQjxmen44WH41bSY0RCZrTiZ1NSVFLyhoNyhaRiZWRzxkZShxTXwvZS1XdD0zeChhKywvUl1mLyZORCRSbyZuVX0wZz1LQSVrSCZOSyRLZTxkU31jQiZJWH41ZyRUTl02bT1VdixJcyZQeT1FZiVLeiMrLyViaSYrQTxGNCRPRyY0QyZGTCM5Vjxaaz0ySV9lRSY2Y11udyZrcSRIR315KyZBOCRQM31PSD1YUF03MCVJUyhBSl9nSCVHWiZ0WSZBWj12Yn42eSYvcj1WST1XdjxaaT1mbD14ZiZlTH1jOH1PTD1NSj1nOCRGNz1ZVH05dT0wK154Q31KSCZuTF5OMH40VF1LMixDeSVPQyM2czt2RyhBQ154ZV5jRyZNRn1CciM5UDt3RC03aCRPLyZ4QX1Gbl5QQ102aV03RyY4ViRRczt2bChUQn43M340bDxtVyY2Vj0yeSZ1WSYrMylhUH1YRjtMUCZreCR3VT10Nzt1eTxGTiZseik3RT1PbypZKzt3SX05cX1sZTtKNiZSaSY0dCZRciM4Qj1jYiZ2Rz1KNXxRbChoNTxZeX40K31RRCxMeD13biVLLyZSSz1kTyZQdyxROT1jbyU0dTs5dX1nMEA2YV40SSViMD16b3wvYyZ0WD1kUT1PUyMrYj15el9BQiZ3QiZQbT1XOSRIUF9nUj02Mj1BTz10aT1oSSxvQSZqciZkSD10bSZiNiRQMih4OD16aTtuR343RjswNV0wbltJeCYzbX1yZz1YcD1jZCZ1el03dDs5Nz1jTjt2VjxqZiZGRiZGMT02USZJaypLayZQNCwyej1mUV03RCYzdSxIMD1kL31VdzxaTjw3Un1LdjswZiRINyxNRF03biRGMCM4OH45WiVkYT1ieTsrVCMvdT1WRiZmTyZrcl5rZjxBQl1zVSxJNSROZyZQejswaSZRRCZ2TT1ZbDpCTTtuSl94Sl1VNyZLZiYzMCwzZnxaOSpkQylqZV9qQSZRNCZLcCROSChZeiM2UyZJZCVJYj1LWCxBRD1LViVkUH10VyZQa14rRV9OaT1jcSwzUn1WWihTaT1iK31ydjswan1yWl11QSwvdyhTeCZKdiR3OSY0ZCZ3RSxOSiRHeT1KL11McyM3azxaUTxZLyZ1al1PdiRQTTt2MywyRiYrdTp1cD1PbiYzZSxKdjs5MD1KKyZRbV02cX1iSyMrZH44WShoMl1oQTs5OSZBUz1JL31xQiZkUX15Si1WTX1WbCZ1aSxpQiZHM3xEY103ZD1lUSVkWCVKQ18xTH40ZF5OUDt2SiYvMSlaSSM3Tl05WFtiUSZQTD0wTChVWixMbSZrYyZJUn1uNyhpUjxBUTxkZz0zMz12Tn1mdH1hdV03SSxCYT14OT1kUn42UiZUcT1YaSwzZCROciZCY31ESSZrdSZ2Zl1EbiwvRiZpRCxMbCZOdz0weSZJNz1Mcz0vQSZ0VT1RZX1VYSZ1ayYrRj1nND1naD1WaiMrMSZRbn1VeSo0NCM1RixQYyZSeipYbj1vaD01Vzswbl9OZihpRTxZNz12cj1adV1veiM1WiVtST1rTj1Cdl9KcChUMjt2dF9NbDxGUyZ1ST1MLyY2UF02NCRNN304NjxibyVRWChTSSVJWSZWSz1BbCZVeDt2djt1dCpFLyV1aDxaRXxPMyxNMih5Y115dT1XayZ0cDpFeH1ocixDbCZXRSkrWj04VX1JMl80USxoQV9zaT1pdz1PTT10TT15WiVJYT1VNzt3VH1iKzt1bz1aYX15UyE1eH1IRH1mYiM1T19kQTtOdiV1Qih5QjswMShTZn1Gazt2N31QdCM4djxtWiM3TCwvciZQbH40dyZmNT1QaCRGd19MRiY4bSxiTD15SiZCSH1wLypKbn10VX41UTt3QihoNl1EZl04cF4rQjtFNCZXYz1kKztFYSZidyQ4QyZGTixETT1ZZn1tUH41dz1mVCM2Vj1tQz1GaT1BVn1qQiZBTn1sV31hSCMvRClkWjtobDt2RX0vNyxDSjszMSZ3OCxoaiV1OV9Kcz1qSiY0TX44az1UTiZlQ31uTCZ1Yy13aSZsWH1kaj1Ndj1lMiM2dT1jciR1cSQ2R104V31KYjpubT1ZZzxiMyhVQTt2WCY2biZ4Rj1LVCxqQyxEZSZSOCZvWT1adiZvQl03Lz1aMiZPYX1iZixoaCg0aF50WiY3MiZOeDtEMiZ4TH41aH40MClaRyloKz1PSiZSQV1CdiR5Qj1PcT1kZixBUSVKbn1PSjsxMSwzeiZUbCZ0ajt2K15IdixEaChpZD1zK103TiZOMyk5UX44ZixTND11Vz13NCZ1WCxMWCYzZF1DSiZ5cCY4eDxiMl9kbyZsUD15LzxjeV9kRz1PaT03UihWSChsdF8xVCxJcV9BQTsxMl42VCVrNiM4S1tCMXtvTzxBVVtCdDsxYiQ5UyZQczw4VD1TdHtiWSxqQihacCY2MyZVdiQ5VixQTV02diZBZn16V1tiV19vcX1zbX1uQiZLcSZnQyZmZl9lcV8ybSY1RiZUSX1yZn1HZjtacl96OTtFUiZqa31pel9zbjxCTn4rbiZ2bz1WaSU5N3xaUj1XYyxXRSY2dF02eiU4NShseSM4ND1LWSk2bV81Lz1hWCxOM31UbSZoZSY2S110Ul9CMi1JMzt1LyZoVSZsSDxBUD1pQiZJQT1YTDsvNSZOaD13djxCSCM3OT12Uz16bDxBQT0wWF9SR31CdyY5cCROVyxBWCZrUF9McCYvWihUY11NdX1ocyM2SX01QiZjSTxicSZIOSM2bT1LOX12SChZMShZMCM0QiZ3NiwvOSZnRzxiRSwvTz16Yn1JNF9sODxCLzt3TCVRbzxIT1tNcT1YWH0wdiZCUCZGNChtR30waX1ubSxFQz05dXtJMyx4RyYvOT1KWSpESyZoUilCWD1FST1jeD1iL3s2a315WCVBKyZ3YX1YYj1sYTt3aV5sTDswdH1qbyZRYj14Zz1YQn1pTzxxb3tiUj1OViY4Zj1hMCZKeTswdj11SylISzt2TiM2aCZqQihoLyV1ZCZOSSV3WS5YNz1QdH1DdS11TCZHc19obCVtSCx0bV03OD1MYl5RMCM3WT0xdTxCdCYrUT1Db19SSCx3MzsxZX11eDxhVTt1aX1VMyZRNSVidF02MyZVUXwwbCZ1TH1PNyYzbyxBViZkbXxOaihYdCo1KyhVdSZIaChwNyhVRj1WUj1CcF5KbCZIZFtpeCk5Lz1JcV1DODw2N102Nn1tQiU2Zn1iYn1KSV04VCRIQX1kYj1ZTSZwYT0ySn10UyZZMD1QUyZ5ND1jWCQ2RSxoWCxYUCZuUjswNCxGUSZsMCZWbV9EdiM1WX44Wj1CaSVNQV02eD1KTzorcCxBeiY5cSxIan42L31TRD1LMTpFSn1uQTtRbyMvRV05UixJZSY2WCVXM102MSZ2ND14WF9NQz0wcTswNihYcT1mc31JR31Edj0wbH1vNyRpWjs5diZMSCZEUC03YSZPWSxTWixLeixDdiZkaD1meHxOaCxGL343cT1YRiZ3Kzs5biZHdzswaH1aNzw3TyZKSyhTNyZMUzxBRDxhYz13bzxEdCZ6dyU0Qj00diM4UDs5b342cCp2Vj1UbSxPciZJNj0xcX1uWT1QMD1ncSZCbCZVdSxDaCV5Yn1VWT16aH1kaH1ybChUNF94ayhZQSM4Uip4SCxJTn1Kbl03Vn1DNCZUeX1qM103cD1jTD0zaCZ3VyVRdjxaMz1mMCZSSSYrUyhpY196cX1vTiYvWT16MTtUZD1MVz0wZT1PSShWYywrYl5qdShVTDswcjpaYSU4dj1ScD16dyY1OCY3MyZ3S31xWF02eSY4RSlhMn1XUj13UF51ciZuUTxjSH1SZT1BcSZ3a31RMCYrcT1QUCxHY3wvZF5rNSxGd104WX1QZ11wMz1qdT1lZH1yNV95ZiZDc103eiQvRzxDbSZKcCY1NF8xR19nUF9MbH1KWjswdV1rOF83ayhTZ102NXs5aT1MTiZTeCZXSyxpVyZmRCZMa3s5YX1FbS05YyM4TiZpbz1zeV04ZCZuVCZJSyhseCM3LyRsVyhUZDxzOH40OSwzbzw3WT1NVyhUK19KciZXZCxpTH1DdD14aCY1Vjt2NCY4biVLeD1pRiZsMl8wQntCKyxJZihKMCxMdjt1OD1LeC12Qj1IQyZ2Uz1aNiZmVSZ2RV54SzszRD00aD1NUiM0NTpKdzswZH1pdz1MVX1JNT1JMF1nQippbSxLOX1HVSwxa180VSZUdD1WcyhpWCZsVShURiM3eSxaT31vQSZtNSM1UH1QTn1Vej1oTTxCMSZGQjxhRyxlNn43VDx0UChVUV9aVD13dSZGOClhUV1pTiwxcl9MbyYvZzpDRH04NHtKMV9LaSZOYSYzbiRqeiZGRT1kYzt1djt2YX1pbn1sbD1mdihoMSYzaH1mcD1DeX1CTSgrRX44bX1sbyV2Nz1oQyhUNiRjaj1CUT1CdyhEUiwyaj1LcyxOU3xGKzswMD1mVT03MH1NYihZVTsrRyZtNyZocj1TayVDb110KyhYNV9Kd30wcn1nQyhBUy1JUCZRSzxaMiM4USRXQ11XWH1UMiZwR19LYSxIQz1SNCYvTjtaKztjaChDNyxENCQzcF9NayZCMiQ4RD1uOSVLeSM1eihDVCZRSiM3Ql1EQ11nV31uZn41TTtJdyM4MH1UY18xRiM0Wi1hQ31IbD1waD1meiwvMz1hV31KTX1ubjtERzt2bX13biw0UH1UMzt3eCZSRyR1K316Sz0wYjsrSl9Fa3tyZTxhWj1BU315WSM1RF03cSxDcH14Tj1WUCoyQ31HWn1hR34rbV9Dcz1PWSM2cl02ZzxHU31MQyhVQj0zQT1Cb31KeTxjNH1JczsxUDxBR31PcDxaMX1sZH1uUz0xWix5TSY5NSY5OD1DSig0dDoyTCRIaz1ab31WYzsrSX1ucCZOMX05eT1pdn1DTyo3cD1qTClweF10Yl56aCZHUyZWbCV2Lzt2Uj0xND16SiY0OXwvZl1oRn1XRzswMz04UH1vLyZHZyZycDtEQixLdn1KaSZQYjthQV5sbCg0aiV5dH0rSyRIdCM0eSZoWV03WTxGMSxlTn1iRyhVaCU2Wl10NSVHNzsrRl9SRTtpdH10TD1MUyZEYT1YeChTKyg0Zj04Rz15SX1jSn1XUD0zNz1qU31wWH1oZClmcDxBOD1KdH4rbyRISj1NNn1pWD1nOX1DUz1kdj1DaihtUCVLZCx4cXwrOSZMRCg0Lz1YbSZRUD1MY31MWCZmTDsrSz1PcChsdT1Rcy5xQzorZSZMKz1KaiM4dztTTF03UyhiKyM0ST1jMSZuR19MZiZ1SDsrUilaVjxiViVCLyxURSYwSCZKcSZBaCVPRiZTcyhwMixXdiZJMz1XbH1WcTsxTCZsSiM5Yl8xSD04cj1iOD1KSChTWj1oRD1KMiM3VSwvVSMvWH42UCxGVTxlTD1qeCxtRz1oRz1DRSZQVT1TZShxWCZMWT1YNj15NCZ0ayZRUSZ0Zj00ZyZ4SX1XKyZtWj1EYyM3d31MZztEQTt3UV9LYihjSj1oUiV5WCZZYixod3tiWF80WDtFUDsxV18yTX1VYz1iNShZRixDTSZUcF5PSntERF02cz12Rj1Zb344cX1YSH1GdSVQNShTSj1RdDtNT11zODxGMyZCMyY4VChVbC1CUypkdyZkUjw4N30vOF02MiRQWl1MeDxBdX05UV03Yz1qYT1LUixHbyxVcyZ2Nihxa31wRyZHMj1ldl5HTSV3NCZINF03RiZkdl1KNn1Fdzo5dz1zai1aTH1ZbSQraChVdChVbX40bj1YcyhVNyVlRT1RY19KUjxDQSM2dDxGdnwvSSxJUyxFRzxGMihYeSQvbjxGYShoOX0rOV8ybyZONCM3WDxacXwrZl9EcD1kdCZuYSxDYT1OSilqWT04Qz1ZRz1zNiZRKzxET31EMz14QiZSMShsdztRbjxiRihDdXwvQn1IVj1TUyZuNywxMCZ1MF1EbSVBNl40UT1XUihURD1YbzxHSCxSaihsOCliUCZuLz1MTSZDRixGNSZtbD1QSjswaz1MRz10cSxSaCxENkA0aT0xcCYrOT1ZQyVlcl9NaDtuSTswcT1Gd104MD14cT1GTSRHdjt2NiZuYzt3SyVIMiZLajt2cyxBQT1ZUCw2Nn1iSShxUn41VT02cX40YiROaT1LNS5YMyRTbyZJdShwK104Rz1DZj1SWShUU19PMyhpSCY1Nz1mRT1EZ19EbyM5eiM3SDtGS3txZF8yayVKUn1lbiZnaF96ODtSeH05cDxjTl9OZSxETztMTl83b34vcD1ORj01WX1nTjxjZTxDMSxRRV1Xdj0zdTxCQ31HS115cX1EWSZ1L19oaj1JSShweiZyQyxqViYrWn11dD1OUTtDZy1TUl9aUywrbz11LztPeV9SS19RRihGeCZ4UH1XciZUQSxVaCZnMT15cntheFtWRiRQZyhZQjtPeD1WeTsrVyhTcH1YViVkZCYzMyhsL11sNCM0WX1PRT02Yz1idyhBNyY5dCV3ZCZOLyZtbyxKSCZRZSlmbT1Bb31mdT10SFwiO1xuY29uc3QgZGVsdGFEYXRhID0gXCJGQVpEQzZCQUxjTFpDQStHQkFSQ1c4d05DY0REWjhMVkZCT3FxRFVpb3UrTTQyVEZBeUVSWEZiN0VqaFArdm1CRnBGclVwZkRWMkY3ZUIrZUNsdENISkZXTEZDRUQrcFdUb2pFSUhGWGMzYUZuNEY2OHpxakV1S2lkUzFRQlZQREVoRTdOQTRtaE1GN29UaEQ0OW90M0ZndHpIRkNLMGFjVzF4OERIMUVtTG9JbHJXRkJMRSt5NStOQTNDeDY1d0pIVGFFWlZhSzFtV0FtUEd4Z1lDZHh3T2pUREl0L2ZhT0VoVGwxdnFOc0t0SkNPaEpXdWlvMmcwN0tMWkVRc0ZCVXBOdHdFQnlCZ3hGc2xGaGVGYmlFUHZpNjFtc0R2QXB4Q3pCNnJCQ3pveDdqb1lBNVVkRGMrQ2I0RlNnSWFicFhGQWozYmprbUZBeENaRSttRC9TRmYvMEVMZWNZQ3QzbkxveEM2V0VaZjJ0S0RCNG9adnJFbXFGa0trN0J3SUxBN2d0WUJwc1RxLy9ENGpEMEYwd0VCOXB5UTFCRDVCYTBvWUhESStzYkRGaHZySFhkREhmZ0ZFSUpMaTVyOHFlcmNORkJnRkxDNGJvNUVSSnRhbVdCREZ5NzNLQ0ViNk04VnBtRXQzMzB5Z0NUSzU4RUlJRmtZZ0Y4NGd0R0E5VXloM202OGlWckZiV0ZiY2JxaUNZSFo5SjFqZVJQYkw4eXN3aE1pRGJoRWhkTm9Td0ZiWnJMVDc0MEFCRXFnQ2tPOEoxQkxkMVZoS0tSNHNEMXlVbzB6K0ZGNTlNdmc3MUNGYnlFaGJIU0ZCS0VJS3lvUU5nUXBwcTlUMEtBcWVQdTBaRkdyWE9IZEtKcWtvVEZoWXZwRE55dXV6bnJOODR0aEpic0NvTzZDdTZYbHZudHZ5MFFZdUFFeFFFWXRUVUJmM0NvQ3F3Z0dGWjR1MUhKRnpEVndFeTNjamNwVjRRdnNQYUJDM3JDR3lDRjIzbzRLM3BwMmdiZXJHZ0ZFSkVIbzRuSElDdHlLSDJacXl4aE4wNUtCQkpJUWxLaC9PdWp2L0RIMzJWcmxxRmRJRkM3Rno5Q3Q0a2FxRk1FMFVFVExwcm5OOWtmeStrRm10UUJCMCs1Q0Z1ME45SWo4bC9WdkpEaDJvcTNoVDZFempUSEtGTjdaalp3b1RzQVo0RXhza282RnBhNldDK3NkdXo4anlyTHBlZ1R2MmgxRUJlWXBMcG0yY3pRVzBLb0NjUzBiQ1ZYQ211V0pEQmpOMW5RTkxkRjU4U0ZKMGg3aTNwQzNvRU9LeS9GakJrbEw3MFh2QkVFSVdwMnlaMDR4T2J6QVdEREpHN2YrRGJxQkVBN0x5aVI5NWo3TURWZERWaXoyUkU1dldsQk12NWU0K1ZmaFAzYVhOUGh2TFN5bmI5TzJ4NHVGQlYrM2pxdTZkNXBDRzI4L3NFVEJ5dm11LytJSjBMM3diNHJqOUROT0xCRjZYUElPRHI0TDE5VTlSUm9mQUc2Tnh5ZGk4QmtpOEJoR0piQkFKS3piSnhrWlNsRjlRMkN1OG9LcWdnQjloQkFyd0xMcUVCV0V0Rm93eThYSzhiRXl3OXNuVCtCZXlGazFaQ1NyZG1nZkV3RmVQVGdDakVMQkVuSWJqYUREUEptMzZyRzlwenRjRXpUOGRHazIzU0JoWEJCMUg0eitPV3plMG9vRnp6OHBEQllGdnA5ajl0dkZCeWY5eTRFRmRWbnowMjZDR1I1cU1yN2Z4TUhOOFVVZGx5SkF6bFRCRFJDMjhrK0w0RkI4MDc4bGp5RDkxdFVqMW9jblRzOHZkRWY3em5iem0rR0lqRVpub1pFNXJuTEw3MDBYYzd5SGZ6MDVuV3h5MDN2QkI5WUdIWU9XeGdNUUdCQ1IyNENWWU5FMWhwZkt4TjB6S25mSkRtbU1nTW1CV3FOYmpmU3lGQ0JXU0NHQ2dSOHlGWGlIeUVqK1Z0RDFGQjNGcEMxekkwa0ZiemlmaUtUTG05eXE1ekZtdXIrcThGSHFqb09CV3NCUGlEYm5DQzJFcnVuVjZjSjZUeWdYRllIWXA3TUtOOVJVbFNJUzgveEJBR1lMemVxVW5CRjRRYnNUdVVrVXFHczZDYWlEV0tXalFLOUVKa2pwa1RtTkNQWVhMXCI7XG5jb25zdCBfd29yZGxpc3QgPSB7XG4gICAgemhfY246IG51bGwsXG4gICAgemhfdHc6IG51bGxcbn07XG5jb25zdCBDaGVja3MgPSB7XG4gICAgemhfY246IFwiMHgxN2JjYzRkODU0N2U1YTcxMzVlMzY1ZDFhYjQ0M2FhYWU5NWU3NmQ4MjMwYzI3ODJjNjczMDVkNGYyMTQ5N2ExXCIsXG4gICAgemhfdHc6IFwiMHg1MWU3MjBlOTBjN2I4N2JlYzFkNzBlYjZlNzRhMjFhNDQ5YmQzZWM5YzAyMGIwMWQzYTQwZWQ5OTFiNjBjZTVkXCJcbn07XG5jb25zdCBjb2RlcyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuY29uc3Qgc3R5bGUgPSBcIn4hQCMkJV4mKl8tPVtde318OzosLigpPD4/XCI7XG5mdW5jdGlvbiBsb2FkV29yZHMobG9jYWxlKSB7XG4gICAgaWYgKF93b3JkbGlzdFtsb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF93b3JkbGlzdFtsb2NhbGVdO1xuICAgIH1cbiAgICBjb25zdCB3b3JkbGlzdCA9IFtdO1xuICAgIGxldCBkZWx0YU9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDQ4OyBpKyspIHtcbiAgICAgICAgY29uc3QgcyA9IHN0eWxlLmluZGV4T2YoZGF0YVtpICogM10pO1xuICAgICAgICBjb25zdCBieXRlcyA9IFtcbiAgICAgICAgICAgIDIyOCArIChzID4+IDIpLFxuICAgICAgICAgICAgMTI4ICsgY29kZXMuaW5kZXhPZihkYXRhW2kgKiAzICsgMV0pLFxuICAgICAgICAgICAgMTI4ICsgY29kZXMuaW5kZXhPZihkYXRhW2kgKiAzICsgMl0pLFxuICAgICAgICBdO1xuICAgICAgICBpZiAobG9jYWxlID09PSBcInpoX3R3XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1vbiA9IHMgJSA0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbW1vbjsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gY29kZXMuaW5kZXhPZihkZWx0YURhdGFbZGVsdGFPZmZzZXQrK10pICsgKChpID09IDApID8gMjI4IDogMTI4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3b3JkbGlzdC5wdXNoKCgwLCBpbmRleF9qc18yLnRvVXRmOFN0cmluZykobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKSk7XG4gICAgfVxuICAgIC8vIFZlcmlmeSB0aGUgY29tcHV0ZWQgbGlzdCBtYXRjaGVzIHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgaW5kZXhfanNfMS5pZCkod29yZGxpc3Quam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChjaGVja3N1bSAhPT0gQ2hlY2tzW2xvY2FsZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCSVAzOSBXb3JkbGlzdCBmb3IgJHtsb2NhbGV9IChDaGluZXNlKSBGQUlMRURgKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBfd29yZGxpc3RbbG9jYWxlXSA9IHdvcmRsaXN0O1xuICAgIHJldHVybiB3b3JkbGlzdDtcbn1cbmNvbnN0IHdvcmRsaXN0cyA9IHt9O1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS16aF9jbl1dIGFuZCBbW2xpbmstYmlwMzktemhfdHddXSBmb3JcbiAqICBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nWmggZXh0ZW5kcyB3b3JkbGlzdF9qc18xLldvcmRsaXN0IHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ2hpbmVzZSBsYW5ndWFnZSBXb3JkbGlzdCBmb3JcbiAgICAgKiAgdGhlICUlZGlhbGVjdCUlLCBlaXRoZXIgYGBcImNuXCJgYCBvciBgYFwidHdcImBgIGZvciBzaW1wbGlmaWVkXG4gICAgICogIG9yIHRyYWRpdGlvbmFsLCByZXNwZWN0aXZlbHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nWmhDbl1dIGFuZCBbW2xhbmdaaFR3XV0gc2hvdWxkIHN1ZmZpY2UuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGlhbGVjdCkgeyBzdXBlcihcInpoX1wiICsgZGlhbGVjdCk7IH1cbiAgICBnZXRXb3JkKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gbG9hZFdvcmRzKHRoaXMubG9jYWxlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAgJiYgaW5kZXggPCB3b3Jkcy5sZW5ndGgsIGBpbnZhbGlkIHdvcmQgaW5kZXg6ICR7aW5kZXh9YCwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB3b3Jkc1tpbmRleF07XG4gICAgfVxuICAgIGdldFdvcmRJbmRleCh3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb2FkV29yZHModGhpcy5sb2NhbGUpLmluZGV4T2Yod29yZCk7XG4gICAgfVxuICAgIHNwbGl0KHBocmFzZSkge1xuICAgICAgICBwaHJhc2UgPSBwaHJhc2UucmVwbGFjZSgvKD86XFx1MzAwMHwgKSsvZywgXCJcIik7XG4gICAgICAgIHJldHVybiBwaHJhc2Uuc3BsaXQoXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nWmhgYCBmb3IgJSVkaWFsZWN0JSUsXG4gICAgICogIGNyZWF0aW5nIGl0IGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqXG4gICAgICogIFVzZSB0aGUgJSVkaWFsZWN0JSUgYGBcImNuXCJgYCBvciBgYFwidHdcImBgIGZvciBzaW1wbGlmaWVkIG9yXG4gICAgICogIHRyYWRpdGlvbmFsLCByZXNwZWN0aXZlbHkuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KGRpYWxlY3QpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0c1tkaWFsZWN0XSA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdHNbZGlhbGVjdF0gPSBuZXcgTGFuZ1poKGRpYWxlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdHNbZGlhbGVjdF07XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nWmggPSBMYW5nWmg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLXpoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-zh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Use the encode-latin.js script to create the necessary\n// data files to be consumed by this class\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WordlistOwl = void 0;\nconst index_js_1 = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst decode_owl_js_1 = __webpack_require__(/*! ./decode-owl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js\");\nconst wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\n/**\n *  An OWL format Wordlist is an encoding method that exploits\n *  the general locality of alphabetically sorted words to\n *  achieve a simple but effective means of compression.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on ASCII-7 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */\nclass WordlistOwl extends wordlist_js_1.Wordlist {\n    #data;\n    #checksum;\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */\n    constructor(locale, data, checksum) {\n        super(locale);\n        this.#data = data;\n        this.#checksum = checksum;\n        this.#words = null;\n    }\n    /**\n     *  The OWL-encoded data.\n     */\n    get _data() { return this.#data; }\n    /**\n     *  Decode all the words for the wordlist.\n     */\n    _decodeWords() {\n        return (0, decode_owl_js_1.decodeOwl)(this.#data);\n    }\n    #words;\n    #loadWords() {\n        if (this.#words == null) {\n            const words = this._decodeWords();\n            // Verify the computed list matches the official list\n            const checksum = (0, index_js_1.id)(words.join(\"\\n\") + \"\\n\");\n            /* c8 ignore start */\n            if (checksum !== this.#checksum) {\n                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);\n            }\n            /* c8 ignore stop */\n            this.#words = words;\n        }\n        return this.#words;\n    }\n    getWord(index) {\n        const words = this.#loadWords();\n        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return this.#loadWords().indexOf(word);\n    }\n}\nexports.WordlistOwl = WordlistOwl;\n//# sourceMappingURL=wordlist-owl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3Qtb3dsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5Qyx3QkFBd0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMscUZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csTUFBTTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3Qtb3dsLmpzPzNiNWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBVc2UgdGhlIGVuY29kZS1sYXRpbi5qcyBzY3JpcHQgdG8gY3JlYXRlIHRoZSBuZWNlc3Nhcnlcbi8vIGRhdGEgZmlsZXMgdG8gYmUgY29uc3VtZWQgYnkgdGhpcyBjbGFzc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3JkbGlzdE93bCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBkZWNvZGVfb3dsX2pzXzEgPSByZXF1aXJlKFwiLi9kZWNvZGUtb3dsLmpzXCIpO1xuY29uc3Qgd29yZGxpc3RfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LmpzXCIpO1xuLyoqXG4gKiAgQW4gT1dMIGZvcm1hdCBXb3JkbGlzdCBpcyBhbiBlbmNvZGluZyBtZXRob2QgdGhhdCBleHBsb2l0c1xuICogIHRoZSBnZW5lcmFsIGxvY2FsaXR5IG9mIGFscGhhYmV0aWNhbGx5IHNvcnRlZCB3b3JkcyB0b1xuICogIGFjaGlldmUgYSBzaW1wbGUgYnV0IGVmZmVjdGl2ZSBtZWFucyBvZiBjb21wcmVzc2lvbi5cbiAqXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCB0byBtb3N0IGRldmVsb3BlcnMgYXNcbiAqICBpdCBpcyB1c2VkIG1haW5seSBpbnRlcm5hbGx5IHRvIGtlZXAgV29yZGxpc3RzIGZvciBsYW5ndWFnZXNcbiAqICBiYXNlZCBvbiBBU0NJSS03IHNtYWxsLlxuICpcbiAqICBJZiBuZWNlc3NhcnksIHRoZXJlIGFyZSB0b29scyB3aXRoaW4gdGhlIGBgZ2VuZXJhdGlvbi9gYCBmb2xkZXJcbiAqICB0byBjcmVhdGUgdGhlIG5lY2Vzc2FyeSBkYXRhLlxuICovXG5jbGFzcyBXb3JkbGlzdE93bCBleHRlbmRzIHdvcmRsaXN0X2pzXzEuV29yZGxpc3Qge1xuICAgICNkYXRhO1xuICAgICNjaGVja3N1bTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBmb3IgJSVsb2NhbGUlJSB1c2luZyB0aGUgT1dMICUlZGF0YSUlXG4gICAgICogIGFuZCB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgJSVjaGVja3N1bSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSwgZGF0YSwgY2hlY2tzdW0pIHtcbiAgICAgICAgc3VwZXIobG9jYWxlKTtcbiAgICAgICAgdGhpcy4jZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuI2NoZWNrc3VtID0gY2hlY2tzdW07XG4gICAgICAgIHRoaXMuI3dvcmRzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBPV0wtZW5jb2RlZCBkYXRhLlxuICAgICAqL1xuICAgIGdldCBfZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlIGFsbCB0aGUgd29yZHMgZm9yIHRoZSB3b3JkbGlzdC5cbiAgICAgKi9cbiAgICBfZGVjb2RlV29yZHMoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZGVjb2RlX293bF9qc18xLmRlY29kZU93bCkodGhpcy4jZGF0YSk7XG4gICAgfVxuICAgICN3b3JkcztcbiAgICAjbG9hZFdvcmRzKCkge1xuICAgICAgICBpZiAodGhpcy4jd29yZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSB0aGlzLl9kZWNvZGVXb3JkcygpO1xuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3RcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gKDAsIGluZGV4X2pzXzEuaWQpKHdvcmRzLmpvaW4oXCJcXG5cIikgKyBcIlxcblwiKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGNoZWNrc3VtICE9PSB0aGlzLiNjaGVja3N1bSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQklQMzkgV29yZGxpc3QgZm9yICR7dGhpcy5sb2NhbGV9IEZBSUxFRGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI3dvcmRzID0gd29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dvcmRzO1xuICAgIH1cbiAgICBnZXRXb3JkKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy4jbG9hZFdvcmRzKCk7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShpbmRleCA+PSAwICYmIGluZGV4IDwgd29yZHMubGVuZ3RoLCBgaW52YWxpZCB3b3JkIGluZGV4OiAke2luZGV4fWAsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd29yZHNbaW5kZXhdO1xuICAgIH1cbiAgICBnZXRXb3JkSW5kZXgod29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbG9hZFdvcmRzKCkuaW5kZXhPZih3b3JkKTtcbiAgICB9XG59XG5leHBvcnRzLldvcmRsaXN0T3dsID0gV29yZGxpc3RPd2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC1vd2wuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WordlistOwlA = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst decode_owla_js_1 = __webpack_require__(/*! ./decode-owla.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/decode-owla.js\");\n/**\n *  An OWL-A format Wordlist extends the OWL format to add an\n *  overlay onto an OWL format Wordlist to support diacritic\n *  marks.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on latin-1 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */\nclass WordlistOwlA extends wordlist_owl_js_1.WordlistOwl {\n    #accent;\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%\n     *  and %%accent%% data and validated against the %%checksum%%.\n     */\n    constructor(locale, data, accent, checksum) {\n        super(locale, data, checksum);\n        this.#accent = accent;\n    }\n    /**\n     *  The OWLA-encoded accent data.\n     */\n    get _accent() { return this.#accent; }\n    /**\n     *  Decode all the words for the wordlist.\n     */\n    _decodeWords() {\n        return (0, decode_owla_js_1.decodeOwlA)(this._data, this._accent);\n    }\n}\nexports.WordlistOwlA = WordlistOwlA;\n//# sourceMappingURL=wordlist-owla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3Qtb3dsYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsMEJBQTBCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3JELHlCQUF5QixtQkFBTyxDQUFDLDJGQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy93b3JkbGlzdC1vd2xhLmpzPzAwYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldvcmRsaXN0T3dsQSA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0X293bF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsLmpzXCIpO1xuY29uc3QgZGVjb2RlX293bGFfanNfMSA9IHJlcXVpcmUoXCIuL2RlY29kZS1vd2xhLmpzXCIpO1xuLyoqXG4gKiAgQW4gT1dMLUEgZm9ybWF0IFdvcmRsaXN0IGV4dGVuZHMgdGhlIE9XTCBmb3JtYXQgdG8gYWRkIGFuXG4gKiAgb3ZlcmxheSBvbnRvIGFuIE9XTCBmb3JtYXQgV29yZGxpc3QgdG8gc3VwcG9ydCBkaWFjcml0aWNcbiAqICBtYXJrcy5cbiAqXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCB0byBtb3N0IGRldmVsb3BlcnMgYXNcbiAqICBpdCBpcyB1c2VkIG1haW5seSBpbnRlcm5hbGx5IHRvIGtlZXAgV29yZGxpc3RzIGZvciBsYW5ndWFnZXNcbiAqICBiYXNlZCBvbiBsYXRpbi0xIHNtYWxsLlxuICpcbiAqICBJZiBuZWNlc3NhcnksIHRoZXJlIGFyZSB0b29scyB3aXRoaW4gdGhlIGBgZ2VuZXJhdGlvbi9gYCBmb2xkZXJcbiAqICB0byBjcmVhdGUgdGhlIG5lY2Vzc2FyeSBkYXRhLlxuICovXG5jbGFzcyBXb3JkbGlzdE93bEEgZXh0ZW5kcyB3b3JkbGlzdF9vd2xfanNfMS5Xb3JkbGlzdE93bCB7XG4gICAgI2FjY2VudDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBmb3IgJSVsb2NhbGUlJSB1c2luZyB0aGUgT1dMQSAlJWRhdGElJVxuICAgICAqICBhbmQgJSVhY2NlbnQlJSBkYXRhIGFuZCB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgJSVjaGVja3N1bSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSwgZGF0YSwgYWNjZW50LCBjaGVja3N1bSkge1xuICAgICAgICBzdXBlcihsb2NhbGUsIGRhdGEsIGNoZWNrc3VtKTtcbiAgICAgICAgdGhpcy4jYWNjZW50ID0gYWNjZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIE9XTEEtZW5jb2RlZCBhY2NlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgX2FjY2VudCgpIHsgcmV0dXJuIHRoaXMuI2FjY2VudDsgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgYWxsIHRoZSB3b3JkcyBmb3IgdGhlIHdvcmRsaXN0LlxuICAgICAqL1xuICAgIF9kZWNvZGVXb3JkcygpIHtcbiAgICAgICAgcmV0dXJuICgwLCBkZWNvZGVfb3dsYV9qc18xLmRlY29kZU93bEEpKHRoaXMuX2RhdGEsIHRoaXMuX2FjY2VudCk7XG4gICAgfVxufVxuZXhwb3J0cy5Xb3JkbGlzdE93bEEgPSBXb3JkbGlzdE93bEE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC1vd2xhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/wordlist.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wordlist = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  A Wordlist represents a collection of language-specific\n *  words used to encode and devoce [[link-bip-39]] encoded data\n *  by mapping words to 11-bit values and vice versa.\n */\nclass Wordlist {\n    locale;\n    /**\n     *  Creates a new Wordlist instance.\n     *\n     *  Sub-classes MUST call this if they provide their own constructor,\n     *  passing in the locale string of the language.\n     *\n     *  Generally there is no need to create instances of a Wordlist,\n     *  since each language-specific Wordlist creates an instance and\n     *  there is no state kept internally, so they are safe to share.\n     */\n    constructor(locale) {\n        (0, index_js_1.defineProperties)(this, { locale });\n    }\n    /**\n     *  Sub-classes may override this to provide a language-specific\n     *  method for spliting %%phrase%% into individual words.\n     *\n     *  By default, %%phrase%% is split using any sequences of\n     *  white-space as defined by regular expressions (i.e. ``/\\s+/``).\n     */\n    split(phrase) {\n        return phrase.toLowerCase().split(/\\s+/g);\n    }\n    /**\n     *  Sub-classes may override this to provider a language-specific\n     *  method for joining %%words%% into a phrase.\n     *\n     *  By default, %%words%% are joined by a single space.\n     */\n    join(words) {\n        return words.join(\" \");\n    }\n}\nexports.Wordlist = Wordlist;\n//# sourceMappingURL=wordlist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3QuanM/Nzg0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29yZGxpc3QgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgQSBXb3JkbGlzdCByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBsYW5ndWFnZS1zcGVjaWZpY1xuICogIHdvcmRzIHVzZWQgdG8gZW5jb2RlIGFuZCBkZXZvY2UgW1tsaW5rLWJpcC0zOV1dIGVuY29kZWQgZGF0YVxuICogIGJ5IG1hcHBpbmcgd29yZHMgdG8gMTEtYml0IHZhbHVlcyBhbmQgdmljZSB2ZXJzYS5cbiAqL1xuY2xhc3MgV29yZGxpc3Qge1xuICAgIGxvY2FsZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBNVVNUIGNhbGwgdGhpcyBpZiB0aGV5IHByb3ZpZGUgdGhlaXIgb3duIGNvbnN0cnVjdG9yLFxuICAgICAqICBwYXNzaW5nIGluIHRoZSBsb2NhbGUgc3RyaW5nIG9mIHRoZSBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqICBHZW5lcmFsbHkgdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGEgV29yZGxpc3QsXG4gICAgICogIHNpbmNlIGVhY2ggbGFuZ3VhZ2Utc3BlY2lmaWMgV29yZGxpc3QgY3JlYXRlcyBhbiBpbnN0YW5jZSBhbmRcbiAgICAgKiAgdGhlcmUgaXMgbm8gc3RhdGUga2VwdCBpbnRlcm5hbGx5LCBzbyB0aGV5IGFyZSBzYWZlIHRvIHNoYXJlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGxvY2FsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgYSBsYW5ndWFnZS1zcGVjaWZpY1xuICAgICAqICBtZXRob2QgZm9yIHNwbGl0aW5nICUlcGhyYXNlJSUgaW50byBpbmRpdmlkdWFsIHdvcmRzLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUlcGhyYXNlJSUgaXMgc3BsaXQgdXNpbmcgYW55IHNlcXVlbmNlcyBvZlxuICAgICAqICB3aGl0ZS1zcGFjZSBhcyBkZWZpbmVkIGJ5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgKGkuZS4gYGAvXFxzKy9gYCkuXG4gICAgICovXG4gICAgc3BsaXQocGhyYXNlKSB7XG4gICAgICAgIHJldHVybiBwaHJhc2UudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGVyIGEgbGFuZ3VhZ2Utc3BlY2lmaWNcbiAgICAgKiAgbWV0aG9kIGZvciBqb2luaW5nICUld29yZHMlJSBpbnRvIGEgcGhyYXNlLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUld29yZHMlJSBhcmUgam9pbmVkIGJ5IGEgc2luZ2xlIHNwYWNlLlxuICAgICAqL1xuICAgIGpvaW4od29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHdvcmRzLmpvaW4oXCIgXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuV29yZGxpc3QgPSBXb3JkbGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsaXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlists.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/wordlists.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wordlists = void 0;\nconst lang_cz_js_1 = __webpack_require__(/*! ./lang-cz.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-cz.js\");\nconst lang_en_js_1 = __webpack_require__(/*! ./lang-en.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\");\nconst lang_es_js_1 = __webpack_require__(/*! ./lang-es.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-es.js\");\nconst lang_fr_js_1 = __webpack_require__(/*! ./lang-fr.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-fr.js\");\nconst lang_ja_js_1 = __webpack_require__(/*! ./lang-ja.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-ja.js\");\nconst lang_ko_js_1 = __webpack_require__(/*! ./lang-ko.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-ko.js\");\nconst lang_it_js_1 = __webpack_require__(/*! ./lang-it.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-it.js\");\nconst lang_pt_js_1 = __webpack_require__(/*! ./lang-pt.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-pt.js\");\nconst lang_zh_js_1 = __webpack_require__(/*! ./lang-zh.js */ \"(ssr)/./node_modules/ethers/lib.commonjs/wordlists/lang-zh.js\");\n/**\n *  The available Wordlists by their\n *  [ISO 639-1 Language Code](link-wiki-iso639).\n *\n *  (**i.e.** [cz](LangCz), [en](LangEn), [es](LangEs), [fr](LangFr),\n *  [ja](LangJa), [ko](LangKo), [it](LangIt), [pt](LangPt),\n *  [zh_cn](LangZh), [zh_tw](LangZh))\n *\n *  The dist files (in the ``/dist`` folder) have had all languages\n *  except English stripped out, which reduces the library size by\n *  about 80kb. If required, they are available by importing the\n *  included ``wordlists-extra.min.js`` file.\n */\nexports.wordlists = {\n    cz: lang_cz_js_1.LangCz.wordlist(),\n    en: lang_en_js_1.LangEn.wordlist(),\n    es: lang_es_js_1.LangEs.wordlist(),\n    fr: lang_fr_js_1.LangFr.wordlist(),\n    it: lang_it_js_1.LangIt.wordlist(),\n    pt: lang_pt_js_1.LangPt.wordlist(),\n    ja: lang_ja_js_1.LangJa.wordlist(),\n    ko: lang_ko_js_1.LangKo.wordlist(),\n    zh_cn: lang_zh_js_1.LangZh.wordlist(\"cn\"),\n    zh_tw: lang_zh_js_1.LangZh.wordlist(\"tw\"),\n};\n//# sourceMappingURL=wordlists.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3RzLmpzPzFlYzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndvcmRsaXN0cyA9IHZvaWQgMDtcbmNvbnN0IGxhbmdfY3pfanNfMSA9IHJlcXVpcmUoXCIuL2xhbmctY3ouanNcIik7XG5jb25zdCBsYW5nX2VuX2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWVuLmpzXCIpO1xuY29uc3QgbGFuZ19lc19qc18xID0gcmVxdWlyZShcIi4vbGFuZy1lcy5qc1wiKTtcbmNvbnN0IGxhbmdfZnJfanNfMSA9IHJlcXVpcmUoXCIuL2xhbmctZnIuanNcIik7XG5jb25zdCBsYW5nX2phX2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWphLmpzXCIpO1xuY29uc3QgbGFuZ19rb19qc18xID0gcmVxdWlyZShcIi4vbGFuZy1rby5qc1wiKTtcbmNvbnN0IGxhbmdfaXRfanNfMSA9IHJlcXVpcmUoXCIuL2xhbmctaXQuanNcIik7XG5jb25zdCBsYW5nX3B0X2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLXB0LmpzXCIpO1xuY29uc3QgbGFuZ196aF9qc18xID0gcmVxdWlyZShcIi4vbGFuZy16aC5qc1wiKTtcbi8qKlxuICogIFRoZSBhdmFpbGFibGUgV29yZGxpc3RzIGJ5IHRoZWlyXG4gKiAgW0lTTyA2MzktMSBMYW5ndWFnZSBDb2RlXShsaW5rLXdpa2ktaXNvNjM5KS5cbiAqXG4gKiAgKCoqaS5lLioqIFtjel0oTGFuZ0N6KSwgW2VuXShMYW5nRW4pLCBbZXNdKExhbmdFcyksIFtmcl0oTGFuZ0ZyKSxcbiAqICBbamFdKExhbmdKYSksIFtrb10oTGFuZ0tvKSwgW2l0XShMYW5nSXQpLCBbcHRdKExhbmdQdCksXG4gKiAgW3poX2NuXShMYW5nWmgpLCBbemhfdHddKExhbmdaaCkpXG4gKlxuICogIFRoZSBkaXN0IGZpbGVzIChpbiB0aGUgYGAvZGlzdGBgIGZvbGRlcikgaGF2ZSBoYWQgYWxsIGxhbmd1YWdlc1xuICogIGV4Y2VwdCBFbmdsaXNoIHN0cmlwcGVkIG91dCwgd2hpY2ggcmVkdWNlcyB0aGUgbGlicmFyeSBzaXplIGJ5XG4gKiAgYWJvdXQgODBrYi4gSWYgcmVxdWlyZWQsIHRoZXkgYXJlIGF2YWlsYWJsZSBieSBpbXBvcnRpbmcgdGhlXG4gKiAgaW5jbHVkZWQgYGB3b3JkbGlzdHMtZXh0cmEubWluLmpzYGAgZmlsZS5cbiAqL1xuZXhwb3J0cy53b3JkbGlzdHMgPSB7XG4gICAgY3o6IGxhbmdfY3pfanNfMS5MYW5nQ3oud29yZGxpc3QoKSxcbiAgICBlbjogbGFuZ19lbl9qc18xLkxhbmdFbi53b3JkbGlzdCgpLFxuICAgIGVzOiBsYW5nX2VzX2pzXzEuTGFuZ0VzLndvcmRsaXN0KCksXG4gICAgZnI6IGxhbmdfZnJfanNfMS5MYW5nRnIud29yZGxpc3QoKSxcbiAgICBpdDogbGFuZ19pdF9qc18xLkxhbmdJdC53b3JkbGlzdCgpLFxuICAgIHB0OiBsYW5nX3B0X2pzXzEuTGFuZ1B0LndvcmRsaXN0KCksXG4gICAgamE6IGxhbmdfamFfanNfMS5MYW5nSmEud29yZGxpc3QoKSxcbiAgICBrbzogbGFuZ19rb19qc18xLkxhbmdLby53b3JkbGlzdCgpLFxuICAgIHpoX2NuOiBsYW5nX3poX2pzXzEuTGFuZ1poLndvcmRsaXN0KFwiY25cIiksXG4gICAgemhfdHc6IGxhbmdfemhfanNfMS5MYW5nWmgud29yZGxpc3QoXCJ0d1wiKSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.commonjs/wordlists/wordlists.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n// created 2023-09-25T01:01:55.148Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\nvar COMPRESSED$1 = 'AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI';\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\r\n\r\n\r\nfunction read_trie(next) {\r\n\tlet ret = [];\r\n\tlet sorted = read_sorted(next); \r\n\texpand(decode([]), []);\r\n\treturn ret; // not sorted\r\n\tfunction decode(Q) { // characters that lead into this node\r\n\t\tlet S = next(); // state: valid, save, check\r\n\t\tlet B = read_array_while(() => { // buckets leading to new nodes\r\n\t\t\tlet cps = read_sorted(next).map(i => sorted[i]);\r\n\t\t\tif (cps.length) return decode(cps);\r\n\t\t});\r\n\t\treturn {S, B, Q};\r\n\t}\r\n\tfunction expand({S, B}, cps, saved) {\r\n\t\tif (S & 4 && saved === cps[cps.length-1]) return;\r\n\t\tif (S & 2) saved = cps[cps.length-1];\r\n\t\tif (S & 1) ret.push(cps); \r\n\t\tfor (let br of B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\texpand(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-09-25T01:01:55.148Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar COMPRESSED = 'AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g';\n\n// https://unicode.org/reports/tr15/\r\n// for reference implementation\r\n// see: /derive/nf.js\r\n\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\r\n\r\nfunction init$1() {\r\n\t//console.time('nf');\r\n\tlet r = read_compressed_payload(COMPRESSED);\r\n\tSHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\n\tEXCLUSIONS = new Set(read_sorted(r));\r\n\tDECOMP = new Map();\r\n\tRECOMP = new Map();\r\n\tfor (let [cp, cps] of read_mapped(r)) {\r\n\t\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\t\tlet [a, b] = cps;\r\n\t\t\tlet bucket = RECOMP.get(a);\r\n\t\t\tif (!bucket) {\r\n\t\t\t\tbucket = new Map();\r\n\t\t\t\tRECOMP.set(a, bucket);\r\n\t\t\t}\r\n\t\t\tbucket.set(b, cp);\r\n\t\t}\r\n\t\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n\t}\r\n\t//console.timeEnd('nf');\r\n\t// 20230905: 11ms\r\n}\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tif (!SHIFTED_RANK) init$1();\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\nconst HYPHEN = 0x2D;\r\nconst STOP = 0x2E;\r\nconst STOP_CH = '.';\r\nconst FE0F = 0xFE0F;\r\nconst UNIQUE_PH = 1;\r\n\r\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\r\nconst Array_from = x => Array.from(x); // Array.from.bind(Array);\r\n\r\nfunction group_has_cp(g, cp) {\r\n\t// 20230913: keep primary and secondary distinct instead of creating valid union\r\n\treturn g.P.has(cp) || g.Q.has(cp);\r\n}\r\n\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; } // free tagging system\r\n}\r\n\r\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\r\n\r\nfunction init() {\r\n\tif (MAPPED) return;\r\n\t\r\n\tlet r = read_compressed_payload(COMPRESSED$1);\r\n\tconst read_sorted_array = () => read_sorted(r);\r\n\tconst read_sorted_set = () => new Set(read_sorted_array());\r\n\tconst set_add_many = (set, v) => v.forEach(x => set.add(x));\r\n\r\n\tMAPPED = new Map(read_mapped(r)); \r\n\tIGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\r\n\r\n\t/*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/\r\n\t// 20230217: we still need all CM for proper error formatting\r\n\t// but norm only needs NSM subset that are potentially-valid\r\n\tCM = read_sorted_array();\r\n\tNSM = new Set(read_sorted_array().map(i => CM[i]));\r\n\tCM = new Set(CM);\r\n\t\r\n\tESCAPE = read_sorted_set(); // characters that should not be printed\r\n\tNFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\r\n\r\n\tlet chunks = read_sorted_arrays(r);\r\n\tlet unrestricted = r();\r\n\t//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\r\n\tconst read_chunked = () => {\r\n\t\t// 20230921: build set in parts, 2x faster\r\n\t\tlet set = new Set();\r\n\t\tread_sorted_array().forEach(i => set_add_many(set, chunks[i]));\r\n\t\tset_add_many(set, read_sorted_array());\r\n\t\treturn set; \r\n\t};\r\n\tGROUPS = read_array_while(i => {\r\n\t\t// minifier property mangling seems unsafe\r\n\t\t// so these are manually renamed to single chars\r\n\t\tlet N = read_array_while(r).map(x => x+0x60);\r\n\t\tif (N.length) {\r\n\t\t\tlet R = i >= unrestricted; // unrestricted then restricted\r\n\t\t\tN[0] -= 32; // capitalize\r\n\t\t\tN = str_from_cps(N);\r\n\t\t\tif (R) N=`Restricted[${N}]`;\r\n\t\t\tlet P = read_chunked(); // primary\r\n\t\t\tlet Q = read_chunked(); // secondary\r\n\t\t\tlet M = !r(); // not-whitelisted, check for NSM\r\n\t\t\t// *** this code currently isn't needed ***\r\n\t\t\t/*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/\r\n\t\t\treturn {N, P, Q, M, R};\r\n\t\t}\r\n\t});\r\n\r\n\t// decode compressed wholes\r\n\tWHOLE_VALID = read_sorted_set();\r\n\tWHOLE_MAP = new Map();\r\n\tlet wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted\r\n\twholes.forEach((cp, i) => {\r\n\t\tlet d = r(); \r\n\t\tlet w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};\r\n\t\tw.V.push(cp); // add to member set\r\n\t\tif (!WHOLE_VALID.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t\t}\r\n\t});\r\n\r\n\t// compute confusable-extent complements\r\n\t// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\r\n\tfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t\t// connect all groups that have each whole character\r\n\t\tlet recs = [];\r\n\t\tfor (let cp of V) {\r\n\t\t\tlet gs = GROUPS.filter(g => group_has_cp(g, cp));\r\n\t\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\t\tif (!rec) {\r\n\t\t\t\trec = {G: new Set(), V: []};\r\n\t\t\t\trecs.push(rec);\r\n\t\t\t}\r\n\t\t\trec.V.push(cp);\r\n\t\t\tset_add_many(rec.G, gs);\r\n\t\t}\r\n\t\t// per character cache groups which are not a member of the extent\r\n\t\tlet union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole\r\n\t\tfor (let {G, V} of recs) {\r\n\t\t\tlet complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent\r\n\t\t\tfor (let cp of V) {\r\n\t\t\t\tM.set(cp, complement); // this is the same reference\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// compute valid set\r\n\t// 20230924: VALID was union but can be re-used\r\n\tVALID = new Set(); // exists in 1+ groups\r\n\tlet multi = new Set(); // exists in 2+ groups\r\n\tconst add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\r\n\tfor (let g of GROUPS) {\r\n\t\tfor (let cp of g.P) add_to_union(cp);\r\n\t\tfor (let cp of g.Q) add_to_union(cp);\r\n\t}\r\n\t// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\n\tfor (let cp of VALID) {\r\n\t\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t\t}\r\n\t}\r\n\t// add all decomposed parts\r\n\t// see derive: \"Valid is Closed (via Brute-force)\"\r\n\tset_add_many(VALID, nfd(VALID));\r\n\t\r\n\t// decode emoji\r\n\t// 20230719: emoji are now fully-expanded to avoid quirk logic \r\n\tEMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);\r\n\tEMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\r\n\tfor (let cps of EMOJI_LIST) {\r\n\t\t// 20230719: change to *slightly* stricter algorithm which disallows \r\n\t\t// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\r\n\t\t// example: beautified [A B] (eg. flag emoji) \r\n\t\t//  before: allow: [A FE0F B], error: [A FE0F FE0F B] \r\n\t\t//   after: error: both\r\n\t\t// note: this code now matches ENSNormalize.{cs,java} logic\r\n\t\tlet prev = [EMOJI_ROOT];\r\n\t\tfor (let cp of cps) {\r\n\t\t\tlet next = prev.map(node => {\r\n\t\t\t\tlet child = node.get(cp);\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\t// should this be object? \r\n\t\t\t\t\t// (most have 1-2 items, few have many)\r\n\t\t\t\t\t// 20230719: no, v8 default map is 4?\r\n\t\t\t\t\tchild = new Map();\r\n\t\t\t\t\tnode.set(cp, child);\r\n\t\t\t\t}\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\tif (cp === FE0F) {\r\n\t\t\t\tprev.push(...next); // less than 20 elements\r\n\t\t\t} else {\r\n\t\t\t\tprev = next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let x of prev) {\r\n\t\t\tx.V = cps;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// if cps exceed max, middle truncate with ellipsis\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tif (cps.length > max) {\r\n\t\tmax >>= 1;\r\n\t\tcps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];\r\n\t}\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\n// note: Object.freeze() doesn't work\r\nfunction is_combining_mark(cp) {\r\n\tinit();\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\tinit();\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\tinit();\r\n\treturn EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tinit();\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(split(name, nfc, filter_fe0f));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet labels = split(name, nfc, x => x); // emoji not exposed\r\n\tfor (let {type, output, error} of labels) {\r\n\t\tif (error) break; // flatten will throw\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(labels);\r\n}\r\n\r\nfunction array_replace(v, a, b) {\r\n\tlet prev = 0;\r\n\twhile (true) {\r\n\t\tlet next = v.indexOf(a, prev);\r\n\t\tif (next < 0) break;\r\n\t\tv[next] = b; \r\n\t\tprev = next + 1;\r\n\t}\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\treturn split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\r\n}\r\n\r\nfunction split(name, nf, ef) {\r\n\tif (!name) return []; // 20230719: empty name allowance\r\n\tinit();\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = tokens_from_str(input, nf, ef);\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} \r\n\t\t\tlet norm = info.output = tokens.flat();\r\n\t\t\tcheck_leading_underscore(norm);\r\n\t\t\tlet emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\r\n\t\t\tif (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\tcheck_label_extension(norm); // only needed for ascii\r\n\t\t\t\t// cant have fenced\r\n\t\t\t\t// cant have cm\r\n\t\t\t\t// cant have wholes\r\n\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\ttype = 'ASCII';\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\tlet unique = Array_from(new Set(chars));\r\n\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = [];\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : Array_from(set);\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaining groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => group_has_cp(g, cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => group_has_cp(g, cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (!GROUPS.some(g => group_has_cp(g, cp))) { \r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\t// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\r\n\t\t\t\t// note: this doesn't have to be a composition\r\n\t\t\t\t// 20230720: change to full check\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp)); // only check primary\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tfor (let cp of cps) {\r\n\t\tif (!group_has_cp(g, cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (g.M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\n// 20230818: rename for 'process' name collision h/t Javarome\r\n// https://github.com/adraffy/ens-normalize.js/issues/23\r\nfunction tokens_from_str(input, nf, ef) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(ef(emoji));\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps); // less than 10 elements\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\t// 20230912: unicode 15.1 changed the order of processing such that\r\n\t\t\t\t\t// disallowed parts are only rejected after NFC\r\n\t\t\t\t\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t\t\t\t\t// this doesn't impact normalization as of today\r\n\t\t\t\t\t// technically, this error can be removed as the group logic will apply similar logic\r\n\t\t\t\t\t// however the error type might be less clear\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet pos = cps.length;\r\n\twhile (pos) {\r\n\t\tnode = node.get(cps[--pos]);\r\n\t\tif (!node) break;\r\n\t\tlet {V} = node;\r\n\t\tif (V) { // this is a valid emoji (so far)\r\n\t\t\temoji = V;\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\treturn emoji;\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tinit();\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TY_EMOJI,\r\n\t\t\t\temoji: emoji.slice(), // copy emoji\r\n\t\t\t\tinput: eaten,\r\n\t\t\t\tcps: filter_fe0f(emoji)\r\n\t\t\t});\r\n\t\t\teaten = []; // reset buffer\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\nexports.ens_beautify = ens_beautify;\nexports.ens_emoji = ens_emoji;\nexports.ens_normalize = ens_normalize;\nexports.ens_normalize_fragment = ens_normalize_fragment;\nexports.ens_split = ens_split;\nexports.ens_tokenize = ens_tokenize;\nexports.is_combining_mark = is_combining_mark;\nexports.nfc = nfc;\nexports.nfd = nfd;\nexports.safe_str_from_cps = safe_str_from_cps;\nexports.should_escape = should_escape;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVTtBQUNWO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRSxZQUFZLEdBQUcsOEJBQThCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsZUFBZTtBQUNmO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUIsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMLElBQUk7QUFDSixXQUFXO0FBQ1g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxnQkFBZ0I7QUFDaEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELFlBQVksTUFBTTtBQUNsQiwyREFBMkQ7QUFDM0Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esd0JBQXdCO0FBQ3hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCO0FBQ0EscUNBQXFDLGtDQUFrQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBRSxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDhCQUE4QixLQUFLO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTSxJQUFJLE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFdBQVcscUJBQXFCO0FBQ2hDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxnREFBZ0Q7QUFDaEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwREFBMEQ7QUFDMUQseUJBQXlCO0FBQ3pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCLE9BQU87QUFDN0M7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx5REFBeUQsMkJBQTJCLElBQUksNEJBQTRCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLEdBQUcsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxzQ0FBc0MsSUFBSSxJQUFJO0FBQzVHO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxjQUFjLE1BQU0sRUFBRSxPQUFPO0FBQzdCO0FBQ0Esc0NBQXNDLEtBQUssSUFBSSxPQUFPO0FBQ3REO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLEtBQUssSUFBSTtBQUM5RjtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixZQUFZO0FBQ1o7QUFDQSx5Q0FBeUMsT0FBTyxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLLEVBQUUsaURBQWlELEdBQUcsSUFBSSxHQUFHLEVBQUU7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0M7QUFDdkQ7QUFDQSxxQkFBcUIsT0FBTyxPQUFPO0FBQ25DO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0RBQXNELEdBQUcsSUFBSSxHQUFHLFFBQVE7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxnQ0FBZ0M7QUFDdkc7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUSxLQUFLLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUssYUFBYSxPQUFPO0FBQzFELDhDQUE4QyxRQUFRLFlBQVksSUFBSTtBQUN0RSx3QkFBd0IsS0FBSyxrQkFBa0IsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPLE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsdUNBQXVDLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1YsV0FBVztBQUNYO0FBQ0EsdURBQXVEO0FBQ3ZELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZTtBQUNmLElBQUk7QUFDSjtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQyxLQUFLO0FBQ0wsaUJBQWlCLDBCQUEwQjtBQUMzQyxLQUFLO0FBQ0wsaUJBQWlCLHFCQUFxQjtBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0M7QUFDeEQsTUFBTTtBQUNOLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHlCQUF5QixxQkFBcUIsU0FBUztBQUN2RCxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQ0FBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLG1CQUFtQjtBQUNuQjtBQUNBLGlCQUFpQjtBQUNqQixNQUFNO0FBQ04sZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSyxzQ0FBc0M7QUFDM0MsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUE0RDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQiw4QkFBOEI7QUFDOUIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsV0FBVztBQUNYLFdBQVc7QUFDWCx5QkFBeUI7QUFDekIscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4LmNqcz8xNTQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gY3JlYXRlZCAyMDIzLTA5LTI1VDAxOjAxOjU1LjE0OFpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1lbnMgZGF0YVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XG4vLyBTSEEtMjU2OiAwNTY1ZWQwNDliOWNmMTYxNGJiOWUxMWJhN2Q4YWM2YTZmYjk2Yzg5MzI1M2Q4OTBmN2UyYjI4ODRiOWRlZDMyXG52YXIgQ09NUFJFU1NFRCQxID0gJ0FFRVVkd21nRFM4QnhRS0tBUDRCT2dEakFUQUFuZ0RVQUlNQW9BQm9BT0FBYWdDT0FFUUFoQUJNQUhJQU93QTlBQ3NBTmdBbUFHSUFIZ0F1QUNnQUp3QVhBQzBBR2dBakFCOEFMd0FVQUNrQUVnQWVBQWtBR3dBUkFCa0FGZ0E1QUNnQUxRQXJBRGNBRlFBcEFCQUFIZ0FpQUJBQUdnQWVBQk1BR0FVaEJlOEJGeFJFTjhzRjJ3QzVBSzVIQVc4QXJRa0R6UUN1aHpjM056Y0JQNjhORWZNQUJRZEhCdXc1QlY4RllBQTlNemtJOXI0WkJnN1F5UUFXQTlDZU93TE5DamNDanFrQ2h1QS9sbStSQXNYVEFvUDZBU2ZuRVFEeXRRRkpBaldWQ2tlWEFPc0E2Z29kQUIvY3dkQVVFMFdsQkNOL0FRVUNRUmpGRC9NUkJqSHhEUVNKYncwakJ6VUFzd0J4bWUrdG5JY0FZd2FiQXlzRzhRQWpBRU1NbXhjRHFnUEtReURYQ01NeEE3a1VRd0QzTlhPckFLbUZJQUFmQkMwRDN4NEJKUURCR2RVRkFoRWdWRDhKbndtUUppTldZVXpyZzBvQUd3QVVBQjBBRm5OY0FDa0FGZ0JQOWgzZ1Bmc0RPV0RLbmVZMkNoZ2xYMVVEWUQzMEFCc0FGQUFkQUJaeklHUkFud0REOHdBakFFRU16UmJEcWdNQjJzQUZZd1hxQXRDbkFzUzRBd3BVSktSdEZIc2FkVXo5QU1NVmJ3THBBQk0xTkpFWDBaa0NnWU1CRXlNQXhSVnZBdWtBRXpVQlVGQXRtVXdTQXk0REJURVIzM0VmdFFIZlN3QjVNeEovQWprV0tRTHpMOEUvY3dCQjZRSDlMUURQRHRPOUFTTnJpUUM1RFFBTkF3Q0syMUVGSTkxekh3Q29MOWtCcVFjSEJ3Y0hLelVEb3dCdkFRb2hQdlUzZkFRZ0h3Q3lBYzhDS1FNQTV6TVNlenI3VUxnRm1EcC9MelZRQmdFR0FpOEZZUVZndDhBRmNUdGxRaHBDV0VtZmU1dG1aNklBRXhzRHpROHQrWDhyQkt0VEFsdGJBbjBqc3k4Qmw2dXRQV01EVFI4RWkya1JBTmtEQnJOSE55c0RCekVDUVdVQWN3RnBKM2tBaXlVaEFKMEJVYjhBTDNFZkFiZk5BejgxS1VzRld3RjNZUVp0QW0wQStWRWZBekVKRFFCUlNRQ3pBUUJsQUhzQU03MEdEL3YzSVpXSEJ3QVJLUUF4QUxzalR3SFpBZU1QRXptWGdJSHdBQklBR1FBOEFFVUFRRHQzZ2R2SUVHY1FaQWtHVFJGTWRFSVZFd0swRDY0TDdSRWRETmtxMDlQZ0FEU3hCL01EV3dmekExc0RXd2Z6Qi9NRFd3ZnpBMXNEV3dOYkExc2NFdkFpMjhnUVp3OVFCSFVGbGdXVEJONElpeVpSRVlrSE1BamFWQlYwSmh4UEEwMEJCQ010U1NRN216TVRKVXBNRkUwTENBUTJTbXl2ZlVBRFR6R3pWUDJRcWdQVE1sYzVkQWtHSG5rU3FBQXlEM3NrTmIxT2hucFBjYWdLVTArMnRZZEphazV2QXNZNnNFQUFDaWtKbTIvRGQxWUdSUkFmSjZrUSt3dzNBYmtCUHczeFM5d0U5UVkvQk0wZmdSa2REOUdWb0FpcExlRU04U2JuTHFXQVhpUDVLb2NGOFV2NFBPRUxVVkZzRDEwTGFRbm5PbWVCVWdNbEFSRWlqd3JoRFQwSWNSRDNDczF2RGVrUlNRYzlBOWxKbmdDcEJ3VUxGUjA1RmJrbUZHS3dDdzA1ZXdiL0d2b0xreWF6RXkxN0FBWFhHaVVHVVFFdEd3TUEweTdyaGJSYU5Wd2dUMk1HQndzcEk4c1VyRkFrRFNsQXUzaE1HaDhIR1NXdEFwVkRkRXFMVVRvZWx5SDZQRUVOYWk0WFVZQUgrVHdKR1ZNTGhUeWlScTlGRWhIV1BwRTlUQ0pOVERBRU9ZTXNNeWVQQ2RNUGlReTlmSFlCWFFrbENiVU1kUk0xRVJzM3lRZzlCeDB4bHlnbkdRZ2xScGxnbmdUN293UDNFOVVERHdWRENVVUhGd081SERFVE1oVXRCUkdCS05zQzl6YlpMcmNDazFhRUFSc0Z6dzhwSCtNUVZFZmtEdTBJbndKcEE0Y2w3d0F4RlNVQUd5S2ZDRWRuQUdPUDNGTUpMczhJeTJwd0kzZ0RheFRyWlJGM0I1VU9Xd2VySERjVnd4emxjTXhlRDRZTUtLZXpDVjhCZVFtZEFXTUU1d2dOTlYrTXBDQkZaMWVMWEJpZklHVkJRMTRBQWpVTWFSV2pSTUdIZkFLUEQyOFNId0U1QVhjSFBRMEZBbnNSOFJGdkVKa0k3NFlJTmJrei9Eb3BCRk1oaHlBVkNpc0RVMnpTQ3lzbS9RejhiUUduRW1ZREVEUkJkL0pucjJDNktCZ0JCeDB5eVVGa0lmVUxsay9SREtBYXhSaEdWRElaNkFmREEvY2E5eWZ1UVZzR0F3T25CeGM2VVRQeUJNRUxiUWlQQ1VNQVRRNm5Hd2ZiR0c0S2RZelVBVFdQQWJ1ZEExdVZod0p6a3dZN0J3OEFhdytMQlgzcEFDRUNxd2luQUFrQTB3TmJBRDBDc1FlaEFCMEFpVVVCUVFNck13RWw2UUtUQTVjSU5jOEJtVE1COXkwRUg4Y01HUUQ3TzI1T0FzTzFBb0J1WnFZRjRWd0NrZ0pOT1FGUktRUUpVa3RWQTdOMTVRRGZBRThHRitOTEFSbXZUczhlNTBjQjQzTXZBTXNBL3dBSk9RY0pSUUhSQWZkeEFMc0JZd3MxQ2FhM3VRRlI3UzBBaHdBWmJ3SGJBbzBBNFFBNUFJUDFBVmNBVVFWZC9RWFhBbE5OQVJVMUhDOWJaUUcvQXlNQk53RVJBSDBHejVHcHpRc2pCSEVIMXdJUUh4WGxBdTh5QjdrRkF5TGpFOUZDeVFLOTRsa0FNaG9LUEFxckNxcGdYMlEzQ2pWMlBWUUFFaCtzUHNzL1VnVlZPMWM3WER0WE8xdzdWenRjTzFjN1hEdFhPMXdEbThQbXcrWUtjRjlKWWU4TXFnM1lSTXc2VFJQZllGVmdOaFBNTGJzVXhSWFNKVm9aUVJyQUp3a2w2RlVORHdndDEyWTBDREEwZVJmQUFFTXBiSU5GWTRvZU5BcFBIT3RUbFZUOExSOEF0VXVtTTdNTnNCc1pSRVFGUzNYeFlpNFdFZ29tQW1TRkFtSkdYMUd6QVY4M0pBS2grd0pvbkFKbURRS2ZpRGdmRHdKbVB3Sm1LZ1J5QklNRGZ4Y0RmcFk1Q2psN0d6bUdPaWNuQW13aEFqSTZPQTRDYmNzQ2JiTHpqZ00zYTBrdkFXc0E0Z0RsQUU0SkI1d01rUUVDRDhZQUVia0Nkek1DZHFaREFubFBSd0o0dmlGZzMwV3lSdmNDZkVNQ2Vzd0NmUTBDZlBSSUJFaUJaeWdBTHhsSlhFcGZHUnRLMEFMUkJRTFEwRXNyQTRoVEE0ZnFSTW1STmdMeXBWMEhBd095UzlKTU1Ta0gwMDFRVGJNQ2kwTUNpdHpGSHdzaFIyc0p1d0tPT3dLT1lFU2JoUUtPM1FLT1lIeFJ1Rk01QVE1UzJGU0pBcFAvQXBNUUFPMEFJRlVpVmJOVjFBb3NIeW1aaWpMbGVHcEZQejBDbDZNQzc3WllKYXdBWFNrQ2xwTUNsb0NnQUsxWnNGb05oVkVBUHdLV3VRS1dVbHhJWE5VQ21jOENtV2hjemwwTEhRS2Nuem5HT3FFQ25Cb0NuNThDbnJ5T0FDRVROUzRUQXAzMUFwNldBTGxCWVRoaDh3S2Uxd0tnY2dHdEFwNmpJd0tlVXFsanpHUXJLUzhDSjdNQ0pvSUNvUDhDb0ZEYkFxWXpBcVhTQXFnREFJRUNwL1pvZ0dpMUFBZE5haUJxMVFLczV3S3NzZ0t0YXdLdEJnSlhJUUpWNEFLeDVkc0RIMUpzbXdLeXdSRUNzdXdiYk9SdFoyMU1Zd01sMFFLMllEOURicFFES1VrQ3VHSUN1VXNaQXJrdWUzQTZjT1VDdlIwRExiWURNaFVDdm94eUJnTXpkUUsrSG5NbWMxTUN3ODhDd3doemhuUlBPVWwwNUFNOHF3RURQSjREUGNNQ3hZQUN4a3NDeGhTTkFzaHRWUUxJU0FMSlV3TEpNZ0prb1FMZDFuaDlaWGl5ZVNsTDFBTVlwMmNHQW1INEdmZVZLSHNQWHBaZXZ4VUN6MjhDejNBelQxZlc5eGVqQU1xeEFzOTNBUzN1QTA0V2ZrOEpBdHdyQXR1T0F0SlRBMUpnQTFOakFRVURWWkNBalVNRXp4cnhaRWw1QTRMU2c1RUMyc3NDMmVLRUZJUk5wMEFEaHFrQU13TmtFb1oxWGYwQVdRTGZhUUxldkhkN0F1SXo3UmdCOHpRckFmU2ZBZkxXaXdMcjl3THBkSDBEQXVyOUF1cm9BUDFMQWIwQzdvMEM2NkNXcnBjSEF1NURBNFhrbUgxdzVIR2xBdk1IQUcwRGpocVpsd0wzRndPUmNnT1Npd0wzbkFMNTNRTDRhcG9nbXErL081c2lBNTJIQXY3K0FSOEFQWjhnQVorM0F3V1JBNlp1QTZiZEFOWEpBd1p1b1l5aUNRMERERTBCRXdFakIzRUdaYjFyQ1FDL0JHL0RGWThldHhFQUczazlBQ2NETnhKUkE0MkRBV2NySlFDTTh3QWxBT2FuQzZPVkNMc0dJNmZKQmdDdkJSbkRCdkVsUlVZRkZvQUZjRDlHU0ROQ0tVSzhYM2taWDhRQWxzMEZPZ0NRVkNHYndUc3VZRG9adXRjT054ak9HSkhKL2dWZkJXQUZYd1ZnQldzRllBVmZCV0FGWHdWZ0JWOEZZQVZmQldCT0hRamZqVzhLQ2dvS2JGN3hNd1RSQTdrR044UERBTU1FcjhNQTcwZ3hGcm9GVGo1eFBuaENSMEsrWDMwL1gvQUFXQmt6c3dDTkJzeHp6QVNtNzBhQ1JTNHJERE1lTHo0OWZuWGZjc0g1R2Nvc2NRRnoxM1k0SHdWbkJYTEp5Y25BQ05kUll3Z0lDQXFFWG9XVHhnQTdQNGtBQ3hiWkJ1MjFLdzBBak1zVEF3a1ZBT1Z0SlVVc0oxSkN1VUxFU1VBclh5OWdQaTlBS3duSlJRWUtURDlMUG9BK2lUNTRQbmtDa1VMRVVVcERYOU5XVjNKVkVqUUFjMXczQTNJQkUzWW5YK2c3UWlNSmI2TUthaXN6UkNVdVFyTkN4RFBNQ2N3RVg5RVdKellSRUJFRUJ3SUhLbjZsMzNKQ05WSWZ5YlBKdEFsdHlkUFVDbWhCWncvdEVLc1pBSk9WSlUxQ0xSdXhiVUhPUUFvN1AwcytlRUpISEE4U0pWUlBkR00wTlZycHZCb0toZlVsTTBKSEhHVVFVaEVXTzF4TFNqOE1PMHVjTkFxSkl6VkNSeHY5RUZzcUt5QTRPUWdOajJud1pncDVaTkZnRTJBMUszWUhTMkFoUVFvakptQzdEZ3B6R0cxV1lGVVpDUVlIWk85Z0hXQ2RZSVZndTJCVFlKbHdGaDhHdlJiY1hiRzhZZ3RESHJNQnd6UFZ5UW9uSFFna0N5WUJnUUowQWpjNG5WcUlBd0dTQ3NCUElnRHNLM1NXRXRJVkJhNU44Z0dqQW8ra1Z3Vklad0QvQUVVU0NEd2VYNElUclJRc0o4SzNUd0JYRkR3RUFCMFR2elZjQXRvVFMyMFJJd0RnVmdaOUJCSW1ZZ0E1QUw0Q29pOExGbmV6T2tDbklRRmpBWTRLQkFQaDlSY0dzZ1pTQnNFQUpjdGRzV0lSdTJrVGtRc3RSdzdEQWNNQktncFBCR0lHTURBd0tDWW5LVFFhTGc0QUtSU1ZBRndDZGwrWVVaMEpkaWNGRDNsUEFkdDFGOVpaS0NHeHVFM3lCeGtGVkdjQS93QkZFZ2lDQndBT0xIUVNqeE90UURnMXo3ZGVGUk1BWjhRVEFHdEtiMUFwSWlQSEFEa0F2Z0tpTHkxREZ0WUNtQmlEQWxERFdOQjBlbzdmcGFNTy9hRVZSUnYwQVRFUVpCSU9EeU1FQWM4SlFoQ2JEUmd6RkQ0VEFFTUF1OVlCQ2dDc0FPa0FtNUkzQUJ3QVl4dk9OblIrTWhYSkF4Z0tReXhMMitra0poTWJoUUtEQk1rU3N2RjBBRDlCTlE2dVFDN1dxU1FId3hFQUVFSXUxaGtoQUgyejRpUVB3eUpQSE5XcGR5WUJSU3BuSkFMem9CQUVWUFBzSDIwTXhBMENDRVFLUmdBRnlBdEZBbE1Od3dqRURVUUpSQXJFTHRhcE1nN0REWmdKSXcrVEd1a0VJd3ZERmtNQXFBdERFTU1NQmhpb2UrUUFPM01NUkFBQ3JnbkVCU1BZOVEwRkRuYlNCb01BQjhNU1l4a1N4QUVKQVBJSkFBQjhGV01PRnRNYy9IY1h3eGhEQUM3REF2T293d0Fld3dKZEtES0hBQUhEQUFMckZVUVZ3d0Fid3l2enBXTVd2OHdBL0FCcEF5KytiY1lEVUtQRDBLaERDd0ttSjFNQUFtTUE1K1Vad3hBYWd3aXBCUkwvZUFEZnc2ZkRHT01DR3NPamszbDZCd09wbzRzQUVzTU9HeE1BQTVzQWJjTU9BQXZEcDBNSkdrTUR3Z2lwbk5JUEF3ZklxVU1HQU9HREFBUHpBQlhEQUFjREFBbkRBR21UQUJyREFBN0RDaGpEam5FV0F3QUJZd0FPY3dBdVV5WUFCc01BRjhNSUtRQU5VZ0M2d3k0QUE4TUFEcU1xOHdDeVlnQWNJd0FCOHdxcEFBWE9DeDBWNHdBSG93QkN3d0VLQUduREFBdURBQjNEQUFqRENha0FCZElBYnFjWjNRQ1pDQ2tBQmRJQUFBRkRBQWZqQUIyakNDa0FCcUlBQ1lNQUd6TUFiU01BNXNPSUFBaGpBQWhEQUJUREJBa3BBQWJTQU9PVEFBbERDNmtPelB0bkFBZERBRzZrUUZBQVR3QUt3d3dBQTBNQUNiVURQd0FISXdBWmd3QUNFNmNEQUFvakFBcERBQW9EcC9NR3d3QUpJd0FERXdBUVF3Z0FGRU1BRVhNQUQ1TUFEZk1BRGNNQUdSTU9GaU1BRlVNQWJxTVd1d0hEQU1JQUUwTUxBR2t6RWdEaFV3QUNRd0FFV2dBWGd3VWpBQWJZQUJqREJTWUJnekJhQUVGTkFMY1FCeFVNZWdBd01uZ0JyQTBJWmdKMEt4UUhCUkVQZDFOMFp6S1JKd2FJSEFacU5UNERxUXE4QnduZ0FCNERBd3QyQVg1NlQxb2NLUU5YQWgxR0FUUUdDM3RPeFlOYWdrZ0FNUUE1Q1FBREFRRUFXeExqQUlPWU5BRXpBSDd0RlJrNlRnbFNBRjhOQUFsWUFRK1MxQUNBUXdRb3JRQmlBTjRkQUoxd1B5ZVRBTlZ6dVFEWDNBSWVFTXA5ZXlNZ1hpVUFFZGtCa0ppektsdGJWVkFhUk1xUkFBRUFoeVEvU0RFejZCbWZWd0I2QVRFc09DbEtJUmNET0YwRS84MzJBRk50NUFCeUFua0NSeEdDT3M5NE5qWGRBd0lOR0JvbkRCd1BBTFcyQXdJQ0FnQUFBQUFBQUFZREJRTURBUnJVQXdBdEFBQUFBZ0VHQmdZR0JnWUZCUVVGQlFVRUJRWUhDQWtFQlFVRkJRUUFBQUlDQUFBQUlnQ05BSkFBbFQwQTZnQzdBTndBcEVRQXdnQ3lBSzBBcUFEdUFLWUEyZ0NqQU9jQkNBRURBTWNBZ1FCaUFOSUExQUVEQU40QThnQ1FBS2tCTVFEcUFOOEEzQXNCQ1E4eU85cmEydHE4eHVMVDF0UkpPQjBCVWdGY05VMEJXZ0ZwQVdnQld3Rk1VVWxMYmhNQlV4c05FQXM2UGhNT0FDY1VLeTB2TWo1QVFFTkRRMFJGRkVZR0pGZFhWMWRaV1ZoWkwxcGJYVnhjSTJObloyWm9aeXBzYm5aMWVIaDRlSGg0ZW5wNmVucDZlbnA2ZW5wOGZIMThlMklBUlBJQVNRQ2FBSGdBTWdCbStBQ09BRmNBVndBM0FuYnZBSXNBQmZqNEFHUUFrL0lBbndCUEFHSUFaUC8vc0FDRkFJVUFhUUJXQUxFQUpBQzJBSU1DUUFKREFQd0E1d0QrQVA0QTZBRC9BT2tBNlFEb0FPWUFMd0o3QVZFQlFBRStBVlFCUGdFK0FUNEJPUUU0QVRnQk9BRWNBVmdYQURFUUNBRUFVeDhTSGdzZEhoWUFqZ0NXQUtZQVVRQnFJQUl4QUhZQWJ3Q1hBeFVESnpJRElVbEdUekVBa1FKUEFNY0NWd0trQU1BQ2xnS1dBcFlDbGdLV0FwWUNpd0tXQXBZQ2xnS1dBcFlDbGdLVkFwVUNtQUtnQXBjQ2xnS1dBcFFDbEFLVUFwUUNrZ0tWQW5VQjFBS1hBcDhDbGdLV0FwVWVBSUVUQlFEK0RRT2ZBbUVDT2g4QlZCZzlBdUlaRWpNYkFVNC9HMVdaQVh1c1JBRnBZUUVGQTBGUEFRWUFtVEVlSUpkeUFERm9BSEVBTmdDUkE1ek1rL0MyakdJTndqTVd5Z0laQ2FYZGZESUxCQ3M1ZEFFN1luUUJ1Z0RsaG9pSGhvaUdpWXFLaG91T2pJYU5rSTZJajRxUWlwR0drb2FUaHBTU2xZYVdocGVLbUlhWmhwcUdtNGFjaTUyUW5vcWZodUlDNFhUcEF0OTBBSXAwTEhTb0FJc0FkSFFFUXdSQUJFSUVSUVJEQkVrRVJnUkJCRWNFU1FSSUJFUUVSZ1JKQUo1dWRBQ3JBNDkwQUx4dUFRMTBBTkZaZEhRQTEzUUNGSFFBL21KMEFQNEJJUUQrQVB3QS9BRDlBUHdEaEdaMDNBU01LMjNIQVA0QS9BRDhBUDBBL0NSMGRBQ1JZblFBL2dDUkFTRUEvZ0NSQXZRQS9nQ1JBNFJtZE53RWpDdHR4eVIwQVA5aWRBRWhBUDRBL2dEOEFQd0EvUUQ4QVA4QS9BRDhBUDBBL0FPRVpuVGNCSXdyYmNja2RIUUFrV0owQVNFQS9nQ1JBUDRBa1FMMEFQNEFrUU9FWm5UY0JJd3JiY2NrZEFKTEFUNTBBbElCUVhRQ1U4bDBkQUpmZEhRRHBnTDBBNllEcGdPbkE2Y0Rwd09uQTRSbWROd0VqQ3R0eHlSMGRBQ1JZblFCSVFPbUFKRURwZ0NSQXZRRHBnQ1JBNFJtZE53RWpDdHR4eVIwQkRoMEFKRUVPUUNSRHBVNWRTZ0NBRFIwM2dWMkN3QXJkQUVGQU01aUNuUjBBRjFpQUFZY09ncDBkQUNSQ25RQVhBRUl3V1owQ25SbWRIUUFrV1owQ25SbWRFWGdBRkYwM2dwMGRFWTB0bFQydTNTT0FRVHdzY3doalpaS3JoWWNCU2ZGcDlYTmJLaVZET0QyYitjcGU0L1oxN21RbmJ0enpoYWVRdEUyR0dqMElETlRqUlVTeVR4eHcvUlBIVy8rdlM3ZDFOZlJ0OXo5UVBaZzRYN1FGZmhDbmt2Z05QSUl0T3NDMmVWNmhQYW5uWk5IbFo5eHJ3WlhJTU9sdTNqU29RU3E3OFdFandMancxRUxTbEYxYUJ2Znp3azVaWDdBVXZRempQUUtiRHVRK3NtNHdOT3A0QTZBZFZ1UlMwdDF5L0RacGc0UjZtN0ZOak05SGd2VzdCaTg4emFNak9vNmxNOHd0QkJkajhMUDR5bHYzekNYUGhlYk1LSmMwNjZvOXNGNzFvRlcvOEpYdTg2SEpid0RJRDVsenc1R1dMUi9MaFQwUXFucDJKUXhOWk5mY2JMSXpQeStZeXBxUm0vbEJtR21leCs4MitQaXN4VXVtU2VKa0FMSVQ2ckplenhNSCtDVEptUXR0NXV3VFZiTDNwdG1qRFVRemxTSXZXaThUbDduZzFOcHVSbjFOZzRuMTRRYyszSWlsN093a3ZOV29nTFNQa24zcGloSUZ5dHlJR21NaE9lM24xdFdzdU15OUJkS3lxRjRaM3YyU2dnZ1RMOUtWdk1YUG5DYlJlK29PdUZGUDNIZWpCRy93OWd2bWZOWXZnNkp1V2lhMmxjU1NOMXVJakJrdHpvSWF6T0hQSlo3a0tIUHo4bVJXVmRXM2xBOFdHRjlkUUY2Qm02NzNib292M0JVV0RVMkpOY2FoUjIzR3RmSEtMT3ovdmlaK3JZblpGYUl6blhPNjdDWUVKMWZYdVRScFpoWVprS2U1NHhlb2Fna05HTHMrTlRaSEUwclg0NS9YdlEyUkdBRFg2dmNBdmR4SVVCVjI3d3hHbTJ6alpvNFgzSUxnQWxyT0ZoZXVaNnd0c3ZhSWo0eUxZN3FxYXdsbGlhSWNyejJHK2MzdnNjQW5Da0N1TXpNbVp2TWZ1OWxMd1R2ZlgrM2NWU3lQZE45WndnRFpoZmpSZ05KY0xpSjY3Yjl4eDhKSHN3cHJiaUUzdjlVcGhvdEFQSWduWFZJTjVLbU1jMHBpWGhjNmNDaFBuTitNUmhHOWFkdGR0dFFUVHdTSXBsOEk0L2ovL2Qzc3oxMzI2cVRCVHBQUk0vSGdoM2t6cUVYczhaQWs0RXJRaE5POGh6clEwRExrV01BL04rOTF0bjJNZE9KbldDMkZDWmVoa1Fyd3p3YktPamh2WnNiTTk1UW9lTDlza1l5TWY0c3JWUFZKU2dnN3BPTFV0ci9uOWVUOTlvZTluTHRGUnBqQTlva1YyS2o4aDlrNUhhQzBvaXZSRDhWeVhrSjgxdGNkNGZITlhQQ2Zsb0lRYXN4c3VPMTgvNDZkUjJqZ3VsL1VJZXQyRzBrUnZueU9OTUtoSHM2SjI2RkVvcVNxZCtyZllqZUVHd0hXVkRwWDFmaDFqQkJjS0dNcVJlcGp1OVkwMG1EVkhDK1hkaWovajQ0cktmdmZqR2luTnMxak8vMEYzakI4M1hDRElOTi9IQjg0YXhsUCszRS9rbGt0Um8rdmwzVS9haXlNSmJJb2RFMVhTc0RuNlVBeklvTXRVT2JZMitrLzRnWS9sK0FrWko1U2oydlFya3lMbTNGb3hqaERYKzMxVVhCRmY5WHJBSDMxZkZxb0JtREVadmh2dnBuWjg3TitvWkV1N1U5Ty9ubmsrUVdqM3g4dXlvUmJFbmYrTzVVTXI5aTBuSFAzOElGNUF2enJCVzhZV0JVUjBtSUF6SXZuZFFxOU4zdi9KdG8zYVBqUFhVUGw4QVNkUFB5QXA3akVOZjhiazdWTU05b2w5WEdtbEJtZURNdUdxdCtXenVMNkNYQXhYakloQ1BNNXZBQ2NoZ01KLzhYQkdMTy9EMWlzVnZHaHd3SEhyMURMYUk1bW4ySnIvYjFwVUQ5MHVjaURhUzhjWE5EekNXdk5tVC9QaFFlNWU4blRubm5rdDhEcy9TSWppYmN1bS9mcURoS29weEFZOEFrU3JQbitJR0RFS09PK1UzWE9QNmRqRnMySDVOOStvcmhPYWhpUWs1S25FVVdhK0N6a1Z6aHA4Yk1IUmJnODFxaGpqWHVJS2JIalNMU0lCS1dxb2NrR3RLaW5ZK3o0L1JkQlVGNnBjYzNKbW5seFZjTmdySTRTRXpLVVpTd2NEMlFDeXh6S3ZlK2dBbWc2WnVTUmtwUEZhNm1mVGh1N0xKTnUzSDVLNDJ1Q3BOdlBBc29lZG9sS1YvTEhlL2VKK0JiYUc1TUcwTmFTR1ZQUlVtTkZNRkZTU3BYRWNYd2JWaDdVRVRPWlp0b1ZOUkdPSWJia2lnM01jRXRSNjhjRzBSWkFvSmV2V1lvN0RnL2xaMUNRemJsV2VVdlZIbXI4Zlk0TnFkOUpKaUgvekVYMjRtSnZpSDYwZkF5RnIwQTNjNGJDMWozeVpVNjBWZ0p4WG44SmdKWExVSXNpQm5tS21NWXorN3lCUUZCdnFiMmVZbnVXNTlqb1pCZjU2L3dYdldJUjRSOHdUbVY4MGkxbVp5K1M0K0JVRVMraHpqazB1WHBDLy8vei9JbHFIWjFtb256bFhwOGFDZmhHS010aTczRkkxS2JMMXE2SUtPNGZ1QnVaNTlnYWdqbjV4VTc5bXVNcEhYZzZTK2UrZ0RNL1U5QktMSGJsOWw2bzhjelFLbDRSVWtKSmlxZnRRRzJpM0JNZy9UUWxVWUZrSkRZQk9PdkF1Z1l1ellTRG5aYkREZC9hU2Q5eDBPZTZGK2JKY0hmbDkrZ3A2TDUvVGdBK0JkRkZvdmJmQ3JRNDBzNXZNUHc4ODY2cE5YOHp5RkdlRldkeElwUFZwOVJnMVVQT1ZGYkZacnZhRnEvWUF6SFFncU1XcGFoTVlmcUhwbXdYZkhMMS9rcFltR3VIRndUNTVtUXUwZHlsZk51cTJPcTBoVE1DUHdxZnhudUJJUExYZmNpNFkxQU55KzFDVWlwUXhsZC9pelZoMTZXeUcyUTBDUVE5TnF0QW54MUhDSHdEajdzWXhPU0Iwd29wWlNuT3p4UU9jRXhteHJWVEYyQmtPdGhWcEdmdWhhR0VDZkNKcEpLcGpuaWhZK3hPVDJRSnhONjErOUs2UVNxdHYyU2hyODJJM2pnSnJxQmcwd0VMRlpQanZIcHZ6VHRhSm5MSzZWYjk3WW45MzNrb08vc2FON2ZzandOS3pwNGwybEpWeDJvcmpDR3pDLzRaTDR6Q3ZlcjZhUVl0QzVzZG95Y2h1RkU2dWZPaW9nK1ZXaTVVRGtibXZtdGFoLzNhQXJFQklpMzlzNUlMVW5sRkxnaWxjR3V6OUNRc2hFWTdmdzJvdW9JTEFZUFZUL2d5QUlxM1RGQUl3VnNsK2t0a1J6L3FHZm5DREdybTVnc2wvbDlRZHZDV0dzalB6M2RVN1h1cUtmZFVyci82WElnanA0cmV5NkFKQm1DbVVKTWpJVEhWZEZiNW0xcCtkTE1DTDh0NTV6RDQyY21mdG1MRUpDMERhMDRZaVJDVlVCTExhOEQwNzEvTjVVQk5CWERoMExGc21oVi81QjVFeE9CNGozV1ZHL1MzbGZLNW8rVjZFTEh2eTZSUjluNGFjK1ZzSzRWRTR5cGhQdlYra0c5RmVnVEJINFpSWEwySHl0VUhDZHVKYXpCL0t5a2pmZXRZeE9YVEx3czI2N2FHT2QrSStKaEtQLy8rVm5YbVM5ME9EL2p2TGNWdTBhc3lxY3VZTjFtU2I2WFRsQ2txdjF2aWdaUElZd05GL3pwV2NUMUdSLzZhRUlSamtoMHloZzRMWEpmYUdvYllKVFk0Skk1OEtpQUtnbW1nQUtXZGw1bllDZUxxYXZSSkdRTnVZdVp0WkZHeCtJa0k0dzROUzJ4d2JldE5NdW5PakJ1L2htS0NJL3c3dGZpaXlVZC8vNHJiVGVXdDRpekJZOFl2R0lONnZ5S1ltUC84WDh3SEtDZU4rV1JjS003MCt0WEtOR3lldlU5SDJEZzVCc2xqblRmOFlic0oxVG1Nczc0Q2UyWGxIaXNsZWd1aHllZzQ0clFPSFp1dy82SFRraG5udXJLMmQ2MnE2eVM3MjEwU3NBSWFSK2pYTVFBK3N2a3JMcHNVWStGMzBVdzg5dU9kR0FSNnZvNEZJTUUwRWZWVmVIVHU2ZUtpY2ZoU3FPZVhKaGJmdGNkMDhzV0VuTlVMMUM5Zm5wclRnZDgzSU11dDhvblZVRjBodnF6WmZIZHVQamJqd0VYSWNvWW15K1A2dGNKWkhtZU92NlZydkVka0hESmVjakh1SGVXQU5lNzlWRzY2MnFUakEvSEN2dW1WdjNxTCtMck9jcHFHcHMyWkd3UWRGSjdQVTRpdXlSbEJyd2ZPK3huUHlyNDdzMmNYVmJXekF5em5EaUJHakNNM2tzeGpqcU02MkdFOUM4ZjVVMzhrQjNWanRhYktwL25SZHZNRVNQR0RHOTBiV1JMQXQxUWs1RHlMdWF6UlIxWXpkQzFjK2haWHZBV1Y4eEE3MlM0QThCNjd2alZoYmJhM01Nb3AyOTNGZUVYcGU3ekl0TVdySkcvTE9IOUJ5T1htWW5OSmZqbWZ1WDlLYnJwZ0xPYmE0blorZmw4R2Jkdi9paHYrNndGR0tIQ1lyVndtaEZDMEozVjJibjJ0SUIxd0NjMUNTVDNkM1gyT3l4aGd1WGNzNHNtNjc5VW5nem9mdVNlQmV3TUZKYm9JUUhiVWgvbTJKaFcyaEc5REl2RzJ0N3laSXpLQlR6OXdCdG5OQysycENSWWhTSXVRMWo4eHN6NVZ2cW55VUl0aHZ1b3l5dTdmTklyZy9LUVVWbUdRYXFrcVprL1Z4NWIzMy9nc0VzOHlYN1NDMUorTlY0aWN6NmJ2SUU3QzVHNk1jQmFJOHJWZzU2cTVRQkpXeG4vODdRMXNQSzQrc1FhOGZMVTVnWG80cGFhcTRjT2NRNHdSMFZCSFBHaktoK1VsUENiQTFuTFh5RVVYNDVxWjhKNy9MbjRGUEpFMlRkekQwWjhNTFNOUWl5a01NbVN5T0NpRmZ5ODRScTYwZW1ZQjJ2RDA5S2pZd3NvSXBlRGNCRFRFbEJiWHhORDcyeWhkOXBDLzFDTWlkLzVIVU12QUwyN090Y0lKRHpOS3BSUE5xUE9weXQyYVBHejlRV0lzOWhROUxpWDVzOG05aGpUVXUvZjdNeUlhdGpqZCt0U2ZRM3VmWnhQcG1KaFRhQnRadEtMVWNmT0NVcUFEdU8rUW9IOEI5djZVK1AwSFYxR0xRbXRvTkZUYjNzNzRpdlpnakVTMHFmSys4UmRHZ0JiY0NNU3k4ZUJ2aDk4K2V0MUtJRnFTZTFLUVB5WFVMQk1Uc0lZbnlzSXdpWkJKWWRJMjB2c2VWK3d1SmtjcUdlbWVoS2phQWI5TDU3eFptM2cyelgwYloyeGsvZlUrYkNvN1RsbmJXN0p1RjFZZFVSby8yR3c3VmNsREcxVzdMT3RhczJMWDR1cGlmWi8yM3J6cHNuWS9BTGZSZ3JjV1A1aFltVjlWeFZPUUExZlp2cDlGMlVOVSs3ZDd4UnlWbTV3aUxwMy8wZGxWN3ZkdzFQTWlacmJEQVl6SVZxRWpSWTJZVTAzc0poUG5sd0lQY1pVRzVsdEw2UzhYQ3hVMWVZUzVjanIzNHZlQm1YQXZ5N3lONFpqQXJJRzBkZkQvNVVwQk5sWDFaUG94Sk93eXFSaTN3UVd0T3pkNG9OS2gwTGtvVG04Y3dxZ0lmS2hxcUdPaHdvNzFJK3pYbk1lbVR2MkIyQVV6QUJXeUZ6dEdnR1VMakREeldZd0pVVkJUaktDbjVLMlFHTUsxQ1FUN1N6emlPam8rQmhBbXFCanp1YzN4WXltMmVlZEdlT0lSSlZ5VHdEdzM3aUNNZTRnNVZibnNiNVpCZHhPQW5NVDdIVTRESHB4V0d1UTdHZWlZMzBDcGJ2enNzNTUrNUttMVlzYkQ1ZWEzTkk5UU5ZSVhvbDVhcGdTdTlkWjhmOHhTNWR0SHBpZG81QmNsRHVMV1k0bGhpazB0YkphMDd5SmhIMEJPeUV1dC9HUmJZVFM2UmZpVFlXR01Da05wZlNIaTdIdmRpVGdsRVZIS1pYYVZoZXpINGtrWGlJdktvcFlBbFB1c2Z0cEU0YTVJWnd2dzF4L2VMdm9ESWgvenBvOUZpUUluc1RiMlNBa0tIVjQyWFlCanBKRGc0Mzc0WGlWYjN3czRxTTBzOWVTUTVIenNNVTRPWkpLdW9wRmpCTStkQVpFbDhSVU14NXVVMk40ODZLcjE0MXRWc0dRZkdqT1JZTUNKQU1zeEVMZU5UNFJtV2pSY3BkVEdCd2N4NlhOOWRyV3FQbUp6Y3JHckg0K0RSYzcrbjF3M2tQWnd1MEJrTnI2aFFycWdvN0pUQjlBNWtkSi9IN1A0Y1dCTXdzbXVpeEF6SkIzeXJRcG5HSXE5MGx4QVhMekRDZG4xTFBpYnNSdDdySE5qZ1FCa2xSZ1BaOHZUYmpYZGdYclRXUXNLNU1kclhYUVZQcDBSaW5xM2ZyelpLSjBxRDZRaGM0MFZ6QXJhVVhsb2IxZ3ZraEszdnBtSGdJNkZSbFFaTng2ZVJxa3Awenk0QVFsWDgxM2ZBUHRMM2pNUmFpdEdGRmpvMHptRXJsb0MraCtZWWRWUTZrNEYvZXB4QW9GMEJtcUVvS05UdDZqNHZRWk5RMkJvcUY5Vmo1M1RPSW9ObURpdTlYcDE1UmtJZ1FJR2NvTHBmb0liZW56cEdVQXRxRkpwNVcrTExueDM4akhlRUNUSi9uYXZLWTFOV2ZOMHNZMVQ4L3BCOGtJSDNEVTNEWCt1NlczWXdweXBCTVlPaGJTeEdqcTg0Ulo4NGZXSm93OHB5SHFuNFMvOUoxNUVjQ01zWHFyZnd5ZDltaGl1MytyRW85cFBwb0prZFpxSGpyYTROdnpGd3VUaE5LeTZoYW8vU2xMdzNaQURVY1VwM3czU1JWZlcycmhsODB6T2dUWW5LRTBIczJxcDFKNkgzeHFQcUlrdlVEUk1GRFl5UmJzRkkzTTlNRXlvdlBrOHJsdzcvMGE4MWNEVkxtQnNSMnplMnBCdUtiMjNmYmVaQzB1WG9JdkRwcGZUd0lEeGsxT3EyZEdlc0djK29KWFdKTEdrT2hhM0NYK0RVbnpnQXA5SEdIOVJzUFpONjNIbjRSTUE1ZVNWaFBITys5UmNSYi9JT2d0VzMxVjFRNUlQR3RveFBqQytNRUpiVmxJTVlBRGQ5YUhZV1VJUUtvcHVQT0htb3FTa3VibkFLbnpnS0hxZ0lPZlc1UmRBZ290TjZCTitPMlpZSGt1ZW1MbnZROFU5VEhWclMxUnRMbUtiY0M3UGVlRHNZem52cXplZzZWQ053bXIwWXl4MXduTGp5VDg0Qlp6M0VKeUNwdEQzeWV1ZUF5RFdJczBMMnFzL1ZRM0hVeXFmcmphMFYxTGREenFBaWtlV3VWNHNjN1JMSUI2OWpFSUJqQ2t5WmVkb1VIcUNyT3ZTaFZ6eWQ3M09kckpXMGhQT3VRdjJxT29IRGM5eFZiNll1NnVxM1hxcDJaYUg0NkE3bHpldmJ4UUVtZnJ6dkFZU0p1WjRXRGsxSHozUVgxTFZkaVVLMEV2bEFHQVlsRzNNZDMwcjdkY1BONjN5cUJDSWoyNXBycHZaUDBuSTQrRWdXb0ZHOTVWNTk2Q3VyWHBLUkJHUmpRbEhDdnk1SWIvaVc4blpKV3dyRVQzbWdkNm1FaGZQNEtDdWFMam9wV3M3aCtNZFhGZEl2OGRIUUpnZzF4aTFlWXFCMHVEWWp4d1ZtcmkwU3Y1WEt1dC9vbnFhcEMrRlFpQzJDMWx2WUo5TVZjbzZ5RFlzUzNBQU5VZk10dnRiWUkyaGZ3WmF0aVNzbm9VZU1aZDM0R1Zqa01NS0ErWG5qSnBYZ1JXMlNIVFpwbFZvd1BtSnN2WHk2dzNjZk8xQUsyZHZ0WkVLVGtDL1RZOUxGaUtIQ0cwRG5yTVFkR20ybHpsQkhNOWlFWXluSDJVY1ZNaFVFanNjMG9EQlRnbzJaU1ExZ3prQUhlV2VCWFlGallMdXVmOHl6VEN5Ny9SRlI4MVdEalhNYnEyQk9INWRVUm54bzZvaXZteEwzY0t6S0lubFprRDMxbnZwSEI5S2s3R2ZjZkUxdCsxVjY0YjlMdGdlSkdscFJGeFFDQXFXSjVEb1k3N3NraThnc09FT3IydXl3WmFvTy9OR2EwWDB5MXBOUUhCaTNiMlNVR05wY1p4RFQ3ckxiQmYxRlNuUThndXhHVzNXKzM2QlcwZ0JqZTRET3o2QmE2U1ZrMHhpS2d0K3EySk9GeXI0U1lmbnUrSWMxUVpZSXV3SEJyZ3pyNlV2T2NTQ3pQVE9vN0Q2SUM0SVNlUzd6a2w0aCsyVm9lSHBuRy91V1IzK3lzTmdQY09JWFFidjBuNG1yM0J3UWNkS0p4Z1BTZXl1UC96MUpqZzRlOW5Vdm9YZWdxUVZJRTMwRUh4NUdIditGQVZVTlRvd1lESmd5RmhmNUl2bFltRXFSaWY2K1dOMU1rRUptRGNRSVR4OUZYMjNhNG14eTFBUVJzT0hPLytlSW1YOWw4RU1KSTNvUFd6Vlh4U09lSFUxZFVXWXIydUFBN0FNYit2QUVaU2JVM3FvYjlpYkN5WGV5cEVNcFo2ODYzbzZRUHFscUdIWmt1V0FCU1RWTmQ0Y09oOWh2M3FFcFN4Mlp5L0RKTVA2Y0l0RW1pQko1UEZxUW5ERUl0M05yQTNDT2xPU2d6NDNEN2dwTkZOSjVNQmg0b0Z6aERQaWdsQzJ5cHNOVTRJU3l3WTJlcmt5YjFOQzNRaC9JZldqMGVEZ1pJNC9sbjhXUGZCc1QzbWVUanExVXF0MUU3WmwvcWZ0cWt4NmFNOUt1ZU1DZWtTbk1yY0hqMUNxVFdXekV6UHNaR2NEZTNVZTRXcytYRllWeE5iT0ZGOGV6a3ZRR1I2Wk90T0xVMmxRRW5NQlN0eDQ3dkU2UGI3QVlNQlJqMk9PZlpYZmlzakpucFRmU05qbzZzWjZxU3ZOeFpObURlUzdHazN5WXlDazFIdEtOMlVuaE1Jak9YVXpBcUR2OTBseDlPL3EvQVQxWk1uaXQ1WFFlOXdtUXhuRS9XU0gwQ3FaOS8ySHkrU2ZtcGVnOFJ3c0hJNVo4a0M4SDI5M20vTEhWVk0vQkE3SGFUSllnNUVuazdNL3hXcHEwMTkyQUNmQmFpMkxBL3FyQ2pDcjZEaDFCSU16TVhJTkJtWDk2TUo1SG4ybnhsbi9SWFBGaHdIeFVtU1YwRVYyVjBqbTg2L2R4eHVZU1UxVzdzVmtFYk45RXprRzBRRndQaHlIS3liM3QrRmo1V29VVVRFcmNhekUvTjZFVzZMdnAwZC8vU0RQajdFVjlVZEpOK0FtbmYzV3drM0EwU2xKOVowMHl2WFo3bjN6NzBHNDdIZnNvdzhXcTFKWGNmd25BK1l4YTVtRnNnVjQ2NEtLUDRUMzF3cUlnekZQZDNlQ2UzajVvcnk1ZkJGMmhnQ0Z5VkZyTHpJOWVldE5Ydk03b1FxeUZnRG80Q1RwL2hEVjlOTVg5SkRIUS9ueUhUTHZaTE5MRjZmdG4yT3hqR204K1BxT3doeG5QSFdpcGtFLzh3YnR5cmk4MFNyN3BNTmtRR01mbzRaWUs5T2NDQzRFU1ZGRmJMTUl2bHhTb1JxV2llMHd4cW5MZmNMU1hNU3BNTVFFSllEVk9iWXNYSVFOdjRUR053anExa3ZUMVVPa2ljVHJHM0lhQlozWGRTY1MzdThzZ2VaUFZwT0xrYmlGOTQwRmpiQ2VOUklOTnZEYmQwMUVQQnJUQ1BwbTEybTQzemUxYkJCNTlJYTZPdmhudXIvTnZ4M0l4d1NXb2wrM0gycWZDSlI4ZGY2YVFmNHY2V2lPTnhrSytJcVQ0cEtRclpLL0xwbGdESS9QSlpiT2VwOGR0YlY3b0NyNkNnZnBXYThOY3pPa1B4ODFpU0hic05oVlNKQk90ckxJTXJMMzFMSzlUcUhxQWJBSGUwUkxtbVY4MDZrUkxETE5FaFVFSmZtOXUwc3hwa0w5M1pnZDZydyt0cUJmVE1pNTl4cVhITFhTSHdTYlNCbDBFSzArbG9FQ09QdHJsKy9uc2FGZTE5N2RpNHlVZ29lNGpLb0FKRFhjNkRHRGpyUU9vRkRXWko5SFh3dDh4RHJRUCs3YVJ3V0tXSTFHRjhzOE80S3p4V0JCY3dubDN2bmwxT2V6M29oNkVhMXZqUjcvejdERFRyRnRxVTJXL0tBRXpBdVhETlo3TVk3M01GMjE2ZHpkU2JXbVVwNGxjbTdrZUpmV2FNSGd1dDl4NUM5bWo2NlowbEoreWhzalZ2eWlXcmZrMWx6UE9UZGhHMTVZN2dRbFh0YWN2STdxdi9YTlNzY0R3cWtnd0hUL2dVc0Q1eUI3TGRSUnZKeFFHWUlObjloVHBvZEtGVlNUUHJ0R3Z5UXcrSGxSRlhJa29kRXJBR3U5SXkxWXBmU1BjM2prRmg1Q1gzbFB4djdhcWpFL0pBZlRJcEVqR2IvSDdNTzBlMnZzVmlTVzFxYS9MbWk0L240REVJM2c3bFlyY2Fuc3BEZkVwS2tkVjFPalNMT3kwQkNVcVZvRUNhQjU1dnMwNnJYbDRqcW1Mc1BzRk0vN3ZZSjB2ckJoRENtLzAwQS9IODFsMXVla0ovNkxtbDNIYjkrTktpTHFBVEptRHB5emZZWkZIdW1FakM2NjJMMEJ3a3hpN0U5VTRjUUEwWE1WRHVNWUFJZUxNUGdRYU1WT2Q4Zm10NVNmbEZJZnVCb3N6ZUF3N293NWdYUEUyWS95QmMvN2pFeEFSVWYvQnhJSFFCRjVTbjNpNjF3NHo1eEpkQ3lPMUYxWDMrM2F4K0pTdk1lWjdTNlFTS3AxRnAvc2pZejZaK1ZnQ1p6aWJHZUVvdWpyeWZNdWxIN1JhaTVrQWZ0OWViY1c1MER5SnIydW8yejk3bVRXSXU0NVlzU25OU01yck5VdUcxWHNZQnREOVREWXpRZmZLQjg3dldia000RWJQQUZnb0JWNEdRUyt2dEZEVXFPRkFvaTFuVHRtSU92ZzM4TjRoVDJTbjhyOGNsbUJDWHNwQmxNQllUbnJxRkpHQlQzd1pPekF5SkRyZTlkSEg3K3g3cWFhS0RPQjRVUUFMRDVlY1MwREU0b2J1YlFFaXVKWjBFcEJWcEx1WWNjZThBYTRQWWQvVjRETERBSkJZS1FQQ1dUY3JFYVo1SFliSmkxMUdkNmhqR29tMWlpMThWSFluRzI4Tktwa3oyVUtWUHhsaFlTcDh1WnIzNjdpT21veTd6c3hlaFc5d3pjeTJ6RzBhODBQQk1DUlFNYjMyaG5hSGVPUjhmbk5EelpoYU5ZaGtPZERzQlVaM2xvRE1hMVlQMHVTMGNqVVAzYi82REJscW1aT2VOQUJEc0xsNUJJNVFKdXBzOHV4QXVXSmRrVUIvcE82WmF4NnRzZzdmTjVtampEZ01HbmdPK0RQY0txaUhJRGJGSUd1ZHh0UFRJeURpOVNGTUtCRGNmZEdRUnY0MXExQXFteGdrVmZKTW5QOHcvQmM3TjkvVFI2QzdtR09iRnFGa0lFb204c0tpMnhZcUpMVENISzdjeHphWnZxT0RvMjJjM3dpc0JDUDRIZUFnY1JiTlBBc0JrTlJoU21ENDhkSHVwZEJSdzRtSXZ0UzVvZUY2emVUMUtNQ3loTW5taHBrRkFHV25Hc2NvTmt3dlE4Wk01bEUvdmdUSEZZTDk5T3VOeGRGQnhURURkNXYycUxSOHk5V2tYc1dnRzZrWk5uZEZHK3BPL1VBa09DaXBxSWhMM2hxN2NSU2RyQ3E3WWhVc1RvY0VjbmFGYTZuVmtoblNlUllVQTFZTzB6NWl0RjlTbHkzVmx4WUR3MjM5VEpKSDZmM0VVZllPNWxiN2JjRmN6OEJwN09vOFFtbnNVSE96L2ZhZ1ZVQnRLRXcxaVQ4OGorYUtrdjhjc2NLTmtNeGpZcjgzNDREMWtGb1o3L3RkMVc2TENOWU41OTQzMDF0VUdSbUZqQXplUmc1dnlvTTFGNitiSlovUTU0ak4vazhTRmQzRHhQVFlhQVVzaXZzQmZnVG43TXg4SDJTcFB0NEdPZFlSbkVKT0g2akhNMnA2U2dCMGd6SVJxNmZIeEdNbVNtcWFQQ21sZnd4aXVsb2FWSWl0TEdOOHdpZTJDRFdoa3pMb0NKY09EaDdLSU9BcWJIRXZYZFV4YVM0VFRUczA3Q2x6ai82R21WczlraVpEZXJNeEVuaFVCNlFRUGxjZnFrRzk4ODJScUhvTGlIR0JvSGZRdVhJc0FHOEdUQXRhbzJLVndSbnZ2YW04am8xZTMxMkdRQUtXRWE0c1VWRUFNRzRHNmNrY09ORHdSY2cxZTJEMytvaFhnWTRVQVdGOHdIS1FNclNuekNnZkZwc3hoK2FIWE1HdFBRcm9RYXNSWTRVNlVkRzByejFWamJrYTBNZWtPR1JaUUV2cVFGbHhzZUZvcjh6V0ZnSGVrM3YyOStXcU42Z2FLNWdaT1RPTVp6cFFJQzEyMDFMa01DWGlsZDN2V1hTYzVVWDl4Y0ZZZmJSUHpHRmExRkRjUGZQQi9qVUVxL0ZlR3Q0MTlDSTNZbUJsVm9Ic2E0S2Rjd1FQNVpTd0hIaEZKNy9QaC9SYXAvNHZtRzkxZUR3UFAwbERmQ0RSQ0xzelRxZnpNNzF4cG1pS2kySHdTNFdscXZHTnd0dndGNURxcG42S1RxOGF4MDBVTVBreERjWnJFRUVzSXZIaVVYWEVwaGRiNEdCNEZ5bWxQd0J6NEdwZXJxcTVwVzdUUTYveU5SaFc4VlQ1Tmh1UDB1ZGx4bzRnSUxxNVp4QVprOFpHaDNnNENxeEpsUEtZN0FReHVwZlVjVnBXVDVWSXRwMSszMFVxb3lQNHdXc1JvM29sUlJna1daWjJaTjZWQzNPWkZlWEI4TmJuVXJTZGlrTnB0RDFRaUd1S2tyOEVtU1IvQUs5UncrRkYzczV1d3VQYnZIR2lQZUZPVmlsdE1LN0FVYU9zcTkreDljbmRrM2lKRUU1TEtaUmxXSmJLT1p3ZVJPem1QTlZQa2pFM0svVHlBNTdSczY4VGtaM01SOGFrS3BtN2NGam5qUGQvRGRrV2pnWW9LSFNyNVd1NXNzb0JZVTRhY1JzNWcyREh4VW1kcThWWE9YUmJ1bkQ4UU4wTGhna3NzZ2FoY2RvWXNOdnVYR1VLL0tYRC83b0ZiK1ZHZGhxSW4wMnZldU01Ykx1ZEpPYzJLeTBHTWFHNFcveFdCeElKY0w3eWxpSk9YT3B4MEFrQnFVZ3psRGN6bUxUNGlJTFhEeHh0UlIxb1phMkpXRmdpQWI0M29ickpuRy9UWkMyS1NLMndxT3pSWlRYYXZaWkZNYjFmM2JYdlZhTmFLODI4dzlUTzYxMGdrOEpOZjNnTWZFVHpYWHNiY3ZSR0NHOUpXUVo2K2NEUHFjNDQ2NllvMlJjS0grUElMZUtPcXRubGJJblIzTW1CZUdHM0ZIMTB5emt5YnVxRUMySFNRd3BBMEFuN2Q5KzczQmtEVVRtMzBiWm1vUC9SR2JnRk4rR3JDT2ZBRGdxcjBXYkkxYTFva3BGbXM4aUhZdzlobTB6VXZsRU1pdkJSeE1vZHJiSkorOS9wM2pVZFFROUJDdFFkeG5PR3JUNWR6UlVtdzA1OTMvbWJSU2RCZzBuUnZSWk01L0UxNm03WkhtREV0V2h3dmZkWkNaOEo4TTEyVzB5Uk1zelhhbVdmUVR3SVo0YXlZa3RybnNjUXVXcjhpZHAzUGpUMmVGL2ptdGRoSWZjcE1uYitJZlpZMkZlYlc2VVkvQUszalA0dTNUdTR6RTRxbG5RZ0xGYk0xOUVCSXNOZjdLaGpkYnFRL0Q2eWlEYitObEVpMlNLRCtpdlhWVUs4aWIwb0JvMzY2Z1hrUjhaeEdqcEpJRGNFZ1pQYTlUY1llMFRJYmlQbC9yUFVRRHUzWEJKOVgvR05xM0ZBVXNLc2xsNTdEemFHTXJqY1QrZ2N0cCs5TUxZWENxK3NxUDgxZVZRMHI5bHQrZ2NRZlpiQUNSYkVqdmxNc2t6dFpHOGdiQzhRbjl0dDI2UTd5N25EcmJacS9MRXo3a1I2SmM2cGczTjlyVlg4WTVNSnJHbE1MOXA5bFU0amJUa0txQ3ZlZVpVSmpIQjAzbTJLUktSMlR5dG9Ga1RYT0xnN2tlVTFzMWxyUE1RSnBvT0tMdUFBQyt5MUhsSnVjVTZ5c0I1aHNYaHZTUFBMcTVKN0p0bnFIS1o0dllqQzRWeTgxNTNRWSs2NzgweER1R0FSc0diT3MxV3F6SDBRUzc2NXJuU0tFYmJLbGtPOG9JL1ZEd1VkMGlzMTN0S3BxSUx1MW1ESkZOeS9pSkFXY3ZEZ2p4dnVzSVQrUEd6M1NUL0o5cjlNdGZkMGpwYUdlaUxZSXFYYzdEaUhTUzhUY2pGVmtzaTY2UEVreFcxejZ1amJMTFVHTk5ZbnpPV3BIOEJaR0s0YkNLN2lSK01iSXY4bmNEQXoxdTRTdE4zdlRUemV3cjlJUWprOXd4RnhuKzZOMWRkS3MwdmZmSmlTMDhOM2E0RzFTVnJsWjk3US9NKzhHOWZlNUFQNmQ5L1FxNFdSbk9SVmhvZlBJS0VkQ3IzbGxzcFVmRTBvS0lJWW9CeUJSUGgrYlgxSExTM0pXR0pSaEl2RTFhVzROVGQ4ZVBpNFora1hiK1o4c25ZZlNOY3FpamhBZ1ZzeDRSQ001NGNYVWlZa2plQm1tQzRhak9IckNob0VMc2NKSkM3Kzlqak1qdzVCYWdaS2xnUk1pU05ZejdoN3Z2WklvUXFidFFtc3BjMGNVazFHLzczaVh0U3BST2w1d3RMZ1FpMG1XMkV4OGkzV1VMaGNnZ3g2RTFMTVZIVXNkYzlHSEkxUEgzVTJLbzBQeUdkbjlLZFZPTG03RlBCdWkwaTlhMEhwQTYwTXNld1ZFNHo4Q0F0NWQ0MDFHdjZ6WGxJVDVZYml0MVZJQTBGQ3M3d3R2WXJlcnUxZlV5VzNvTEFaLythVG5ack9jWVJOVkE4c3BvUnRsUm9XZmxzUkNsRmNnemtxaUhPcmYwL1NWdytFcFZhRmxKMGc0S3hxMU1NT21pUWRwTU5wdGU4bE1NUXFtNmNJRlhsbkdiZkpsbHlzS0RpKzBKSk1vdGtxZ0l4T1NRZ1U5ZG4vbFdrZVZmOG5VbTNpd1gyTmwzV0R3OWk2QVVLM3ZCQWJaWnJjSnBEUS9ONjRBVndqVDA3SmVmMzBHU1NtdE51MldsVzdZb3lXMkZsV2ZaRlFVd2s4NjdFZExZS2s5Vkc2SmdFbkJpQnhrWTdMTW80WUxRSkpsQW85bC9vVHZKa1NBUkRGL1h0eUF6TThPMnQzZVQvaVhhNndETjNXZXdObVFIZFBmc3hDaFUvS3RMRzJNbjhpNFpxS2RTbElhQlphZHhKbVJ6VlMvbzR5QTY1UlRTVmlxNjBvYTM5NUxxdzBwelk0U2lwd0UwU1hYc0tWK0dacmFHU2tyL1JXMDh3UFJ2cXZTVWtZQk1BOWxQeDRtMjRheitJSG1DYlhBKzBmYXhUUkU5d3VHZU8wNkRJWGE2UWxLSjNwdUl5aXVBVmZQcjczNnZ6bzJwQmlyUytWeGVsM1RNbTNKS2h6OW8yWm9SdmFGVnBJa3lrYjBIY200b0hGQk1jTlNOajcvNEdKdDQzb2dvblkyVmc0bnNEUUlXeEFjb3JwWEFDemdCcVFQallzRS9WVXBYcHdOTWFuRXJ1NE53TUNGUGtYdk1vcXZvZUxOM3F5dS9OMWVXRUh0dE1ENjV2MTlsLzBrSDJtUjM1aXYvRkkreWpvSEo5Z1BNejY3YWYzTXEvQm9XWHF1M3JwaGlXTVhWa21uUFNFa3BHcFVJMmgxTVRoaWRlR0ZFT0s2WVpIUHdZek1CdnBOQzcrWkh4UGI3ZXBmZWZHeUlCNEp6TzlEVE5FWW5ETFZWSGRReXZPRVZlZnJrNlV2NWtUUVlWWVdXZHFyZGNJbDd5bGp3d0lXZGZRL3krMlFCM2VSL3F4WU9idVl5QjRnVGJvMmluNFB6YXJVMXNPOW5FVGttajkvQW94REErSk0zR01xUXRKUjRqdGR1SHRub0NMeGQxZ1FVc2NIUkIvTW9SWUlFc1AycERaOUt2SGd0bGsxaVRiV1diSGhvaHdGRVlYN3k1MWZVVjJudVVtbm9VY3FuV0lRQUFnbDlMVFZYK0JjMFFHTkVoQ2h4SFI0WWpmRTUxUFVkR2ZzU0ZFNmNrN0JMMy9oVGY5akxxNEcxSWFmSU54T0xLZUF0TzdxdXVsWXZINVlPQmMrelg3Q3JNZ1duVzQ3L2pmUnNXbkpqWVlvRTd4TWZXVjJITjJpeUlxTEknO1xuY29uc3QgRkVOQ0VEID0gbmV3IE1hcChbWzgyMTcsXCJhcG9zdHJvcGhlXCJdLFs4MjYwLFwiZnJhY3Rpb24gc2xhc2hcIl0sWzEyNTM5LFwibWlkZGxlIGRvdFwiXV0pO1xuY29uc3QgTlNNX01BWCA9IDQ7XG5cbmZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0ZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxyXG5cdFxyXG5cdC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXHJcblx0bGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xyXG5cdGxldCB0b3RhbCA9IDE7XHJcblx0bGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcclxuXHRcdGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcclxuXHR9XHJcblxyXG5cdC8vIHNraXAgdGhlIHNpemVkLXBheWxvYWQgdGhhdCB0aGUgbGFzdCAzIHN5bWJvbHMgaW5kZXggaW50b1xyXG5cdGxldCBza2lwID0gdTE2KCk7XHJcblx0bGV0IHBvc19wYXlsb2FkID0gcG9zO1xyXG5cdHBvcyArPSBza2lwO1xyXG5cclxuXHRsZXQgcmVhZF93aWR0aCA9IDA7XHJcblx0bGV0IHJlYWRfYnVmZmVyID0gMDsgXHJcblx0ZnVuY3Rpb24gcmVhZF9iaXQoKSB7XHJcblx0XHRpZiAocmVhZF93aWR0aCA9PSAwKSB7XHJcblx0XHRcdC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXHJcblx0XHRcdC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXHJcblx0XHRcdHJlYWRfYnVmZmVyID0gKHJlYWRfYnVmZmVyIDw8IDgpIHwgYnl0ZXNbcG9zKytdO1xyXG5cdFx0XHRyZWFkX3dpZHRoID0gODtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XHJcblx0fVxyXG5cclxuXHRjb25zdCBOID0gMzE7XHJcblx0Y29uc3QgRlVMTCA9IDIqKk47XHJcblx0Y29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XHJcblx0Y29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcclxuXHRjb25zdCBNQVNLID0gRlVMTCAtIDE7XHJcblxyXG5cdC8vIGZpbGwgcmVnaXN0ZXJcclxuXHRsZXQgcmVnaXN0ZXIgPSAwO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XHJcblxyXG5cdGxldCBzeW1ib2xzID0gW107XHJcblx0bGV0IGxvdyA9IDA7XHJcblx0bGV0IHJhbmdlID0gRlVMTDsgLy8gdHJlYXQgbGlrZSBhIGZsb2F0XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xyXG5cdFx0bGV0IHN0YXJ0ID0gMDtcclxuXHRcdGxldCBlbmQgPSBzeW1ib2xfY291bnQ7XHJcblx0XHR3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcclxuXHRcdFx0bGV0IG1pZCA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcblx0XHRcdGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XHJcblx0XHRcdFx0ZW5kID0gbWlkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXJ0ID0gbWlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoc3RhcnQgPT0gMCkgYnJlYWs7IC8vIGZpcnN0IHN5bWJvbCBpcyBlbmQgbWFya1xyXG5cdFx0c3ltYm9scy5wdXNoKHN0YXJ0KTtcclxuXHRcdGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gICAvIHRvdGFsKTtcclxuXHRcdGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCsxXSAvIHRvdGFsKSAtIDE7XHJcblx0XHR3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpICYgTUFTSyB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSAmIE1BU0s7XHJcblx0XHRcdGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKGEgJiB+YiAmIFFSVFIpIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpIF4gSEFMRjtcclxuXHRcdFx0YiA9ICgoYiBeIEhBTEYpIDw8IDEpIHwgSEFMRiB8IDE7XHJcblx0XHR9XHJcblx0XHRsb3cgPSBhO1xyXG5cdFx0cmFuZ2UgPSAxICsgYiAtIGE7XHJcblx0fVxyXG5cdGxldCBvZmZzZXQgPSBzeW1ib2xfY291bnQgLSA0O1xyXG5cdHJldHVybiBzeW1ib2xzLm1hcCh4ID0+IHsgLy8gaW5kZXggaW50byBwYXlsb2FkXHJcblx0XHRzd2l0Y2ggKHggLSBvZmZzZXQpIHtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiBvZmZzZXQgKyAweDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xyXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4geCAtIDE7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cdFxyXG5cclxuLy8gcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBuZXh0IHN5bWJvbFxyXG5mdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdHJldHVybiAoKSA9PiB2W3BvcysrXTtcclxufVxyXG5mdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChzKSB7XHJcblx0cmV0dXJuIHJlYWRfcGF5bG9hZChkZWNvZGVfYXJpdGhtZXRpYyh1bnNhZmVfYXRvYihzKSkpO1xyXG59XHJcblxyXG4vLyB1bnNhZmUgaW4gdGhlIHNlbnNlOlxyXG4vLyBleHBlY3RlZCB3ZWxsLWZvcm1lZCBCYXNlNjQgdy9vIHBhZGRpbmcgXHJcbi8vIDIwMjIwOTIyOiBhZGRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvNFxyXG5mdW5jdGlvbiB1bnNhZmVfYXRvYihzKSB7XHJcblx0bGV0IGxvb2t1cCA9IFtdO1xyXG5cdFsuLi4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLmZvckVhY2goKGMsIGkpID0+IGxvb2t1cFtjLmNoYXJDb2RlQXQoMCldID0gaSk7XHJcblx0bGV0IG4gPSBzLmxlbmd0aDtcclxuXHRsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoKDYgKiBuKSA+PiAzKTtcclxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgd2lkdGggPSAwLCBjYXJyeSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNhcnJ5ID0gKGNhcnJ5IDw8IDYpIHwgbG9va3VwW3MuY2hhckNvZGVBdChpKV07XHJcblx0XHR3aWR0aCArPSA2O1xyXG5cdFx0aWYgKHdpZHRoID49IDgpIHtcclxuXHRcdFx0cmV0W3BvcysrXSA9IChjYXJyeSA+PiAod2lkdGggLT0gOCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxyXG5mdW5jdGlvbiBzaWduZWQoaSkgeyBcclxuXHRyZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XHJcblx0bGV0IHYgPSBBcnJheShuKTtcclxuXHRmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyBbMTIzXVs1XSA9PiBbMCAzXSBbMSAxXSBbMCAwXVxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZChuZXh0LCBwcmV2ID0gMCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KCk7XHJcblx0XHRsZXQgbiA9IG5leHQoKTtcclxuXHRcdGlmICghbikgYnJlYWs7XHJcblx0XHRwcmV2ICs9IHg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRyZXQucHVzaChwcmV2ICsgaSk7XHJcblx0XHR9XHJcblx0XHRwcmV2ICs9IG4gKyAxO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZF9hcnJheXMobmV4dCkge1xyXG5cdHJldHVybiByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgXHJcblx0XHRsZXQgdiA9IHJlYWRfc29ydGVkKG5leHQpO1xyXG5cdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdjtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBtYXAgb2YgeCA9PiB5c1xyXG5mdW5jdGlvbiByZWFkX21hcHBlZChuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKTtcclxuXHRcdGlmICh3ID09IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCkgLSAxO1xyXG5cdFx0aWYgKHcgPCAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0LmZsYXQoKTtcclxufVxyXG5cclxuLy8gcmVhZCB1bnRpbCBuZXh0IGlzIGZhbHN5XHJcbi8vIHJldHVybiBhcnJheSBvZiByZWFkIHZhbHVlc1xyXG5mdW5jdGlvbiByZWFkX2FycmF5X3doaWxlKG5leHQpIHtcclxuXHRsZXQgdiA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQodi5sZW5ndGgpO1xyXG5cdFx0aWYgKCF4KSBicmVhaztcclxuXHRcdHYucHVzaCh4KTtcclxuXHR9XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIHJlYWQgdyBjb2x1bW5zIG9mIGxlbmd0aCBuXHJcbi8vIHJldHVybiBhcyBuIHJvd3Mgb2YgbGVuZ3RoIHdcclxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcclxuXHRsZXQgbSA9IEFycmF5KG4pLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcblx0XHRyZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufVxyXG4gXHJcbi8vIHJldHVybnMgW1t4LCB5c10sIFt4K2R4LCB5cytkeV0sIFt4KzIqZHgsIHlzKzIqZHldLCAuLi5dXHJcbi8vIHdoZXJlIGR4L2R5ID0gc3RlcHMsIG4gPSBydW4gc2l6ZSwgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcclxuXHRsZXQgZHggPSAxICsgbmV4dCgpO1xyXG5cdGxldCBkeSA9IG5leHQoKTtcclxuXHRsZXQgdk4gPSByZWFkX2FycmF5X3doaWxlKG5leHQpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5mbGF0TWFwKCh2LCBpKSA9PiB7XHJcblx0XHRsZXQgW3gsIC4uLnlzXSA9IHY7XHJcblx0XHRyZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcclxuXHRcdFx0bGV0IGpfZHkgPSBqICogZHk7XHJcblx0XHRcdHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm4gW1t4LCB5cy4uLl0sIC4uLl1cclxuLy8gd2hlcmUgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkgeyBcclxuXHRsZXQgbiA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVhZF90cmllKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHNvcnRlZCA9IHJlYWRfc29ydGVkKG5leHQpOyBcclxuXHRleHBhbmQoZGVjb2RlKFtdKSwgW10pO1xyXG5cdHJldHVybiByZXQ7IC8vIG5vdCBzb3J0ZWRcclxuXHRmdW5jdGlvbiBkZWNvZGUoUSkgeyAvLyBjaGFyYWN0ZXJzIHRoYXQgbGVhZCBpbnRvIHRoaXMgbm9kZVxyXG5cdFx0bGV0IFMgPSBuZXh0KCk7IC8vIHN0YXRlOiB2YWxpZCwgc2F2ZSwgY2hlY2tcclxuXHRcdGxldCBCID0gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IC8vIGJ1Y2tldHMgbGVhZGluZyB0byBuZXcgbm9kZXNcclxuXHRcdFx0bGV0IGNwcyA9IHJlYWRfc29ydGVkKG5leHQpLm1hcChpID0+IHNvcnRlZFtpXSk7XHJcblx0XHRcdGlmIChjcHMubGVuZ3RoKSByZXR1cm4gZGVjb2RlKGNwcyk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB7UywgQiwgUX07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGV4cGFuZCh7UywgQn0sIGNwcywgc2F2ZWQpIHtcclxuXHRcdGlmIChTICYgNCAmJiBzYXZlZCA9PT0gY3BzW2Nwcy5sZW5ndGgtMV0pIHJldHVybjtcclxuXHRcdGlmIChTICYgMikgc2F2ZWQgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdGlmIChTICYgMSkgcmV0LnB1c2goY3BzKTsgXHJcblx0XHRmb3IgKGxldCBiciBvZiBCKSB7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGJyLlEpIHtcclxuXHRcdFx0XHRleHBhbmQoYnIsIFsuLi5jcHMsIGNwXSwgc2F2ZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XG5cbmZ1bmN0aW9uIGhleF9jcChjcCkge1xyXG5cdHJldHVybiBjcC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdW90ZV9jcChjcCkge1xyXG5cdHJldHVybiBgeyR7aGV4X2NwKGNwKX19YDsgLy8gcmFmZnkgY29udmVudGlvbjogbGlrZSBcIlxcdXtYfVwiIHcvbyB0aGUgXCJcXHVcIlxyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7XHJcblx0cmV0dXJuIFsuLi5zXS5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApKTtcclxufVxyXG4qL1xyXG5mdW5jdGlvbiBleHBsb2RlX2NwKHMpIHsgLy8gdGhpcyBpcyBhYm91dCAyeCBmYXN0ZXJcclxuXHRsZXQgY3BzID0gW107XHJcblx0Zm9yIChsZXQgcG9zID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XHJcblx0XHRsZXQgY3AgPSBzLmNvZGVQb2ludEF0KHBvcyk7XHJcblx0XHRwb3MgKz0gY3AgPCAweDEwMDAwID8gMSA6IDI7XHJcblx0XHRjcHMucHVzaChjcCk7XHJcblx0fVxyXG5cdHJldHVybiBjcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cl9mcm9tX2NwcyhjcHMpIHtcclxuXHRjb25zdCBjaHVuayA9IDQwOTY7XHJcblx0bGV0IGxlbiA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGxlbiA8IGNodW5rKSByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xyXG5cdFx0YnVmLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzLnNsaWNlKGksIGkgKz0gY2h1bmspKSk7XHJcblx0fVxyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVfYXJyYXlzKGEsIGIpIHtcclxuXHRsZXQgbiA9IGEubGVuZ3RoO1xyXG5cdGxldCBjID0gbiAtIGIubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBjID09IDAgJiYgaSA8IG47IGkrKykgYyA9IGFbaV0gLSBiW2ldO1xyXG5cdHJldHVybiBjO1xyXG59XG5cbi8vIGNyZWF0ZWQgMjAyMy0wOS0yNVQwMTowMTo1NS4xNDhaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtbmYgZGF0YVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XG4vLyBTSEEtMjU2OiBhOTc0YjZmODU0MWZjMjlkOTE5YmM4NTExOGFmMGE0NDAxNTg1MWZhYjUzNDNmODY3OWNiMzFiZTJiZGIyMDllXG52YXIgQ09NUFJFU1NFRCA9ICdBRVVEVEFIQkNGUUFUUURSQURBQWNnQWdBRFFBRkFBc0FCUUFId0FPQUNRQURRQVJBQW9BRndBSEFCSUFDQUFQQUFVQUN3QUZBQXdBQkFBUUFBTUFCd0FFQUFvQUJRQUlBQUlBQ2dBQkFBUUFGQUFMQUFJQUN3QUJBQUlBQVFBSEFBTUFBd0FFQUFzQURBQU1BQXdBQ2dBTkFBMEFBd0FLQUFrQUJBQWRBQVlBWndEU0Fkc0RKZ0MwQ2tNQjh4aFpBcWZvQzE5MFVHY1RoZ0J1cndmN1BUMDlQYjA5QWpnSnVtOE9qRGxseEhZVUtYQVB4enE2dEFCQXhnSzh5c1V2V0FnTVBUMDlQVDA5UFNzNkxUMkhjZ1dYV3dGTG9TTUVFRWw1UkZWTUt2TzBYUThFeERkSk1uSWdzajI2UFRReXk4RmZFUThBWThJUEFHY0Vid1J3QkhFRWNnUnpCSFFFZFFSMkJIY0VlQVI2QkhzRWZBUitCSUFFZ2ZuZEJRb0JZZ1VMQVdJRkRBRmlCTmNFMkFUWkJSQUZFUVV2QmRBTEZBc1ZEUGNOQncxM0RZY09NQTR4RGpNQjRCbGxISTBCMmdyYkFNRHBITGtRN1FIVkFQUk5RUUZuR1JVRWcweUVCMnVhSkY4QUpwSUJwb2I1QUVSU01BS05vQVhxYVFMVUJNQ3pFaUFDbndSWkVra1ZzUzd0QU5Bc0JHMFJ1QVFMRVBBQnY5SElDVFVCWGlnUFp3UkJBcE1ET3dBYW1odGFBQnFFQVk4S3ZLeDNMUTRBckFCOFVod0VCQVZTYWdEOEFFRlpBRGtCSWFkVmoyVU1VZ3g1SWw0QU5RQzlBeElCMUJsYkVQTUFzMzBDR3hsWEFod1pLUUlFQ0JjNkVic0NveG5nenY3VXpSUUE4TTBCYXdMNlp3a043d0FCQUQzM09RUmNzZ0xKQ2pNQ2pxVUNodHcva20rTkFzWFBBb1AyQlQ4NFB3VVJBSzBSQXZwdGI2Y0FwUVMvT01NZXk1SEpTODRVZHhweFRQa0NvZ1ZGSVRhVE93RVJBSzVwQXZrTkJPVnlBN3EzQktsT0pTQUxBZ1VJQlJjRWRBU3BCWHF6QUJYRlNXWk9hd0xDT3F3Ly9Bb2xDWmR2djNkU0JrRVFHeWVsRVBjTU13RzFBVHNON1V2WUJQRUdPd1RKSDMwWkdRL05sWndJcFMzZERPMG00eTZoZ0ZvajlTcURCZTFMOUR6ZEMwMVJhQTlaQzJVSjR6cGpnVTRESVFFTklvc0szUTA1Q0cwUTh3ckphdzNsRVVVSE9RUFZTWm9BcFFjQkN4RWROUlcxSmhCaXJBc0pPWGNHK3hyMkM0OG1yeE1wZXZ3RjB4b2hCazBCS1JyL0FNOHU1NFd3V2pGY0hFOWZCZ01MSlNQSEZLaFFJQTBsUUxkNFNCb2JCeFVscVFLUlEzQktoMUUySHBNaDlqdzlEV1l1RTFGOEIvVThCUmxQQzRFOG5rYXJSUTRSMGo2TlBVZ2lTVXdzQkRWL0xDOG5pd25QRDRVTXVYeHlBVmtKSVFteERIRVRNUkVYTjhVSU9RY1pMWmNrSnhVSUlVYVZZSm9FOTU4RDh4UFJBd3NGUHdsQkJ4TUR0Und0RXk0VktRVU5nU1RYQXZNMjFTNnpBbzlXZ0FFWEJjc1BKUi9mRUZCSDRBN3BDSnNDWlFPREplc0FMUlVoQUJjaW13aERZd0JmajloVEJTN0xDTWRxYkNOMEEyY1U1MkVSY3dlUkRsY0hweHd6RmI4YzRYRElYZ3VHQ0NpanJ3bGJBWFVKbVFGZkJPTUlDVFZiaktBZ1FXZFRpMWdZbXlCaFFUOWQvQUl4REdVVm4wUzloM2dDaXc5ckVoc0JOUUZ6QnprTkFRSjNFZTBSYXhDVkNPdUdCRFcxTS9nNkpRUlBJWU1nRVFvbkEwOXN6Z3NuSnZrTStHa0JveEppQXd3MFBYZnVaNnRndGlRWC9RY1pNc1ZCWUNIeEM1SlB6UXljR3NFWVFsUXVHZVFIdndQekd2TW42a0ZYQmY4RG93TVRPazB6N2dTOUMya0lpd2svQUVrT294Y0gxeGhxQ25HTTBBRXhpd0czbVFOWGtZTUNiNDhHTndjTEFHY0xod1Y1NVFBZEFxY0lvd0FGQU04RFZ3QTVBcTBIblFBWkFJVkJBVDBESnk4QkllVUNqd09UQ0RITEFaVXZBZk1wQkJ2RERCVUE5emR1U2dMRHNRS0FhbWFpQmQxWUFvNENTVFVCVFNVRUJVNUhVUU92Y2VFQTJ3QkxCaFBmUndFVnEwckxHdU5EQWQ5dkt3REhBUHNBQlRVSEJVRUJ6UUh6YlFDM0FWOExNUW1pczdVQlRla3BBSU1BRldzQjF3S0pBTjBBTlFCLzhRRlRBRTBGV2ZrRjB3SlBTUUVSTVJnclYyRUJ1d01mQVRNQkRRQjVCc3VOcGNrSEh3UnRCOU1DRUJzVjRRTHZMZ2UxQVFNaTN4UE5Rc1VDdmQ1Vm9XQUNaSUVDWWtKYlRhOWJOeUFDb2ZjQ2FKZ0NaZ2tDbjRRNEd3c0NaanNDWmlZRWJnUi9BMzhUQTM2U09RWTVkeGM1Z2pvakl3SnNIUUl5TmpnS0FtM0hBbTJ1NzRvelowVXJBV2NBM2dEaEFFb0ZCNWdNalFEK0M4SUFEYlVDZHk4Q2RxSS9BbmxMUXdKNHVoMWMyMFd1UnRjQ2ZEOENlc2dDZlFrQ2ZQQUZXUVVnU0FCSWZXTWtBb0Z0QW9BQUFvQUZBbit1U1ZoS1d4VVhTc3dDMFFFQzBNeExKd09JVHdPSDVrVEZrVElDOHFGZEF3TURya3ZPVEMwbEE4OU5URTJ2QW9zL0Fvcll3UnNISFVObkJiY0NqamNDamx4QWw0RUNqdGtDamx4NFViUlROUXBTMUZTRkFwUDdBcE1NQU9rQUhGVWVWYTlWMEFZc0d5bVZoakxoZUdaRk96a0NsNThDNzdKWUlhZ0FXU1VDbG84Q2xueWNBS2xackZvSmdVMEFPd0tXdFFLV1RseEVYTkVDbWNzQ21XUmN5bDBIR1FLY216bkNPcDBDbkJZQ241c0NucmlLQUIwUE1Tb1BBcDN4QXA2U0FMVTlZVFJoN3dLZTB3S2diZ0dwQXA2Zkh3S2VUcVZqeUdRbkpTc0NKNjhDSm40Q29Qc0NvRXdDb3QwQ29jUUNwaThDcGM0Q3AvOEFmUUtuOG1oOGFMRUFBMGxxSEdyUkFxempBcXl1QXExbkFxMENBbGNkQWxYY0FySGgxd01mVG15WEFySzlEUUt5NkJkczRHMWpiVWhmQXlYTkFyWmNPejl1a0FNcFJRSzRYZ0s1UnhVQ3VTcDNjRFp3NFFLOUdRSzcybkNXQXpJUkFyNkljZ0lETTNFQ3ZocHpJbk5QQXNQTEFzTUVjNEowU3pWRmRPQURQS2NEUEpvRFBiOEN4WHdDeGtjQ3hoQ0pBc2hwVVFMSVJBTEpUd0xKTGdKa25RTGQwbmg1WVhpdWVTVkwwQU1ZbzJjQ0FtSDBHZk9WSkhzTFhwSmV1eEVDejJzQ3oyd3ZTMVBTOHhPZkFNYXRBczl6QVNucUEwNFNma3NGQXR3bkF0dUtBdEpQQTFKY0ExTmZBUUVEVll5QWlUOEF5eGJ0WUVXQ0hJTFRnczZEalFMYXh3TFozb1FRaEVtblBBT0dwUUF2QTJRT2huRlorUUJWQXQ5bEF0NjRjM2NDNGkvdEZBSHpNQ2NCOUpzQjh0S0hBdXZ6QXVsd2VRTHErUUxxNUFENVJ3RzVBdTZKQXV1Y2xxcVhBd0x1UHdPRjRKaDVjT0J4b1FMekF3QnBBNDRXbVpNQzl4TURrVzREa29jQzk1Z0MrZGtDK0dhYUhKcXJ1emViSGdPZGd3TCsrZ0ViQURtZkhKK3pBd1dOQTZacUE2YlpBTkhGQXdacW9ZaWlCUWtEREVrQ3dBQS9Bd0RoUVJkVEFSSHpBMnNIbDJjRkFKTXRLN2V2dmRzQmlaa1VmeEVFT1FIN0tRVWhEcDBKbndDUy9TbFh4UUwzQVowQXR3VzVBRzhMYlVFdUZDYU5MZ0ZEQVlEOEFiVW1BSFVERGdSdEFDd0NGZ3loQUFBS0FqMENhZ1BkQTM0RWtRRWdSUVVoZkFvQUJRQkVBQk1BTmhJQ2R3RUFCZFVEYSs4S3hRSUE5d3FmSjcreHQrVUJrU0ZCUWdIcEZIOFJOTUNKQUFRQUd3QmFBa1VDaElzQUJqcFRPcFNOYlFDNE9vODYwQUNOT01FNjNBQ2xBT2dBeXdFNmdUbzdPZnc1K1R0MmlUcGJPNTZKT204NUdBRldBVE1CYkFVdk5WMDFuald0TldZMWRUVzJOY1UxZ2pXUk5kSTE0VFdlTmEwMTdqWDlOYkkxd1RZQ05oRTF4alhWTmhZMkp6WGVOZTAyTGpZOU5pNDFMU0UyT2pZOU5qdzJ5VGNJQkpBOFZ6WTROdDAzSURjUE5zb2dONGszTUFvRXNEeG5OaVEzR1Rkc09vMDNJVUxVUXdkQzRFTUxIQThQQ1pzb2JTaFJWUVlBNlg4QTZiQUJGQ25YQXVrQm93QzlCYmNBYndOekJMOE1EQU1NQVFnREFBa0tDd3NMQ1FvR0JBVlZCSS9EdndEejliMjlrYVVDYjBRdHNSVE5MdDRlR0JjU0hBTVpGaFlaRWhZRUFSQUVCVUVjUVJ4QkhFRWNRUnhCSEVFYVFSeEJIRUZDU1R4QlBFbElTVWhCTmtNMlFUWWJOa2xJU1ZtQlZJZ0JGTFdaQXUwQmhRQ2pCY0VBYnlrQnZ3R0pBYVFjRVowZVBDa2xNQUFoTXZBSU1BTDU0Z0M3Qm04RWVzY2p6UU1wQVJRcEtnRFVBQmF2QWo2MjZ4UUFKUDBBM2V0enVmNE5OUkE3ZWZ5Mlo5TlFyQ25DME9TeUFOejVCQkliSjVJRkRSNm1pSWF2WVM2dHByamptdUtlYnhtNUM3NFEyMjVYMXBrYVlZUGI2ZjFESzRrM3hNRUJiOVMyV01qRWliVE5XaHNSSklBK3Z3TlZFaVhURTVpWHMvd2V6VjY2b0ZMZnA5TlpHWVcrR2sxOUoyK2JDVDZZZTJ3NkxEWWRnektNVWFiazU5NWVMQkNYQU56OUhVcFdiQVRxOXZxWFZ4OVhEZytQYzlYcDQrYnNTMDA1U1ZNL0JKQk00Njg3V1V1ZitVajlkRWk4YUROYVB4dHBiRHhjRzFUSFRJbVVNWnE0VUNhYU5ZcHNWcXJhTnlLTEpYRFlzRlovNWpsN2JMUnRPODh0N1AzeFphQXhoYjVPZFBNWHFzU2twMVdDaWVHOGpYbTFVOTkrYmx2TGxYelBDUytNOTNWbkpDaUsrMDlMZmFTYUJBVkJvbXlEZ0p1YThkZlV6UjdnYTM0SXZSMk52aitBOWhlSjZsc2wxS0c0TmtJMTAzMkNuZmYxbTF3b2YyQjlvSEpLNGJpNkprRWRTcWVOZWl1bzZRb1paaW5jb2M3My9USDlTWEY4c0NFN1h5dVl5VzhXU2diR0ZDalBWMGloTEtoZFBzMDhUeDgyZllBa0xMYzRJMndkbDRhcFk3R1U1bEhSRnpSV0plcDdXdzN3YmVBM3FtZDU5Lzg2UDR4dU5hcURweWdYdDZNODVnbFNCSE9DR2dKRG50K3BOOWJLN0hBcE1ndVg2KzA2UlpOanpWbWNaSit3Y1VySjkvL2JwUk54TnVLcE5sOXVGZHMrUzl0ZHg3TGFNNVprSXJQajZuSVU5bW5iRnRWYnM5cy91TGdsOE1WY3pBd2V0K2lPRXp6QmxZVzdSQ01nRTZneU5MZXE2KzF0SXg0ZHBnWm5kMERrc0pTNWYrSk5EcHd3Y1BOWGFhVnNwcTFmYlFhak9ySmdLMG9mS3RKMU5lOTBMNlZPNE1PbDVTODg2cDd1NnhvN09Makc4VEdMK0hVMUpYR0pncHBnNG5OYk5KNW5selNwdVBZeTIxSlVFY1VBOTRQb0ZpWmZqWnVlK1FueVE4MGVrT3VaVmt4eDRnK2N2aEpmSGdObDRoeTEvYTYrUktjS2xhci9KMjl5Ly9FenRsYlZQSFZVZVExelg4NmVRVkFqUi9NM2RBOXc0VzhMZmFYcDRFZ004NXdPV2FzbGk4MzdQelZNT25zTHpSK2szbzc1L2xSUEFKU0UxeEFLUXpFaTV2MTBrZStWQnZSdDFjd1FSTWQrVTVtTENUR1ZkNlhpWnRnQkc1Y0RpMHcyMkdLY1ZOdkhpdTVMUWJaRURWdHowb25uN2s1K2hldUtYVnNadFN6aWxrTFJBVW1qTVhFTUIzSjlZQzUwWEJ4UGl6NTNTQytFaG5QbDlXc0tDdjkyU00vT0ZGSU1KWllmbDBXVzh0SU8zVXhZY3dkTUFqN0ZTbWdyc1oyYUFaTzAzQk9oUDFiTk5aSXR5WFlRRlRwQzNTRzFWdVBEcUg5R2tpQ0RtRStKd3h5SVZTTzVzaURFckFPcEVYRmdqeTZQUXRPVkRqK3M2ZTFyOGhlV1Z2bVpuVGNpdWY0RWlOWnpDQWQ3U09NaFhFUklPbHNISU1HMzk5aTlhTFR5M20yaFJMWmpKVkROTFM1M2lHSUsxMWRQcVF0MHpCRHlnNnFjN1lxa0RtMk01VmU2ZENXQ2FDYlRYWDJyVG9hSWd6Nit6aDRsWVVpLys2bnFjRk1Ba1FKS0hZTEswd1lrNU45c3pWNnhpaERiRERGcjQ1bE4xSzRhQ1hCcS9GaXRQU3VkOWdMdDVaVm4rWnFHWDdjd20yejVFR01nZkZwSUZ5aEdHdURQbXNvNlRJdFRNd255Kzd1UG5MQ2Y0VzZnb0ZRRlYwb1FTc2M5VmZNbVZMY0xyNlpldERaYmFTRlRMcW5TTy9iSVBqQTMvekFVb3FnR0ZBRVFTNElodU16RXAySTNqSnpiemtrL0lFbXlheCtyaFpUd2Q2ZitDR3R3UGl4dThJdnpBQ3F1UFdQUkV1OVp2R2tVenBSd3ZSUnVhTk42Y3IwVzF3V2l0czlJQ2RZSjdsdGJnTWlTTDNzVFBldWZnTmNWcU1WV0ZrQ1BESDRqRzJqQTBYY1ZnUWo2MkNiMjl2OWYvei8rMktiWXZJdi96empwUUFQa2xpYVZEek5yVzU3VFovWk95WkQwbmxmTW1BSUJJQUdBSTBEM2svbWRONHhyOXY4NVpiWmJicWZIMmpHZDVoVXFOWld3bDVTUGZvR21mRWxtYXpVSWVOTDFqL21rRjdWTkF6VHE0ak50OEpvUTExTlFPY21ocHJYb3hTeGZSR0o5TERFT0FRK2RteEFRSDkwaXRpOWUydS9Nb2V1YUdjRFRIb0MreHNtRWVXbXhFS2VmUXVJekhicHc1VGM1Y0VvY2JvQUQwOW9pcFdRaHRUTzF3aXZmL08rRFJlMnJwbC9FOXdscnpCb3JqSnNPZUcxQi9YUFc0RWFKRUZkTmxFQ0VaZ2E1Wm9HUkhYZ1lvdUdSdVZrbTh0REVTaUV5Rk5vKzNzNU01cHVTZFR5VUwybGxuSU5WSEV0OTFYVU5XNGV3ZE1nSjRib0pmRXl0L2lZNVdYcWJBK0EyRmt0NVowbHV0aVdoZTluWkl5SVVqeVhEQzNVc2FHMXQrZU54Nno0Vy9PWW9UQjdBNngrZE5TVE9pOUFJbmN0YkVTcW01Z3ZPTHd3N09XWFBybUh3Vlphc3JsNGVEMTEzcG0rSnRUN0pWT3ZuQ1hxZHp6ZFRSSGdKMFBpR1RGWVc1R3Z0OVI5TEQ2THpmczB2L1RaWkhTbXlWTnE3dmlJSEU2REJLN1FwMDdJejU1RU04U1l0UXZaZi9vYkJuaVRXaTVDMi9vdkhmdzRWbmRrRTVYWWRqT2hDTVJqRGVPRWZYZU4vQ3dmR2R1aVVJZnNvRmVVeFhlUVhiYTdjNzk3MlhOdjh3K2RUampVTTBRZU5BUmVXK0owMTRkS0FEL01jUVlYVDdjMEdRUElrbjNMbDZSN2dHanVpUW9aRDBURWVFcVFwS29aMTVnLzBPUFFJMTdRaVN2OUFVUk9hL1YvVFFOM2R2TEFyZWMzUnJzWWx2Qm0xYjhMV3psdGR1Z3NDNTBsTktZTEVwMmErWlpZcVBlalVMUmxPSmg1emovTFZNeVREdndLaE14eHd1RGt4SjFRcG9OSTBPVFdMb200WjcxU056STlUVjFpWEpySXU5V2NuZCtNQ2FBdzhvMWpTWGQ5NFlVLzFnbmtyQzlCVUVPdFF2RUlRN2cwaTZoK0tMMkpLazhZZGw3SHJ1dmdXTVNBbU5lK0xzaEdoVjRxbldIaE85L1JJUFF6WTF0SFJqMlZxT3lOc0RwSzBjd3crNTZBZERDNGdzV3dZMFh4b3VjSVdJcXMvR2N3bldxbGFUMEtQcjhtYks1VTk0LzMwMWkxV0x0NFlJTlRWdkNGQnJGWmJJYlk4ZXljT2RlSjJ0ZUQ1SWZQTENSZzdqamNGVHdsTUZObDl6ZGgvbzNFL2hIUHdqN0JXZzBNVTA5cFByQkxickNnbTU0QTZIK0k2djI3K2pMNWdraldnL2lZZGtzOWpiZlZQNXkvbjBkbGdXRU1sS2FzbDdKdkZaZDU2TGZ5YlcxZWVhVk8wZ3hUZlhad0Q4RzRTSTExNnl4N1VLVlJndWk2WWExWXBpeHFYZU5MYzhJeHRBd0NVNUlod1FnbitOcUhuUmFEdjYxQ3hLaE9xNHBPWDdNNnBrQStQbXBkNGoxdm42QUNVQUxvTExjNHZwWGNpOFZpZEx4em03cUZCZTdzK3F1dUpzNkVUWW1ucGdTM0x3U1p4UElsdGdCRFh6OE0xay9XMnlTTnYyZjkvTlBoeExHSzJEMjFka0hlU0dtZW5SVDNZcWNkbDBtL2gzT1lyOFYrbFhOWUdmOGFDQ3BkNGJXakU0UUlQajd2VUtONE5yZnM3TUw2WTJPeVM4MzBKQ25vZmcvazdscEZwdDRTcVpjNUhHZzFIQ09ySHZPZEM4YlA2RkdEYkUvVlYwbVg0SWFremJkUy9vcCtLdDNHMjQvOFFiQlY3eTg2c0dTUS92WnpVOEZYczd1NmpJdndjaHNFUDJCcEloVzNHOHVXTndhM0htamZIL1pqaGhDV3ZsdUFjRituTWYxNENsS2c1aEdndFBMSjk4dWVOQWtjNUhzMldabGsyUUh2ZnJlQ0sxQ0NHTzZuTVpWU2I5OVZNL2FqcjhXSFR0ZTlKU21rWHEvaS9VOTQzSEViZHpXNlJlL1M4OGRLZ2c4cEdPTGxBZU5pcXJjTGtVUjMvYUNsRnBNWGNPVVAzcm1FVGNXU2ZNWFpFM1RVT2k4aStmcVJuVFlMZmxWeC9WYi82R0o3ZUlSWlVBNmszUllSM2lGU0s5YzRpRGROd0p1WkwyRkt6L0lLNVZpbWNOV0VxZFhqU294U2dtRjBVUGxEb1VsTnJQY003ZnRtQThZOWdLaXFLRUh1V04rQVpSSXd0VlN4eWUyS2Y4ck0zbGhKNVhjQlhVOW40djBPeTFSVTJNKzRxTThBUVBWd3NlOEVyTlNvYjVvRlBXeHVxWm5Wem8xcUIvSUJ4a00zRVZVS0ZVVWxPM2U1MTI1OUdnTmNKYkNtbHZyZGp0b1RXN3JDaG0xd3lDS3pwQ1R3b3pVVUVPSWNXTG5lUkxnTVhoK1NqR1NGa0FsbHpiR1M1SEs3TGxmQ01STlJEU3ZiUVBqY1hhZW5OWXhDdnUyUXl6bno2U3R1eFZqNjZTZ0kwVDhCNi9zZkhBSllaYVo3OHRoak9TSUZ1bU5XTFFiZVppeERDQ0MrdjBZQnRreGlCQjNqZWZIcVovZEZIVStjcmJqNk92UzF4L0pERDd2bG03ek9WUHdwVUMwMW5oeFp1WS82M0U3Zyc7XG5cbi8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjE1L1xyXG4vLyBmb3IgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXHJcbi8vIHNlZTogL2Rlcml2ZS9uZi5qc1xyXG5cclxuXHJcbi8vIGFsZ29yaXRobWljIGhhbmd1bFxyXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy92ZXJzaW9ucy9Vbmljb2RlMTUuMC4wL2NoMDMucGRmIChwYWdlIDE0NClcclxuY29uc3QgUzAgPSAweEFDMDA7XHJcbmNvbnN0IEwwID0gMHgxMTAwO1xyXG5jb25zdCBWMCA9IDB4MTE2MTtcclxuY29uc3QgVDAgPSAweDExQTc7XHJcbmNvbnN0IExfQ09VTlQgPSAxOTtcclxuY29uc3QgVl9DT1VOVCA9IDIxO1xyXG5jb25zdCBUX0NPVU5UID0gMjg7XHJcbmNvbnN0IE5fQ09VTlQgPSBWX0NPVU5UICogVF9DT1VOVDtcclxuY29uc3QgU19DT1VOVCA9IExfQ09VTlQgKiBOX0NPVU5UO1xyXG5jb25zdCBTMSA9IFMwICsgU19DT1VOVDtcclxuY29uc3QgTDEgPSBMMCArIExfQ09VTlQ7XHJcbmNvbnN0IFYxID0gVjAgKyBWX0NPVU5UO1xyXG5jb25zdCBUMSA9IFQwICsgVF9DT1VOVDtcclxuXHJcbmZ1bmN0aW9uIHVucGFja19jYyhwYWNrZWQpIHtcclxuXHRyZXR1cm4gKHBhY2tlZCA+PiAyNCkgJiAweEZGO1xyXG59XHJcbmZ1bmN0aW9uIHVucGFja19jcChwYWNrZWQpIHtcclxuXHRyZXR1cm4gcGFja2VkICYgMHhGRkZGRkY7XHJcbn1cclxuXHJcbmxldCBTSElGVEVEX1JBTkssIEVYQ0xVU0lPTlMsIERFQ09NUCwgUkVDT01QO1xyXG5cclxuZnVuY3Rpb24gaW5pdCQxKCkge1xyXG5cdC8vY29uc29sZS50aW1lKCduZicpO1xyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCk7XHJcblx0U0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5cdEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuXHRERUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0UkVDT01QID0gbmV3IE1hcCgpO1xyXG5cdGZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdFx0aWYgKCFFWENMVVNJT05TLmhhcyhjcCkgJiYgY3BzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0XHR9XHJcblx0XHRERUNPTVAuc2V0KGNwLCBjcHMucmV2ZXJzZSgpKTsgLy8gc3RvcmVkIHJldmVyc2VkXHJcblx0fVxyXG5cdC8vY29uc29sZS50aW1lRW5kKCduZicpO1xyXG5cdC8vIDIwMjMwOTA1OiAxMW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX2hhbmd1bChjcCkge1xyXG5cdHJldHVybiBjcCA+PSBTMCAmJiBjcCA8IFMxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlX3BhaXIoYSwgYikge1xyXG5cdGlmIChhID49IEwwICYmIGEgPCBMMSAmJiBiID49IFYwICYmIGIgPCBWMSkge1xyXG5cdFx0cmV0dXJuIFMwICsgKGEgLSBMMCkgKiBOX0NPVU5UICsgKGIgLSBWMCkgKiBUX0NPVU5UO1xyXG5cdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGEpICYmIGIgPiBUMCAmJiBiIDwgVDEgJiYgKGEgLSBTMCkgJSBUX0NPVU5UID09IDApIHtcclxuXHRcdHJldHVybiBhICsgKGIgLSBUMCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxldCByZWNvbXAgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRyZWNvbXAgPSByZWNvbXAuZ2V0KGIpO1xyXG5cdFx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlY29tcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVjb21wb3NlZChjcHMpIHtcclxuXHRpZiAoIVNISUZURURfUkFOSykgaW5pdCQxKCk7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XG5cbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5cclxuLy8gMjAyMzA5MTM6IHJlcGxhY2UgWy4uLnZdIHdpdGggQXJyYXlfZnJvbSh2KSB0byBhdm9pZCBsYXJnZSBzcHJlYWRzXHJcbmNvbnN0IEFycmF5X2Zyb20gPSB4ID0+IEFycmF5LmZyb20oeCk7IC8vIEFycmF5LmZyb20uYmluZChBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBncm91cF9oYXNfY3AoZywgY3ApIHtcclxuXHQvLyAyMDIzMDkxMzoga2VlcCBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgZGlzdGluY3QgaW5zdGVhZCBvZiBjcmVhdGluZyB2YWxpZCB1bmlvblxyXG5cdHJldHVybiBnLlAuaGFzKGNwKSB8fCBnLlEuaGFzKGNwKTtcclxufVxyXG5cclxuY2xhc3MgRW1vamkgZXh0ZW5kcyBBcnJheSB7XHJcblx0Z2V0IGlzX2Vtb2ppKCkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbn1cclxuXHJcbmxldCBNQVBQRUQsIElHTk9SRUQsIENNLCBOU00sIEVTQ0FQRSwgTkZDX0NIRUNLLCBHUk9VUFMsIFdIT0xFX1ZBTElELCBXSE9MRV9NQVAsIFZBTElELCBFTU9KSV9MSVNULCBFTU9KSV9ST09UO1xyXG5cclxuZnVuY3Rpb24gaW5pdCgpIHtcclxuXHRpZiAoTUFQUEVEKSByZXR1cm47XHJcblx0XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEJDEpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX2FycmF5ID0gKCkgPT4gcmVhZF9zb3J0ZWQocik7XHJcblx0Y29uc3QgcmVhZF9zb3J0ZWRfc2V0ID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRjb25zdCBzZXRfYWRkX21hbnkgPSAoc2V0LCB2KSA9PiB2LmZvckVhY2goeCA9PiBzZXQuYWRkKHgpKTtcclxuXHJcblx0TUFQUEVEID0gbmV3IE1hcChyZWFkX21hcHBlZChyKSk7IFxyXG5cdElHTk9SRUQgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gaWdub3JlZCBjaGFyYWN0ZXJzIGFyZSBub3QgdmFsaWQsIHNvIGp1c3QgcmVhZCByYXcgY29kZXBvaW50c1xyXG5cclxuXHQvKlxyXG5cdC8vIGRpcmVjdCBpbmNsdWRlIGZyb20gcGF5bG9hZCBpcyBzbWFsbGVyIHRoYW4gdGhlIGRlY29tcHJlc3Npb24gY29kZVxyXG5cdGNvbnN0IEZFTkNFRCA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRsZXQgY3AgPSByKCk7XHJcblx0XHRpZiAoY3ApIHJldHVybiBbY3AsIHJlYWRfc3RyKHIoKSldO1xyXG5cdH0pKTtcclxuXHQqL1xyXG5cdC8vIDIwMjMwMjE3OiB3ZSBzdGlsbCBuZWVkIGFsbCBDTSBmb3IgcHJvcGVyIGVycm9yIGZvcm1hdHRpbmdcclxuXHQvLyBidXQgbm9ybSBvbmx5IG5lZWRzIE5TTSBzdWJzZXQgdGhhdCBhcmUgcG90ZW50aWFsbHktdmFsaWRcclxuXHRDTSA9IHJlYWRfc29ydGVkX2FycmF5KCk7XHJcblx0TlNNID0gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLm1hcChpID0+IENNW2ldKSk7XHJcblx0Q00gPSBuZXcgU2V0KENNKTtcclxuXHRcclxuXHRFU0NBUEUgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gY2hhcmFjdGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJpbnRlZFxyXG5cdE5GQ19DSEVDSyA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBvbmx5IG5lZWRlZCB0byBpbGx1c3RyYXRlIGVuc190b2tlbml6ZSgpIHRyYW5zZm9ybWF0aW9uc1xyXG5cclxuXHRsZXQgY2h1bmtzID0gcmVhZF9zb3J0ZWRfYXJyYXlzKHIpO1xyXG5cdGxldCB1bnJlc3RyaWN0ZWQgPSByKCk7XHJcblx0Ly9jb25zdCByZWFkX2NodW5rZWQgPSAoKSA9PiBuZXcgU2V0KHJlYWRfc29ydGVkX2FycmF5KCkuZmxhdE1hcChpID0+IGNodW5rc1tpXSkuY29uY2F0KHJlYWRfc29ydGVkX2FycmF5KCkpKTtcclxuXHRjb25zdCByZWFkX2NodW5rZWQgPSAoKSA9PiB7XHJcblx0XHQvLyAyMDIzMDkyMTogYnVpbGQgc2V0IGluIHBhcnRzLCAyeCBmYXN0ZXJcclxuXHRcdGxldCBzZXQgPSBuZXcgU2V0KCk7XHJcblx0XHRyZWFkX3NvcnRlZF9hcnJheSgpLmZvckVhY2goaSA9PiBzZXRfYWRkX21hbnkoc2V0LCBjaHVua3NbaV0pKTtcclxuXHRcdHNldF9hZGRfbWFueShzZXQsIHJlYWRfc29ydGVkX2FycmF5KCkpO1xyXG5cdFx0cmV0dXJuIHNldDsgXHJcblx0fTtcclxuXHRHUk9VUFMgPSByZWFkX2FycmF5X3doaWxlKGkgPT4ge1xyXG5cdFx0Ly8gbWluaWZpZXIgcHJvcGVydHkgbWFuZ2xpbmcgc2VlbXMgdW5zYWZlXHJcblx0XHQvLyBzbyB0aGVzZSBhcmUgbWFudWFsbHkgcmVuYW1lZCB0byBzaW5nbGUgY2hhcnNcclxuXHRcdGxldCBOID0gcmVhZF9hcnJheV93aGlsZShyKS5tYXAoeCA9PiB4KzB4NjApO1xyXG5cdFx0aWYgKE4ubGVuZ3RoKSB7XHJcblx0XHRcdGxldCBSID0gaSA+PSB1bnJlc3RyaWN0ZWQ7IC8vIHVucmVzdHJpY3RlZCB0aGVuIHJlc3RyaWN0ZWRcclxuXHRcdFx0TlswXSAtPSAzMjsgLy8gY2FwaXRhbGl6ZVxyXG5cdFx0XHROID0gc3RyX2Zyb21fY3BzKE4pO1xyXG5cdFx0XHRpZiAoUikgTj1gUmVzdHJpY3RlZFske059XWA7XHJcblx0XHRcdGxldCBQID0gcmVhZF9jaHVua2VkKCk7IC8vIHByaW1hcnlcclxuXHRcdFx0bGV0IFEgPSByZWFkX2NodW5rZWQoKTsgLy8gc2Vjb25kYXJ5XHJcblx0XHRcdGxldCBNID0gIXIoKTsgLy8gbm90LXdoaXRlbGlzdGVkLCBjaGVjayBmb3IgTlNNXHJcblx0XHRcdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHRcdFx0LypcclxuXHRcdFx0bGV0IFYgPSBbLi4uUCwgLi4uUV0uc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gZGVyaXZlOiBzb3J0ZWQgdmFsaWRcclxuXHRcdFx0bGV0IE0gPSByKCktMTsgLy8gbnVtYmVyIG9mIGNvbWJpbmluZyBtYXJrXHJcblx0XHRcdGlmIChNIDwgMCkgeyAvLyB3aGl0ZWxpc3RlZFxyXG5cdFx0XHRcdE0gPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IGkgPSByKCk7XHJcblx0XHRcdFx0XHRpZiAoaSkgcmV0dXJuIFtWW2ktMV0sIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgdiA9IHJlYWRfYXJyYXlfd2hpbGUocik7XHJcblx0XHRcdFx0XHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHYubWFwKHggPT4geC0xKTtcclxuXHRcdFx0XHRcdH0pXTtcclxuXHRcdFx0XHR9KSk7XHJcblx0XHRcdH0qL1xyXG5cdFx0XHRyZXR1cm4ge04sIFAsIFEsIE0sIFJ9O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBkZWNvZGUgY29tcHJlc3NlZCB3aG9sZXNcclxuXHRXSE9MRV9WQUxJRCA9IHJlYWRfc29ydGVkX3NldCgpO1xyXG5cdFdIT0xFX01BUCA9IG5ldyBNYXAoKTtcclxuXHRsZXQgd2hvbGVzID0gcmVhZF9zb3J0ZWRfYXJyYXkoKS5jb25jYXQoQXJyYXlfZnJvbShXSE9MRV9WQUxJRCkpLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIG11c3QgYmUgc29ydGVkXHJcblx0d2hvbGVzLmZvckVhY2goKGNwLCBpKSA9PiB7XHJcblx0XHRsZXQgZCA9IHIoKTsgXHJcblx0XHRsZXQgdyA9IHdob2xlc1tpXSA9IGQgPyB3aG9sZXNbaS1kXSA6IHtWOiBbXSwgTTogbmV3IE1hcCgpfTtcclxuXHRcdHcuVi5wdXNoKGNwKTsgLy8gYWRkIHRvIG1lbWJlciBzZXRcclxuXHRcdGlmICghV0hPTEVfVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRXSE9MRV9NQVAuc2V0KGNwLCB3KTsgIC8vIHJlZ2lzdGVyIHdpdGggd2hvbGUgbWFwXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8vIGNvbXB1dGUgY29uZnVzYWJsZS1leHRlbnQgY29tcGxlbWVudHNcclxuXHQvLyB1c2FnZTogV0hPTEVfTUFQLmdldChjcCkuTS5nZXQoY3ApID0gY29tcGxlbWVudCBzZXRcclxuXHRmb3IgKGxldCB7ViwgTX0gb2YgbmV3IFNldChXSE9MRV9NQVAudmFsdWVzKCkpKSB7XHJcblx0XHQvLyBjb25uZWN0IGFsbCBncm91cHMgdGhhdCBoYXZlIGVhY2ggd2hvbGUgY2hhcmFjdGVyXHJcblx0XHRsZXQgcmVjcyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgVikge1xyXG5cdFx0XHRsZXQgZ3MgPSBHUk9VUFMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRcdGxldCByZWMgPSByZWNzLmZpbmQoKHtHfSkgPT4gZ3Muc29tZShnID0+IEcuaGFzKGcpKSk7XHJcblx0XHRcdGlmICghcmVjKSB7XHJcblx0XHRcdFx0cmVjID0ge0c6IG5ldyBTZXQoKSwgVjogW119O1xyXG5cdFx0XHRcdHJlY3MucHVzaChyZWMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJlYy5WLnB1c2goY3ApO1xyXG5cdFx0XHRzZXRfYWRkX21hbnkocmVjLkcsIGdzKTtcclxuXHRcdH1cclxuXHRcdC8vIHBlciBjaGFyYWN0ZXIgY2FjaGUgZ3JvdXBzIHdoaWNoIGFyZSBub3QgYSBtZW1iZXIgb2YgdGhlIGV4dGVudFxyXG5cdFx0bGV0IHVuaW9uID0gcmVjcy5mbGF0TWFwKHggPT4gQXJyYXlfZnJvbSh4LkcpKTsgLy8gYWxsIG9mIHRoZSBncm91cHMgdXNlZCBieSB0aGlzIHdob2xlXHJcblx0XHRmb3IgKGxldCB7RywgVn0gb2YgcmVjcykge1xyXG5cdFx0XHRsZXQgY29tcGxlbWVudCA9IG5ldyBTZXQodW5pb24uZmlsdGVyKGcgPT4gIUcuaGFzKGcpKSk7IC8vIGdyb3VwcyBub3QgY292ZXJlZCBieSB0aGUgZXh0ZW50XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0XHRNLnNldChjcCwgY29tcGxlbWVudCk7IC8vIHRoaXMgaXMgdGhlIHNhbWUgcmVmZXJlbmNlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGNvbXB1dGUgdmFsaWQgc2V0XHJcblx0Ly8gMjAyMzA5MjQ6IFZBTElEIHdhcyB1bmlvbiBidXQgY2FuIGJlIHJlLXVzZWRcclxuXHRWQUxJRCA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDErIGdyb3Vwc1xyXG5cdGxldCBtdWx0aSA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDIrIGdyb3Vwc1xyXG5cdGNvbnN0IGFkZF90b191bmlvbiA9IGNwID0+IFZBTElELmhhcyhjcCkgPyBtdWx0aS5hZGQoY3ApIDogVkFMSUQuYWRkKGNwKTtcclxuXHRmb3IgKGxldCBnIG9mIEdST1VQUykge1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5QKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5RKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdH1cclxuXHQvLyBkdWFsIHB1cnBvc2UgV0hPTEVfTUFQOiByZXR1cm4gcGxhY2Vob2xkZXIgaWYgdW5pcXVlIG5vbi1jb25mdXNhYmxlXHJcblx0Zm9yIChsZXQgY3Agb2YgVkFMSUQpIHtcclxuXHRcdGlmICghV0hPTEVfTUFQLmhhcyhjcCkgJiYgIW11bHRpLmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgVU5JUVVFX1BIKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gYWRkIGFsbCBkZWNvbXBvc2VkIHBhcnRzXHJcblx0Ly8gc2VlIGRlcml2ZTogXCJWYWxpZCBpcyBDbG9zZWQgKHZpYSBCcnV0ZS1mb3JjZSlcIlxyXG5cdHNldF9hZGRfbWFueShWQUxJRCwgbmZkKFZBTElEKSk7XHJcblx0XHJcblx0Ly8gZGVjb2RlIGVtb2ppXHJcblx0Ly8gMjAyMzA3MTk6IGVtb2ppIGFyZSBub3cgZnVsbHktZXhwYW5kZWQgdG8gYXZvaWQgcXVpcmsgbG9naWMgXHJcblx0RU1PSklfTElTVCA9IHJlYWRfdHJpZShyKS5tYXAodiA9PiBFbW9qaS5mcm9tKHYpKS5zb3J0KGNvbXBhcmVfYXJyYXlzKTtcclxuXHRFTU9KSV9ST09UID0gbmV3IE1hcCgpOyAvLyB0aGlzIGhhcyBhcHByb3ggN0sgbm9kZXMgKDIrIHBlciBlbW9qaSlcclxuXHRmb3IgKGxldCBjcHMgb2YgRU1PSklfTElTVCkge1xyXG5cdFx0Ly8gMjAyMzA3MTk6IGNoYW5nZSB0byAqc2xpZ2h0bHkqIHN0cmljdGVyIGFsZ29yaXRobSB3aGljaCBkaXNhbGxvd3MgXHJcblx0XHQvLyBpbnNlcnRpb24gb2YgbWlzcGxhY2VkIEZFMEYgaW4gZW1vamkgc2VxdWVuY2VzIChtYXRjaGluZyBFTlNJUC0xNSlcclxuXHRcdC8vIGV4YW1wbGU6IGJlYXV0aWZpZWQgW0EgQl0gKGVnLiBmbGFnIGVtb2ppKSBcclxuXHRcdC8vICBiZWZvcmU6IGFsbG93OiBbQSBGRTBGIEJdLCBlcnJvcjogW0EgRkUwRiBGRTBGIEJdIFxyXG5cdFx0Ly8gICBhZnRlcjogZXJyb3I6IGJvdGhcclxuXHRcdC8vIG5vdGU6IHRoaXMgY29kZSBub3cgbWF0Y2hlcyBFTlNOb3JtYWxpemUue2NzLGphdmF9IGxvZ2ljXHJcblx0XHRsZXQgcHJldiA9IFtFTU9KSV9ST09UXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRsZXQgbmV4dCA9IHByZXYubWFwKG5vZGUgPT4ge1xyXG5cdFx0XHRcdGxldCBjaGlsZCA9IG5vZGUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoIWNoaWxkKSB7XHJcblx0XHRcdFx0XHQvLyBzaG91bGQgdGhpcyBiZSBvYmplY3Q/IFxyXG5cdFx0XHRcdFx0Ly8gKG1vc3QgaGF2ZSAxLTIgaXRlbXMsIGZldyBoYXZlIG1hbnkpXHJcblx0XHRcdFx0XHQvLyAyMDIzMDcxOTogbm8sIHY4IGRlZmF1bHQgbWFwIGlzIDQ/XHJcblx0XHRcdFx0XHRjaGlsZCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRcdG5vZGUuc2V0KGNwLCBjaGlsZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmIChjcCA9PT0gRkUwRikge1xyXG5cdFx0XHRcdHByZXYucHVzaCguLi5uZXh0KTsgLy8gbGVzcyB0aGFuIDIwIGVsZW1lbnRzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJldiA9IG5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAobGV0IHggb2YgcHJldikge1xyXG5cdFx0XHR4LlYgPSBjcHM7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBpZiBlc2NhcGVkOiB7SEVYfVxyXG4vLyAgICAgICBlbHNlOiBcInhcIiB7SEVYfVxyXG5mdW5jdGlvbiBxdW90ZWRfY3AoY3ApIHtcclxuXHRyZXR1cm4gKHNob3VsZF9lc2NhcGUoY3ApID8gJycgOiBgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKFtjcF0pKX0gYCkgKyBxdW90ZV9jcChjcCk7XHJcbn1cclxuXHJcbi8vIDIwMjMwMjExOiBzb21lIG1lc3NhZ2VzIGNhbiBiZSBtaXhlZC1kaXJlY3Rpb25hbCBhbmQgcmVzdWx0IGluIHNwaWxsb3ZlclxyXG4vLyB1c2UgMjAwRSBhZnRlciBhIHF1b3RlZCBzdHJpbmcgdG8gZm9yY2UgdGhlIHJlbWFpbmRlciBvZiBhIHN0cmluZyBmcm9tIFxyXG4vLyBhY3F1cmluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBxdW90ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtYmlkaS11bmljb2RlLWNvbnRyb2xzI2V4Y2VwdGlvbnNcclxuZnVuY3Rpb24gYmlkaV9xcShzKSB7XHJcblx0cmV0dXJuIGBcIiR7c31cIlxcdTIwMEVgOyAvLyBzdHJvbmcgTFRSXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX2xhYmVsX2V4dGVuc2lvbihjcHMpIHtcclxuXHRpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwc1syXSA9PSBIWVBIRU4gJiYgY3BzWzNdID09IEhZUEhFTikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbjogXCIke3N0cl9mcm9tX2NwcyhjcHMuc2xpY2UoMCwgNCkpfVwiYCk7IC8vIHRoaXMgY2FuIG9ubHkgYmUgYXNjaWkgc28gY2FudCBiZSBiaWRpXHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShjcHMpIHtcclxuXHRjb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcclxuXHRmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpOyBpID4gMDsgKSB7XHJcblx0XHRpZiAoY3BzWy0taV0gIT09IFVOREVSU0NPUkUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bmRlcnNjb3JlIGFsbG93ZWQgb25seSBhdCBzdGFydCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4vLyBjaGVjayB0aGF0IGEgZmVuY2VkIGNwIGlzIG5vdCBsZWFkaW5nLCB0cmFpbGluZywgb3IgdG91Y2hpbmcgYW5vdGhlciBmZW5jZWQgY3BcclxuZnVuY3Rpb24gY2hlY2tfZmVuY2VkKGNwcykge1xyXG5cdGxldCBjcCA9IGNwc1swXTtcclxuXHRsZXQgcHJldiA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdGlmIChwcmV2KSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGxlYWRpbmcgJHtwcmV2fWApO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRsZXQgbGFzdCA9IC0xOyAvLyBwcmV2ZW50cyB0cmFpbGluZyBmcm9tIHRocm93aW5nXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNwID0gY3BzW2ldO1xyXG5cdFx0bGV0IG1hdGNoID0gRkVOQ0VELmdldChjcCk7XHJcblx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0Ly8gc2luY2UgY3BzWzBdIGlzbid0IGZlbmNlZCwgY3BzWzFdIGNhbm5vdCB0aHJvd1xyXG5cdFx0XHRpZiAobGFzdCA9PSBpKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYCR7cHJldn0gKyAke21hdGNofWApO1xyXG5cdFx0XHRsYXN0ID0gaSArIDE7XHJcblx0XHRcdHByZXYgPSBtYXRjaDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhc3QgPT0gbikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGB0cmFpbGluZyAke3ByZXZ9YCk7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIHNhZmUgdG8gcHJpbnQgc3RyaW5nIFxyXG4vLyBpbnZpc2libGVzIGFyZSBlc2NhcGVkXHJcbi8vIGxlYWRpbmcgY20gdXNlcyBwbGFjZWhvbGRlclxyXG4vLyBpZiBjcHMgZXhjZWVkIG1heCwgbWlkZGxlIHRydW5jYXRlIHdpdGggZWxsaXBzaXNcclxuLy8gcXVvdGVyKGNwKSA9PiBzdHJpbmcsIGVnLiAzMDAwID0+IFwiezMwMDB9XCJcclxuLy8gbm90ZTogaW4gaHRtbCwgeW91J2QgY2FsbCB0aGlzIGZ1bmN0aW9uIHRoZW4gcmVwbGFjZSBbPD4mXSB3aXRoIGVudGl0aWVzXHJcbmZ1bmN0aW9uIHNhZmVfc3RyX2Zyb21fY3BzKGNwcywgbWF4ID0gSW5maW5pdHksIHF1b3RlciA9IHF1b3RlX2NwKSB7XHJcblx0Ly9pZiAoTnVtYmVyLmlzSW50ZWdlcihjcHMpKSBjcHMgPSBbY3BzXTtcclxuXHQvL2lmICghQXJyYXkuaXNBcnJheShjcHMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBjb2RlcG9pbnRzYCk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGlmIChpc19jb21iaW5pbmdfbWFyayhjcHNbMF0pKSBidWYucHVzaCgn4peMJyk7XHJcblx0aWYgKGNwcy5sZW5ndGggPiBtYXgpIHtcclxuXHRcdG1heCA+Pj0gMTtcclxuXHRcdGNwcyA9IFsuLi5jcHMuc2xpY2UoMCwgbWF4KSwgMHgyMDI2LCAuLi5jcHMuc2xpY2UoLW1heCldO1xyXG5cdH1cclxuXHRsZXQgcHJldiA9IDA7XHJcblx0bGV0IG4gPSBjcHMubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaV07XHJcblx0XHRpZiAoc2hvdWxkX2VzY2FwZShjcCkpIHtcclxuXHRcdFx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBpKSkpO1xyXG5cdFx0XHRidWYucHVzaChxdW90ZXIoY3ApKTtcclxuXHRcdFx0cHJldiA9IGkgKyAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIG4pKSk7XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuLy8gbm90ZTogc2V0KHMpIGNhbm5vdCBiZSBleHBvc2VkIGJlY2F1c2UgdGhleSBjYW4gYmUgbW9kaWZpZWRcclxuLy8gbm90ZTogT2JqZWN0LmZyZWV6ZSgpIGRvZXNuJ3Qgd29ya1xyXG5mdW5jdGlvbiBpc19jb21iaW5pbmdfbWFyayhjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gQ00uaGFzKGNwKTtcclxufVxyXG5mdW5jdGlvbiBzaG91bGRfZXNjYXBlKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFU0NBUEUuaGFzKGNwKTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGFsbCBzdXBwb3J0ZWQgZW1vamkgYXMgZnVsbHktcXVhbGlmaWVkIGVtb2ppIFxyXG4vLyBvcmRlcmVkIGJ5IGxlbmd0aCB0aGVuIGxleGljb2dyYXBoaWMgXHJcbmZ1bmN0aW9uIGVuc19lbW9qaSgpIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVNT0pJX0xJU1QubWFwKHggPT4geC5zbGljZSgpKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplX2ZyYWdtZW50KGZyYWcsIGRlY29tcG9zZSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgbmYgPSBkZWNvbXBvc2UgPyBuZmQgOiBuZmM7XHJcblx0cmV0dXJuIGZyYWcuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHN0cl9mcm9tX2Nwcyh0b2tlbnNfZnJvbV9zdHIoZXhwbG9kZV9jcChsYWJlbCksIG5mLCBmaWx0ZXJfZmUwZikuZmxhdCgpKSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XHJcblx0cmV0dXJuIGZsYXR0ZW4oc3BsaXQobmFtZSwgbmZjLCBmaWx0ZXJfZmUwZikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfYmVhdXRpZnkobmFtZSkge1xyXG5cdGxldCBsYWJlbHMgPSBzcGxpdChuYW1lLCBuZmMsIHggPT4geCk7IC8vIGVtb2ppIG5vdCBleHBvc2VkXHJcblx0Zm9yIChsZXQge3R5cGUsIG91dHB1dCwgZXJyb3J9IG9mIGxhYmVscykge1xyXG5cdFx0aWYgKGVycm9yKSBicmVhazsgLy8gZmxhdHRlbiB3aWxsIHRocm93XHJcblxyXG5cdFx0Ly8gcmVwbGFjZSBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlblxyXG5cdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGJlYXV0aWZpbmcgYWxsIG9yIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuIHRvIHVuaWNvZGUgdmFyaWFudFxyXG5cdFx0Ly8gbm90IGV4YWN0bHkgdGhlIHNhbWUgaW4gZXZlcnkgZm9udCwgYnV0IHZlcnkgc2ltaWxhcjogXCItXCIgdnMgXCLigJBcIlxyXG5cdFx0LypcclxuXHRcdGNvbnN0IFVOSUNPREVfSFlQSEVOID0gMHgyMDEwO1xyXG5cdFx0Ly8gbWF5YmUgdGhpcyBzaG91bGQgcmVwbGFjZSBhbGwgZm9yIHZpc3VhbCBjb25zaXN0YW5jeT9cclxuXHRcdC8vIGBub2RlIHRvb2xzL3JlZy1jb3VudC5qcyByZWdleCBeLVxcezIsXFx9YCA9PiA1OTJcclxuXHRcdC8vZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIGlmIChvdXRwdXRbaV0gPT0gMHgyRCkgb3V0cHV0W2ldID0gMHgyMDEwO1xyXG5cdFx0aWYgKG91dHB1dFswXSA9PSBIWVBIRU4pIG91dHB1dFswXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0bGV0IGVuZCA9IG91dHB1dC5sZW5ndGgtMTtcclxuXHRcdGlmIChvdXRwdXRbZW5kXSA9PSBIWVBIRU4pIG91dHB1dFtlbmRdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHQqL1xyXG5cdFx0Ly8gMjAyMzAxMjM6IFdIQVRXRyBVUkwgdXNlcyBcIkNoZWNrSHlwaGVuc1wiIGZhbHNlXHJcblx0XHQvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lkbmFcclxuXHJcblx0XHQvLyB1cGRhdGUgZXRoZXJldW0gc3ltYm9sXHJcblx0XHQvLyDOviA9PiDOniBpZiBub3QgZ3JlZWtcclxuXHRcdGlmICh0eXBlICE9PSAnR3JlZWsnKSBhcnJheV9yZXBsYWNlKG91dHB1dCwgMHgzQkUsIDB4MzlFKTtcclxuXHJcblx0XHQvLyAyMDIyMTIxMzogZml4ZXMgYmlkaSBzdWJkb21haW4gaXNzdWUsIGJ1dCBicmVha3MgaW52YXJpYW50ICgyMDBFIGlzIGRpc2FsbG93ZWQpXHJcblx0XHQvLyBjb3VsZCBiZSBmaXhlZCB3aXRoIHNwZWNpYWwgY2FzZSBmb3I6IDJEICguKSArIDIwMEUgKExUUilcclxuXHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2JpZGktbGFiZWwtb3JkZXJpbmctc3Bvb2YvMTU4MjRcclxuXHRcdC8vb3V0cHV0LnNwbGljZSgwLCAwLCAweDIwMEUpO1xyXG5cdH1cclxuXHRyZXR1cm4gZmxhdHRlbihsYWJlbHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheV9yZXBsYWNlKHYsIGEsIGIpIHtcclxuXHRsZXQgcHJldiA9IDA7XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCBuZXh0ID0gdi5pbmRleE9mKGEsIHByZXYpO1xyXG5cdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdHZbbmV4dF0gPSBiOyBcclxuXHRcdHByZXYgPSBuZXh0ICsgMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19zcGxpdChuYW1lLCBwcmVzZXJ2ZV9lbW9qaSkge1xyXG5cdHJldHVybiBzcGxpdChuYW1lLCBuZmMsIHByZXNlcnZlX2Vtb2ppID8geCA9PiB4LnNsaWNlKCkgOiBmaWx0ZXJfZmUwZik7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXQobmFtZSwgbmYsIGVmKSB7XHJcblx0aWYgKCFuYW1lKSByZXR1cm4gW107IC8vIDIwMjMwNzE5OiBlbXB0eSBuYW1lIGFsbG93YW5jZVxyXG5cdGluaXQoKTtcclxuXHRsZXQgb2Zmc2V0ID0gMDtcclxuXHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHQvLyA0LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgY29udGFpbiBhIFUrMDAyRSAoIC4gKSBGVUxMIFNUT1AuXCJcclxuXHRyZXR1cm4gbmFtZS5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4ge1xyXG5cdFx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChsYWJlbCk7XHJcblx0XHRsZXQgaW5mbyA9IHtcclxuXHRcdFx0aW5wdXQsXHJcblx0XHRcdG9mZnNldCwgLy8gY29kZXBvaW50LCBub3Qgc3Vic3RyaW5nIVxyXG5cdFx0fTtcclxuXHRcdG9mZnNldCArPSBpbnB1dC5sZW5ndGggKyAxOyAvLyArIHN0b3BcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIDEuKSBcIlRoZSBsYWJlbCBtdXN0IGJlIGluIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3JtIE5GQ1wiXHJcblx0XHRcdGxldCB0b2tlbnMgPSBpbmZvLnRva2VucyA9IHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKTtcclxuXHRcdFx0bGV0IHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuXHRcdFx0bGV0IHR5cGU7XHJcblx0XHRcdGlmICghdG9rZW5fY291bnQpIHsgLy8gdGhlIGxhYmVsIHdhcyBlZmZlY3RpdmVseSBlbXB0eSAoY291bGQgb2YgaGFkIGlnbm9yZWQgY2hhcmFjdGVycylcclxuXHRcdFx0XHQvL25vcm0gPSBbXTtcclxuXHRcdFx0XHQvL3R5cGUgPSAnTm9uZSc7IC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgbmV4dCBtYXRjaCwgXCJBU0NJSVwiXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjA6IGNoYW5nZSB0byBzdHJpY3RcclxuXHRcdFx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9lbnMtbmFtZS1ub3JtYWxpemF0aW9uLTJuZC8xNDU2NC81OVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZW1wdHkgbGFiZWxgKTtcclxuXHRcdFx0fSBcclxuXHRcdFx0bGV0IG5vcm0gPSBpbmZvLm91dHB1dCA9IHRva2Vucy5mbGF0KCk7XHJcblx0XHRcdGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShub3JtKTtcclxuXHRcdFx0bGV0IGVtb2ppID0gaW5mby5lbW9qaSA9IHRva2VuX2NvdW50ID4gMSB8fCB0b2tlbnNbMF0uaXNfZW1vamk7IC8vIHNhbWUgYXM6IHRva2Vucy5zb21lKHggPT4geC5pc19lbW9qaSk7XHJcblx0XHRcdGlmICghZW1vamkgJiYgbm9ybS5ldmVyeShjcCA9PiBjcCA8IDB4ODApKSB7IC8vIHNwZWNpYWwgY2FzZSBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyAyMDIzMDEyMzogbWF0Y2hlcyBtYXRjaGVzIFdIQVRXRywgc2VlIG5vdGUgMy4zXHJcblx0XHRcdFx0Y2hlY2tfbGFiZWxfZXh0ZW5zaW9uKG5vcm0pOyAvLyBvbmx5IG5lZWRlZCBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgZmVuY2VkXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGNtXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIHdob2xlc1xyXG5cdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiRmFzdHBhdGggQVNDSUlcIlxyXG5cdFx0XHRcdHR5cGUgPSAnQVNDSUknO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjaGFycyA9IHRva2Vucy5mbGF0TWFwKHggPT4geC5pc19lbW9qaSA/IFtdIDogeCk7IC8vIGFsbCBvZiB0aGUgbmZjIHRva2VucyBjb25jYXQgdG9nZXRoZXJcclxuXHRcdFx0XHRpZiAoIWNoYXJzLmxlbmd0aCkgeyAvLyB0aGVyZXMgbm8gdGV4dCwganVzdCBlbW9qaVxyXG5cdFx0XHRcdFx0dHlwZSA9ICdFbW9qaSc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIDUuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgY29tYmluaW5nIG1hcmssIHRoYXQgaXM6IEdlbmVyYWxfQ2F0ZWdvcnk9TWFyay5cIlxyXG5cdFx0XHRcdFx0aWYgKENNLmhhcyhub3JtWzBdKSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KCdsZWFkaW5nIGNvbWJpbmluZyBtYXJrJyk7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRva2VuX2NvdW50OyBpKyspIHsgLy8gd2UndmUgYWxyZWFkeSBjaGVja2VkIHRoZSBmaXJzdCB0b2tlblxyXG5cdFx0XHRcdFx0XHRsZXQgY3BzID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdFx0XHRpZiAoIWNwcy5pc19lbW9qaSAmJiBDTS5oYXMoY3BzWzBdKSkgeyAvLyBldmVyeSB0ZXh0IHRva2VuIGhhcyBlbW9qaSBuZWlnaGJvcnMsIGVnLiBFdEVFRXRFdC4uLlxyXG5cdFx0XHRcdFx0XHRcdC8vIGJpZGlfcXEoKSBub3QgbmVlZGVkIHNpbmNlIGVtb2ppIGlzIExUUiBhbmQgY3BzIGlzIGEgQ01cclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGVtb2ppICsgY29tYmluaW5nIG1hcms6IFwiJHtzdHJfZnJvbV9jcHModG9rZW5zW2ktMV0pfSArICR7c2FmZV9zdHJfZnJvbV9jcHMoW2Nwc1swXV0pfVwiYCk7IFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjaGVja19mZW5jZWQobm9ybSk7XHJcblx0XHRcdFx0XHRsZXQgdW5pcXVlID0gQXJyYXlfZnJvbShuZXcgU2V0KGNoYXJzKSk7XHJcblx0XHRcdFx0XHRsZXQgW2ddID0gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSk7IC8vIHRha2UgdGhlIGZpcnN0IG1hdGNoXHJcblx0XHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIk1hdGNoaW5nIEdyb3VwcyBoYXZlIFNhbWUgQ00gU3R5bGVcIlxyXG5cdFx0XHRcdFx0Ly8gYWx0ZXJuYXRpdmU6IGNvdWxkIGZvcm0gYSBoeWJyaWQgdHlwZTogTGF0aW4vSmFwYW5lc2UvLi4uXHRcclxuXHRcdFx0XHRcdGNoZWNrX2dyb3VwKGcsIGNoYXJzKTsgLy8gbmVlZCB0ZXh0IGluIG9yZGVyXHJcblx0XHRcdFx0XHRjaGVja193aG9sZShnLCB1bmlxdWUpOyAvLyBvbmx5IG5lZWQgdW5pcXVlIHRleHQgKG9yZGVyIHdvdWxkIGJlIHJlcXVpcmVkIGZvciBtdWx0aXBsZS1jaGFyIGNvbmZ1c2FibGVzKVxyXG5cdFx0XHRcdFx0dHlwZSA9IGcuTjtcclxuXHRcdFx0XHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBleHBvc2luZyByZXN0cmljdGVkIGZsYWdcclxuXHRcdFx0XHRcdC8vIGl0J3Mgc2ltcGxlciB0byBqdXN0IGNoZWNrIGZvciAnUmVzdHJpY3RlZCdcclxuXHRcdFx0XHRcdC8vIG9yIGV2ZW4gYmV0dGVyOiB0eXBlLmVuZHNXaXRoKCddJylcclxuXHRcdFx0XHRcdC8vaWYgKGcuUikgaW5mby5yZXN0cmljdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aW5mby50eXBlID0gdHlwZTtcclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRpbmZvLmVycm9yID0gZXJyOyAvLyB1c2UgZnVsbCBlcnJvciBvYmplY3RcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbmZvO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja193aG9sZShncm91cCwgdW5pcXVlKSB7XHJcblx0bGV0IG1ha2VyO1xyXG5cdGxldCBzaGFyZWQgPSBbXTtcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdGxldCB3aG9sZSA9IFdIT0xFX01BUC5nZXQoY3ApO1xyXG5cdFx0aWYgKHdob2xlID09PSBVTklRVUVfUEgpIHJldHVybjsgLy8gdW5pcXVlLCBub24tY29uZnVzYWJsZVxyXG5cdFx0aWYgKHdob2xlKSB7XHJcblx0XHRcdGxldCBzZXQgPSB3aG9sZS5NLmdldChjcCk7IC8vIGdyb3VwcyB3aGljaCBoYXZlIGEgY2hhcmFjdGVyIHRoYXQgbG9vay1saWtlIHRoaXMgY2hhcmFjdGVyXHJcblx0XHRcdG1ha2VyID0gbWFrZXIgPyBtYWtlci5maWx0ZXIoZyA9PiBzZXQuaGFzKGcpKSA6IEFycmF5X2Zyb20oc2V0KTtcclxuXHRcdFx0aWYgKCFtYWtlci5sZW5ndGgpIHJldHVybjsgLy8gY29uZnVzYWJsZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNoYXJlZC5wdXNoKGNwKTsgXHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChtYWtlcikge1xyXG5cdFx0Ly8gd2UgaGF2ZSAxKyBjb25mdXNhYmxlXHJcblx0XHQvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHJlbWFpbmluZyBncm91cHNcclxuXHRcdC8vIGNvbnRhaW4gdGhlIHNoYXJlZCBjaGFyYWN0ZXJzIHRvb1xyXG5cdFx0Zm9yIChsZXQgZyBvZiBtYWtlcikge1xyXG5cdFx0XHRpZiAoc2hhcmVkLmV2ZXJ5KGNwID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB3aG9sZS1zY3JpcHQgY29uZnVzYWJsZTogJHtncm91cC5OfS8ke2cuTn1gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogdW5pcXVlLnNpemUgPiAwXHJcbi8vIHJldHVybnMgbGlzdCBvZiBtYXRjaGluZyBncm91cHNcclxuZnVuY3Rpb24gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSkge1xyXG5cdGxldCBncm91cHMgPSBHUk9VUFM7XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHQvLyBub3RlOiB3ZSBuZWVkIHRvIGRvZGdlIENNIHRoYXQgYXJlIHdoaXRlbGlzdGVkXHJcblx0XHQvLyBidXQgdGhhdCBjb2RlIGlzbid0IGN1cnJlbnRseSBuZWNlc3NhcnlcclxuXHRcdGxldCBncyA9IGdyb3Vwcy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdGlmICghZ3MubGVuZ3RoKSB7XHJcblx0XHRcdGlmICghR1JPVVBTLnNvbWUoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkgeyBcclxuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIHdhcyBjb21wb3NlZCBvZiB2YWxpZCBwYXJ0c1xyXG5cdFx0XHRcdC8vIGJ1dCBpdCdzIE5GQyBmb3JtIGlzIGludmFsaWRcclxuXHRcdFx0XHQvLyAyMDIzMDcxNjogY2hhbmdlIHRvIG1vcmUgZXhhY3Qgc3RhdGVtZW50LCBzZWU6IEVOU05vcm1hbGl6ZS57Y3MsamF2YX1cclxuXHRcdFx0XHQvLyBub3RlOiB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZSBhIGNvbXBvc2l0aW9uXHJcblx0XHRcdFx0Ly8gMjAyMzA3MjA6IGNoYW5nZSB0byBmdWxsIGNoZWNrXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7IC8vIHRoaXMgc2hvdWxkIGJlIHJhcmVcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBncm91cCB0aGF0IGNvbnRhaW5zIGFsbCB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0XHRcdFx0Ly8gdGhyb3cgdXNpbmcgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgZ3JvdXAgdGhhdCBtYXRjaGVkXHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZ3JvdXBzWzBdLCBjcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGdyb3VwcyA9IGdzO1xyXG5cdFx0aWYgKGdzLmxlbmd0aCA9PSAxKSBicmVhazsgLy8gdGhlcmUgaXMgb25seSBvbmUgZ3JvdXAgbGVmdFxyXG5cdH1cclxuXHQvLyB0aGVyZSBhcmUgYXQgbGVhc3QgMSBncm91cChzKSB3aXRoIGFsbCBvZiB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0cmV0dXJuIGdyb3VwcztcclxufVxyXG5cclxuLy8gdGhyb3cgb24gZmlyc3QgZXJyb3JcclxuZnVuY3Rpb24gZmxhdHRlbihzcGxpdCkge1xyXG5cdHJldHVybiBzcGxpdC5tYXAoKHtpbnB1dCwgZXJyb3IsIG91dHB1dH0pID0+IHtcclxuXHRcdGlmIChlcnJvcikge1xyXG5cdFx0XHQvLyBkb24ndCBwcmludCBsYWJlbCBhZ2FpbiBpZiBqdXN0IGEgc2luZ2xlIGxhYmVsXHJcblx0XHRcdGxldCBtc2cgPSBlcnJvci5tZXNzYWdlO1xyXG5cdFx0XHQvLyBiaWRpX3FxKCkgb25seSBuZWNlc3NhcnkgaWYgbXNnIGlzIGRpZ2l0c1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3BsaXQubGVuZ3RoID09IDEgPyBtc2cgOiBgSW52YWxpZCBsYWJlbCAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoaW5wdXQsIDYzKSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTsgLy8gb25seSBjaGVjayBwcmltYXJ5XHJcblx0aWYgKGdnKSB7XHJcblx0XHRxdW90ZWQgPSBgJHtnZy5OfSAke3F1b3RlZH1gO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIG1peHR1cmU6ICR7Zy5OfSArICR7cXVvdGVkfWApO1xyXG59XHJcbmZ1bmN0aW9uIGVycm9yX3BsYWNlbWVudCh3aGVyZSkge1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgcGxhY2VtZW50OiAke3doZXJlfWApO1xyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiBjcHMubGVuZ3RoID4gMFxyXG4vLyBhc3N1bXB0aW9uOiBjcHNbMF0gaXNuJ3QgYSBDTVxyXG4vLyBhc3N1bXB0aW9uOiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzbid0IGFuIGVtb2ppXHJcbmZ1bmN0aW9uIGNoZWNrX2dyb3VwKGcsIGNwcykge1xyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0aWYgKCFncm91cF9oYXNfY3AoZywgY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5QLCAuLi5nLlFdLmZsYXRNYXAobmZjKS5maWx0ZXIoY3AgPT4gQ00uaGFzKGNwKSkpXHJcblx0XHRcdC8vICAgMy4gd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2lmIChNID49IDApIHsgLy8gd2UgaGF2ZSBhIGtub3duIGZpeGVkIGNtIGNvdW50XHJcblx0aWYgKGcuTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIG5vbi1zcGFjaW5nIG1hcmtzOiAke3F1b3RlZF9jcChjcCl9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcGFyc2UgdG8gZW5kIHNvIHdlIGhhdmUgZnVsbCBuc20gY291bnRcclxuXHRcdFx0XHQvLyBiLiBGb3JiaWQgc2VxdWVuY2VzIG9mIG1vcmUgdGhhbiA0IG5vbnNwYWNpbmcgbWFya3MgKGdjPU1uIG9yIGdjPU1lKS5cclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBOU01fTUFYKSB7XHJcblx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIHNsaWNlIHN0YXJ0cyB3aXRoIGEgYmFzZSBjaGFyIG9yIHNwYWNpbmctbWFyayBjbVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleGNlc3NpdmUgbm9uLXNwYWNpbmcgbWFya3M6ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG4vLyAyMDIzMDgxODogcmVuYW1lIGZvciAncHJvY2VzcycgbmFtZSBjb2xsaXNpb24gaC90IEphdmFyb21lXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzIzXHJcbmZ1bmN0aW9uIHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBjaGFycyA9IFtdO1xyXG5cdGlucHV0ID0gaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIGZsaXAgc28gd2UgY2FuIHBvcFxyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQpO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdFx0XHRcdGNoYXJzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0LnB1c2goZWYoZW1vamkpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7IC8vIGxlc3MgdGhhbiAxMCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzA5MTI6IHVuaWNvZGUgMTUuMSBjaGFuZ2VkIHRoZSBvcmRlciBvZiBwcm9jZXNzaW5nIHN1Y2ggdGhhdFxyXG5cdFx0XHRcdFx0Ly8gZGlzYWxsb3dlZCBwYXJ0cyBhcmUgb25seSByZWplY3RlZCBhZnRlciBORkNcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2Vzbid0IGltcGFjdCBub3JtYWxpemF0aW9uIGFzIG9mIHRvZGF5XHJcblx0XHRcdFx0XHQvLyB0ZWNobmljYWxseSwgdGhpcyBlcnJvciBjYW4gYmUgcmVtb3ZlZCBhcyB0aGUgZ3JvdXAgbG9naWMgd2lsbCBhcHBseSBzaW1pbGFyIGxvZ2ljXHJcblx0XHRcdFx0XHQvLyBob3dldmVyIHRoZSBlcnJvciB0eXBlIG1pZ2h0IGJlIGxlc3MgY2xlYXJcclxuXHRcdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcclxuXHRyZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSBGRTBGKTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYXJyYXkgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIHRoZSBsb25nZXN0IHZhbGlkIGVtb2ppIHNlcXVlbmNlIChvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2gpXHJcbi8vICpNVVRBVEVTKiB0aGUgc3VwcGxpZWQgYXJyYXlcclxuLy8gZGlzYWxsb3dzIGludGVybGVhdmVkIGlnbm9yZWQgY2hhcmFjdGVyc1xyXG4vLyBmaWxscyAob3B0aW9uYWwpIGVhdGVuIGFycmF5IHdpdGggbWF0Y2hlZCBjb2RlcG9pbnRzXHJcbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xyXG5cdGxldCBub2RlID0gRU1PSklfUk9PVDtcclxuXHRsZXQgZW1vamk7XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0d2hpbGUgKHBvcykge1xyXG5cdFx0bm9kZSA9IG5vZGUuZ2V0KGNwc1stLXBvc10pO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGxldCB7Vn0gPSBub2RlO1xyXG5cdFx0aWYgKFYpIHsgLy8gdGhpcyBpcyBhIHZhbGlkIGVtb2ppIChzbyBmYXIpXHJcblx0XHRcdGVtb2ppID0gVjtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKC4uLmNwcy5zbGljZShwb3MpLnJldmVyc2UoKSk7IC8vIChvcHRpb25hbCkgY29weSBpbnB1dCwgdXNlZCBmb3IgZW5zX3Rva2VuaXplKClcclxuXHRcdFx0Y3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVtb2ppO1xyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTtcclxuXHRsZXQgZWF0ZW4gPSBbXTtcclxuXHRsZXQgdG9rZW5zID0gW107XHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHR0eXBlOiBUWV9FTU9KSSxcclxuXHRcdFx0XHRlbW9qaTogZW1vamkuc2xpY2UoKSwgLy8gY29weSBlbW9qaVxyXG5cdFx0XHRcdGlucHV0OiBlYXRlbixcclxuXHRcdFx0XHRjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0ZWF0ZW4gPSBbXTsgLy8gcmVzZXQgYnVmZmVyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cblxuZXhwb3J0cy5lbnNfYmVhdXRpZnkgPSBlbnNfYmVhdXRpZnk7XG5leHBvcnRzLmVuc19lbW9qaSA9IGVuc19lbW9qaTtcbmV4cG9ydHMuZW5zX25vcm1hbGl6ZSA9IGVuc19ub3JtYWxpemU7XG5leHBvcnRzLmVuc19ub3JtYWxpemVfZnJhZ21lbnQgPSBlbnNfbm9ybWFsaXplX2ZyYWdtZW50O1xuZXhwb3J0cy5lbnNfc3BsaXQgPSBlbnNfc3BsaXQ7XG5leHBvcnRzLmVuc190b2tlbml6ZSA9IGVuc190b2tlbml6ZTtcbmV4cG9ydHMuaXNfY29tYmluaW5nX21hcmsgPSBpc19jb21iaW5pbmdfbWFyaztcbmV4cG9ydHMubmZjID0gbmZjO1xuZXhwb3J0cy5uZmQgPSBuZmQ7XG5leHBvcnRzLnNhZmVfc3RyX2Zyb21fY3BzID0gc2FmZV9zdHJfZnJvbV9jcHM7XG5leHBvcnRzLnNob3VsZF9lc2NhcGUgPSBzaG91bGRfZXNjYXBlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AES_key, _AES_Kd, _AES_Ke;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AES = void 0;\n// Number of rounds by keysize\nconst numberOfRounds = { 16: 10, 24: 12, 32: 14 };\n// Round constant words\nconst rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\n// S-box and Inverse S-box (S is for Substitution)\nconst S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\nconst Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\n// Transformations for encryption\nconst T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\nconst T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\nconst T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\nconst T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\n// Transformations for decryption\nconst T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\nconst T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\nconst T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\nconst T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\n// Transformations for decryption key expansion\nconst U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\nconst U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\nconst U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\nconst U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\nfunction convertToInt32(bytes) {\n    const result = [];\n    for (let i = 0; i < bytes.length; i += 4) {\n        result.push((bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | bytes[i + 3]);\n    }\n    return result;\n}\nclass AES {\n    get key() { return __classPrivateFieldGet(this, _AES_key, \"f\").slice(); }\n    constructor(key) {\n        _AES_key.set(this, void 0);\n        _AES_Kd.set(this, void 0);\n        _AES_Ke.set(this, void 0);\n        if (!(this instanceof AES)) {\n            throw Error('AES must be instanitated with `new`');\n        }\n        __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), \"f\");\n        const rounds = numberOfRounds[this.key.length];\n        if (rounds == null) {\n            throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');\n        }\n        // encryption round keys\n        __classPrivateFieldSet(this, _AES_Ke, [], \"f\");\n        // decryption round keys\n        __classPrivateFieldSet(this, _AES_Kd, [], \"f\");\n        for (let i = 0; i <= rounds; i++) {\n            __classPrivateFieldGet(this, _AES_Ke, \"f\").push([0, 0, 0, 0]);\n            __classPrivateFieldGet(this, _AES_Kd, \"f\").push([0, 0, 0, 0]);\n        }\n        const roundKeyCount = (rounds + 1) * 4;\n        const KC = this.key.length / 4;\n        // convert the key into ints\n        const tk = convertToInt32(this.key);\n        // copy values into round key arrays\n        let index;\n        for (let i = 0; i < KC; i++) {\n            index = i >> 2;\n            __classPrivateFieldGet(this, _AES_Ke, \"f\")[index][i % 4] = tk[i];\n            __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - index][i % 4] = tk[i];\n        }\n        // key expansion (fips-197 section 5.2)\n        let rconpointer = 0;\n        let t = KC, tt;\n        while (t < roundKeyCount) {\n            tt = tk[KC - 1];\n            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n                (S[(tt >> 8) & 0xFF] << 16) ^\n                (S[tt & 0xFF] << 8) ^\n                S[(tt >> 24) & 0xFF] ^\n                (rcon[rconpointer] << 24));\n            rconpointer += 1;\n            // key expansion (for non-256 bit)\n            if (KC != 8) {\n                for (let i = 1; i < KC; i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n                // key expansion for 256-bit keys is \"slightly different\" (fips-197)\n            }\n            else {\n                for (let i = 1; i < (KC / 2); i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n                tt = tk[(KC / 2) - 1];\n                tk[KC / 2] ^= (S[tt & 0xFF] ^\n                    (S[(tt >> 8) & 0xFF] << 8) ^\n                    (S[(tt >> 16) & 0xFF] << 16) ^\n                    (S[(tt >> 24) & 0xFF] << 24));\n                for (let i = (KC / 2) + 1; i < KC; i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n            }\n            // copy values into round key arrays\n            let i = 0, r, c;\n            while (i < KC && t < roundKeyCount) {\n                r = t >> 2;\n                c = t % 4;\n                __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][c] = tk[i];\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - r][c] = tk[i++];\n                t++;\n            }\n        }\n        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n        for (let r = 1; r < rounds; r++) {\n            for (let c = 0; c < 4; c++) {\n                tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c];\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c] = (U1[(tt >> 24) & 0xFF] ^\n                    U2[(tt >> 16) & 0xFF] ^\n                    U3[(tt >> 8) & 0xFF] ^\n                    U4[tt & 0xFF]);\n            }\n        }\n    }\n    encrypt(plaintext) {\n        if (plaintext.length != 16) {\n            throw new TypeError('invalid plaintext size (must be 16 bytes)');\n        }\n        const rounds = __classPrivateFieldGet(this, _AES_Ke, \"f\").length - 1;\n        const a = [0, 0, 0, 0];\n        // convert plaintext to (ints ^ key)\n        let t = convertToInt32(plaintext);\n        for (let i = 0; i < 4; i++) {\n            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, \"f\")[0][i];\n        }\n        // apply round transforms\n        for (let r = 1; r < rounds; r++) {\n            for (let i = 0; i < 4; i++) {\n                a[i] = (T1[(t[i] >> 24) & 0xff] ^\n                    T2[(t[(i + 1) % 4] >> 16) & 0xff] ^\n                    T3[(t[(i + 2) % 4] >> 8) & 0xff] ^\n                    T4[t[(i + 3) % 4] & 0xff] ^\n                    __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][i]);\n            }\n            t = a.slice();\n        }\n        // the last round is special\n        const result = new Uint8Array(16);\n        let tt = 0;\n        for (let i = 0; i < 4; i++) {\n            tt = __classPrivateFieldGet(this, _AES_Ke, \"f\")[rounds][i];\n            result[4 * i] = (S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n            result[4 * i + 2] = (S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;\n            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;\n        }\n        return result;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length != 16) {\n            throw new TypeError('invalid ciphertext size (must be 16 bytes)');\n        }\n        const rounds = __classPrivateFieldGet(this, _AES_Kd, \"f\").length - 1;\n        const a = [0, 0, 0, 0];\n        // convert plaintext to (ints ^ key)\n        let t = convertToInt32(ciphertext);\n        for (let i = 0; i < 4; i++) {\n            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, \"f\")[0][i];\n        }\n        // apply round transforms\n        for (let r = 1; r < rounds; r++) {\n            for (let i = 0; i < 4; i++) {\n                a[i] = (T5[(t[i] >> 24) & 0xff] ^\n                    T6[(t[(i + 3) % 4] >> 16) & 0xff] ^\n                    T7[(t[(i + 2) % 4] >> 8) & 0xff] ^\n                    T8[t[(i + 1) % 4] & 0xff] ^\n                    __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][i]);\n            }\n            t = a.slice();\n        }\n        // the last round is special\n        const result = new Uint8Array(16);\n        let tt = 0;\n        for (let i = 0; i < 4; i++) {\n            tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds][i];\n            result[4 * i] = (Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;\n            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;\n        }\n        return result;\n    }\n}\nexports.AES = AES;\n_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();\n//# sourceMappingURL=aes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL2Flcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVc7QUFDWDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEMsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL2Flcy5qcz82MzYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIE1JVCBMaWNlbnNlLiBDb3B5cmlnaHQgMjAxNS0yMDIyIFJpY2hhcmQgTW9vcmUgPG1lQHJpY21vby5jb20+LiBTZWUgTElDRU5TRS50eHQuICovXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX0FFU19rZXksIF9BRVNfS2QsIF9BRVNfS2U7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFFUyA9IHZvaWQgMDtcbi8vIE51bWJlciBvZiByb3VuZHMgYnkga2V5c2l6ZVxuY29uc3QgbnVtYmVyT2ZSb3VuZHMgPSB7IDE2OiAxMCwgMjQ6IDEyLCAzMjogMTQgfTtcbi8vIFJvdW5kIGNvbnN0YW50IHdvcmRzXG5jb25zdCByY29uID0gWzB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsIDB4MmYsIDB4NWUsIDB4YmMsIDB4NjMsIDB4YzYsIDB4OTcsIDB4MzUsIDB4NmEsIDB4ZDQsIDB4YjMsIDB4N2QsIDB4ZmEsIDB4ZWYsIDB4YzUsIDB4OTFdO1xuLy8gUy1ib3ggYW5kIEludmVyc2UgUy1ib3ggKFMgaXMgZm9yIFN1YnN0aXR1dGlvbilcbmNvbnN0IFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XG5jb25zdCBTaSA9IFsweDUyLCAweDA5LCAweDZhLCAweGQ1LCAweDMwLCAweDM2LCAweGE1LCAweDM4LCAweGJmLCAweDQwLCAweGEzLCAweDllLCAweDgxLCAweGYzLCAweGQ3LCAweGZiLCAweDdjLCAweGUzLCAweDM5LCAweDgyLCAweDliLCAweDJmLCAweGZmLCAweDg3LCAweDM0LCAweDhlLCAweDQzLCAweDQ0LCAweGM0LCAweGRlLCAweGU5LCAweGNiLCAweDU0LCAweDdiLCAweDk0LCAweDMyLCAweGE2LCAweGMyLCAweDIzLCAweDNkLCAweGVlLCAweDRjLCAweDk1LCAweDBiLCAweDQyLCAweGZhLCAweGMzLCAweDRlLCAweDA4LCAweDJlLCAweGExLCAweDY2LCAweDI4LCAweGQ5LCAweDI0LCAweGIyLCAweDc2LCAweDViLCAweGEyLCAweDQ5LCAweDZkLCAweDhiLCAweGQxLCAweDI1LCAweDcyLCAweGY4LCAweGY2LCAweDY0LCAweDg2LCAweDY4LCAweDk4LCAweDE2LCAweGQ0LCAweGE0LCAweDVjLCAweGNjLCAweDVkLCAweDY1LCAweGI2LCAweDkyLCAweDZjLCAweDcwLCAweDQ4LCAweDUwLCAweGZkLCAweGVkLCAweGI5LCAweGRhLCAweDVlLCAweDE1LCAweDQ2LCAweDU3LCAweGE3LCAweDhkLCAweDlkLCAweDg0LCAweDkwLCAweGQ4LCAweGFiLCAweDAwLCAweDhjLCAweGJjLCAweGQzLCAweDBhLCAweGY3LCAweGU0LCAweDU4LCAweDA1LCAweGI4LCAweGIzLCAweDQ1LCAweDA2LCAweGQwLCAweDJjLCAweDFlLCAweDhmLCAweGNhLCAweDNmLCAweDBmLCAweDAyLCAweGMxLCAweGFmLCAweGJkLCAweDAzLCAweDAxLCAweDEzLCAweDhhLCAweDZiLCAweDNhLCAweDkxLCAweDExLCAweDQxLCAweDRmLCAweDY3LCAweGRjLCAweGVhLCAweDk3LCAweGYyLCAweGNmLCAweGNlLCAweGYwLCAweGI0LCAweGU2LCAweDczLCAweDk2LCAweGFjLCAweDc0LCAweDIyLCAweGU3LCAweGFkLCAweDM1LCAweDg1LCAweGUyLCAweGY5LCAweDM3LCAweGU4LCAweDFjLCAweDc1LCAweGRmLCAweDZlLCAweDQ3LCAweGYxLCAweDFhLCAweDcxLCAweDFkLCAweDI5LCAweGM1LCAweDg5LCAweDZmLCAweGI3LCAweDYyLCAweDBlLCAweGFhLCAweDE4LCAweGJlLCAweDFiLCAweGZjLCAweDU2LCAweDNlLCAweDRiLCAweGM2LCAweGQyLCAweDc5LCAweDIwLCAweDlhLCAweGRiLCAweGMwLCAweGZlLCAweDc4LCAweGNkLCAweDVhLCAweGY0LCAweDFmLCAweGRkLCAweGE4LCAweDMzLCAweDg4LCAweDA3LCAweGM3LCAweDMxLCAweGIxLCAweDEyLCAweDEwLCAweDU5LCAweDI3LCAweDgwLCAweGVjLCAweDVmLCAweDYwLCAweDUxLCAweDdmLCAweGE5LCAweDE5LCAweGI1LCAweDRhLCAweDBkLCAweDJkLCAweGU1LCAweDdhLCAweDlmLCAweDkzLCAweGM5LCAweDljLCAweGVmLCAweGEwLCAweGUwLCAweDNiLCAweDRkLCAweGFlLCAweDJhLCAweGY1LCAweGIwLCAweGM4LCAweGViLCAweGJiLCAweDNjLCAweDgzLCAweDUzLCAweDk5LCAweDYxLCAweDE3LCAweDJiLCAweDA0LCAweDdlLCAweGJhLCAweDc3LCAweGQ2LCAweDI2LCAweGUxLCAweDY5LCAweDE0LCAweDYzLCAweDU1LCAweDIxLCAweDBjLCAweDdkXTtcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZW5jcnlwdGlvblxuY29uc3QgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XG5jb25zdCBUMiA9IFsweGE1YzY2MzYzLCAweDg0Zjg3YzdjLCAweDk5ZWU3Nzc3LCAweDhkZjY3YjdiLCAweDBkZmZmMmYyLCAweGJkZDY2YjZiLCAweGIxZGU2ZjZmLCAweDU0OTFjNWM1LCAweDUwNjAzMDMwLCAweDAzMDIwMTAxLCAweGE5Y2U2NzY3LCAweDdkNTYyYjJiLCAweDE5ZTdmZWZlLCAweDYyYjVkN2Q3LCAweGU2NGRhYmFiLCAweDlhZWM3Njc2LCAweDQ1OGZjYWNhLCAweDlkMWY4MjgyLCAweDQwODljOWM5LCAweDg3ZmE3ZDdkLCAweDE1ZWZmYWZhLCAweGViYjI1OTU5LCAweGM5OGU0NzQ3LCAweDBiZmJmMGYwLCAweGVjNDFhZGFkLCAweDY3YjNkNGQ0LCAweGZkNWZhMmEyLCAweGVhNDVhZmFmLCAweGJmMjM5YzljLCAweGY3NTNhNGE0LCAweDk2ZTQ3MjcyLCAweDViOWJjMGMwLCAweGMyNzViN2I3LCAweDFjZTFmZGZkLCAweGFlM2Q5MzkzLCAweDZhNGMyNjI2LCAweDVhNmMzNjM2LCAweDQxN2UzZjNmLCAweDAyZjVmN2Y3LCAweDRmODNjY2NjLCAweDVjNjgzNDM0LCAweGY0NTFhNWE1LCAweDM0ZDFlNWU1LCAweDA4ZjlmMWYxLCAweDkzZTI3MTcxLCAweDczYWJkOGQ4LCAweDUzNjIzMTMxLCAweDNmMmExNTE1LCAweDBjMDgwNDA0LCAweDUyOTVjN2M3LCAweDY1NDYyMzIzLCAweDVlOWRjM2MzLCAweDI4MzAxODE4LCAweGExMzc5Njk2LCAweDBmMGEwNTA1LCAweGI1MmY5YTlhLCAweDA5MGUwNzA3LCAweDM2MjQxMjEyLCAweDliMWI4MDgwLCAweDNkZGZlMmUyLCAweDI2Y2RlYmViLCAweDY5NGUyNzI3LCAweGNkN2ZiMmIyLCAweDlmZWE3NTc1LCAweDFiMTIwOTA5LCAweDllMWQ4MzgzLCAweDc0NTgyYzJjLCAweDJlMzQxYTFhLCAweDJkMzYxYjFiLCAweGIyZGM2ZTZlLCAweGVlYjQ1YTVhLCAweGZiNWJhMGEwLCAweGY2YTQ1MjUyLCAweDRkNzYzYjNiLCAweDYxYjdkNmQ2LCAweGNlN2RiM2IzLCAweDdiNTIyOTI5LCAweDNlZGRlM2UzLCAweDcxNWUyZjJmLCAweDk3MTM4NDg0LCAweGY1YTY1MzUzLCAweDY4YjlkMWQxLCAweDAwMDAwMDAwLCAweDJjYzFlZGVkLCAweDYwNDAyMDIwLCAweDFmZTNmY2ZjLCAweGM4NzliMWIxLCAweGVkYjY1YjViLCAweGJlZDQ2YTZhLCAweDQ2OGRjYmNiLCAweGQ5NjdiZWJlLCAweDRiNzIzOTM5LCAweGRlOTQ0YTRhLCAweGQ0OTg0YzRjLCAweGU4YjA1ODU4LCAweDRhODVjZmNmLCAweDZiYmJkMGQwLCAweDJhYzVlZmVmLCAweGU1NGZhYWFhLCAweDE2ZWRmYmZiLCAweGM1ODY0MzQzLCAweGQ3OWE0ZDRkLCAweDU1NjYzMzMzLCAweDk0MTE4NTg1LCAweGNmOGE0NTQ1LCAweDEwZTlmOWY5LCAweDA2MDQwMjAyLCAweDgxZmU3ZjdmLCAweGYwYTA1MDUwLCAweDQ0NzgzYzNjLCAweGJhMjU5ZjlmLCAweGUzNGJhOGE4LCAweGYzYTI1MTUxLCAweGZlNWRhM2EzLCAweGMwODA0MDQwLCAweDhhMDU4ZjhmLCAweGFkM2Y5MjkyLCAweGJjMjE5ZDlkLCAweDQ4NzAzODM4LCAweDA0ZjFmNWY1LCAweGRmNjNiY2JjLCAweGMxNzdiNmI2LCAweDc1YWZkYWRhLCAweDYzNDIyMTIxLCAweDMwMjAxMDEwLCAweDFhZTVmZmZmLCAweDBlZmRmM2YzLCAweDZkYmZkMmQyLCAweDRjODFjZGNkLCAweDE0MTgwYzBjLCAweDM1MjYxMzEzLCAweDJmYzNlY2VjLCAweGUxYmU1ZjVmLCAweGEyMzU5Nzk3LCAweGNjODg0NDQ0LCAweDM5MmUxNzE3LCAweDU3OTNjNGM0LCAweGYyNTVhN2E3LCAweDgyZmM3ZTdlLCAweDQ3N2EzZDNkLCAweGFjYzg2NDY0LCAweGU3YmE1ZDVkLCAweDJiMzIxOTE5LCAweDk1ZTY3MzczLCAweGEwYzA2MDYwLCAweDk4MTk4MTgxLCAweGQxOWU0ZjRmLCAweDdmYTNkY2RjLCAweDY2NDQyMjIyLCAweDdlNTQyYTJhLCAweGFiM2I5MDkwLCAweDgzMGI4ODg4LCAweGNhOGM0NjQ2LCAweDI5YzdlZWVlLCAweGQzNmJiOGI4LCAweDNjMjgxNDE0LCAweDc5YTdkZWRlLCAweGUyYmM1ZTVlLCAweDFkMTYwYjBiLCAweDc2YWRkYmRiLCAweDNiZGJlMGUwLCAweDU2NjQzMjMyLCAweDRlNzQzYTNhLCAweDFlMTQwYTBhLCAweGRiOTI0OTQ5LCAweDBhMGMwNjA2LCAweDZjNDgyNDI0LCAweGU0Yjg1YzVjLCAweDVkOWZjMmMyLCAweDZlYmRkM2QzLCAweGVmNDNhY2FjLCAweGE2YzQ2MjYyLCAweGE4Mzk5MTkxLCAweGE0MzE5NTk1LCAweDM3ZDNlNGU0LCAweDhiZjI3OTc5LCAweDMyZDVlN2U3LCAweDQzOGJjOGM4LCAweDU5NmUzNzM3LCAweGI3ZGE2ZDZkLCAweDhjMDE4ZDhkLCAweDY0YjFkNWQ1LCAweGQyOWM0ZTRlLCAweGUwNDlhOWE5LCAweGI0ZDg2YzZjLCAweGZhYWM1NjU2LCAweDA3ZjNmNGY0LCAweDI1Y2ZlYWVhLCAweGFmY2E2NTY1LCAweDhlZjQ3YTdhLCAweGU5NDdhZWFlLCAweDE4MTAwODA4LCAweGQ1NmZiYWJhLCAweDg4ZjA3ODc4LCAweDZmNGEyNTI1LCAweDcyNWMyZTJlLCAweDI0MzgxYzFjLCAweGYxNTdhNmE2LCAweGM3NzNiNGI0LCAweDUxOTdjNmM2LCAweDIzY2JlOGU4LCAweDdjYTFkZGRkLCAweDljZTg3NDc0LCAweDIxM2UxZjFmLCAweGRkOTY0YjRiLCAweGRjNjFiZGJkLCAweDg2MGQ4YjhiLCAweDg1MGY4YThhLCAweDkwZTA3MDcwLCAweDQyN2MzZTNlLCAweGM0NzFiNWI1LCAweGFhY2M2NjY2LCAweGQ4OTA0ODQ4LCAweDA1MDYwMzAzLCAweDAxZjdmNmY2LCAweDEyMWMwZTBlLCAweGEzYzI2MTYxLCAweDVmNmEzNTM1LCAweGY5YWU1NzU3LCAweGQwNjliOWI5LCAweDkxMTc4Njg2LCAweDU4OTljMWMxLCAweDI3M2ExZDFkLCAweGI5Mjc5ZTllLCAweDM4ZDllMWUxLCAweDEzZWJmOGY4LCAweGIzMmI5ODk4LCAweDMzMjIxMTExLCAweGJiZDI2OTY5LCAweDcwYTlkOWQ5LCAweDg5MDc4ZThlLCAweGE3MzM5NDk0LCAweGI2MmQ5YjliLCAweDIyM2MxZTFlLCAweDkyMTU4Nzg3LCAweDIwYzllOWU5LCAweDQ5ODdjZWNlLCAweGZmYWE1NTU1LCAweDc4NTAyODI4LCAweDdhYTVkZmRmLCAweDhmMDM4YzhjLCAweGY4NTlhMWExLCAweDgwMDk4OTg5LCAweDE3MWEwZDBkLCAweGRhNjViZmJmLCAweDMxZDdlNmU2LCAweGM2ODQ0MjQyLCAweGI4ZDA2ODY4LCAweGMzODI0MTQxLCAweGIwMjk5OTk5LCAweDc3NWEyZDJkLCAweDExMWUwZjBmLCAweGNiN2JiMGIwLCAweGZjYTg1NDU0LCAweGQ2NmRiYmJiLCAweDNhMmMxNjE2XTtcbmNvbnN0IFQzID0gWzB4NjNhNWM2NjMsIDB4N2M4NGY4N2MsIDB4Nzc5OWVlNzcsIDB4N2I4ZGY2N2IsIDB4ZjIwZGZmZjIsIDB4NmJiZGQ2NmIsIDB4NmZiMWRlNmYsIDB4YzU1NDkxYzUsIDB4MzA1MDYwMzAsIDB4MDEwMzAyMDEsIDB4NjdhOWNlNjcsIDB4MmI3ZDU2MmIsIDB4ZmUxOWU3ZmUsIDB4ZDc2MmI1ZDcsIDB4YWJlNjRkYWIsIDB4NzY5YWVjNzYsIDB4Y2E0NThmY2EsIDB4ODI5ZDFmODIsIDB4Yzk0MDg5YzksIDB4N2Q4N2ZhN2QsIDB4ZmExNWVmZmEsIDB4NTllYmIyNTksIDB4NDdjOThlNDcsIDB4ZjAwYmZiZjAsIDB4YWRlYzQxYWQsIDB4ZDQ2N2IzZDQsIDB4YTJmZDVmYTIsIDB4YWZlYTQ1YWYsIDB4OWNiZjIzOWMsIDB4YTRmNzUzYTQsIDB4NzI5NmU0NzIsIDB4YzA1YjliYzAsIDB4YjdjMjc1YjcsIDB4ZmQxY2UxZmQsIDB4OTNhZTNkOTMsIDB4MjY2YTRjMjYsIDB4MzY1YTZjMzYsIDB4M2Y0MTdlM2YsIDB4ZjcwMmY1ZjcsIDB4Y2M0ZjgzY2MsIDB4MzQ1YzY4MzQsIDB4YTVmNDUxYTUsIDB4ZTUzNGQxZTUsIDB4ZjEwOGY5ZjEsIDB4NzE5M2UyNzEsIDB4ZDg3M2FiZDgsIDB4MzE1MzYyMzEsIDB4MTUzZjJhMTUsIDB4MDQwYzA4MDQsIDB4Yzc1Mjk1YzcsIDB4MjM2NTQ2MjMsIDB4YzM1ZTlkYzMsIDB4MTgyODMwMTgsIDB4OTZhMTM3OTYsIDB4MDUwZjBhMDUsIDB4OWFiNTJmOWEsIDB4MDcwOTBlMDcsIDB4MTIzNjI0MTIsIDB4ODA5YjFiODAsIDB4ZTIzZGRmZTIsIDB4ZWIyNmNkZWIsIDB4Mjc2OTRlMjcsIDB4YjJjZDdmYjIsIDB4NzU5ZmVhNzUsIDB4MDkxYjEyMDksIDB4ODM5ZTFkODMsIDB4MmM3NDU4MmMsIDB4MWEyZTM0MWEsIDB4MWIyZDM2MWIsIDB4NmViMmRjNmUsIDB4NWFlZWI0NWEsIDB4YTBmYjViYTAsIDB4NTJmNmE0NTIsIDB4M2I0ZDc2M2IsIDB4ZDY2MWI3ZDYsIDB4YjNjZTdkYjMsIDB4Mjk3YjUyMjksIDB4ZTMzZWRkZTMsIDB4MmY3MTVlMmYsIDB4ODQ5NzEzODQsIDB4NTNmNWE2NTMsIDB4ZDE2OGI5ZDEsIDB4MDAwMDAwMDAsIDB4ZWQyY2MxZWQsIDB4MjA2MDQwMjAsIDB4ZmMxZmUzZmMsIDB4YjFjODc5YjEsIDB4NWJlZGI2NWIsIDB4NmFiZWQ0NmEsIDB4Y2I0NjhkY2IsIDB4YmVkOTY3YmUsIDB4Mzk0YjcyMzksIDB4NGFkZTk0NGEsIDB4NGNkNDk4NGMsIDB4NThlOGIwNTgsIDB4Y2Y0YTg1Y2YsIDB4ZDA2YmJiZDAsIDB4ZWYyYWM1ZWYsIDB4YWFlNTRmYWEsIDB4ZmIxNmVkZmIsIDB4NDNjNTg2NDMsIDB4NGRkNzlhNGQsIDB4MzM1NTY2MzMsIDB4ODU5NDExODUsIDB4NDVjZjhhNDUsIDB4ZjkxMGU5ZjksIDB4MDIwNjA0MDIsIDB4N2Y4MWZlN2YsIDB4NTBmMGEwNTAsIDB4M2M0NDc4M2MsIDB4OWZiYTI1OWYsIDB4YThlMzRiYTgsIDB4NTFmM2EyNTEsIDB4YTNmZTVkYTMsIDB4NDBjMDgwNDAsIDB4OGY4YTA1OGYsIDB4OTJhZDNmOTIsIDB4OWRiYzIxOWQsIDB4Mzg0ODcwMzgsIDB4ZjUwNGYxZjUsIDB4YmNkZjYzYmMsIDB4YjZjMTc3YjYsIDB4ZGE3NWFmZGEsIDB4MjE2MzQyMjEsIDB4MTAzMDIwMTAsIDB4ZmYxYWU1ZmYsIDB4ZjMwZWZkZjMsIDB4ZDI2ZGJmZDIsIDB4Y2Q0YzgxY2QsIDB4MGMxNDE4MGMsIDB4MTMzNTI2MTMsIDB4ZWMyZmMzZWMsIDB4NWZlMWJlNWYsIDB4OTdhMjM1OTcsIDB4NDRjYzg4NDQsIDB4MTczOTJlMTcsIDB4YzQ1NzkzYzQsIDB4YTdmMjU1YTcsIDB4N2U4MmZjN2UsIDB4M2Q0NzdhM2QsIDB4NjRhY2M4NjQsIDB4NWRlN2JhNWQsIDB4MTkyYjMyMTksIDB4NzM5NWU2NzMsIDB4NjBhMGMwNjAsIDB4ODE5ODE5ODEsIDB4NGZkMTllNGYsIDB4ZGM3ZmEzZGMsIDB4MjI2NjQ0MjIsIDB4MmE3ZTU0MmEsIDB4OTBhYjNiOTAsIDB4ODg4MzBiODgsIDB4NDZjYThjNDYsIDB4ZWUyOWM3ZWUsIDB4YjhkMzZiYjgsIDB4MTQzYzI4MTQsIDB4ZGU3OWE3ZGUsIDB4NWVlMmJjNWUsIDB4MGIxZDE2MGIsIDB4ZGI3NmFkZGIsIDB4ZTAzYmRiZTAsIDB4MzI1NjY0MzIsIDB4M2E0ZTc0M2EsIDB4MGExZTE0MGEsIDB4NDlkYjkyNDksIDB4MDYwYTBjMDYsIDB4MjQ2YzQ4MjQsIDB4NWNlNGI4NWMsIDB4YzI1ZDlmYzIsIDB4ZDM2ZWJkZDMsIDB4YWNlZjQzYWMsIDB4NjJhNmM0NjIsIDB4OTFhODM5OTEsIDB4OTVhNDMxOTUsIDB4ZTQzN2QzZTQsIDB4Nzk4YmYyNzksIDB4ZTczMmQ1ZTcsIDB4Yzg0MzhiYzgsIDB4Mzc1OTZlMzcsIDB4NmRiN2RhNmQsIDB4OGQ4YzAxOGQsIDB4ZDU2NGIxZDUsIDB4NGVkMjljNGUsIDB4YTllMDQ5YTksIDB4NmNiNGQ4NmMsIDB4NTZmYWFjNTYsIDB4ZjQwN2YzZjQsIDB4ZWEyNWNmZWEsIDB4NjVhZmNhNjUsIDB4N2E4ZWY0N2EsIDB4YWVlOTQ3YWUsIDB4MDgxODEwMDgsIDB4YmFkNTZmYmEsIDB4Nzg4OGYwNzgsIDB4MjU2ZjRhMjUsIDB4MmU3MjVjMmUsIDB4MWMyNDM4MWMsIDB4YTZmMTU3YTYsIDB4YjRjNzczYjQsIDB4YzY1MTk3YzYsIDB4ZTgyM2NiZTgsIDB4ZGQ3Y2ExZGQsIDB4NzQ5Y2U4NzQsIDB4MWYyMTNlMWYsIDB4NGJkZDk2NGIsIDB4YmRkYzYxYmQsIDB4OGI4NjBkOGIsIDB4OGE4NTBmOGEsIDB4NzA5MGUwNzAsIDB4M2U0MjdjM2UsIDB4YjVjNDcxYjUsIDB4NjZhYWNjNjYsIDB4NDhkODkwNDgsIDB4MDMwNTA2MDMsIDB4ZjYwMWY3ZjYsIDB4MGUxMjFjMGUsIDB4NjFhM2MyNjEsIDB4MzU1ZjZhMzUsIDB4NTdmOWFlNTcsIDB4YjlkMDY5YjksIDB4ODY5MTE3ODYsIDB4YzE1ODk5YzEsIDB4MWQyNzNhMWQsIDB4OWViOTI3OWUsIDB4ZTEzOGQ5ZTEsIDB4ZjgxM2ViZjgsIDB4OThiMzJiOTgsIDB4MTEzMzIyMTEsIDB4NjliYmQyNjksIDB4ZDk3MGE5ZDksIDB4OGU4OTA3OGUsIDB4OTRhNzMzOTQsIDB4OWJiNjJkOWIsIDB4MWUyMjNjMWUsIDB4ODc5MjE1ODcsIDB4ZTkyMGM5ZTksIDB4Y2U0OTg3Y2UsIDB4NTVmZmFhNTUsIDB4Mjg3ODUwMjgsIDB4ZGY3YWE1ZGYsIDB4OGM4ZjAzOGMsIDB4YTFmODU5YTEsIDB4ODk4MDA5ODksIDB4MGQxNzFhMGQsIDB4YmZkYTY1YmYsIDB4ZTYzMWQ3ZTYsIDB4NDJjNjg0NDIsIDB4NjhiOGQwNjgsIDB4NDFjMzgyNDEsIDB4OTliMDI5OTksIDB4MmQ3NzVhMmQsIDB4MGYxMTFlMGYsIDB4YjBjYjdiYjAsIDB4NTRmY2E4NTQsIDB4YmJkNjZkYmIsIDB4MTYzYTJjMTZdO1xuY29uc3QgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb25cbmNvbnN0IFQ1ID0gWzB4NTFmNGE3NTAsIDB4N2U0MTY1NTMsIDB4MWExN2E0YzMsIDB4M2EyNzVlOTYsIDB4M2JhYjZiY2IsIDB4MWY5ZDQ1ZjEsIDB4YWNmYTU4YWIsIDB4NGJlMzAzOTMsIDB4MjAzMGZhNTUsIDB4YWQ3NjZkZjYsIDB4ODhjYzc2OTEsIDB4ZjUwMjRjMjUsIDB4NGZlNWQ3ZmMsIDB4YzUyYWNiZDcsIDB4MjYzNTQ0ODAsIDB4YjU2MmEzOGYsIDB4ZGViMTVhNDksIDB4MjViYTFiNjcsIDB4NDVlYTBlOTgsIDB4NWRmZWMwZTEsIDB4YzMyZjc1MDIsIDB4ODE0Y2YwMTIsIDB4OGQ0Njk3YTMsIDB4NmJkM2Y5YzYsIDB4MDM4ZjVmZTcsIDB4MTU5MjljOTUsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4ZDRiZTgzMmQsIDB4NTg3NDIxZDMsIDB4NDllMDY5MjksIDB4OGVjOWM4NDQsIDB4NzVjMjg5NmEsIDB4ZjQ4ZTc5NzgsIDB4OTk1ODNlNmIsIDB4MjdiOTcxZGQsIDB4YmVlMTRmYjYsIDB4ZjA4OGFkMTcsIDB4YzkyMGFjNjYsIDB4N2RjZTNhYjQsIDB4NjNkZjRhMTgsIDB4ZTUxYTMxODIsIDB4OTc1MTMzNjAsIDB4NjI1MzdmNDUsIDB4YjE2NDc3ZTAsIDB4YmI2YmFlODQsIDB4ZmU4MWEwMWMsIDB4ZjkwODJiOTQsIDB4NzA0ODY4NTgsIDB4OGY0NWZkMTksIDB4OTRkZTZjODcsIDB4NTI3YmY4YjcsIDB4YWI3M2QzMjMsIDB4NzI0YjAyZTIsIDB4ZTMxZjhmNTcsIDB4NjY1NWFiMmEsIDB4YjJlYjI4MDcsIDB4MmZiNWMyMDMsIDB4ODZjNTdiOWEsIDB4ZDMzNzA4YTUsIDB4MzAyODg3ZjIsIDB4MjNiZmE1YjIsIDB4MDIwMzZhYmEsIDB4ZWQxNjgyNWMsIDB4OGFjZjFjMmIsIDB4YTc3OWI0OTIsIDB4ZjMwN2YyZjAsIDB4NGU2OWUyYTEsIDB4NjVkYWY0Y2QsIDB4MDYwNWJlZDUsIDB4ZDEzNDYyMWYsIDB4YzRhNmZlOGEsIDB4MzQyZTUzOWQsIDB4YTJmMzU1YTAsIDB4MDU4YWUxMzIsIDB4YTRmNmViNzUsIDB4MGI4M2VjMzksIDB4NDA2MGVmYWEsIDB4NWU3MTlmMDYsIDB4YmQ2ZTEwNTEsIDB4M2UyMThhZjksIDB4OTZkZDA2M2QsIDB4ZGQzZTA1YWUsIDB4NGRlNmJkNDYsIDB4OTE1NDhkYjUsIDB4NzFjNDVkMDUsIDB4MDQwNmQ0NmYsIDB4NjA1MDE1ZmYsIDB4MTk5OGZiMjQsIDB4ZDZiZGU5OTcsIDB4ODk0MDQzY2MsIDB4NjdkOTllNzcsIDB4YjBlODQyYmQsIDB4MDc4OThiODgsIDB4ZTcxOTViMzgsIDB4NzljOGVlZGIsIDB4YTE3YzBhNDcsIDB4N2M0MjBmZTksIDB4Zjg4NDFlYzksIDB4MDAwMDAwMDAsIDB4MDk4MDg2ODMsIDB4MzIyYmVkNDgsIDB4MWUxMTcwYWMsIDB4NmM1YTcyNGUsIDB4ZmQwZWZmZmIsIDB4MGY4NTM4NTYsIDB4M2RhZWQ1MWUsIDB4MzYyZDM5MjcsIDB4MGEwZmQ5NjQsIDB4Njg1Y2E2MjEsIDB4OWI1YjU0ZDEsIDB4MjQzNjJlM2EsIDB4MGMwYTY3YjEsIDB4OTM1N2U3MGYsIDB4YjRlZTk2ZDIsIDB4MWI5YjkxOWUsIDB4ODBjMGM1NGYsIDB4NjFkYzIwYTIsIDB4NWE3NzRiNjksIDB4MWMxMjFhMTYsIDB4ZTI5M2JhMGEsIDB4YzBhMDJhZTUsIDB4M2MyMmUwNDMsIDB4MTIxYjE3MWQsIDB4MGUwOTBkMGIsIDB4ZjI4YmM3YWQsIDB4MmRiNmE4YjksIDB4MTQxZWE5YzgsIDB4NTdmMTE5ODUsIDB4YWY3NTA3NGMsIDB4ZWU5OWRkYmIsIDB4YTM3ZjYwZmQsIDB4ZjcwMTI2OWYsIDB4NWM3MmY1YmMsIDB4NDQ2NjNiYzUsIDB4NWJmYjdlMzQsIDB4OGI0MzI5NzYsIDB4Y2IyM2M2ZGMsIDB4YjZlZGZjNjgsIDB4YjhlNGYxNjMsIDB4ZDczMWRjY2EsIDB4NDI2Mzg1MTAsIDB4MTM5NzIyNDAsIDB4ODRjNjExMjAsIDB4ODU0YTI0N2QsIDB4ZDJiYjNkZjgsIDB4YWVmOTMyMTEsIDB4YzcyOWExNmQsIDB4MWQ5ZTJmNGIsIDB4ZGNiMjMwZjMsIDB4MGQ4NjUyZWMsIDB4NzdjMWUzZDAsIDB4MmJiMzE2NmMsIDB4YTk3MGI5OTksIDB4MTE5NDQ4ZmEsIDB4NDdlOTY0MjIsIDB4YThmYzhjYzQsIDB4YTBmMDNmMWEsIDB4NTY3ZDJjZDgsIDB4MjIzMzkwZWYsIDB4ODc0OTRlYzcsIDB4ZDkzOGQxYzEsIDB4OGNjYWEyZmUsIDB4OThkNDBiMzYsIDB4YTZmNTgxY2YsIDB4YTU3YWRlMjgsIDB4ZGFiNzhlMjYsIDB4M2ZhZGJmYTQsIDB4MmMzYTlkZTQsIDB4NTA3ODkyMGQsIDB4NmE1ZmNjOWIsIDB4NTQ3ZTQ2NjIsIDB4ZjY4ZDEzYzIsIDB4OTBkOGI4ZTgsIDB4MmUzOWY3NWUsIDB4ODJjM2FmZjUsIDB4OWY1ZDgwYmUsIDB4NjlkMDkzN2MsIDB4NmZkNTJkYTksIDB4Y2YyNTEyYjMsIDB4YzhhYzk5M2IsIDB4MTAxODdkYTcsIDB4ZTg5YzYzNmUsIDB4ZGIzYmJiN2IsIDB4Y2QyNjc4MDksIDB4NmU1OTE4ZjQsIDB4ZWM5YWI3MDEsIDB4ODM0ZjlhYTgsIDB4ZTY5NTZlNjUsIDB4YWFmZmU2N2UsIDB4MjFiY2NmMDgsIDB4ZWYxNWU4ZTYsIDB4YmFlNzliZDksIDB4NGE2ZjM2Y2UsIDB4ZWE5ZjA5ZDQsIDB4MjliMDdjZDYsIDB4MzFhNGIyYWYsIDB4MmEzZjIzMzEsIDB4YzZhNTk0MzAsIDB4MzVhMjY2YzAsIDB4NzQ0ZWJjMzcsIDB4ZmM4MmNhYTYsIDB4ZTA5MGQwYjAsIDB4MzNhN2Q4MTUsIDB4ZjEwNDk4NGEsIDB4NDFlY2RhZjcsIDB4N2ZjZDUwMGUsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4NDNlZmIwNGQsIDB4Y2NhYTRkNTQsIDB4ZTQ5NjA0ZGYsIDB4OWVkMWI1ZTMsIDB4NGM2YTg4MWIsIDB4YzEyYzFmYjgsIDB4NDY2NTUxN2YsIDB4OWQ1ZWVhMDQsIDB4MDE4YzM1NWQsIDB4ZmE4Nzc0NzMsIDB4ZmIwYjQxMmUsIDB4YjM2NzFkNWEsIDB4OTJkYmQyNTIsIDB4ZTkxMDU2MzMsIDB4NmRkNjQ3MTMsIDB4OWFkNzYxOGMsIDB4MzdhMTBjN2EsIDB4NTlmODE0OGUsIDB4ZWIxMzNjODksIDB4Y2VhOTI3ZWUsIDB4Yjc2MWM5MzUsIDB4ZTExY2U1ZWQsIDB4N2E0N2IxM2MsIDB4OWNkMmRmNTksIDB4NTVmMjczM2YsIDB4MTgxNGNlNzksIDB4NzNjNzM3YmYsIDB4NTNmN2NkZWEsIDB4NWZmZGFhNWIsIDB4ZGYzZDZmMTQsIDB4Nzg0NGRiODYsIDB4Y2FhZmYzODEsIDB4Yjk2OGM0M2UsIDB4MzgyNDM0MmMsIDB4YzJhMzQwNWYsIDB4MTYxZGMzNzIsIDB4YmNlMjI1MGMsIDB4MjgzYzQ5OGIsIDB4ZmYwZDk1NDEsIDB4MzlhODAxNzEsIDB4MDgwY2IzZGUsIDB4ZDhiNGU0OWMsIDB4NjQ1NmMxOTAsIDB4N2JjYjg0NjEsIDB4ZDUzMmI2NzAsIDB4NDg2YzVjNzQsIDB4ZDBiODU3NDJdO1xuY29uc3QgVDYgPSBbMHg1MDUxZjRhNywgMHg1MzdlNDE2NSwgMHhjMzFhMTdhNCwgMHg5NjNhMjc1ZSwgMHhjYjNiYWI2YiwgMHhmMTFmOWQ0NSwgMHhhYmFjZmE1OCwgMHg5MzRiZTMwMywgMHg1NTIwMzBmYSwgMHhmNmFkNzY2ZCwgMHg5MTg4Y2M3NiwgMHgyNWY1MDI0YywgMHhmYzRmZTVkNywgMHhkN2M1MmFjYiwgMHg4MDI2MzU0NCwgMHg4ZmI1NjJhMywgMHg0OWRlYjE1YSwgMHg2NzI1YmExYiwgMHg5ODQ1ZWEwZSwgMHhlMTVkZmVjMCwgMHgwMmMzMmY3NSwgMHgxMjgxNGNmMCwgMHhhMzhkNDY5NywgMHhjNjZiZDNmOSwgMHhlNzAzOGY1ZiwgMHg5NTE1OTI5YywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHgyZGQ0YmU4MywgMHhkMzU4NzQyMSwgMHgyOTQ5ZTA2OSwgMHg0NDhlYzljOCwgMHg2YTc1YzI4OSwgMHg3OGY0OGU3OSwgMHg2Yjk5NTgzZSwgMHhkZDI3Yjk3MSwgMHhiNmJlZTE0ZiwgMHgxN2YwODhhZCwgMHg2NmM5MjBhYywgMHhiNDdkY2UzYSwgMHgxODYzZGY0YSwgMHg4MmU1MWEzMSwgMHg2MDk3NTEzMywgMHg0NTYyNTM3ZiwgMHhlMGIxNjQ3NywgMHg4NGJiNmJhZSwgMHgxY2ZlODFhMCwgMHg5NGY5MDgyYiwgMHg1ODcwNDg2OCwgMHgxOThmNDVmZCwgMHg4Nzk0ZGU2YywgMHhiNzUyN2JmOCwgMHgyM2FiNzNkMywgMHhlMjcyNGIwMiwgMHg1N2UzMWY4ZiwgMHgyYTY2NTVhYiwgMHgwN2IyZWIyOCwgMHgwMzJmYjVjMiwgMHg5YTg2YzU3YiwgMHhhNWQzMzcwOCwgMHhmMjMwMjg4NywgMHhiMjIzYmZhNSwgMHhiYTAyMDM2YSwgMHg1Y2VkMTY4MiwgMHgyYjhhY2YxYywgMHg5MmE3NzliNCwgMHhmMGYzMDdmMiwgMHhhMTRlNjllMiwgMHhjZDY1ZGFmNCwgMHhkNTA2MDViZSwgMHgxZmQxMzQ2MiwgMHg4YWM0YTZmZSwgMHg5ZDM0MmU1MywgMHhhMGEyZjM1NSwgMHgzMjA1OGFlMSwgMHg3NWE0ZjZlYiwgMHgzOTBiODNlYywgMHhhYTQwNjBlZiwgMHgwNjVlNzE5ZiwgMHg1MWJkNmUxMCwgMHhmOTNlMjE4YSwgMHgzZDk2ZGQwNiwgMHhhZWRkM2UwNSwgMHg0NjRkZTZiZCwgMHhiNTkxNTQ4ZCwgMHgwNTcxYzQ1ZCwgMHg2ZjA0MDZkNCwgMHhmZjYwNTAxNSwgMHgyNDE5OThmYiwgMHg5N2Q2YmRlOSwgMHhjYzg5NDA0MywgMHg3NzY3ZDk5ZSwgMHhiZGIwZTg0MiwgMHg4ODA3ODk4YiwgMHgzOGU3MTk1YiwgMHhkYjc5YzhlZSwgMHg0N2ExN2MwYSwgMHhlOTdjNDIwZiwgMHhjOWY4ODQxZSwgMHgwMDAwMDAwMCwgMHg4MzA5ODA4NiwgMHg0ODMyMmJlZCwgMHhhYzFlMTE3MCwgMHg0ZTZjNWE3MiwgMHhmYmZkMGVmZiwgMHg1NjBmODUzOCwgMHgxZTNkYWVkNSwgMHgyNzM2MmQzOSwgMHg2NDBhMGZkOSwgMHgyMTY4NWNhNiwgMHhkMTliNWI1NCwgMHgzYTI0MzYyZSwgMHhiMTBjMGE2NywgMHgwZjkzNTdlNywgMHhkMmI0ZWU5NiwgMHg5ZTFiOWI5MSwgMHg0ZjgwYzBjNSwgMHhhMjYxZGMyMCwgMHg2OTVhNzc0YiwgMHgxNjFjMTIxYSwgMHgwYWUyOTNiYSwgMHhlNWMwYTAyYSwgMHg0MzNjMjJlMCwgMHgxZDEyMWIxNywgMHgwYjBlMDkwZCwgMHhhZGYyOGJjNywgMHhiOTJkYjZhOCwgMHhjODE0MWVhOSwgMHg4NTU3ZjExOSwgMHg0Y2FmNzUwNywgMHhiYmVlOTlkZCwgMHhmZGEzN2Y2MCwgMHg5ZmY3MDEyNiwgMHhiYzVjNzJmNSwgMHhjNTQ0NjYzYiwgMHgzNDViZmI3ZSwgMHg3NjhiNDMyOSwgMHhkY2NiMjNjNiwgMHg2OGI2ZWRmYywgMHg2M2I4ZTRmMSwgMHhjYWQ3MzFkYywgMHgxMDQyNjM4NSwgMHg0MDEzOTcyMiwgMHgyMDg0YzYxMSwgMHg3ZDg1NGEyNCwgMHhmOGQyYmIzZCwgMHgxMWFlZjkzMiwgMHg2ZGM3MjlhMSwgMHg0YjFkOWUyZiwgMHhmM2RjYjIzMCwgMHhlYzBkODY1MiwgMHhkMDc3YzFlMywgMHg2YzJiYjMxNiwgMHg5OWE5NzBiOSwgMHhmYTExOTQ0OCwgMHgyMjQ3ZTk2NCwgMHhjNGE4ZmM4YywgMHgxYWEwZjAzZiwgMHhkODU2N2QyYywgMHhlZjIyMzM5MCwgMHhjNzg3NDk0ZSwgMHhjMWQ5MzhkMSwgMHhmZThjY2FhMiwgMHgzNjk4ZDQwYiwgMHhjZmE2ZjU4MSwgMHgyOGE1N2FkZSwgMHgyNmRhYjc4ZSwgMHhhNDNmYWRiZiwgMHhlNDJjM2E5ZCwgMHgwZDUwNzg5MiwgMHg5YjZhNWZjYywgMHg2MjU0N2U0NiwgMHhjMmY2OGQxMywgMHhlODkwZDhiOCwgMHg1ZTJlMzlmNywgMHhmNTgyYzNhZiwgMHhiZTlmNWQ4MCwgMHg3YzY5ZDA5MywgMHhhOTZmZDUyZCwgMHhiM2NmMjUxMiwgMHgzYmM4YWM5OSwgMHhhNzEwMTg3ZCwgMHg2ZWU4OWM2MywgMHg3YmRiM2JiYiwgMHgwOWNkMjY3OCwgMHhmNDZlNTkxOCwgMHgwMWVjOWFiNywgMHhhODgzNGY5YSwgMHg2NWU2OTU2ZSwgMHg3ZWFhZmZlNiwgMHgwODIxYmNjZiwgMHhlNmVmMTVlOCwgMHhkOWJhZTc5YiwgMHhjZTRhNmYzNiwgMHhkNGVhOWYwOSwgMHhkNjI5YjA3YywgMHhhZjMxYTRiMiwgMHgzMTJhM2YyMywgMHgzMGM2YTU5NCwgMHhjMDM1YTI2NiwgMHgzNzc0NGViYywgMHhhNmZjODJjYSwgMHhiMGUwOTBkMCwgMHgxNTMzYTdkOCwgMHg0YWYxMDQ5OCwgMHhmNzQxZWNkYSwgMHgwZTdmY2Q1MCwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg0ZDQzZWZiMCwgMHg1NGNjYWE0ZCwgMHhkZmU0OTYwNCwgMHhlMzllZDFiNSwgMHgxYjRjNmE4OCwgMHhiOGMxMmMxZiwgMHg3ZjQ2NjU1MSwgMHgwNDlkNWVlYSwgMHg1ZDAxOGMzNSwgMHg3M2ZhODc3NCwgMHgyZWZiMGI0MSwgMHg1YWIzNjcxZCwgMHg1MjkyZGJkMiwgMHgzM2U5MTA1NiwgMHgxMzZkZDY0NywgMHg4YzlhZDc2MSwgMHg3YTM3YTEwYywgMHg4ZTU5ZjgxNCwgMHg4OWViMTMzYywgMHhlZWNlYTkyNywgMHgzNWI3NjFjOSwgMHhlZGUxMWNlNSwgMHgzYzdhNDdiMSwgMHg1OTljZDJkZiwgMHgzZjU1ZjI3MywgMHg3OTE4MTRjZSwgMHhiZjczYzczNywgMHhlYTUzZjdjZCwgMHg1YjVmZmRhYSwgMHgxNGRmM2Q2ZiwgMHg4Njc4NDRkYiwgMHg4MWNhYWZmMywgMHgzZWI5NjhjNCwgMHgyYzM4MjQzNCwgMHg1ZmMyYTM0MCwgMHg3MjE2MWRjMywgMHgwY2JjZTIyNSwgMHg4YjI4M2M0OSwgMHg0MWZmMGQ5NSwgMHg3MTM5YTgwMSwgMHhkZTA4MGNiMywgMHg5Y2Q4YjRlNCwgMHg5MDY0NTZjMSwgMHg2MTdiY2I4NCwgMHg3MGQ1MzJiNiwgMHg3NDQ4NmM1YywgMHg0MmQwYjg1N107XG5jb25zdCBUNyA9IFsweGE3NTA1MWY0LCAweDY1NTM3ZTQxLCAweGE0YzMxYTE3LCAweDVlOTYzYTI3LCAweDZiY2IzYmFiLCAweDQ1ZjExZjlkLCAweDU4YWJhY2ZhLCAweDAzOTM0YmUzLCAweGZhNTUyMDMwLCAweDZkZjZhZDc2LCAweDc2OTE4OGNjLCAweDRjMjVmNTAyLCAweGQ3ZmM0ZmU1LCAweGNiZDdjNTJhLCAweDQ0ODAyNjM1LCAweGEzOGZiNTYyLCAweDVhNDlkZWIxLCAweDFiNjcyNWJhLCAweDBlOTg0NWVhLCAweGMwZTE1ZGZlLCAweDc1MDJjMzJmLCAweGYwMTI4MTRjLCAweDk3YTM4ZDQ2LCAweGY5YzY2YmQzLCAweDVmZTcwMzhmLCAweDljOTUxNTkyLCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDgzMmRkNGJlLCAweDIxZDM1ODc0LCAweDY5Mjk0OWUwLCAweGM4NDQ4ZWM5LCAweDg5NmE3NWMyLCAweDc5NzhmNDhlLCAweDNlNmI5OTU4LCAweDcxZGQyN2I5LCAweDRmYjZiZWUxLCAweGFkMTdmMDg4LCAweGFjNjZjOTIwLCAweDNhYjQ3ZGNlLCAweDRhMTg2M2RmLCAweDMxODJlNTFhLCAweDMzNjA5NzUxLCAweDdmNDU2MjUzLCAweDc3ZTBiMTY0LCAweGFlODRiYjZiLCAweGEwMWNmZTgxLCAweDJiOTRmOTA4LCAweDY4NTg3MDQ4LCAweGZkMTk4ZjQ1LCAweDZjODc5NGRlLCAweGY4Yjc1MjdiLCAweGQzMjNhYjczLCAweDAyZTI3MjRiLCAweDhmNTdlMzFmLCAweGFiMmE2NjU1LCAweDI4MDdiMmViLCAweGMyMDMyZmI1LCAweDdiOWE4NmM1LCAweDA4YTVkMzM3LCAweDg3ZjIzMDI4LCAweGE1YjIyM2JmLCAweDZhYmEwMjAzLCAweDgyNWNlZDE2LCAweDFjMmI4YWNmLCAweGI0OTJhNzc5LCAweGYyZjBmMzA3LCAweGUyYTE0ZTY5LCAweGY0Y2Q2NWRhLCAweGJlZDUwNjA1LCAweDYyMWZkMTM0LCAweGZlOGFjNGE2LCAweDUzOWQzNDJlLCAweDU1YTBhMmYzLCAweGUxMzIwNThhLCAweGViNzVhNGY2LCAweGVjMzkwYjgzLCAweGVmYWE0MDYwLCAweDlmMDY1ZTcxLCAweDEwNTFiZDZlLCAweDhhZjkzZTIxLCAweDA2M2Q5NmRkLCAweDA1YWVkZDNlLCAweGJkNDY0ZGU2LCAweDhkYjU5MTU0LCAweDVkMDU3MWM0LCAweGQ0NmYwNDA2LCAweDE1ZmY2MDUwLCAweGZiMjQxOTk4LCAweGU5OTdkNmJkLCAweDQzY2M4OTQwLCAweDllNzc2N2Q5LCAweDQyYmRiMGU4LCAweDhiODgwNzg5LCAweDViMzhlNzE5LCAweGVlZGI3OWM4LCAweDBhNDdhMTdjLCAweDBmZTk3YzQyLCAweDFlYzlmODg0LCAweDAwMDAwMDAwLCAweDg2ODMwOTgwLCAweGVkNDgzMjJiLCAweDcwYWMxZTExLCAweDcyNGU2YzVhLCAweGZmZmJmZDBlLCAweDM4NTYwZjg1LCAweGQ1MWUzZGFlLCAweDM5MjczNjJkLCAweGQ5NjQwYTBmLCAweGE2MjE2ODVjLCAweDU0ZDE5YjViLCAweDJlM2EyNDM2LCAweDY3YjEwYzBhLCAweGU3MGY5MzU3LCAweDk2ZDJiNGVlLCAweDkxOWUxYjliLCAweGM1NGY4MGMwLCAweDIwYTI2MWRjLCAweDRiNjk1YTc3LCAweDFhMTYxYzEyLCAweGJhMGFlMjkzLCAweDJhZTVjMGEwLCAweGUwNDMzYzIyLCAweDE3MWQxMjFiLCAweDBkMGIwZTA5LCAweGM3YWRmMjhiLCAweGE4YjkyZGI2LCAweGE5YzgxNDFlLCAweDE5ODU1N2YxLCAweDA3NGNhZjc1LCAweGRkYmJlZTk5LCAweDYwZmRhMzdmLCAweDI2OWZmNzAxLCAweGY1YmM1YzcyLCAweDNiYzU0NDY2LCAweDdlMzQ1YmZiLCAweDI5NzY4YjQzLCAweGM2ZGNjYjIzLCAweGZjNjhiNmVkLCAweGYxNjNiOGU0LCAweGRjY2FkNzMxLCAweDg1MTA0MjYzLCAweDIyNDAxMzk3LCAweDExMjA4NGM2LCAweDI0N2Q4NTRhLCAweDNkZjhkMmJiLCAweDMyMTFhZWY5LCAweGExNmRjNzI5LCAweDJmNGIxZDllLCAweDMwZjNkY2IyLCAweDUyZWMwZDg2LCAweGUzZDA3N2MxLCAweDE2NmMyYmIzLCAweGI5OTlhOTcwLCAweDQ4ZmExMTk0LCAweDY0MjI0N2U5LCAweDhjYzRhOGZjLCAweDNmMWFhMGYwLCAweDJjZDg1NjdkLCAweDkwZWYyMjMzLCAweDRlYzc4NzQ5LCAweGQxYzFkOTM4LCAweGEyZmU4Y2NhLCAweDBiMzY5OGQ0LCAweDgxY2ZhNmY1LCAweGRlMjhhNTdhLCAweDhlMjZkYWI3LCAweGJmYTQzZmFkLCAweDlkZTQyYzNhLCAweDkyMGQ1MDc4LCAweGNjOWI2YTVmLCAweDQ2NjI1NDdlLCAweDEzYzJmNjhkLCAweGI4ZTg5MGQ4LCAweGY3NWUyZTM5LCAweGFmZjU4MmMzLCAweDgwYmU5ZjVkLCAweDkzN2M2OWQwLCAweDJkYTk2ZmQ1LCAweDEyYjNjZjI1LCAweDk5M2JjOGFjLCAweDdkYTcxMDE4LCAweDYzNmVlODljLCAweGJiN2JkYjNiLCAweDc4MDljZDI2LCAweDE4ZjQ2ZTU5LCAweGI3MDFlYzlhLCAweDlhYTg4MzRmLCAweDZlNjVlNjk1LCAweGU2N2VhYWZmLCAweGNmMDgyMWJjLCAweGU4ZTZlZjE1LCAweDliZDliYWU3LCAweDM2Y2U0YTZmLCAweDA5ZDRlYTlmLCAweDdjZDYyOWIwLCAweGIyYWYzMWE0LCAweDIzMzEyYTNmLCAweDk0MzBjNmE1LCAweDY2YzAzNWEyLCAweGJjMzc3NDRlLCAweGNhYTZmYzgyLCAweGQwYjBlMDkwLCAweGQ4MTUzM2E3LCAweDk4NGFmMTA0LCAweGRhZjc0MWVjLCAweDUwMGU3ZmNkLCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGIwNGQ0M2VmLCAweDRkNTRjY2FhLCAweDA0ZGZlNDk2LCAweGI1ZTM5ZWQxLCAweDg4MWI0YzZhLCAweDFmYjhjMTJjLCAweDUxN2Y0NjY1LCAweGVhMDQ5ZDVlLCAweDM1NWQwMThjLCAweDc0NzNmYTg3LCAweDQxMmVmYjBiLCAweDFkNWFiMzY3LCAweGQyNTI5MmRiLCAweDU2MzNlOTEwLCAweDQ3MTM2ZGQ2LCAweDYxOGM5YWQ3LCAweDBjN2EzN2ExLCAweDE0OGU1OWY4LCAweDNjODllYjEzLCAweDI3ZWVjZWE5LCAweGM5MzViNzYxLCAweGU1ZWRlMTFjLCAweGIxM2M3YTQ3LCAweGRmNTk5Y2QyLCAweDczM2Y1NWYyLCAweGNlNzkxODE0LCAweDM3YmY3M2M3LCAweGNkZWE1M2Y3LCAweGFhNWI1ZmZkLCAweDZmMTRkZjNkLCAweGRiODY3ODQ0LCAweGYzODFjYWFmLCAweGM0M2ViOTY4LCAweDM0MmMzODI0LCAweDQwNWZjMmEzLCAweGMzNzIxNjFkLCAweDI1MGNiY2UyLCAweDQ5OGIyODNjLCAweDk1NDFmZjBkLCAweDAxNzEzOWE4LCAweGIzZGUwODBjLCAweGU0OWNkOGI0LCAweGMxOTA2NDU2LCAweDg0NjE3YmNiLCAweGI2NzBkNTMyLCAweDVjNzQ0ODZjLCAweDU3NDJkMGI4XTtcbmNvbnN0IFQ4ID0gWzB4ZjRhNzUwNTEsIDB4NDE2NTUzN2UsIDB4MTdhNGMzMWEsIDB4Mjc1ZTk2M2EsIDB4YWI2YmNiM2IsIDB4OWQ0NWYxMWYsIDB4ZmE1OGFiYWMsIDB4ZTMwMzkzNGIsIDB4MzBmYTU1MjAsIDB4NzY2ZGY2YWQsIDB4Y2M3NjkxODgsIDB4MDI0YzI1ZjUsIDB4ZTVkN2ZjNGYsIDB4MmFjYmQ3YzUsIDB4MzU0NDgwMjYsIDB4NjJhMzhmYjUsIDB4YjE1YTQ5ZGUsIDB4YmExYjY3MjUsIDB4ZWEwZTk4NDUsIDB4ZmVjMGUxNWQsIDB4MmY3NTAyYzMsIDB4NGNmMDEyODEsIDB4NDY5N2EzOGQsIDB4ZDNmOWM2NmIsIDB4OGY1ZmU3MDMsIDB4OTI5Yzk1MTUsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4YmU4MzJkZDQsIDB4NzQyMWQzNTgsIDB4ZTA2OTI5NDksIDB4YzljODQ0OGUsIDB4YzI4OTZhNzUsIDB4OGU3OTc4ZjQsIDB4NTgzZTZiOTksIDB4Yjk3MWRkMjcsIDB4ZTE0ZmI2YmUsIDB4ODhhZDE3ZjAsIDB4MjBhYzY2YzksIDB4Y2UzYWI0N2QsIDB4ZGY0YTE4NjMsIDB4MWEzMTgyZTUsIDB4NTEzMzYwOTcsIDB4NTM3ZjQ1NjIsIDB4NjQ3N2UwYjEsIDB4NmJhZTg0YmIsIDB4ODFhMDFjZmUsIDB4MDgyYjk0ZjksIDB4NDg2ODU4NzAsIDB4NDVmZDE5OGYsIDB4ZGU2Yzg3OTQsIDB4N2JmOGI3NTIsIDB4NzNkMzIzYWIsIDB4NGIwMmUyNzIsIDB4MWY4ZjU3ZTMsIDB4NTVhYjJhNjYsIDB4ZWIyODA3YjIsIDB4YjVjMjAzMmYsIDB4YzU3YjlhODYsIDB4MzcwOGE1ZDMsIDB4Mjg4N2YyMzAsIDB4YmZhNWIyMjMsIDB4MDM2YWJhMDIsIDB4MTY4MjVjZWQsIDB4Y2YxYzJiOGEsIDB4NzliNDkyYTcsIDB4MDdmMmYwZjMsIDB4NjllMmExNGUsIDB4ZGFmNGNkNjUsIDB4MDViZWQ1MDYsIDB4MzQ2MjFmZDEsIDB4YTZmZThhYzQsIDB4MmU1MzlkMzQsIDB4ZjM1NWEwYTIsIDB4OGFlMTMyMDUsIDB4ZjZlYjc1YTQsIDB4ODNlYzM5MGIsIDB4NjBlZmFhNDAsIDB4NzE5ZjA2NWUsIDB4NmUxMDUxYmQsIDB4MjE4YWY5M2UsIDB4ZGQwNjNkOTYsIDB4M2UwNWFlZGQsIDB4ZTZiZDQ2NGQsIDB4NTQ4ZGI1OTEsIDB4YzQ1ZDA1NzEsIDB4MDZkNDZmMDQsIDB4NTAxNWZmNjAsIDB4OThmYjI0MTksIDB4YmRlOTk3ZDYsIDB4NDA0M2NjODksIDB4ZDk5ZTc3NjcsIDB4ZTg0MmJkYjAsIDB4ODk4Yjg4MDcsIDB4MTk1YjM4ZTcsIDB4YzhlZWRiNzksIDB4N2MwYTQ3YTEsIDB4NDIwZmU5N2MsIDB4ODQxZWM5ZjgsIDB4MDAwMDAwMDAsIDB4ODA4NjgzMDksIDB4MmJlZDQ4MzIsIDB4MTE3MGFjMWUsIDB4NWE3MjRlNmMsIDB4MGVmZmZiZmQsIDB4ODUzODU2MGYsIDB4YWVkNTFlM2QsIDB4MmQzOTI3MzYsIDB4MGZkOTY0MGEsIDB4NWNhNjIxNjgsIDB4NWI1NGQxOWIsIDB4MzYyZTNhMjQsIDB4MGE2N2IxMGMsIDB4NTdlNzBmOTMsIDB4ZWU5NmQyYjQsIDB4OWI5MTllMWIsIDB4YzBjNTRmODAsIDB4ZGMyMGEyNjEsIDB4Nzc0YjY5NWEsIDB4MTIxYTE2MWMsIDB4OTNiYTBhZTIsIDB4YTAyYWU1YzAsIDB4MjJlMDQzM2MsIDB4MWIxNzFkMTIsIDB4MDkwZDBiMGUsIDB4OGJjN2FkZjIsIDB4YjZhOGI5MmQsIDB4MWVhOWM4MTQsIDB4ZjExOTg1NTcsIDB4NzUwNzRjYWYsIDB4OTlkZGJiZWUsIDB4N2Y2MGZkYTMsIDB4MDEyNjlmZjcsIDB4NzJmNWJjNWMsIDB4NjYzYmM1NDQsIDB4ZmI3ZTM0NWIsIDB4NDMyOTc2OGIsIDB4MjNjNmRjY2IsIDB4ZWRmYzY4YjYsIDB4ZTRmMTYzYjgsIDB4MzFkY2NhZDcsIDB4NjM4NTEwNDIsIDB4OTcyMjQwMTMsIDB4YzYxMTIwODQsIDB4NGEyNDdkODUsIDB4YmIzZGY4ZDIsIDB4ZjkzMjExYWUsIDB4MjlhMTZkYzcsIDB4OWUyZjRiMWQsIDB4YjIzMGYzZGMsIDB4ODY1MmVjMGQsIDB4YzFlM2QwNzcsIDB4YjMxNjZjMmIsIDB4NzBiOTk5YTksIDB4OTQ0OGZhMTEsIDB4ZTk2NDIyNDcsIDB4ZmM4Y2M0YTgsIDB4ZjAzZjFhYTAsIDB4N2QyY2Q4NTYsIDB4MzM5MGVmMjIsIDB4NDk0ZWM3ODcsIDB4MzhkMWMxZDksIDB4Y2FhMmZlOGMsIDB4ZDQwYjM2OTgsIDB4ZjU4MWNmYTYsIDB4N2FkZTI4YTUsIDB4Yjc4ZTI2ZGEsIDB4YWRiZmE0M2YsIDB4M2E5ZGU0MmMsIDB4Nzg5MjBkNTAsIDB4NWZjYzliNmEsIDB4N2U0NjYyNTQsIDB4OGQxM2MyZjYsIDB4ZDhiOGU4OTAsIDB4MzlmNzVlMmUsIDB4YzNhZmY1ODIsIDB4NWQ4MGJlOWYsIDB4ZDA5MzdjNjksIDB4ZDUyZGE5NmYsIDB4MjUxMmIzY2YsIDB4YWM5OTNiYzgsIDB4MTg3ZGE3MTAsIDB4OWM2MzZlZTgsIDB4M2JiYjdiZGIsIDB4MjY3ODA5Y2QsIDB4NTkxOGY0NmUsIDB4OWFiNzAxZWMsIDB4NGY5YWE4ODMsIDB4OTU2ZTY1ZTYsIDB4ZmZlNjdlYWEsIDB4YmNjZjA4MjEsIDB4MTVlOGU2ZWYsIDB4ZTc5YmQ5YmEsIDB4NmYzNmNlNGEsIDB4OWYwOWQ0ZWEsIDB4YjA3Y2Q2MjksIDB4YTRiMmFmMzEsIDB4M2YyMzMxMmEsIDB4YTU5NDMwYzYsIDB4YTI2NmMwMzUsIDB4NGViYzM3NzQsIDB4ODJjYWE2ZmMsIDB4OTBkMGIwZTAsIDB4YTdkODE1MzMsIDB4MDQ5ODRhZjEsIDB4ZWNkYWY3NDEsIDB4Y2Q1MDBlN2YsIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4ZWZiMDRkNDMsIDB4YWE0ZDU0Y2MsIDB4OTYwNGRmZTQsIDB4ZDFiNWUzOWUsIDB4NmE4ODFiNGMsIDB4MmMxZmI4YzEsIDB4NjU1MTdmNDYsIDB4NWVlYTA0OWQsIDB4OGMzNTVkMDEsIDB4ODc3NDczZmEsIDB4MGI0MTJlZmIsIDB4NjcxZDVhYjMsIDB4ZGJkMjUyOTIsIDB4MTA1NjMzZTksIDB4ZDY0NzEzNmQsIDB4ZDc2MThjOWEsIDB4YTEwYzdhMzcsIDB4ZjgxNDhlNTksIDB4MTMzYzg5ZWIsIDB4YTkyN2VlY2UsIDB4NjFjOTM1YjcsIDB4MWNlNWVkZTEsIDB4NDdiMTNjN2EsIDB4ZDJkZjU5OWMsIDB4ZjI3MzNmNTUsIDB4MTRjZTc5MTgsIDB4YzczN2JmNzMsIDB4ZjdjZGVhNTMsIDB4ZmRhYTViNWYsIDB4M2Q2ZjE0ZGYsIDB4NDRkYjg2NzgsIDB4YWZmMzgxY2EsIDB4NjhjNDNlYjksIDB4MjQzNDJjMzgsIDB4YTM0MDVmYzIsIDB4MWRjMzcyMTYsIDB4ZTIyNTBjYmMsIDB4M2M0OThiMjgsIDB4MGQ5NTQxZmYsIDB4YTgwMTcxMzksIDB4MGNiM2RlMDgsIDB4YjRlNDljZDgsIDB4NTZjMTkwNjQsIDB4Y2I4NDYxN2IsIDB4MzJiNjcwZDUsIDB4NmM1Yzc0NDgsIDB4Yjg1NzQyZDBdO1xuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBkZWNyeXB0aW9uIGtleSBleHBhbnNpb25cbmNvbnN0IFUxID0gWzB4MDAwMDAwMDAsIDB4MGUwOTBkMGIsIDB4MWMxMjFhMTYsIDB4MTIxYjE3MWQsIDB4MzgyNDM0MmMsIDB4MzYyZDM5MjcsIDB4MjQzNjJlM2EsIDB4MmEzZjIzMzEsIDB4NzA0ODY4NTgsIDB4N2U0MTY1NTMsIDB4NmM1YTcyNGUsIDB4NjI1MzdmNDUsIDB4NDg2YzVjNzQsIDB4NDY2NTUxN2YsIDB4NTQ3ZTQ2NjIsIDB4NWE3NzRiNjksIDB4ZTA5MGQwYjAsIDB4ZWU5OWRkYmIsIDB4ZmM4MmNhYTYsIDB4ZjI4YmM3YWQsIDB4ZDhiNGU0OWMsIDB4ZDZiZGU5OTcsIDB4YzRhNmZlOGEsIDB4Y2FhZmYzODEsIDB4OTBkOGI4ZTgsIDB4OWVkMWI1ZTMsIDB4OGNjYWEyZmUsIDB4ODJjM2FmZjUsIDB4YThmYzhjYzQsIDB4YTZmNTgxY2YsIDB4YjRlZTk2ZDIsIDB4YmFlNzliZDksIDB4ZGIzYmJiN2IsIDB4ZDUzMmI2NzAsIDB4YzcyOWExNmQsIDB4YzkyMGFjNjYsIDB4ZTMxZjhmNTcsIDB4ZWQxNjgyNWMsIDB4ZmYwZDk1NDEsIDB4ZjEwNDk4NGEsIDB4YWI3M2QzMjMsIDB4YTU3YWRlMjgsIDB4Yjc2MWM5MzUsIDB4Yjk2OGM0M2UsIDB4OTM1N2U3MGYsIDB4OWQ1ZWVhMDQsIDB4OGY0NWZkMTksIDB4ODE0Y2YwMTIsIDB4M2JhYjZiY2IsIDB4MzVhMjY2YzAsIDB4MjdiOTcxZGQsIDB4MjliMDdjZDYsIDB4MDM4ZjVmZTcsIDB4MGQ4NjUyZWMsIDB4MWY5ZDQ1ZjEsIDB4MTE5NDQ4ZmEsIDB4NGJlMzAzOTMsIDB4NDVlYTBlOTgsIDB4NTdmMTE5ODUsIDB4NTlmODE0OGUsIDB4NzNjNzM3YmYsIDB4N2RjZTNhYjQsIDB4NmZkNTJkYTksIDB4NjFkYzIwYTIsIDB4YWQ3NjZkZjYsIDB4YTM3ZjYwZmQsIDB4YjE2NDc3ZTAsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4OWI1YjU0ZDEsIDB4ODk0MDQzY2MsIDB4ODc0OTRlYzcsIDB4ZGQzZTA1YWUsIDB4ZDMzNzA4YTUsIDB4YzEyYzFmYjgsIDB4Y2YyNTEyYjMsIDB4ZTUxYTMxODIsIDB4ZWIxMzNjODksIDB4ZjkwODJiOTQsIDB4ZjcwMTI2OWYsIDB4NGRlNmJkNDYsIDB4NDNlZmIwNGQsIDB4NTFmNGE3NTAsIDB4NWZmZGFhNWIsIDB4NzVjMjg5NmEsIDB4N2JjYjg0NjEsIDB4NjlkMDkzN2MsIDB4NjdkOTllNzcsIDB4M2RhZWQ1MWUsIDB4MzNhN2Q4MTUsIDB4MjFiY2NmMDgsIDB4MmZiNWMyMDMsIDB4MDU4YWUxMzIsIDB4MGI4M2VjMzksIDB4MTk5OGZiMjQsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4Nzg0NGRiODYsIDB4NmE1ZmNjOWIsIDB4NjQ1NmMxOTAsIDB4NGU2OWUyYTEsIDB4NDA2MGVmYWEsIDB4NTI3YmY4YjcsIDB4NWM3MmY1YmMsIDB4MDYwNWJlZDUsIDB4MDgwY2IzZGUsIDB4MWExN2E0YzMsIDB4MTQxZWE5YzgsIDB4M2UyMThhZjksIDB4MzAyODg3ZjIsIDB4MjIzMzkwZWYsIDB4MmMzYTlkZTQsIDB4OTZkZDA2M2QsIDB4OThkNDBiMzYsIDB4OGFjZjFjMmIsIDB4ODRjNjExMjAsIDB4YWVmOTMyMTEsIDB4YTBmMDNmMWEsIDB4YjJlYjI4MDcsIDB4YmNlMjI1MGMsIDB4ZTY5NTZlNjUsIDB4ZTg5YzYzNmUsIDB4ZmE4Nzc0NzMsIDB4ZjQ4ZTc5NzgsIDB4ZGViMTVhNDksIDB4ZDBiODU3NDIsIDB4YzJhMzQwNWYsIDB4Y2NhYTRkNTQsIDB4NDFlY2RhZjcsIDB4NGZlNWQ3ZmMsIDB4NWRmZWMwZTEsIDB4NTNmN2NkZWEsIDB4NzljOGVlZGIsIDB4NzdjMWUzZDAsIDB4NjVkYWY0Y2QsIDB4NmJkM2Y5YzYsIDB4MzFhNGIyYWYsIDB4M2ZhZGJmYTQsIDB4MmRiNmE4YjksIDB4MjNiZmE1YjIsIDB4MDk4MDg2ODMsIDB4MDc4OThiODgsIDB4MTU5MjljOTUsIDB4MWI5YjkxOWUsIDB4YTE3YzBhNDcsIDB4YWY3NTA3NGMsIDB4YmQ2ZTEwNTEsIDB4YjM2NzFkNWEsIDB4OTk1ODNlNmIsIDB4OTc1MTMzNjAsIDB4ODU0YTI0N2QsIDB4OGI0MzI5NzYsIDB4ZDEzNDYyMWYsIDB4ZGYzZDZmMTQsIDB4Y2QyNjc4MDksIDB4YzMyZjc1MDIsIDB4ZTkxMDU2MzMsIDB4ZTcxOTViMzgsIDB4ZjUwMjRjMjUsIDB4ZmIwYjQxMmUsIDB4OWFkNzYxOGMsIDB4OTRkZTZjODcsIDB4ODZjNTdiOWEsIDB4ODhjYzc2OTEsIDB4YTJmMzU1YTAsIDB4YWNmYTU4YWIsIDB4YmVlMTRmYjYsIDB4YjBlODQyYmQsIDB4ZWE5ZjA5ZDQsIDB4ZTQ5NjA0ZGYsIDB4ZjY4ZDEzYzIsIDB4Zjg4NDFlYzksIDB4ZDJiYjNkZjgsIDB4ZGNiMjMwZjMsIDB4Y2VhOTI3ZWUsIDB4YzBhMDJhZTUsIDB4N2E0N2IxM2MsIDB4NzQ0ZWJjMzcsIDB4NjY1NWFiMmEsIDB4Njg1Y2E2MjEsIDB4NDI2Mzg1MTAsIDB4NGM2YTg4MWIsIDB4NWU3MTlmMDYsIDB4NTA3ODkyMGQsIDB4MGEwZmQ5NjQsIDB4MDQwNmQ0NmYsIDB4MTYxZGMzNzIsIDB4MTgxNGNlNzksIDB4MzIyYmVkNDgsIDB4M2MyMmUwNDMsIDB4MmUzOWY3NWUsIDB4MjAzMGZhNTUsIDB4ZWM5YWI3MDEsIDB4ZTI5M2JhMGEsIDB4ZjA4OGFkMTcsIDB4ZmU4MWEwMWMsIDB4ZDRiZTgzMmQsIDB4ZGFiNzhlMjYsIDB4YzhhYzk5M2IsIDB4YzZhNTk0MzAsIDB4OWNkMmRmNTksIDB4OTJkYmQyNTIsIDB4ODBjMGM1NGYsIDB4OGVjOWM4NDQsIDB4YTRmNmViNzUsIDB4YWFmZmU2N2UsIDB4YjhlNGYxNjMsIDB4YjZlZGZjNjgsIDB4MGMwYTY3YjEsIDB4MDIwMzZhYmEsIDB4MTAxODdkYTcsIDB4MWUxMTcwYWMsIDB4MzQyZTUzOWQsIDB4M2EyNzVlOTYsIDB4MjgzYzQ5OGIsIDB4MjYzNTQ0ODAsIDB4N2M0MjBmZTksIDB4NzI0YjAyZTIsIDB4NjA1MDE1ZmYsIDB4NmU1OTE4ZjQsIDB4NDQ2NjNiYzUsIDB4NGE2ZjM2Y2UsIDB4NTg3NDIxZDMsIDB4NTY3ZDJjZDgsIDB4MzdhMTBjN2EsIDB4MzlhODAxNzEsIDB4MmJiMzE2NmMsIDB4MjViYTFiNjcsIDB4MGY4NTM4NTYsIDB4MDE4YzM1NWQsIDB4MTM5NzIyNDAsIDB4MWQ5ZTJmNGIsIDB4NDdlOTY0MjIsIDB4NDllMDY5MjksIDB4NWJmYjdlMzQsIDB4NTVmMjczM2YsIDB4N2ZjZDUwMGUsIDB4NzFjNDVkMDUsIDB4NjNkZjRhMTgsIDB4NmRkNjQ3MTMsIDB4ZDczMWRjY2EsIDB4ZDkzOGQxYzEsIDB4Y2IyM2M2ZGMsIDB4YzUyYWNiZDcsIDB4ZWYxNWU4ZTYsIDB4ZTExY2U1ZWQsIDB4ZjMwN2YyZjAsIDB4ZmQwZWZmZmIsIDB4YTc3OWI0OTIsIDB4YTk3MGI5OTksIDB4YmI2YmFlODQsIDB4YjU2MmEzOGYsIDB4OWY1ZDgwYmUsIDB4OTE1NDhkYjUsIDB4ODM0ZjlhYTgsIDB4OGQ0Njk3YTNdO1xuY29uc3QgVTIgPSBbMHgwMDAwMDAwMCwgMHgwYjBlMDkwZCwgMHgxNjFjMTIxYSwgMHgxZDEyMWIxNywgMHgyYzM4MjQzNCwgMHgyNzM2MmQzOSwgMHgzYTI0MzYyZSwgMHgzMTJhM2YyMywgMHg1ODcwNDg2OCwgMHg1MzdlNDE2NSwgMHg0ZTZjNWE3MiwgMHg0NTYyNTM3ZiwgMHg3NDQ4NmM1YywgMHg3ZjQ2NjU1MSwgMHg2MjU0N2U0NiwgMHg2OTVhNzc0YiwgMHhiMGUwOTBkMCwgMHhiYmVlOTlkZCwgMHhhNmZjODJjYSwgMHhhZGYyOGJjNywgMHg5Y2Q4YjRlNCwgMHg5N2Q2YmRlOSwgMHg4YWM0YTZmZSwgMHg4MWNhYWZmMywgMHhlODkwZDhiOCwgMHhlMzllZDFiNSwgMHhmZThjY2FhMiwgMHhmNTgyYzNhZiwgMHhjNGE4ZmM4YywgMHhjZmE2ZjU4MSwgMHhkMmI0ZWU5NiwgMHhkOWJhZTc5YiwgMHg3YmRiM2JiYiwgMHg3MGQ1MzJiNiwgMHg2ZGM3MjlhMSwgMHg2NmM5MjBhYywgMHg1N2UzMWY4ZiwgMHg1Y2VkMTY4MiwgMHg0MWZmMGQ5NSwgMHg0YWYxMDQ5OCwgMHgyM2FiNzNkMywgMHgyOGE1N2FkZSwgMHgzNWI3NjFjOSwgMHgzZWI5NjhjNCwgMHgwZjkzNTdlNywgMHgwNDlkNWVlYSwgMHgxOThmNDVmZCwgMHgxMjgxNGNmMCwgMHhjYjNiYWI2YiwgMHhjMDM1YTI2NiwgMHhkZDI3Yjk3MSwgMHhkNjI5YjA3YywgMHhlNzAzOGY1ZiwgMHhlYzBkODY1MiwgMHhmMTFmOWQ0NSwgMHhmYTExOTQ0OCwgMHg5MzRiZTMwMywgMHg5ODQ1ZWEwZSwgMHg4NTU3ZjExOSwgMHg4ZTU5ZjgxNCwgMHhiZjczYzczNywgMHhiNDdkY2UzYSwgMHhhOTZmZDUyZCwgMHhhMjYxZGMyMCwgMHhmNmFkNzY2ZCwgMHhmZGEzN2Y2MCwgMHhlMGIxNjQ3NywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHhkMTliNWI1NCwgMHhjYzg5NDA0MywgMHhjNzg3NDk0ZSwgMHhhZWRkM2UwNSwgMHhhNWQzMzcwOCwgMHhiOGMxMmMxZiwgMHhiM2NmMjUxMiwgMHg4MmU1MWEzMSwgMHg4OWViMTMzYywgMHg5NGY5MDgyYiwgMHg5ZmY3MDEyNiwgMHg0NjRkZTZiZCwgMHg0ZDQzZWZiMCwgMHg1MDUxZjRhNywgMHg1YjVmZmRhYSwgMHg2YTc1YzI4OSwgMHg2MTdiY2I4NCwgMHg3YzY5ZDA5MywgMHg3NzY3ZDk5ZSwgMHgxZTNkYWVkNSwgMHgxNTMzYTdkOCwgMHgwODIxYmNjZiwgMHgwMzJmYjVjMiwgMHgzMjA1OGFlMSwgMHgzOTBiODNlYywgMHgyNDE5OThmYiwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg4Njc4NDRkYiwgMHg5YjZhNWZjYywgMHg5MDY0NTZjMSwgMHhhMTRlNjllMiwgMHhhYTQwNjBlZiwgMHhiNzUyN2JmOCwgMHhiYzVjNzJmNSwgMHhkNTA2MDViZSwgMHhkZTA4MGNiMywgMHhjMzFhMTdhNCwgMHhjODE0MWVhOSwgMHhmOTNlMjE4YSwgMHhmMjMwMjg4NywgMHhlZjIyMzM5MCwgMHhlNDJjM2E5ZCwgMHgzZDk2ZGQwNiwgMHgzNjk4ZDQwYiwgMHgyYjhhY2YxYywgMHgyMDg0YzYxMSwgMHgxMWFlZjkzMiwgMHgxYWEwZjAzZiwgMHgwN2IyZWIyOCwgMHgwY2JjZTIyNSwgMHg2NWU2OTU2ZSwgMHg2ZWU4OWM2MywgMHg3M2ZhODc3NCwgMHg3OGY0OGU3OSwgMHg0OWRlYjE1YSwgMHg0MmQwYjg1NywgMHg1ZmMyYTM0MCwgMHg1NGNjYWE0ZCwgMHhmNzQxZWNkYSwgMHhmYzRmZTVkNywgMHhlMTVkZmVjMCwgMHhlYTUzZjdjZCwgMHhkYjc5YzhlZSwgMHhkMDc3YzFlMywgMHhjZDY1ZGFmNCwgMHhjNjZiZDNmOSwgMHhhZjMxYTRiMiwgMHhhNDNmYWRiZiwgMHhiOTJkYjZhOCwgMHhiMjIzYmZhNSwgMHg4MzA5ODA4NiwgMHg4ODA3ODk4YiwgMHg5NTE1OTI5YywgMHg5ZTFiOWI5MSwgMHg0N2ExN2MwYSwgMHg0Y2FmNzUwNywgMHg1MWJkNmUxMCwgMHg1YWIzNjcxZCwgMHg2Yjk5NTgzZSwgMHg2MDk3NTEzMywgMHg3ZDg1NGEyNCwgMHg3NjhiNDMyOSwgMHgxZmQxMzQ2MiwgMHgxNGRmM2Q2ZiwgMHgwOWNkMjY3OCwgMHgwMmMzMmY3NSwgMHgzM2U5MTA1NiwgMHgzOGU3MTk1YiwgMHgyNWY1MDI0YywgMHgyZWZiMGI0MSwgMHg4YzlhZDc2MSwgMHg4Nzk0ZGU2YywgMHg5YTg2YzU3YiwgMHg5MTg4Y2M3NiwgMHhhMGEyZjM1NSwgMHhhYmFjZmE1OCwgMHhiNmJlZTE0ZiwgMHhiZGIwZTg0MiwgMHhkNGVhOWYwOSwgMHhkZmU0OTYwNCwgMHhjMmY2OGQxMywgMHhjOWY4ODQxZSwgMHhmOGQyYmIzZCwgMHhmM2RjYjIzMCwgMHhlZWNlYTkyNywgMHhlNWMwYTAyYSwgMHgzYzdhNDdiMSwgMHgzNzc0NGViYywgMHgyYTY2NTVhYiwgMHgyMTY4NWNhNiwgMHgxMDQyNjM4NSwgMHgxYjRjNmE4OCwgMHgwNjVlNzE5ZiwgMHgwZDUwNzg5MiwgMHg2NDBhMGZkOSwgMHg2ZjA0MDZkNCwgMHg3MjE2MWRjMywgMHg3OTE4MTRjZSwgMHg0ODMyMmJlZCwgMHg0MzNjMjJlMCwgMHg1ZTJlMzlmNywgMHg1NTIwMzBmYSwgMHgwMWVjOWFiNywgMHgwYWUyOTNiYSwgMHgxN2YwODhhZCwgMHgxY2ZlODFhMCwgMHgyZGQ0YmU4MywgMHgyNmRhYjc4ZSwgMHgzYmM4YWM5OSwgMHgzMGM2YTU5NCwgMHg1OTljZDJkZiwgMHg1MjkyZGJkMiwgMHg0ZjgwYzBjNSwgMHg0NDhlYzljOCwgMHg3NWE0ZjZlYiwgMHg3ZWFhZmZlNiwgMHg2M2I4ZTRmMSwgMHg2OGI2ZWRmYywgMHhiMTBjMGE2NywgMHhiYTAyMDM2YSwgMHhhNzEwMTg3ZCwgMHhhYzFlMTE3MCwgMHg5ZDM0MmU1MywgMHg5NjNhMjc1ZSwgMHg4YjI4M2M0OSwgMHg4MDI2MzU0NCwgMHhlOTdjNDIwZiwgMHhlMjcyNGIwMiwgMHhmZjYwNTAxNSwgMHhmNDZlNTkxOCwgMHhjNTQ0NjYzYiwgMHhjZTRhNmYzNiwgMHhkMzU4NzQyMSwgMHhkODU2N2QyYywgMHg3YTM3YTEwYywgMHg3MTM5YTgwMSwgMHg2YzJiYjMxNiwgMHg2NzI1YmExYiwgMHg1NjBmODUzOCwgMHg1ZDAxOGMzNSwgMHg0MDEzOTcyMiwgMHg0YjFkOWUyZiwgMHgyMjQ3ZTk2NCwgMHgyOTQ5ZTA2OSwgMHgzNDViZmI3ZSwgMHgzZjU1ZjI3MywgMHgwZTdmY2Q1MCwgMHgwNTcxYzQ1ZCwgMHgxODYzZGY0YSwgMHgxMzZkZDY0NywgMHhjYWQ3MzFkYywgMHhjMWQ5MzhkMSwgMHhkY2NiMjNjNiwgMHhkN2M1MmFjYiwgMHhlNmVmMTVlOCwgMHhlZGUxMWNlNSwgMHhmMGYzMDdmMiwgMHhmYmZkMGVmZiwgMHg5MmE3NzliNCwgMHg5OWE5NzBiOSwgMHg4NGJiNmJhZSwgMHg4ZmI1NjJhMywgMHhiZTlmNWQ4MCwgMHhiNTkxNTQ4ZCwgMHhhODgzNGY5YSwgMHhhMzhkNDY5N107XG5jb25zdCBVMyA9IFsweDAwMDAwMDAwLCAweDBkMGIwZTA5LCAweDFhMTYxYzEyLCAweDE3MWQxMjFiLCAweDM0MmMzODI0LCAweDM5MjczNjJkLCAweDJlM2EyNDM2LCAweDIzMzEyYTNmLCAweDY4NTg3MDQ4LCAweDY1NTM3ZTQxLCAweDcyNGU2YzVhLCAweDdmNDU2MjUzLCAweDVjNzQ0ODZjLCAweDUxN2Y0NjY1LCAweDQ2NjI1NDdlLCAweDRiNjk1YTc3LCAweGQwYjBlMDkwLCAweGRkYmJlZTk5LCAweGNhYTZmYzgyLCAweGM3YWRmMjhiLCAweGU0OWNkOGI0LCAweGU5OTdkNmJkLCAweGZlOGFjNGE2LCAweGYzODFjYWFmLCAweGI4ZTg5MGQ4LCAweGI1ZTM5ZWQxLCAweGEyZmU4Y2NhLCAweGFmZjU4MmMzLCAweDhjYzRhOGZjLCAweDgxY2ZhNmY1LCAweDk2ZDJiNGVlLCAweDliZDliYWU3LCAweGJiN2JkYjNiLCAweGI2NzBkNTMyLCAweGExNmRjNzI5LCAweGFjNjZjOTIwLCAweDhmNTdlMzFmLCAweDgyNWNlZDE2LCAweDk1NDFmZjBkLCAweDk4NGFmMTA0LCAweGQzMjNhYjczLCAweGRlMjhhNTdhLCAweGM5MzViNzYxLCAweGM0M2ViOTY4LCAweGU3MGY5MzU3LCAweGVhMDQ5ZDVlLCAweGZkMTk4ZjQ1LCAweGYwMTI4MTRjLCAweDZiY2IzYmFiLCAweDY2YzAzNWEyLCAweDcxZGQyN2I5LCAweDdjZDYyOWIwLCAweDVmZTcwMzhmLCAweDUyZWMwZDg2LCAweDQ1ZjExZjlkLCAweDQ4ZmExMTk0LCAweDAzOTM0YmUzLCAweDBlOTg0NWVhLCAweDE5ODU1N2YxLCAweDE0OGU1OWY4LCAweDM3YmY3M2M3LCAweDNhYjQ3ZGNlLCAweDJkYTk2ZmQ1LCAweDIwYTI2MWRjLCAweDZkZjZhZDc2LCAweDYwZmRhMzdmLCAweDc3ZTBiMTY0LCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDU0ZDE5YjViLCAweDQzY2M4OTQwLCAweDRlYzc4NzQ5LCAweDA1YWVkZDNlLCAweDA4YTVkMzM3LCAweDFmYjhjMTJjLCAweDEyYjNjZjI1LCAweDMxODJlNTFhLCAweDNjODllYjEzLCAweDJiOTRmOTA4LCAweDI2OWZmNzAxLCAweGJkNDY0ZGU2LCAweGIwNGQ0M2VmLCAweGE3NTA1MWY0LCAweGFhNWI1ZmZkLCAweDg5NmE3NWMyLCAweDg0NjE3YmNiLCAweDkzN2M2OWQwLCAweDllNzc2N2Q5LCAweGQ1MWUzZGFlLCAweGQ4MTUzM2E3LCAweGNmMDgyMWJjLCAweGMyMDMyZmI1LCAweGUxMzIwNThhLCAweGVjMzkwYjgzLCAweGZiMjQxOTk4LCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGRiODY3ODQ0LCAweGNjOWI2YTVmLCAweGMxOTA2NDU2LCAweGUyYTE0ZTY5LCAweGVmYWE0MDYwLCAweGY4Yjc1MjdiLCAweGY1YmM1YzcyLCAweGJlZDUwNjA1LCAweGIzZGUwODBjLCAweGE0YzMxYTE3LCAweGE5YzgxNDFlLCAweDhhZjkzZTIxLCAweDg3ZjIzMDI4LCAweDkwZWYyMjMzLCAweDlkZTQyYzNhLCAweDA2M2Q5NmRkLCAweDBiMzY5OGQ0LCAweDFjMmI4YWNmLCAweDExMjA4NGM2LCAweDMyMTFhZWY5LCAweDNmMWFhMGYwLCAweDI4MDdiMmViLCAweDI1MGNiY2UyLCAweDZlNjVlNjk1LCAweDYzNmVlODljLCAweDc0NzNmYTg3LCAweDc5NzhmNDhlLCAweDVhNDlkZWIxLCAweDU3NDJkMGI4LCAweDQwNWZjMmEzLCAweDRkNTRjY2FhLCAweGRhZjc0MWVjLCAweGQ3ZmM0ZmU1LCAweGMwZTE1ZGZlLCAweGNkZWE1M2Y3LCAweGVlZGI3OWM4LCAweGUzZDA3N2MxLCAweGY0Y2Q2NWRhLCAweGY5YzY2YmQzLCAweGIyYWYzMWE0LCAweGJmYTQzZmFkLCAweGE4YjkyZGI2LCAweGE1YjIyM2JmLCAweDg2ODMwOTgwLCAweDhiODgwNzg5LCAweDljOTUxNTkyLCAweDkxOWUxYjliLCAweDBhNDdhMTdjLCAweDA3NGNhZjc1LCAweDEwNTFiZDZlLCAweDFkNWFiMzY3LCAweDNlNmI5OTU4LCAweDMzNjA5NzUxLCAweDI0N2Q4NTRhLCAweDI5NzY4YjQzLCAweDYyMWZkMTM0LCAweDZmMTRkZjNkLCAweDc4MDljZDI2LCAweDc1MDJjMzJmLCAweDU2MzNlOTEwLCAweDViMzhlNzE5LCAweDRjMjVmNTAyLCAweDQxMmVmYjBiLCAweDYxOGM5YWQ3LCAweDZjODc5NGRlLCAweDdiOWE4NmM1LCAweDc2OTE4OGNjLCAweDU1YTBhMmYzLCAweDU4YWJhY2ZhLCAweDRmYjZiZWUxLCAweDQyYmRiMGU4LCAweDA5ZDRlYTlmLCAweDA0ZGZlNDk2LCAweDEzYzJmNjhkLCAweDFlYzlmODg0LCAweDNkZjhkMmJiLCAweDMwZjNkY2IyLCAweDI3ZWVjZWE5LCAweDJhZTVjMGEwLCAweGIxM2M3YTQ3LCAweGJjMzc3NDRlLCAweGFiMmE2NjU1LCAweGE2MjE2ODVjLCAweDg1MTA0MjYzLCAweDg4MWI0YzZhLCAweDlmMDY1ZTcxLCAweDkyMGQ1MDc4LCAweGQ5NjQwYTBmLCAweGQ0NmYwNDA2LCAweGMzNzIxNjFkLCAweGNlNzkxODE0LCAweGVkNDgzMjJiLCAweGUwNDMzYzIyLCAweGY3NWUyZTM5LCAweGZhNTUyMDMwLCAweGI3MDFlYzlhLCAweGJhMGFlMjkzLCAweGFkMTdmMDg4LCAweGEwMWNmZTgxLCAweDgzMmRkNGJlLCAweDhlMjZkYWI3LCAweDk5M2JjOGFjLCAweDk0MzBjNmE1LCAweGRmNTk5Y2QyLCAweGQyNTI5MmRiLCAweGM1NGY4MGMwLCAweGM4NDQ4ZWM5LCAweGViNzVhNGY2LCAweGU2N2VhYWZmLCAweGYxNjNiOGU0LCAweGZjNjhiNmVkLCAweDY3YjEwYzBhLCAweDZhYmEwMjAzLCAweDdkYTcxMDE4LCAweDcwYWMxZTExLCAweDUzOWQzNDJlLCAweDVlOTYzYTI3LCAweDQ5OGIyODNjLCAweDQ0ODAyNjM1LCAweDBmZTk3YzQyLCAweDAyZTI3MjRiLCAweDE1ZmY2MDUwLCAweDE4ZjQ2ZTU5LCAweDNiYzU0NDY2LCAweDM2Y2U0YTZmLCAweDIxZDM1ODc0LCAweDJjZDg1NjdkLCAweDBjN2EzN2ExLCAweDAxNzEzOWE4LCAweDE2NmMyYmIzLCAweDFiNjcyNWJhLCAweDM4NTYwZjg1LCAweDM1NWQwMThjLCAweDIyNDAxMzk3LCAweDJmNGIxZDllLCAweDY0MjI0N2U5LCAweDY5Mjk0OWUwLCAweDdlMzQ1YmZiLCAweDczM2Y1NWYyLCAweDUwMGU3ZmNkLCAweDVkMDU3MWM0LCAweDRhMTg2M2RmLCAweDQ3MTM2ZGQ2LCAweGRjY2FkNzMxLCAweGQxYzFkOTM4LCAweGM2ZGNjYjIzLCAweGNiZDdjNTJhLCAweGU4ZTZlZjE1LCAweGU1ZWRlMTFjLCAweGYyZjBmMzA3LCAweGZmZmJmZDBlLCAweGI0OTJhNzc5LCAweGI5OTlhOTcwLCAweGFlODRiYjZiLCAweGEzOGZiNTYyLCAweDgwYmU5ZjVkLCAweDhkYjU5MTU0LCAweDlhYTg4MzRmLCAweDk3YTM4ZDQ2XTtcbmNvbnN0IFU0ID0gWzB4MDAwMDAwMDAsIDB4MDkwZDBiMGUsIDB4MTIxYTE2MWMsIDB4MWIxNzFkMTIsIDB4MjQzNDJjMzgsIDB4MmQzOTI3MzYsIDB4MzYyZTNhMjQsIDB4M2YyMzMxMmEsIDB4NDg2ODU4NzAsIDB4NDE2NTUzN2UsIDB4NWE3MjRlNmMsIDB4NTM3ZjQ1NjIsIDB4NmM1Yzc0NDgsIDB4NjU1MTdmNDYsIDB4N2U0NjYyNTQsIDB4Nzc0YjY5NWEsIDB4OTBkMGIwZTAsIDB4OTlkZGJiZWUsIDB4ODJjYWE2ZmMsIDB4OGJjN2FkZjIsIDB4YjRlNDljZDgsIDB4YmRlOTk3ZDYsIDB4YTZmZThhYzQsIDB4YWZmMzgxY2EsIDB4ZDhiOGU4OTAsIDB4ZDFiNWUzOWUsIDB4Y2FhMmZlOGMsIDB4YzNhZmY1ODIsIDB4ZmM4Y2M0YTgsIDB4ZjU4MWNmYTYsIDB4ZWU5NmQyYjQsIDB4ZTc5YmQ5YmEsIDB4M2JiYjdiZGIsIDB4MzJiNjcwZDUsIDB4MjlhMTZkYzcsIDB4MjBhYzY2YzksIDB4MWY4ZjU3ZTMsIDB4MTY4MjVjZWQsIDB4MGQ5NTQxZmYsIDB4MDQ5ODRhZjEsIDB4NzNkMzIzYWIsIDB4N2FkZTI4YTUsIDB4NjFjOTM1YjcsIDB4NjhjNDNlYjksIDB4NTdlNzBmOTMsIDB4NWVlYTA0OWQsIDB4NDVmZDE5OGYsIDB4NGNmMDEyODEsIDB4YWI2YmNiM2IsIDB4YTI2NmMwMzUsIDB4Yjk3MWRkMjcsIDB4YjA3Y2Q2MjksIDB4OGY1ZmU3MDMsIDB4ODY1MmVjMGQsIDB4OWQ0NWYxMWYsIDB4OTQ0OGZhMTEsIDB4ZTMwMzkzNGIsIDB4ZWEwZTk4NDUsIDB4ZjExOTg1NTcsIDB4ZjgxNDhlNTksIDB4YzczN2JmNzMsIDB4Y2UzYWI0N2QsIDB4ZDUyZGE5NmYsIDB4ZGMyMGEyNjEsIDB4NzY2ZGY2YWQsIDB4N2Y2MGZkYTMsIDB4NjQ3N2UwYjEsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4NWI1NGQxOWIsIDB4NDA0M2NjODksIDB4NDk0ZWM3ODcsIDB4M2UwNWFlZGQsIDB4MzcwOGE1ZDMsIDB4MmMxZmI4YzEsIDB4MjUxMmIzY2YsIDB4MWEzMTgyZTUsIDB4MTMzYzg5ZWIsIDB4MDgyYjk0ZjksIDB4MDEyNjlmZjcsIDB4ZTZiZDQ2NGQsIDB4ZWZiMDRkNDMsIDB4ZjRhNzUwNTEsIDB4ZmRhYTViNWYsIDB4YzI4OTZhNzUsIDB4Y2I4NDYxN2IsIDB4ZDA5MzdjNjksIDB4ZDk5ZTc3NjcsIDB4YWVkNTFlM2QsIDB4YTdkODE1MzMsIDB4YmNjZjA4MjEsIDB4YjVjMjAzMmYsIDB4OGFlMTMyMDUsIDB4ODNlYzM5MGIsIDB4OThmYjI0MTksIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4NDRkYjg2NzgsIDB4NWZjYzliNmEsIDB4NTZjMTkwNjQsIDB4NjllMmExNGUsIDB4NjBlZmFhNDAsIDB4N2JmOGI3NTIsIDB4NzJmNWJjNWMsIDB4MDViZWQ1MDYsIDB4MGNiM2RlMDgsIDB4MTdhNGMzMWEsIDB4MWVhOWM4MTQsIDB4MjE4YWY5M2UsIDB4Mjg4N2YyMzAsIDB4MzM5MGVmMjIsIDB4M2E5ZGU0MmMsIDB4ZGQwNjNkOTYsIDB4ZDQwYjM2OTgsIDB4Y2YxYzJiOGEsIDB4YzYxMTIwODQsIDB4ZjkzMjExYWUsIDB4ZjAzZjFhYTAsIDB4ZWIyODA3YjIsIDB4ZTIyNTBjYmMsIDB4OTU2ZTY1ZTYsIDB4OWM2MzZlZTgsIDB4ODc3NDczZmEsIDB4OGU3OTc4ZjQsIDB4YjE1YTQ5ZGUsIDB4Yjg1NzQyZDAsIDB4YTM0MDVmYzIsIDB4YWE0ZDU0Y2MsIDB4ZWNkYWY3NDEsIDB4ZTVkN2ZjNGYsIDB4ZmVjMGUxNWQsIDB4ZjdjZGVhNTMsIDB4YzhlZWRiNzksIDB4YzFlM2QwNzcsIDB4ZGFmNGNkNjUsIDB4ZDNmOWM2NmIsIDB4YTRiMmFmMzEsIDB4YWRiZmE0M2YsIDB4YjZhOGI5MmQsIDB4YmZhNWIyMjMsIDB4ODA4NjgzMDksIDB4ODk4Yjg4MDcsIDB4OTI5Yzk1MTUsIDB4OWI5MTllMWIsIDB4N2MwYTQ3YTEsIDB4NzUwNzRjYWYsIDB4NmUxMDUxYmQsIDB4NjcxZDVhYjMsIDB4NTgzZTZiOTksIDB4NTEzMzYwOTcsIDB4NGEyNDdkODUsIDB4NDMyOTc2OGIsIDB4MzQ2MjFmZDEsIDB4M2Q2ZjE0ZGYsIDB4MjY3ODA5Y2QsIDB4MmY3NTAyYzMsIDB4MTA1NjMzZTksIDB4MTk1YjM4ZTcsIDB4MDI0YzI1ZjUsIDB4MGI0MTJlZmIsIDB4ZDc2MThjOWEsIDB4ZGU2Yzg3OTQsIDB4YzU3YjlhODYsIDB4Y2M3NjkxODgsIDB4ZjM1NWEwYTIsIDB4ZmE1OGFiYWMsIDB4ZTE0ZmI2YmUsIDB4ZTg0MmJkYjAsIDB4OWYwOWQ0ZWEsIDB4OTYwNGRmZTQsIDB4OGQxM2MyZjYsIDB4ODQxZWM5ZjgsIDB4YmIzZGY4ZDIsIDB4YjIzMGYzZGMsIDB4YTkyN2VlY2UsIDB4YTAyYWU1YzAsIDB4NDdiMTNjN2EsIDB4NGViYzM3NzQsIDB4NTVhYjJhNjYsIDB4NWNhNjIxNjgsIDB4NjM4NTEwNDIsIDB4NmE4ODFiNGMsIDB4NzE5ZjA2NWUsIDB4Nzg5MjBkNTAsIDB4MGZkOTY0MGEsIDB4MDZkNDZmMDQsIDB4MWRjMzcyMTYsIDB4MTRjZTc5MTgsIDB4MmJlZDQ4MzIsIDB4MjJlMDQzM2MsIDB4MzlmNzVlMmUsIDB4MzBmYTU1MjAsIDB4OWFiNzAxZWMsIDB4OTNiYTBhZTIsIDB4ODhhZDE3ZjAsIDB4ODFhMDFjZmUsIDB4YmU4MzJkZDQsIDB4Yjc4ZTI2ZGEsIDB4YWM5OTNiYzgsIDB4YTU5NDMwYzYsIDB4ZDJkZjU5OWMsIDB4ZGJkMjUyOTIsIDB4YzBjNTRmODAsIDB4YzljODQ0OGUsIDB4ZjZlYjc1YTQsIDB4ZmZlNjdlYWEsIDB4ZTRmMTYzYjgsIDB4ZWRmYzY4YjYsIDB4MGE2N2IxMGMsIDB4MDM2YWJhMDIsIDB4MTg3ZGE3MTAsIDB4MTE3MGFjMWUsIDB4MmU1MzlkMzQsIDB4Mjc1ZTk2M2EsIDB4M2M0OThiMjgsIDB4MzU0NDgwMjYsIDB4NDIwZmU5N2MsIDB4NGIwMmUyNzIsIDB4NTAxNWZmNjAsIDB4NTkxOGY0NmUsIDB4NjYzYmM1NDQsIDB4NmYzNmNlNGEsIDB4NzQyMWQzNTgsIDB4N2QyY2Q4NTYsIDB4YTEwYzdhMzcsIDB4YTgwMTcxMzksIDB4YjMxNjZjMmIsIDB4YmExYjY3MjUsIDB4ODUzODU2MGYsIDB4OGMzNTVkMDEsIDB4OTcyMjQwMTMsIDB4OWUyZjRiMWQsIDB4ZTk2NDIyNDcsIDB4ZTA2OTI5NDksIDB4ZmI3ZTM0NWIsIDB4ZjI3MzNmNTUsIDB4Y2Q1MDBlN2YsIDB4YzQ1ZDA1NzEsIDB4ZGY0YTE4NjMsIDB4ZDY0NzEzNmQsIDB4MzFkY2NhZDcsIDB4MzhkMWMxZDksIDB4MjNjNmRjY2IsIDB4MmFjYmQ3YzUsIDB4MTVlOGU2ZWYsIDB4MWNlNWVkZTEsIDB4MDdmMmYwZjMsIDB4MGVmZmZiZmQsIDB4NzliNDkyYTcsIDB4NzBiOTk5YTksIDB4NmJhZTg0YmIsIDB4NjJhMzhmYjUsIDB4NWQ4MGJlOWYsIDB4NTQ4ZGI1OTEsIDB4NGY5YWE4ODMsIDB4NDY5N2EzOGRdO1xuZnVuY3Rpb24gY29udmVydFRvSW50MzIoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKChieXRlc1tpXSA8PCAyNCkgfCAoYnl0ZXNbaSArIDFdIDw8IDE2KSB8IChieXRlc1tpICsgMl0gPDwgOCkgfCBieXRlc1tpICsgM10pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgQUVTIHtcbiAgICBnZXQga2V5KCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX2tleSwgXCJmXCIpLnNsaWNlKCk7IH1cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgX0FFU19rZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBRVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BRVNfa2V5LCBuZXcgVWludDhBcnJheShrZXkpLCBcImZcIik7XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG4gICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZSwgW10sIFwiZlwiKTtcbiAgICAgICAgLy8gZGVjcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZCwgW10sIFwiZlwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZEtleUNvdW50ID0gKHJvdW5kcyArIDEpICogNDtcbiAgICAgICAgY29uc3QgS0MgPSB0aGlzLmtleS5sZW5ndGggLyA0O1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG4gICAgICAgIGNvbnN0IHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4ID0gaSA+PiAyO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZpcHMtMTk3IHNlY3Rpb24gNS4yKVxuICAgICAgICBsZXQgcmNvbnBvaW50ZXIgPSAwO1xuICAgICAgICBsZXQgdCA9IEtDLCB0dDtcbiAgICAgICAgd2hpbGUgKHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG4gICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG4gICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAoU1t0dCAmIDB4RkZdIDw8IDgpIF5cbiAgICAgICAgICAgICAgICBTWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgKHJjb25bcmNvbnBvaW50ZXJdIDw8IDI0KSk7XG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZm9yIG5vbi0yNTYgYml0KVxuICAgICAgICAgICAgaWYgKEtDICE9IDgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XG4gICAgICAgICAgICAgICAgdGtbS0MgLyAyXSBePSAoU1t0dCAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgOCkgXlxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IChLQyAvIDIpICsgMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuICAgICAgICAgICAgbGV0IGkgPSAwLCByLCBjO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBLQyAmJiB0IDwgcm91bmRLZXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG4gICAgICAgICAgICAgICAgYyA9IHQgJSA0O1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW3JdW2NdID0gdGtbaV07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuICAgICAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA0OyBjKyspIHtcbiAgICAgICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUzWyh0dCA+PiA4KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgVTRbdHQgJiAweEZGXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91bmRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIikubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG4gICAgICAgIGxldCB0ID0gY29udmVydFRvSW50MzIocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbMF1baV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgcm91bmQgdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSAoVDFbKHRbaV0gPj4gMjQpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ0W3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBsZXQgdHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdHQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyb3VuZHNdW2ldO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpXSA9IChTWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF4gKHR0ID4+IDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTW3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIC8vIGNvbnZlcnQgcGxhaW50ZXh0IHRvIChpbnRzIF4ga2V5KVxuICAgICAgICBsZXQgdCA9IGNvbnZlcnRUb0ludDMyKGNpcGhlcnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVswXVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ3Wyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDhbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGxldCB0dCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JvdW5kc11baV07XG4gICAgICAgICAgICByZXN1bHRbNCAqIGldID0gKFNpWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNpW3RbKGkgKyAxKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BRVMgPSBBRVM7XG5fQUVTX2tleSA9IG5ldyBXZWFrTWFwKCksIF9BRVNfS2QgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tlID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pkcs7Strip = exports.pkcs7Pad = exports.OFB = exports.ECB = exports.CTR = exports.CFB = exports.CBC = exports.ModeOfOperation = exports.AES = void 0;\nvar aes_js_1 = __webpack_require__(/*! ./aes.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js\");\nObject.defineProperty(exports, \"AES\", ({ enumerable: true, get: function () { return aes_js_1.AES; } }));\nvar mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nObject.defineProperty(exports, \"ModeOfOperation\", ({ enumerable: true, get: function () { return mode_js_1.ModeOfOperation; } }));\nvar mode_cbc_js_1 = __webpack_require__(/*! ./mode-cbc.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cbc.js\");\nObject.defineProperty(exports, \"CBC\", ({ enumerable: true, get: function () { return mode_cbc_js_1.CBC; } }));\nvar mode_cfb_js_1 = __webpack_require__(/*! ./mode-cfb.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cfb.js\");\nObject.defineProperty(exports, \"CFB\", ({ enumerable: true, get: function () { return mode_cfb_js_1.CFB; } }));\nvar mode_ctr_js_1 = __webpack_require__(/*! ./mode-ctr.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ctr.js\");\nObject.defineProperty(exports, \"CTR\", ({ enumerable: true, get: function () { return mode_ctr_js_1.CTR; } }));\nvar mode_ecb_js_1 = __webpack_require__(/*! ./mode-ecb.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ecb.js\");\nObject.defineProperty(exports, \"ECB\", ({ enumerable: true, get: function () { return mode_ecb_js_1.ECB; } }));\nvar mode_ofb_js_1 = __webpack_require__(/*! ./mode-ofb.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ofb.js\");\nObject.defineProperty(exports, \"OFB\", ({ enumerable: true, get: function () { return mode_ofb_js_1.OFB; } }));\nvar padding_js_1 = __webpack_require__(/*! ./padding.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/padding.js\");\nObject.defineProperty(exports, \"pkcs7Pad\", ({ enumerable: true, get: function () { return padding_js_1.pkcs7Pad; } }));\nObject.defineProperty(exports, \"pkcs7Strip\", ({ enumerable: true, get: function () { return padding_js_1.pkcs7Strip; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsdUJBQXVCLEdBQUcsV0FBVztBQUNuSixlQUFlLG1CQUFPLENBQUMscUZBQVU7QUFDakMsdUNBQXNDLEVBQUUscUNBQXFDLHdCQUF3QixFQUFDO0FBQ3RHLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFXO0FBQ25DLG1EQUFrRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMvSCxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBZTtBQUMzQyx1Q0FBc0MsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDM0csb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWU7QUFDM0MsdUNBQXNDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzNHLG9CQUFvQixtQkFBTyxDQUFDLCtGQUFlO0FBQzNDLHVDQUFzQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMzRyxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBZTtBQUMzQyx1Q0FBc0MsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDM0csb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWU7QUFDM0MsdUNBQXNDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzNHLG1CQUFtQixtQkFBTyxDQUFDLDZGQUFjO0FBQ3pDLDRDQUEyQyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNwSCw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL2luZGV4LmpzPzMzN2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBrY3M3U3RyaXAgPSBleHBvcnRzLnBrY3M3UGFkID0gZXhwb3J0cy5PRkIgPSBleHBvcnRzLkVDQiA9IGV4cG9ydHMuQ1RSID0gZXhwb3J0cy5DRkIgPSBleHBvcnRzLkNCQyA9IGV4cG9ydHMuTW9kZU9mT3BlcmF0aW9uID0gZXhwb3J0cy5BRVMgPSB2b2lkIDA7XG52YXIgYWVzX2pzXzEgPSByZXF1aXJlKFwiLi9hZXMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBRVNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFlc19qc18xLkFFUzsgfSB9KTtcbnZhciBtb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9kZU9mT3BlcmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlX2pzXzEuTW9kZU9mT3BlcmF0aW9uOyB9IH0pO1xudmFyIG1vZGVfY2JjX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLWNiYy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNCQ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kZV9jYmNfanNfMS5DQkM7IH0gfSk7XG52YXIgbW9kZV9jZmJfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUtY2ZiLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ0ZCXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlX2NmYl9qc18xLkNGQjsgfSB9KTtcbnZhciBtb2RlX2N0cl9qc18xID0gcmVxdWlyZShcIi4vbW9kZS1jdHIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDVFJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZGVfY3RyX2pzXzEuQ1RSOyB9IH0pO1xudmFyIG1vZGVfZWNiX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLWVjYi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVDQlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kZV9lY2JfanNfMS5FQ0I7IH0gfSk7XG52YXIgbW9kZV9vZmJfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUtb2ZiLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT0ZCXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlX29mYl9qc18xLk9GQjsgfSB9KTtcbnZhciBwYWRkaW5nX2pzXzEgPSByZXF1aXJlKFwiLi9wYWRkaW5nLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGtjczdQYWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhZGRpbmdfanNfMS5wa2NzN1BhZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBrY3M3U3RyaXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhZGRpbmdfanNfMS5wa2NzN1N0cmlwOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cbc.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cbc.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Cipher Block Chaining\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CBC_iv, _CBC_lastBlock;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CBC = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass CBC extends mode_js_1.ModeOfOperation {\n    constructor(key, iv) {\n        super(\"ECC\", key, CBC);\n        _CBC_iv.set(this, void 0);\n        _CBC_lastBlock.set(this, void 0);\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, \"f\");\n    }\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, \"f\")); }\n    encrypt(plaintext) {\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const ciphertext = new Uint8Array(plaintext.length);\n        for (let i = 0; i < plaintext.length; i += 16) {\n            for (let j = 0; j < 16; j++) {\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] ^= plaintext[i + j];\n            }\n            __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\")), \"f\");\n            ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\"), i);\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        const plaintext = new Uint8Array(ciphertext.length);\n        for (let i = 0; i < ciphertext.length; i += 16) {\n            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));\n            for (let j = 0; j < 16; j++) {\n                plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j];\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] = ciphertext[i + j];\n            }\n        }\n        return plaintext;\n    }\n}\nexports.CBC = CBC;\n_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();\n//# sourceMappingURL=mode-cbc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY2JjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5jb21tb25qcy9tb2RlLWNiYy5qcz80MDMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ2lwaGVyIEJsb2NrIENoYWluaW5nXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NCQ19pdiwgX0NCQ19sYXN0QmxvY2s7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNCQyA9IHZvaWQgMDtcbmNvbnN0IG1vZGVfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUuanNcIik7XG5jbGFzcyBDQkMgZXh0ZW5kcyBtb2RlX2pzXzEuTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGl2KSB7XG4gICAgICAgIHN1cGVyKFwiRUNDXCIsIGtleSwgQ0JDKTtcbiAgICAgICAgX0NCQ19pdi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NCQ19sYXN0QmxvY2suc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgaWYgKGl2Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfaXYsIG5ldyBVaW50OEFycmF5KGl2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2l2LCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCB0aGlzLml2LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBpdigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19pdiwgXCJmXCIpKTsgfVxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgIGlmIChwbGFpbnRleHQubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdIF49IHBsYWludGV4dFtpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgICAgIGNpcGhlcnRleHQuc2V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5hZXMuZGVjcnlwdChjaXBoZXJ0ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSA9IGJsb2NrW2pdIF4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXSA9IGNpcGhlcnRleHRbaSArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfVxufVxuZXhwb3J0cy5DQkMgPSBDQkM7XG5fQ0JDX2l2ID0gbmV3IFdlYWtNYXAoKSwgX0NCQ19sYXN0QmxvY2sgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1jYmMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cbc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cfb.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cfb.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Cipher Feedback\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CFB = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass CFB extends mode_js_1.ModeOfOperation {\n    constructor(key, iv, segmentSize = 8) {\n        super(\"CFB\", key, CFB);\n        _CFB_instances.add(this);\n        _CFB_iv.set(this, void 0);\n        _CFB_shiftRegister.set(this, void 0);\n        // This library currently only handles byte-aligned segmentSize\n        if (!Number.isInteger(segmentSize) || (segmentSize % 8)) {\n            throw new TypeError(\"invalid segmentSize\");\n        }\n        Object.defineProperties(this, {\n            segmentSize: { enumerable: true, value: segmentSize }\n        });\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, \"f\");\n    }\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \"f\")); }\n    encrypt(plaintext) {\n        if (8 * plaintext.length % this.segmentSize) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const ciphertext = new Uint8Array(plaintext);\n        for (let i = 0; i < ciphertext.length; i += segmentSize) {\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for (let j = 0; j < segmentSize; j++) {\n                ciphertext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (8 * ciphertext.length % this.segmentSize) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const plaintext = new Uint8Array(ciphertext);\n        for (let i = 0; i < plaintext.length; i += segmentSize) {\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for (let j = 0; j < segmentSize; j++) {\n                plaintext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return plaintext;\n    }\n}\nexports.CFB = CFB;\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\n    const segmentSize = this.segmentSize / 8;\n    // Shift the register\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").subarray(segmentSize));\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(data.subarray(0, segmentSize), 16 - segmentSize);\n};\n//# sourceMappingURL=mode-cfb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY2ZiLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY2ZiLmpzPzE2MzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDaXBoZXIgRmVlZGJhY2tcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ0ZCX2luc3RhbmNlcywgX0NGQl9pdiwgX0NGQl9zaGlmdFJlZ2lzdGVyLCBfQ0ZCX3NoaWZ0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DRkIgPSB2b2lkIDA7XG5jb25zdCBtb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLmpzXCIpO1xuY2xhc3MgQ0ZCIGV4dGVuZHMgbW9kZV9qc18xLk1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpdiwgc2VnbWVudFNpemUgPSA4KSB7XG4gICAgICAgIHN1cGVyKFwiQ0ZCXCIsIGtleSwgQ0ZCKTtcbiAgICAgICAgX0NGQl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBfQ0ZCX2l2LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ0ZCX3NoaWZ0UmVnaXN0ZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8vIFRoaXMgbGlicmFyeSBjdXJyZW50bHkgb25seSBoYW5kbGVzIGJ5dGUtYWxpZ25lZCBzZWdtZW50U2l6ZVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VnbWVudFNpemUpIHx8IChzZWdtZW50U2l6ZSAlIDgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBzZWdtZW50U2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBzZWdtZW50U2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogc2VnbWVudFNpemUgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICBpZiAoaXYubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpdiBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NGQl9pdiwgbmV3IFVpbnQ4QXJyYXkoaXYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DRkJfaXYsIG5ldyBVaW50OEFycmF5KDE2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCB0aGlzLml2LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBpdigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9pdiwgXCJmXCIpKTsgfVxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgIGlmICg4ICogcGxhaW50ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIHNlZ21lbnRTaXplIGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWdtZW50U2l6ZSA9IHRoaXMuc2VnbWVudFNpemUgLyA4O1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSBzZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgeG9yU2VnbWVudCA9IHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlZ21lbnRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0W2kgKyBqXSBePSB4b3JTZWdtZW50W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX2luc3RhbmNlcywgXCJtXCIsIF9DRkJfc2hpZnQpLmNhbGwodGhpcywgY2lwaGVydGV4dC5zdWJhcnJheShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoOCAqIGNpcGhlcnRleHQubGVuZ3RoICUgdGhpcy5zZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIHNlZ21lbnRTaXplIGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWdtZW50U2l6ZSA9IHRoaXMuc2VnbWVudFNpemUgLyA4O1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IHNlZ21lbnRTaXplKSB7XG4gICAgICAgICAgICBjb25zdCB4b3JTZWdtZW50ID0gdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VnbWVudFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9pbnN0YW5jZXMsIFwibVwiLCBfQ0ZCX3NoaWZ0KS5jYWxsKHRoaXMsIGNpcGhlcnRleHQuc3ViYXJyYXkoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfVxufVxuZXhwb3J0cy5DRkIgPSBDRkI7XG5fQ0ZCX2l2ID0gbmV3IFdlYWtNYXAoKSwgX0NGQl9zaGlmdFJlZ2lzdGVyID0gbmV3IFdlYWtNYXAoKSwgX0NGQl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfQ0ZCX3NoaWZ0ID0gZnVuY3Rpb24gX0NGQl9zaGlmdChkYXRhKSB7XG4gICAgY29uc3Qgc2VnbWVudFNpemUgPSB0aGlzLnNlZ21lbnRTaXplIC8gODtcbiAgICAvLyBTaGlmdCB0aGUgcmVnaXN0ZXJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpLnNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpLnN1YmFycmF5KHNlZ21lbnRTaXplKSk7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKS5zZXQoZGF0YS5zdWJhcnJheSgwLCBzZWdtZW50U2l6ZSksIDE2IC0gc2VnbWVudFNpemUpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY2ZiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cfb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ctr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ctr.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Counter Mode\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CTR_remaining, _CTR_remainingIndex, _CTR_counter;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CTR = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass CTR extends mode_js_1.ModeOfOperation {\n    constructor(key, initialValue) {\n        super(\"CTR\", key, CTR);\n        // Remaining bytes for the one-time pad\n        _CTR_remaining.set(this, void 0);\n        _CTR_remainingIndex.set(this, void 0);\n        // The current counter\n        _CTR_counter.set(this, void 0);\n        __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), \"f\");\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").fill(0);\n        __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, \"f\"), \"f\"); // This will be discarded immediately\n        __classPrivateFieldSet(this, _CTR_remainingIndex, 16, \"f\");\n        if (initialValue == null) {\n            initialValue = 1;\n        }\n        if (typeof (initialValue) === \"number\") {\n            this.setCounterValue(initialValue);\n        }\n        else {\n            this.setCounterBytes(initialValue);\n        }\n    }\n    get counter() { return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, \"f\")); }\n    setCounterValue(value) {\n        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {\n            throw new TypeError(\"invalid counter initial integer value\");\n        }\n        for (let index = 15; index >= 0; --index) {\n            __classPrivateFieldGet(this, _CTR_counter, \"f\")[index] = value % 256;\n            value = Math.floor(value / 256);\n        }\n    }\n    setCounterBytes(value) {\n        if (value.length !== 16) {\n            throw new TypeError(\"invalid counter initial Uint8Array value length\");\n        }\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").set(value);\n    }\n    increment() {\n        for (let i = 15; i >= 0; i--) {\n            if (__classPrivateFieldGet(this, _CTR_counter, \"f\")[i] === 255) {\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i] = 0;\n            }\n            else {\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i]++;\n                break;\n            }\n        }\n    }\n    encrypt(plaintext) {\n        var _a, _b;\n        const crypttext = new Uint8Array(plaintext);\n        for (let i = 0; i < crypttext.length; i++) {\n            if (__classPrivateFieldGet(this, _CTR_remainingIndex, \"f\") === 16) {\n                __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, \"f\");\n                this.increment();\n            }\n            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, \"f\")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\n        }\n        return crypttext;\n    }\n    decrypt(ciphertext) {\n        return this.encrypt(ciphertext);\n    }\n}\nexports.CTR = CTR;\n_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();\n//# sourceMappingURL=mode-ctr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY3RyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5jb21tb25qcy9tb2RlLWN0ci5qcz8wZTliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ291bnRlciBNb2RlXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NUUl9yZW1haW5pbmcsIF9DVFJfcmVtYWluaW5nSW5kZXgsIF9DVFJfY291bnRlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ1RSID0gdm9pZCAwO1xuY29uc3QgbW9kZV9qc18xID0gcmVxdWlyZShcIi4vbW9kZS5qc1wiKTtcbmNsYXNzIENUUiBleHRlbmRzIG1vZGVfanNfMS5Nb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIHN1cGVyKFwiQ1RSXCIsIGtleSwgQ1RSKTtcbiAgICAgICAgLy8gUmVtYWluaW5nIGJ5dGVzIGZvciB0aGUgb25lLXRpbWUgcGFkXG4gICAgICAgIF9DVFJfcmVtYWluaW5nLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ1RSX3JlbWFpbmluZ0luZGV4LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvLyBUaGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIF9DVFJfY291bnRlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIG5ldyBVaW50OEFycmF5KDE2KSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpLmZpbGwoMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIiksIFwiZlwiKTsgLy8gVGhpcyB3aWxsIGJlIGRpc2NhcmRlZCBpbW1lZGlhdGVseVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIDE2LCBcImZcIik7XG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChpbml0aWFsVmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvdW50ZXJWYWx1ZShpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDb3VudGVyQnl0ZXMoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY291bnRlcigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikpOyB9XG4gICAgc2V0Q291bnRlclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNvdW50ZXIgaW5pdGlhbCBpbnRlZ2VyIHZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTU7IGluZGV4ID49IDA7IC0taW5kZXgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaW5kZXhdID0gdmFsdWUgJSAyNTY7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyAyNTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvdW50ZXJCeXRlcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY291bnRlciBpbml0aWFsIFVpbnQ4QXJyYXkgdmFsdWUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikuc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgaW5jcmVtZW50KCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTU7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpXSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY3J5cHR0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcnlwdHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIFwiZlwiKSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nLCB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikpLCBcImZcIik7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAwLCBcImZcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyeXB0dGV4dFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nLCBcImZcIilbX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAoX2IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIFwiZlwiKSwgX2EgPSBfYisrLCBfYiksIFwiZlwiKSwgX2FdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcnlwdHRleHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0KGNpcGhlcnRleHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ1RSID0gQ1RSO1xuX0NUUl9yZW1haW5pbmcgPSBuZXcgV2Vha01hcCgpLCBfQ1RSX3JlbWFpbmluZ0luZGV4ID0gbmV3IFdlYWtNYXAoKSwgX0NUUl9jb3VudGVyID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY3RyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ctr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ecb.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ecb.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Electronic Code Book\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ECB = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass ECB extends mode_js_1.ModeOfOperation {\n    constructor(key) {\n        super(\"ECB\", key, ECB);\n    }\n    encrypt(plaintext) {\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const crypttext = new Uint8Array(plaintext.length);\n        for (let i = 0; i < plaintext.length; i += 16) {\n            crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);\n        }\n        return crypttext;\n    }\n    decrypt(crypttext) {\n        if (crypttext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        const plaintext = new Uint8Array(crypttext.length);\n        for (let i = 0; i < crypttext.length; i += 16) {\n            plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);\n        }\n        return plaintext;\n    }\n}\nexports.ECB = ECB;\n//# sourceMappingURL=mode-ecb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtZWNiLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5jb21tb25qcy9tb2RlLWVjYi5qcz84NDRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gRWxlY3Ryb25pYyBDb2RlIEJvb2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRUNCID0gdm9pZCAwO1xuY29uc3QgbW9kZV9qc18xID0gcmVxdWlyZShcIi4vbW9kZS5qc1wiKTtcbmNsYXNzIEVDQiBleHRlbmRzIG1vZGVfanNfMS5Nb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICBzdXBlcihcIkVDQlwiLCBrZXksIEVDQik7XG4gICAgfVxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgIGlmIChwbGFpbnRleHQubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcnlwdHRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBjcnlwdHRleHQuc2V0KHRoaXMuYWVzLmVuY3J5cHQocGxhaW50ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3J5cHR0ZXh0O1xuICAgIH1cbiAgICBkZWNyeXB0KGNyeXB0dGV4dCkge1xuICAgICAgICBpZiAoY3J5cHR0ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IG5ldyBVaW50OEFycmF5KGNyeXB0dGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNyeXB0dGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIHBsYWludGV4dC5zZXQodGhpcy5hZXMuZGVjcnlwdChjcnlwdHRleHQuc3ViYXJyYXkoaSwgaSArIDE2KSksIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfVxufVxuZXhwb3J0cy5FQ0IgPSBFQ0I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWVjYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ecb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ofb.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ofb.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Output Feedback\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OFB = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass OFB extends mode_js_1.ModeOfOperation {\n    constructor(key, iv) {\n        super(\"OFB\", key, OFB);\n        _OFB_iv.set(this, void 0);\n        _OFB_lastPrecipher.set(this, void 0);\n        _OFB_lastPrecipherIndex.set(this, void 0);\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(iv), \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _OFB_lastPrecipher, this.iv, \"f\");\n        __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 16, \"f\");\n    }\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, \"f\")); }\n    encrypt(plaintext) {\n        var _a, _b;\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const ciphertext = new Uint8Array(plaintext);\n        for (let i = 0; i < ciphertext.length; i++) {\n            if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\") === 16) {\n                __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, \"f\");\n            }\n            ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")[__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        return this.encrypt(ciphertext);\n    }\n}\nexports.OFB = OFB;\n_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();\n//# sourceMappingURL=mode-ofb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtb2ZiLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5jb21tb25qcy9tb2RlLW9mYi5qcz85NGM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gT3V0cHV0IEZlZWRiYWNrXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX09GQl9pdiwgX09GQl9sYXN0UHJlY2lwaGVyLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT0ZCID0gdm9pZCAwO1xuY29uc3QgbW9kZV9qc18xID0gcmVxdWlyZShcIi4vbW9kZS5qc1wiKTtcbmNsYXNzIE9GQiBleHRlbmRzIG1vZGVfanNfMS5Nb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgaXYpIHtcbiAgICAgICAgc3VwZXIoXCJPRkJcIiwga2V5LCBPRkIpO1xuICAgICAgICBfT0ZCX2l2LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfT0ZCX2xhc3RQcmVjaXBoZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgIGlmIChpdi5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGl2IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2l2LCBuZXcgVWludDhBcnJheShpdiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9pdiwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXIsIHRoaXMuaXYsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleCwgMTYsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGl2KCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfT0ZCX2l2LCBcImZcIikpOyB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCBcImZcIikgPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXIsIHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXIsIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCAwLCBcImZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0W2ldIF49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVyLCBcImZcIilbX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleCwgKF9iID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleCwgXCJmXCIpLCBfYSA9IF9iKyssIF9iKSwgXCJmXCIpLCBfYV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0KGNpcGhlcnRleHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuT0ZCID0gT0ZCO1xuX09GQl9pdiA9IG5ldyBXZWFrTWFwKCksIF9PRkJfbGFzdFByZWNpcGhlciA9IG5ldyBXZWFrTWFwKCksIF9PRkJfbGFzdFByZWNpcGhlckluZGV4ID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtb2ZiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ofb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModeOfOperation = void 0;\nconst aes_js_1 = __webpack_require__(/*! ./aes.js */ \"(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js\");\nclass ModeOfOperation {\n    constructor(name, key, cls) {\n        if (cls && !(this instanceof cls)) {\n            throw new Error(`${name} must be instantiated with \"new\"`);\n        }\n        Object.defineProperties(this, {\n            aes: { enumerable: true, value: new aes_js_1.AES(key) },\n            name: { enumerable: true, value: name }\n        });\n    }\n}\nexports.ModeOfOperation = ModeOfOperation;\n//# sourceMappingURL=mode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWdEO0FBQ25FLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS5qcz8yMjgxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nb2RlT2ZPcGVyYXRpb24gPSB2b2lkIDA7XG5jb25zdCBhZXNfanNfMSA9IHJlcXVpcmUoXCIuL2Flcy5qc1wiKTtcbmNsYXNzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwga2V5LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBjbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBcIm5ld1wiYCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWVzOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBuZXcgYWVzX2pzXzEuQUVTKGtleSkgfSxcbiAgICAgICAgICAgIG5hbWU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IG5hbWUgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk1vZGVPZk9wZXJhdGlvbiA9IE1vZGVPZk9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/padding.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/padding.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pkcs7Strip = exports.pkcs7Pad = void 0;\nfunction pkcs7Pad(data) {\n    const padder = 16 - (data.length % 16);\n    const result = new Uint8Array(data.length + padder);\n    result.set(data);\n    for (let i = data.length; i < result.length; i++) {\n        result[i] = padder;\n    }\n    return result;\n}\nexports.pkcs7Pad = pkcs7Pad;\nfunction pkcs7Strip(data) {\n    if (data.length < 16) {\n        throw new TypeError('PKCS#7 invalid length');\n    }\n    const padder = data[data.length - 1];\n    if (padder > 16) {\n        throw new TypeError('PKCS#7 padding byte out of range');\n    }\n    const length = data.length - padder;\n    for (let i = 0; i < padder; i++) {\n        if (data[length + i] !== padder) {\n            throw new TypeError('PKCS#7 invalid padding byte');\n        }\n    }\n    return new Uint8Array(data.subarray(0, length));\n}\nexports.pkcs7Strip = pkcs7Strip;\n//# sourceMappingURL=padding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL3BhZGRpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL3BhZGRpbmcuanM/NzcxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGtjczdTdHJpcCA9IGV4cG9ydHMucGtjczdQYWQgPSB2b2lkIDA7XG5mdW5jdGlvbiBwa2NzN1BhZChkYXRhKSB7XG4gICAgY29uc3QgcGFkZGVyID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBwYWRkZXIpO1xuICAgIHJlc3VsdC5zZXQoZGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IHBhZGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGtjczdQYWQgPSBwa2NzN1BhZDtcbmZ1bmN0aW9uIHBrY3M3U3RyaXAoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZXIgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgaWYgKHBhZGRlciA+IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoIC0gcGFkZGVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVyOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbbGVuZ3RoICsgaV0gIT09IHBhZGRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUEtDUyM3IGludmFsaWQgcGFkZGluZyBieXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEuc3ViYXJyYXkoMCwgbGVuZ3RoKSk7XG59XG5leHBvcnRzLnBrY3M3U3RyaXAgPSBwa2NzN1N0cmlwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkZGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/padding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n/**\n *  The current version of Ethers.\n */\nconst version = \"6.11.1\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL192ZXJzaW9uLmpzPzQzYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogRG8gTk9UIG1vZGlmeSB0aGlzIGZpbGU7IHNlZSAvc3JjLnRzL19hZG1pbi91cGRhdGUtdmVyc2lvbi50cyAqL1xuLyoqXG4gKiAgVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBFdGhlcnMuXG4gKi9cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCI2LjExLjFcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\n\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nfunction getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nfunction getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nfunction isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nfunction hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nfunction concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nfunction dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nfunction dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nfunction stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nfunction zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nfunction zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanM/MzAxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIGRhdGEgaGVscGVycy5cbiAqXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6RGF0YSBIZWxwZXJzICBbYWJvdXQtZGF0YV1cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXjB4KFswLTlhLWZdWzAtOWEtZl0pKiQvaSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQnl0ZXNMaWtlIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUuIElmIGFscmVhZHkgYSBVaW50OEFycmF5XG4gKiAgdGhlIG9yaWdpbmFsICUldmFsdWUlJSBpcyByZXR1cm5lZDsgaWYgYSBjb3B5IGlzIHJlcXVpcmVkIHVzZVxuICogIFtbZ2V0Qnl0ZXNDb3B5XV0uXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzQ29weVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUsIGNyZWF0aW5nIGEgY29weSBpZiBuZWNlc3NhcnlcbiAqICB0byBwcmV2ZW50IGFueSBtb2RpZmljYXRpb25zIG9mIHRoZSByZXR1cm5lZCB2YWx1ZSBmcm9tIGJlaW5nXG4gKiAgcmVmbGVjdGVkIGVsc2V3aGVyZS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzQ29weSh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIHRydWUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbSGV4U3RyaW5nXV0uXG4gKlxuICogIElmICUlbGVuZ3RoJSUgaXMgYGB0cnVlYGAgb3IgYSAvL251bWJlci8vLCBpdCBhbHNvIGNoZWNrcyB0aGF0XG4gKiAgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVsZW5ndGglJSAoaWYgYSAvL251bWJlci8vKVxuICogIGJ5dGVzIG9mIGRhdGEgKGUuZy4gYGAweDEyMzRgYCBpcyAyIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChsZW5ndGgpID09PSBcIm51bWJlclwiICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSB0cnVlICYmICh2YWx1ZS5sZW5ndGggJSAyKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIGFyYml0cmFyeVxuICogIGRhdGEgKGkuZS4gYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvciBhIFVpbnQ4QXJyYXkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSk7XG59XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gcmVwcmVzZW50YXRpb24gb2YgJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gYnl0ZXNbaV07XG4gICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBjb25jYXRlbmF0aW5nIGFsbCB2YWx1ZXNcbiAqICB3aXRoaW4gJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoZGF0YXMpIHtcbiAgICByZXR1cm4gXCIweFwiICsgZGF0YXMubWFwKChkKSA9PiBoZXhsaWZ5KGQpLnN1YnN0cmluZygyKSkuam9pbihcIlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiAlJWRhdGElJSwgaW4gYnl0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJ5dGVzKGRhdGEpLmxlbmd0aDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBzbGljaW5nICUlZGF0YSUlIGZyb20gdGhlICUlc3RhcnQlJVxuICogIG9mZnNldCB0byB0aGUgJSVlbmQlJSBvZmZzZXQuXG4gKlxuICogIEJ5IGRlZmF1bHQgJSVzdGFydCUlIGlzIDAgYW5kICUlZW5kJSUgaXMgdGhlIGxlbmd0aCBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFTbGljZShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBpZiAoZW5kICE9IG51bGwgJiYgZW5kID4gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3Qgc2xpY2UgYmV5b25kIGRhdGEgYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBieXRlcy5sZW5ndGgsIG9mZnNldDogZW5kXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcy5zbGljZSgoc3RhcnQgPT0gbnVsbCkgPyAwIDogc3RhcnQsIChlbmQgPT0gbnVsbCkgPyBieXRlcy5sZW5ndGggOiBlbmQpKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gcmVzdWx0IGJ5IHN0cmlwcGluZyBhbGwgKipsZWFkaW5nKipcbiAqKiB6ZXJvIGJ5dGVzIGZyb20gJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFplcm9zTGVmdChkYXRhKSB7XG4gICAgbGV0IGJ5dGVzID0gaGV4bGlmeShkYXRhKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKGJ5dGVzLnN0YXJ0c1dpdGgoXCIwMFwiKSkge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGJ5dGVzO1xufVxuZnVuY3Rpb24gemVyb1BhZChkYXRhLCBsZW5ndGgsIGxlZnQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGFzc2VydChsZW5ndGggPj0gYnl0ZXMubGVuZ3RoLCBcInBhZGRpbmcgZXhjZWVkcyBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShieXRlcyksXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBvZmZzZXQ6IGxlbmd0aCArIDFcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHJlc3VsdC5maWxsKDApO1xuICAgIGlmIChsZWZ0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIGxlbmd0aCAtIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKmxlZnQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqdmFsdWVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGB1aW50MTI4YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZFZhbHVlKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipyaWdodCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKipieXRlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgYnl0ZXMxNmBgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRCeXRlcyhkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIGZhbHNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(ssr)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\n\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nfunction isError(error, code) {\n    return (error && error.code === code);\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nfunction isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nfunction makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { shortMessage });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nfunction assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nfunction assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nfunction assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nfunction assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QixhQUFhLElBQUksb0JBQW9CLG1CQUFtQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnQkFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEMsZ0NBQWdDLGdEQUFPLENBQUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFnQixVQUFVLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFnQixVQUFVLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHlEQUF5RDtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNLE9BQU87QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Vycm9ycy5qcz81NWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEFsbCBlcnJvcnMgaW4gZXRoZXJzIGluY2x1ZGUgcHJvcGVydGllcyB0byBlbnN1cmUgdGhleSBhcmUgYm90aFxuICogIGh1bWFuLXJlYWRhYmxlIChpLmUuIGBgLm1lc3NhZ2VgYCkgYW5kIG1hY2hpbmUtcmVhZGFibGUgKGkuZS4gYGAuY29kZWBgKS5cbiAqXG4gKiAgVGhlIFtbaXNFcnJvcl1dIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoZSBlcnJvciBgYGNvZGVgYCBhbmRcbiAqICBwcm92aWRlIGEgdHlwZSBndWFyZCBmb3IgdGhlIHByb3BlcnRpZXMgcHJlc2VudCBvbiB0aGF0IGVycm9yIGludGVyZmFjZS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZXJyb3JzOkVycm9ycyAgW2Fib3V0LWVycm9yc11cbiAqL1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fdmVyc2lvbi5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIlsgXCIgKyAodmFsdWUubWFwKHN0cmluZ2lmeSkpLmpvaW4oXCIsIFwiKSArIFwiIF1cIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gJiAweGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKHZhbHVlLnRvSlNPTikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlLnRvSlNPTigpKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gXCJ7IFwiICsga2V5cy5tYXAoKGspID0+IGAke3N0cmluZ2lmeShrKX06ICR7c3RyaW5naWZ5KHZhbHVlW2tdKX1gKS5qb2luKFwiLCBcIikgKyBcIiB9XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBbIENPVUxEIE5PVCBTRVJJQUxJWkUgXWA7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgdGhlICUlZXJyb3IlJSBtYXRjaGVzIGFuIGVycm9yIHRocm93biBieSBldGhlcnNcbiAqICB0aGF0IG1hdGNoZXMgdGhlIGVycm9yICUlY29kZSUlLlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhpcyBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGF0ICUlZXJyb3IlJVxuICogIG1hdGNoZXMgYW4gRXRoZXJzRXJyb3IgdHlwZSwgd2hpY2ggbWVhbnMgdGhlIGV4cGVjdGVkIHByb3BlcnRpZXMgd2lsbFxuICogIGJlIHNldC5cbiAqXG4gKiAgQFNlZSBbRXJyb3JDb2Rlc10oYXBpOkVycm9yQ29kZSlcbiAqICBAZXhhbXBsZVxuICogICAgdHJ5IHtcbiAqICAgICAgLy8gY29kZS4uLi5cbiAqICAgIH0gY2F0Y2ggKGUpIHtcbiAqICAgICAgaWYgKGlzRXJyb3IoZSwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICogICAgICAgICAgLy8gVGhlIFR5cGUgR3VhcmQgaGFzIHZhbGlkYXRlZCB0aGlzIG9iamVjdFxuICogICAgICAgICAgY29uc29sZS5sb2coZS5kYXRhKTtcbiAqICAgICAgfVxuICogICAgfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcihlcnJvciwgY29kZSkge1xuICAgIHJldHVybiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gY29kZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVlcnJvciUlIGlzIGEgW1tDYWxsRXhjZXB0aW9uRXJyb3JdLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsRXhjZXB0aW9uKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIik7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgbmV3IEVycm9yIGNvbmZpZ3VyZWQgdG8gdGhlIGZvcm1hdCBldGhlcnMgZW1pdHMgZXJyb3JzLCB3aXRoXG4gKiAgdGhlICUlbWVzc2FnZSUlLCBbW2FwaTpFcnJvckNvZGVdXSAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiAgZm9yIHRoZSBjb3JyZXNwb25kaW5nIEV0aGVyc0Vycm9yLlxuICpcbiAqICBFYWNoIGVycm9yIGluIGV0aGVycyBpbmNsdWRlcyB0aGUgdmVyc2lvbiBvZiBldGhlcnMsIGFcbiAqICBtYWNoaW5lLXJlYWRhYmxlIFtbRXJyb3JDb2RlXV0sIGFuZCBkZXBlbmRpbmcgb24gJSVjb2RlJSUsIGFkZGl0aW9uYWxcbiAqICByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUaGUgZXJyb3IgbWVzc2FnZSB3aWxsIGFsc28gaW5jbHVkZSB0aGUgJSVtZXNzYWdlJSUsXG4gKiAgZXRoZXJzIHZlcnNpb24sICUlY29kZSUlIGFuZCBhbGwgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCBzZXJpYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBsZXQgc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiBpbmZvIHx8IFwiY29kZVwiIGluIGluZm8gfHwgXCJuYW1lXCIgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgd2lsbCBvdmVyd3JpdGUgcG9wdWxhdGVkIHZhbHVlczogJHtzdHJpbmdpZnkoaW5mbyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzaG9ydE1lc3NhZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5mb1trZXldKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1NTVwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVtjb3VsZCBub3Qgc2VyaWFsaXplIG9iamVjdF1cIik7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIGRldGFpbHMucHVzaChgdmVyc2lvbj0ke3ZlcnNpb259YCk7XG4gICAgICAgIGlmIChkZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBkZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlcnJvcjtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBcIklOVkFMSURfQVJHVU1FTlRcIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTlVNRVJJQ19GQVVMVFwiOlxuICAgICAgICBjYXNlIFwiQlVGRkVSX09WRVJSVU5cIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IGNvZGUgfSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlcnJvciwgaW5mbyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5zaG9ydE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IHNob3J0TWVzc2FnZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLyoqXG4gKiAgVGhyb3dzIGFuIEV0aGVyc0Vycm9yIHdpdGggJSVtZXNzYWdlJSUsICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIGVycm9yXG4gKiAgJSVpbmZvJSUgd2hlbiAlJWNoZWNrJSUgaXMgZmFsc2lzaC4uXG4gKlxuICogIEBzZWUgW1thcGk6bWFrZUVycm9yXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjaGVjaywgbWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgdGhyb3cgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgc2ltcGxlIGhlbHBlciB0byBzaW1wbHkgZW5zdXJpbmcgcHJvdmlkZWQgYXJndW1lbnRzIG1hdGNoIGV4cGVjdGVkXG4gKiAgY29uc3RyYWludHMsIHRocm93aW5nIGlmIG5vdC5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoZSAlJWNoZWNrJSUgaGFzIGJlZW4gYXNzZXJ0ZWQgdHJ1ZSwgc29cbiAqICBhbnkgZnVydGhlciBjb2RlIGRvZXMgbm90IG5lZWQgYWRkaXRpb25hbCBjb21waWxlLXRpbWUgY2hlY2tzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvdW50ID49IGV4cGVjdGVkQ291bnQsIFwibWlzc2luZyBhcmd1ZW1udFwiICsgbWVzc2FnZSwgXCJNSVNTSU5HX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG4gICAgYXNzZXJ0KGNvdW50IDw9IGV4cGVjdGVkQ291bnQsIFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBcIlVORVhQRUNURURfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbn1cbmNvbnN0IF9ub3JtYWxpemVGb3JtcyA9IFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLnJlZHVjZSgoYWNjdW0sIGZvcm0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBHZW5lcmFsIHRlc3QgZm9yIG5vcm1hbGl6ZVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmIChmb3JtID09PSBcIk5GRFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChjaGVjayAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtLnB1c2goZm9ybSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGFjY3VtO1xufSwgW10pO1xuLyoqXG4gKiAgVGhyb3dzIGlmIHRoZSBub3JtYWxpemF0aW9uICUlZm9ybSUlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3JtYWxpemUoZm9ybSkge1xuICAgIGFzc2VydChfbm9ybWFsaXplRm9ybXMuaW5kZXhPZihmb3JtKSA+PSAwLCBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgaW5mbzogeyBmb3JtIH1cbiAgICB9KTtcbn1cbi8qKlxuICogIE1hbnkgY2xhc3NlcyB1c2UgZmlsZS1zY29wZWQgdmFsdWVzIHRvIGd1YXJkIHRoZSBjb25zdHJ1Y3RvcixcbiAqICBtYWtpbmcgaXQgZWZmZWN0aXZlbHkgcHJpdmF0ZS4gVGhpcyBmYWNpbGl0YXRlcyB0aGF0IHBhdHRlcm5cbiAqICBieSBlbnN1cmluZyB0aGUgJSVnaXZlbkdhdXJkJSUgbWF0Y2hlcyB0aGUgZmlsZS1zY29wZWQgJSVndWFyZCUlLFxuICogIHRocm93aW5nIGlmIG5vdCwgaW5kaWNhdGluZyB0aGUgJSVjbGFzc05hbWUlJSBpZiBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFByaXZhdGUoZ2l2ZW5HdWFyZCwgZ3VhcmQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoZ2l2ZW5HdWFyZCAhPT0gZ3VhcmQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGNsYXNzTmFtZSwgb3BlcmF0aW9uID0gXCJuZXdcIjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbWV0aG9kICs9IFwiLlwiO1xuICAgICAgICAgICAgb3BlcmF0aW9uICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHByaXZhdGUgY29uc3RydWN0b3I7IHVzZSAke21ldGhvZH1mcm9tKiBtZXRob2RzYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\n\n\n\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while (result.length < decimals) {\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        if (val > BN_0) {\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\n        }\n        else {\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\n        }\n    }\n    else {\n        const limit = (BN_1 << width);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof (value) === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof (value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        }\n        else if (value === \"ufixed\") {\n            signed = false;\n        }\n        else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    }\n    else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue) => {\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return { signed, width, decimals, name };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return (negative + str);\n    }\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) {\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return (negative + str);\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nclass FixedNumber {\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    format;\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _value;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */\n    constructor(guard, value, format) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { format: format.name, _value });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed() { return this.#format.signed; }\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width() { return this.#format.width; }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals() { return this.#format.decimals; }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value() { return this.#val; }\n    #checkFormat(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other) { return this.#add(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other) { return this.#add(other, \"add\"); }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other) { return this.#sub(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other) { return this.#sub(other, \"sub\"); }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other) { return this.#mul(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other) { return this.#mul(other, \"mul\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other) { return this.#div(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other) { return this.#div(other, \"div\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n    cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        }\n        else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n    eq(other) { return this.cmp(other) === 0; }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n    lt(other) { return this.cmp(other) < 0; }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n    lte(other) { return this.cmp(other) <= 0; }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n    gt(other) { return this.cmp(other) > 0; }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n    gte(other) { return this.cmp(other) >= 0; }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero() { return (this.#val === BN_0); }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative() { return (this.#val < BN_0); }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString() { return this._value; }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value, _decimals, _format) {\n        const decimals = (_decimals == null) ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        }\n        else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n        // Pad out the decimals\n        while (decimal.length < format.decimals) {\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value, _format) {\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUMrQjtBQUNRO0FBQ3pCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLG1EQUFRLENBQUMsK0NBQUk7QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixtREFBUSxDQUFDLCtDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBYztBQUNsQixJQUFJLDBEQUFjO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFnQixTQUFTLDZCQUE2QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFFBQVEsMERBQWMscURBQXFEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0RBQVM7QUFDNUQ7QUFDQSxvQkFBb0Isb0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrREFBTTtBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBUSxDQUFDLGtEQUFRO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanM/M2Y0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgKipGaXhlZE51bWJlcioqIGNsYXNzIHBlcm1pdHMgdXNpbmcgdmFsdWVzIHdpdGggZGVjaW1hbCBwbGFjZXMsXG4gKiAgdXNpbmcgZml4ZWQtcG9udCBtYXRoLlxuICpcbiAqICBGaXhlZC1wb2ludCBtYXRoIGlzIHN0aWxsIGJhc2VkIG9uIGludGVnZXJzIHVuZGVyLXRoZS1ob29kLCBidXQgdXNlcyBhblxuICogIGludGVybmFsIG9mZnNldCB0byBzdG9yZSBmcmFjdGlvbmFsIGNvbXBvbmVudHMgYmVsb3csIGFuZCBlYWNoIG9wZXJhdGlvblxuICogIGNvcnJlY3RzIGZvciB0aGlzIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9maXhlZC1wb2ludC1tYXRoOkZpeGVkLVBvaW50IE1hdGhzICBbYWJvdXQtZml4ZWQtcG9pbnQtbWF0aF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgZnJvbVR3b3MsIG1hc2ssIHRvQmlnSW50IH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5jb25zdCBCTl9OMSA9IEJpZ0ludCgtMSk7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzUgPSBCaWdJbnQoNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbmxldCBaZXJvcyA9IFwiMDAwMFwiO1xud2hpbGUgKFplcm9zLmxlbmd0aCA8IDgwKSB7XG4gICAgWmVyb3MgKz0gWmVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRUZW5zKGRlY2ltYWxzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChcIjFcIiArIHJlc3VsdC5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsLCBmb3JtYXQsIHNhZmVPcCkge1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGZvcm1hdC53aWR0aCk7XG4gICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IC1saW1pdCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gLWZyb21Ud29zKG1hc2soLXZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgd2lkdGgpO1xuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBzYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbCA9ICgoKHZhbCAlIGxpbWl0KSArIGxpbWl0KSAlIGxpbWl0KSAmIChsaW1pdCAtIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybWF0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhbHVlID0gYGZpeGVkMTI4eCR7dmFsdWV9YDtcbiAgICB9XG4gICAgbGV0IHNpZ25lZCA9IHRydWU7XG4gICAgbGV0IHdpZHRoID0gMTI4O1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBQYXJzZSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtYXRjaCwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2W2tleV0pID09PSB0eXBlLCBcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gdltrZXldO1xuICAgICAgICB9O1xuICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoKHdpZHRoICUgOCkgPT09IDAsIFwiaW52YWxpZCBGaXhlZE51bWJlciB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuICAgIGFzc2VydEFyZ3VtZW50KGRlY2ltYWxzIDw9IDgwLCBcImludmFsaWQgRml4ZWROdW1iZXIgZGVjaW1hbHMgKHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IG5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgcmV0dXJuIHsgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMsIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCwgZGVjaW1hbHMpIHtcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xuICAgIGlmICh2YWwgPCBCTl8wKSB7XG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG4gICAgICAgIHZhbCAqPSBCTl9OMTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygpO1xuICAgIC8vIE5vIGRlY2ltYWwgcG9pbnQgZm9yIHdob2xlIHZhbHVlc1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcbiAgICB9XG4gICAgLy8gUGFkIG91dCB0byB0aGUgd2hvbGUgY29tcG9uZW50IChpbmNsdWRpbmcgYSB3aG9sZSBkaWdpdClcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8PSBkZWNpbWFscykge1xuICAgICAgICBzdHIgPSBaZXJvcyArIHN0cjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBkZWNpbWFsIHBvaW50XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gZGVjaW1hbHM7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCkgKyBcIi5cIiArIHN0ci5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIC8vIFRyaW0gdGhlIHdob2xlIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyWzBdID09PSBcIjBcIiAmJiBzdHJbMV0gIT09IFwiLlwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIC8vIFRyaW0gdGhlIGRlY2ltYWwgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxuICAgIHdoaWxlIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIjBcIiAmJiBzdHJbc3RyLmxlbmd0aCAtIDJdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG59XG4vKipcbiAqICBBIEZpeGVkTnVtYmVyIHJlcHJlc2VudHMgYSB2YWx1ZSBvdmVyIGl0cyBbW0ZpeGVkRm9ybWF0XV1cbiAqICBhcml0aG1ldGljIGZpZWxkLlxuICpcbiAqICBBIEZpeGVkTnVtYmVyIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbWF0aCwgbG9zc2xlc3NseSwgb25cbiAqICB2YWx1ZXMgd2hpY2ggaGF2ZSBkZWNtaWFsIHBsYWNlcy5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBoYXMgYSBmaXhlZCBiaXQtd2lkdGggdG8gc3RvcmUgdmFsdWVzIGluLCBhbmQgc3RvcmVzIGFsbFxuICogIHZhbHVlcyBpbnRlcm5hbGx5IGJ5IG11bHRpcGx5aW5nIHRoZSB2YWx1ZSBieSAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mXG4gKiAgJSVkZWNpbWFscyUlLlxuICpcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGdyb3cgdG9vIGhpZ2ggKGNsb3NlIHRvXG4gKiAgcG9zaXRpdmUgaW5maW5pdHkpIG9yIHRvbyBsb3cgKGNsb3NlIHRvIG5lZ2F0aXZlIGluZmluaXR5KSwgdGhlIHZhbHVlXG4gKiAgaXMgc2FpZCB0byAvL292ZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhbiA4LWJpdCBzaWduZWQgdmFsdWUsIHdpdGggMCBkZWNpbWFscyBtYXkgb25seSBiZSB3aXRoaW5cbiAqICB0aGUgcmFuZ2UgYGAtMTI4YGAgdG8gYGAxMjdgYDsgc28gYGAtMTI4IC0gMWBgIHdpbGwgb3ZlcmZsb3cgYW5kIGJlY29tZVxuICogIGBgMTI3YGAuIExpa2V3aXNlLCBgYDEyNyArIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWUgYGAtMTI3YGAuXG4gKlxuICogIE1hbnkgb3BlcmF0aW9uIGhhdmUgYSBub3JtYWwgYW5kIC8vdW5zYWZlLy8gdmFyaWFudC4gVGhlIG5vcm1hbCB2YXJpYW50XG4gKiAgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiBhbnkgb3ZlcmZsb3csIHdoaWxlIHRoZSAvL3Vuc2FmZS8vXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGFsbG93IG92ZXJmbG93LCBjb3JydXB0aW5nIGl0cyB2YWx1ZSB2YWx1ZS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBiZWNvbWUgdG9vIHNtYWxsXG4gKiAgKGNsb3NlIHRvIHplcm8pLCB0aGUgdmFsdWUgbG9zZXMgcHJlY2lzb24gYW5kIGlzIHNhaWQgdG8gLy91bmRlcmZsb3cvLy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGFuIHZhbHVlIHdpdGggMSBkZWNpbWFsIHBsYWNlIG1heSBzdG9yZSBhIG51bWJlciBhcyBzbWFsbFxuICogIGFzIGBgMC4xYGAsIGJ1dCB0aGUgdmFsdWUgb2YgYGAwLjEgLyAyYGAgaXMgYGAwLjA1YGAsIHdoaWNoIGNhbm5vdCBmaXRcbiAqICBpbnRvIDEgZGVjaW1hbCBwbGFjZSwgc28gdW5kZXJmbG93IG9jY3VycyB3aGljaCBtZWFucyBwcmVjaXNpb24gaXMgbG9zdFxuICogIGFuZCB0aGUgdmFsdWUgYmVjb21lcyBgYDBgYC5cbiAqXG4gKiAgU29tZSBvcGVyYXRpb25zIGhhdmUgYSBub3JtYWwgYW5kIC8vc2lnbmFsbGluZy8vIHZhcmlhbnQuIFRoZSBub3JtYWxcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgaWdub3JlIHVuZGVyZmxvdywgd2hpbGUgdGhlIC8vc2lnbmFsbGluZy8vIHZhcmlhbnRcbiAqICB3aWxsIHRob3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gdW5kZXJmbG93LlxuICovXG5leHBvcnQgY2xhc3MgRml4ZWROdW1iZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc3BlY2lmaWMgZml4ZWQtcG9pbnQgYXJpdGhtZXRpYyBmaWVsZCBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmb3JtYXQ7XG4gICAgI2Zvcm1hdDtcbiAgICAvLyBUaGUgYWN0dWFsIHZhbHVlIChhY2NvdW50aW5nIGZvciBkZWNpbWFscylcbiAgICAjdmFsO1xuICAgIC8vIEEgYmFzZS0xMCB2YWx1ZSB0byBtdWx0aXBsZSB2YWx1ZXMgYnkgdG8gbWFpbnRhaW4gdGhlIG1hZ25pdHVkZVxuICAgICN0ZW5zO1xuICAgIC8qKlxuICAgICAqICBUaGlzIGlzIGEgcHJvcGVydHkgc28gY29uc29sZS5sb2cgc2hvd3MgYSBodW1hbi1tZWFuaW5nZnVsIHZhbHVlLlxuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbHVlO1xuICAgIC8vIFVzZSB0aGlzIHdoZW4gY2hhbmdpbmcgdGhpcyBmaWxlIHRvIGdldCBzb21lIHR5cGluZyBpbmZvLFxuICAgIC8vIGJ1dCB0aGVuIHN3aXRjaCB0byBhbnkgdG8gbWFzayB0aGUgaW50ZXJuYWwgdHlwZVxuICAgIC8vY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgdmFsdWU6IGJpZ2ludCwgZm9ybWF0OiBfRml4ZWRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRml4ZWROdW1iZXJcIik7XG4gICAgICAgIHRoaXMuI3ZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLiNmb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZm9ybWF0OiBmb3JtYXQubmFtZSwgX3ZhbHVlIH0pO1xuICAgICAgICB0aGlzLiN0ZW5zID0gZ2V0VGVucyhmb3JtYXQuZGVjaW1hbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdHJ1ZSwgbmVnYXRpdmUgdmFsdWVzIGFyZSBwZXJtaXR0ZWQsIG90aGVyd2lzZSBvbmx5XG4gICAgICogIHBvc2l0aXZlIHZhbHVlcyBhbmQgemVybyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmVkKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LnNpZ25lZDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJpdHMgYXZhaWxhYmxlIHRvIHN0b3JlIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQud2lkdGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpbiB0aGUgZml4ZWQtcG9pbnQgYXJpdGhtZW50IGZpZWxkLlxuICAgICAqL1xuICAgIGdldCBkZWNpbWFscygpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5kZWNpbWFsczsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgYXMgYW4gaW50ZWdlciwgYmFzZWQgb24gdGhlIHNtYWxsZXN0IHVuaXQgdGhlXG4gICAgICogIFtbZGVjaW1hbHNdXSBhbGxvdy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWw7IH1cbiAgICAjY2hlY2tGb3JtYXQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodGhpcy5mb3JtYXQgPT09IG90aGVyLmZvcm1hdCwgXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgfVxuICAgICNjaGVja1ZhbHVlKHZhbCwgc2FmZU9wKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBCaWdJbnQodGhpcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmcm9tVHdvcyhtYXNrKHZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrZWQgPSBtYXNrKHZhbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA9PT0gbWFza2VkKSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFza2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsID0gY2hlY2tWYWx1ZSh2YWwsIHRoaXMuI2Zvcm1hdCwgc2FmZU9wKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbCwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgI2FkZChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCArIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIGFkZFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIGFkZChvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyLCBcImFkZFwiKTsgfVxuICAgICNzdWIobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgLSBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3ViVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIHN1YihvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyLCBcInN1YlwiKTsgfVxuICAgICNtdWwobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogby4jdmFsKSAvIHRoaXMuI3RlbnMsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93IGFuZCB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBtdWxVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bChvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyLCBcIm11bFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMgb3IgaWYgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bFNpZ25hbChvdGhlcikge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsICogb3RoZXIuI3ZhbDtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIHRoaXMuI3RlbnMpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIG11bFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm11bFNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gdGhpcy4jdGVucywgXCJtdWxTaWduYWxcIik7XG4gICAgfVxuICAgICNkaXYobywgc2FmZU9wKSB7XG4gICAgICAgIGFzc2VydChvLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKSAvIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2VW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2KG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIsIFwiZGl2XCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIHVuZGVyZmxvd1xuICAgICAqICAocHJlY2lzaW9uIGxvc3MpIG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZTaWduYWwob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KG90aGVyLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKTtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIG90aGVyLiN2YWwpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIGRpdlwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gb3RoZXIuI3ZhbCwgXCJkaXZTaWduYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgY29tcGFyaXNvbiByZXN1bHQgYmV0d2VlbiAlJXRoaXMlJSBhbmQgJSVvdGhlciUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzb3J0aW5nLCB3aGVyZSBgYC0xYGAgaW1wbGllcyAlJXRoaXMlJVxuICAgICAqICBpcyBzbWFsbGVyLCBgYDFgYCBpbXBsaWVzICUldGhpcyUlIGlzIGxhcmdlciBhbmQgYGAwYGAgaW1wbGllc1xuICAgICAqICBib3RoIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLnZhbHVlLCBiID0gb3RoZXIudmFsdWU7XG4gICAgICAgIC8vIENvZXJjZSBhIGFuZCBiIHRvIHRoZSBzYW1lIG1hZ25pdHVkZVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBvdGhlci5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgYiAqPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIGEgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbW5wYXJlXG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPT09IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHQob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHRlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPD0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID4gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBsYXJnZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGZsb29yKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsIDwgQk5fMCkge1xuICAgICAgICAgICAgdmFsIC09IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJmbG9vclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBzbWFsbGVzdCAqKmludGVnZXIqKlxuICAgICAqICB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cbiAgICAgKi9cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsICs9IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJjZWlsaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgZGVjaW1hbCBjb21wb25lbnRcbiAgICAgKiAgcm91bmRlZCB1cCBvbiB0aWVzIGF0ICUlZGVjaW1hbHMlJSBwbGFjZXMuXG4gICAgICovXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZW5vdWdoIHByZWNpc2lvbiB0byBub3QgYWxyZWFkeSBiZSByb3VuZGVkXG4gICAgICAgIGlmIChkZWNpbWFscyA+PSB0aGlzLmRlY2ltYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBkZWNpbWFscztcbiAgICAgICAgY29uc3QgYnVtcCA9IEJOXzUgKiBnZXRUZW5zKGRlbHRhIC0gMSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWUgKyBidW1wO1xuICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC8gdGVucykgKiB0ZW5zO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCB0aGlzLiNmb3JtYXQsIFwicm91bmRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBlcXVhbCB0byBgYDBgYC5cbiAgICAgKi9cbiAgICBpc1plcm8oKSB7IHJldHVybiAodGhpcy4jdmFsID09PSBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgbGVzcyB0aGFuIGBgMGBgLlxuICAgICAqL1xuICAgIGlzTmVnYXRpdmUoKSB7IHJldHVybiAodGhpcy4jdmFsIDwgQk5fMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICUldGhpcyUlLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZsb2F0IGFwcHJveGltYXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIElFRUUgNzU0IHByZWNpc3Npb24gKG9yIGxhY2sgdGhlcmVvZiksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiAgY2FuIG9ubHkgcmV0dXJuIGFuIGFwcHJveGltYXRpb24gYW5kIG1vc3QgdmFsdWVzIHdpbGwgY29udGFpblxuICAgICAqICByb3VuZGluZyBlcnJvcnMuXG4gICAgICovXG4gICAgdG9VbnNhZmVGbG9hdCgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHNhbWUgdmFsdWUgYnV0IGhhcyBoYWRcbiAgICAgKiAgaXRzIGZpZWxkIHNldCB0byAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgdmFsdWUgY2Fubm90IGZpdCBpbnRvICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMudG9TdHJpbmcoKSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgZGl2aWRlZCBieVxuICAgICAqICAlJWRlY2ltYWwlJSBwbGFjZXMgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgKG9uY2UgYWRqdXN0ZWRcbiAgICAgKiAgZm9yICUlZGVjaW1hbHMlJSkgY2Fubm90IGZpdCBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93XG4gICAgICogIG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWUoX3ZhbHVlLCBfZGVjaW1hbHMsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSAoX2RlY2ltYWxzID09IG51bGwpID8gMCA6IGdldE51bWJlcihfZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZGVjaW1hbHMgLSBmb3JtYXQuZGVjaW1hbHM7XG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgICAgIGFzc2VydCgodmFsdWUgJSB0ZW5zKSA9PT0gQk5fMCwgXCJ2YWx1ZSBsb3NlcyBwcmVjaXNpb24gZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVmFsdWVcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUgLz0gdGVucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlICo9IGdldFRlbnMoLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvdyBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfdmFsdWUubWF0Y2goL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoICYmIChtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGgpID4gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHN0cmluZyB2YWx1ZVwiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHdob2xlID0gKG1hdGNoWzJdIHx8IFwiMFwiKSwgZGVjaW1hbCA9IChtYXRjaFszXSB8fCBcIlwiKTtcbiAgICAgICAgLy8gUGFkIG91dCB0aGUgZGVjaW1hbHNcbiAgICAgICAgd2hpbGUgKGRlY2ltYWwubGVuZ3RoIDwgZm9ybWF0LmRlY2ltYWxzKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFplcm9zO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHByZWNpc2lvbiBpcyBzYWZlXG4gICAgICAgIGFzc2VydChkZWNpbWFsLnN1YnN0cmluZyhmb3JtYXQuZGVjaW1hbHMpLm1hdGNoKC9eMCokLyksIFwidG9vIG1hbnkgZGVjaW1hbHMgZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21TdHJpbmdcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlbW92ZSBleHRyYSBwYWRkaW5nXG4gICAgICAgIGRlY2ltYWwgPSBkZWNpbWFsLnN1YnN0cmluZygwLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChtYXRjaFsxXSArIHdob2xlICsgZGVjaW1hbCk7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tU3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uXG4gICAgICogICUldmFsdWUlJSB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XG4gICAgICogIGluICUlZm9ybWF0JSUgZHVlIHRvIG92ZXJmbG93LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoX3ZhbHVlLCBfZm9ybWF0KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRvQmlnSW50KGdldEJ5dGVzKF92YWx1ZSwgXCJ2YWx1ZVwiKSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIGZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21CeXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbn1cbi8vY29uc3QgZjEgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMTIuNTZcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnN0IGYyID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjAuM1wiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc29sZS5sb2coZjEuZGl2U2lnbmFsKGYyKSk7XG4vL2NvbnN0IEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nfunction fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nfunction toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = (BN_1 << (width - BN_1));\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    }\n    else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nfunction mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getBigInt(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            }\n            catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nfunction getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nfunction toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getNumber(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            }\n            catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nfunction toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nfunction toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    }\n    else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while (result.length < (width * 2)) {\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nfunction toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nfunction toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) {\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\n//# sourceMappingURL=maths.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUQ7QUFDSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFjLHdDQUF3QyxVQUFVO0FBQ2hGO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQixZQUFZLDBEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBYyxtQ0FBbUMsVUFBVTtBQUMzRTtBQUNBO0FBQ0EsSUFBSSwwREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTSxxREFBcUQsT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsaURBQU8sQ0FBQyxxREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanM/YTk5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUhleFwiLFxuICAgICAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhZCB0aGUgdmFsdWUgdG8gdGhlIHJlcXVpcmVkIHdpZHRoXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAodmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMjtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nasync function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nfunction defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMENBQTBDO0FBQ3ZGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9wcm9wZXJ0aWVzLmpzP2FmYmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgUHJvcGVydHkgaGVscGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpQcm9wZXJ0aWVzICBbYWJvdXQtcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gY2hlY2tUeXBlKHZhbHVlLCB0eXBlLCBuYW1lKSB7XG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KFwifFwiKS5tYXAodCA9PiB0LnRyaW0oKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkIHZhbHVlIGZvciB0eXBlICR7dHlwZX1gKTtcbiAgICBlcnJvci5jb2RlID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgZXJyb3IuYXJndW1lbnQgPSBgdmFsdWUuJHtuYW1lfWA7XG4gICAgZXJyb3IudmFsdWUgPSB2YWx1ZTtcbiAgICB0aHJvdyBlcnJvcjtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGEgbmV3IG9iamVjdCB0aGF0IGlzIGEgY29weSBvZiAlJXZhbHVlJSUsIGJ1dCB3aXRoIGFsbFxuICogIHZhbHVlcyByZXNvbHZlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoa2V5cy5tYXAoKGspID0+IFByb21pc2UucmVzb2x2ZSh2YWx1ZVtrXSkpKTtcbiAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCB2LCBpbmRleCkgPT4ge1xuICAgICAgICBhY2N1bVtrZXlzW2luZGV4XV0gPSB2O1xuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiAgQXNzaWducyB0aGUgJSV2YWx1ZXMlJSB0byAlJXRhcmdldCUlIGFzIHJlYWQtb25seSB2YWx1ZXMuXG4gKlxuICogIEl0ICUldHlwZXMlJSBpcyBzcGVjaWZpZWQsIHRoZSB2YWx1ZXMgYXJlIGNoZWNrZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgdmFsdWVzLCB0eXBlcykge1xuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSAodHlwZXMgPyB0eXBlc1trZXldIDogbnVsbCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBjaGVja1R5cGUodmFsdWUsIHR5cGUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/units.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/units.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\n\n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nfunction formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nfunction parseUnits(value, unit) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=units.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdW5pdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QztBQUNFO0FBQ1I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUztBQUM1QjtBQUNBLFdBQVcsd0RBQVcsOEJBQThCLHNCQUFzQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQVM7QUFDNUI7QUFDQSxXQUFXLHdEQUFXLHFCQUFxQixzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3VuaXRzLmpzPzhlOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBFdGhlcmV1bSByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlcywgd2hpY2ggdXNlXG4gKiAgdGhlIHNtYWxsZXN0IG1hZ25pdHVkZSB1bml0LlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBkZWFsaW5nIHdpdGggZG9sbGFycyBhbmQgY2VudHMuIFNpbmNlIGRvbGxhcnNcbiAqICBhcmUgZGl2aXNpYmxlLCBub24taW50ZWdlciB2YWx1ZXMgYXJlIHBvc3NpYmxlLCBzdWNoIGFzIGBgJDEwLjc3YGAuXG4gKiAgQnkgdXNpbmcgdGhlIHNtYWxsZXN0IGluZGl2aXNpYmxlIHVuaXQgKGkuZS4gY2VudHMpLCB0aGUgdmFsdWUgY2FuXG4gKiAgYmUga2VwdCBhcyB0aGUgaW50ZWdlciBgYDEwNzdgYC5cbiAqXG4gKiAgV2hlbiByZWNlaXZpbmcgZGVjaW1hbCBpbnB1dCBmcm9tIHRoZSB1c2VyIChhcyBhIGRlY2ltYWwgc3RyaW5nKSxcbiAqICB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGFuZCB3aGVuIHNob3dpbmcgYSB1c2VyXG4gKiAgYSB2YWx1ZSwgdGhlIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqICBUaGlzIGNyZWF0ZXMgYSBjbGVhciBkaXN0aW5jdGlvbiwgYmV0d2VlbiB2YWx1ZXMgdG8gYmUgdXNlZCBieSBjb2RlXG4gKiAgKGludGVnZXJzKSBhbmQgdmFsdWVzIHVzZWQgZm9yIGRpc3BsYXkgbG9naWMgdG8gdXNlcnMgKGRlY2ltYWxzKS5cbiAqXG4gKiAgVGhlIG5hdGl2ZSB1bml0IGluIEV0aGVyZXVtLCAvL2V0aGVyLy8gaXMgZGl2aXNpYmxlIHRvIDE4IGRlY2ltYWwgcGxhY2VzLFxuICogIHdoZXJlIGVhY2ggaW5kaXZpZHVhbCB1bml0IGlzIGNhbGxlZCBhIC8vd2VpLy8uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6VW5pdCBDb252ZXJzaW9uICBbYWJvdXQtdW5pdHNdXG4gKi9cbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBGaXhlZE51bWJlciB9IGZyb20gXCIuL2ZpeGVkbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBnZXROdW1iZXIgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8sIGFzc3VtaW5nICUldW5pdCUlIGRlY2ltYWxcbiAqICBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgYmUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvciB0aGUgbmFtZSBvZlxuICogIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCB1bml0KSB7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS50b1N0cmluZygpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQsIGFzc3VtaW5nXG4gKiAgJSV1bml0JSUgZGVjaW1hbCBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogIG9yIHRoZSBuYW1lIG9mIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS52YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vIHVzaW5nIDE4IGRlY2ltYWwgcGxhY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG4gICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJWV0aGVyJSUgdG8gYSBCaWdJbnQsIHVzaW5nIDE4XG4gKiAgZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/units.js\n");

/***/ })

};
;