"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lit-siwe";
exports.ids = ["vendor-chunks/lit-siwe"];
exports.modules = {

/***/ "(ssr)/./node_modules/lit-siwe/dist/client.js":
/*!**********************************************!*\
  !*** ./node_modules/lit-siwe/dist/client.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateNonce = exports.checkContractWalletSignature = exports.SiweMessage = exports.SignatureType = exports.ErrorTypes = void 0;\nconst random_1 = __webpack_require__(/*! @stablelib/random */ \"(ssr)/./node_modules/@stablelib/random/lib/random.js\");\n// TODO: Figure out how to get types from this lib:\n// import { Contract, ethers, utils } from 'ethers';\nconst contracts_1 = __webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\nconst wallet_1 = __webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\nconst hash_1 = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/index.js\");\nconst siwe_parser_1 = __webpack_require__(/*! @spruceid/siwe-parser */ \"(ssr)/./node_modules/@spruceid/siwe-parser/dist/parsers.js\");\n/**\n * Possible message error types.\n */\nvar ErrorTypes;\n(function (ErrorTypes) {\n    /**Thrown when the `validate()` function can verify the message. */\n    ErrorTypes[\"INVALID_SIGNATURE\"] = \"Invalid signature.\";\n    /**Thrown when the `expirationTime` is present and in the past. */\n    ErrorTypes[\"EXPIRED_MESSAGE\"] = \"Expired message.\";\n    /**Thrown when some required field is missing. */\n    ErrorTypes[\"MALFORMED_SESSION\"] = \"Malformed session.\";\n})(ErrorTypes = exports.ErrorTypes || (exports.ErrorTypes = {}));\n/**@deprecated\n * Possible signature types that this library supports.\n *\n * This enum will be removed in future releases. And signature type will be\n * inferred from version.\n */\nvar SignatureType;\n(function (SignatureType) {\n    /**EIP-191 signature scheme */\n    SignatureType[\"PERSONAL_SIGNATURE\"] = \"Personal signature\";\n})(SignatureType = exports.SignatureType || (exports.SignatureType = {}));\nclass SiweMessage {\n    /**\n     * Creates a parsed Sign-In with Ethereum Message (EIP-4361) object from a\n     * string or an object. If a string is used an ABNF parser is called to\n     * validate the parameter, otherwise the fields are attributed.\n     * @param param {string | SiweMessage} Sign message as a string or an object.\n     */\n    constructor(param) {\n        if (typeof param === \"string\") {\n            const parsedMessage = new siwe_parser_1.ParsedMessage(param);\n            this.domain = parsedMessage.domain;\n            this.address = parsedMessage.address;\n            this.statement = parsedMessage.statement;\n            this.uri = parsedMessage.uri;\n            this.version = parsedMessage.version;\n            this.nonce = parsedMessage.nonce;\n            this.issuedAt = parsedMessage.issuedAt;\n            this.expirationTime = parsedMessage.expirationTime;\n            this.notBefore = parsedMessage.notBefore;\n            this.requestId = parsedMessage.requestId;\n            this.chainId = parsedMessage.chainId;\n            this.resources = parsedMessage.resources;\n        }\n        else {\n            Object.assign(this, param);\n            if (typeof this.chainId === \"string\") {\n                this.chainId = parseInt(this.chainId);\n            }\n        }\n    }\n    /**\n     * Given a sign message (EIP-4361) returns the correct matching groups.\n     * @param message {string}\n     * @returns {RegExpExecArray} The matching groups for the message\n     */\n    regexFromMessage(message) {\n        const parsedMessage = new siwe_parser_1.ParsedMessageRegExp(message);\n        return parsedMessage.match;\n    }\n    /**\n     * This function can be used to retrieve an EIP-4361 formated message for\n     * signature, although you can call it directly it's advised to use\n     * [signMessage()] instead which will resolve to the correct method based\n     * on the [type] attribute of this object, in case of other formats being\n     * implemented.\n     * @returns {string} EIP-4361 formated message, ready for EIP-191 signing.\n     */\n    toMessage() {\n        const header = `${this.domain} wants you to sign in with your Ethereum account:`;\n        const uriField = `URI: ${this.uri}`;\n        let prefix = [header, this.address].join(\"\\n\");\n        const versionField = `Version: ${this.version}`;\n        if (!this.nonce) {\n            this.nonce = (0, exports.generateNonce)();\n        }\n        const chainField = `Chain ID: ` + this.chainId || 0;\n        const nonceField = `Nonce: ${this.nonce}`;\n        const suffixArray = [uriField, versionField, chainField, nonceField];\n        if (this.issuedAt) {\n            Date.parse(this.issuedAt);\n        }\n        this.issuedAt = this.issuedAt ? this.issuedAt : new Date().toISOString();\n        suffixArray.push(`Issued At: ${this.issuedAt}`);\n        if (this.expirationTime) {\n            const expiryField = `Expiration Time: ${this.expirationTime}`;\n            suffixArray.push(expiryField);\n        }\n        if (this.notBefore) {\n            suffixArray.push(`Not Before: ${this.notBefore}`);\n        }\n        if (this.requestId) {\n            suffixArray.push(`Request ID: ${this.requestId}`);\n        }\n        if (this.resources) {\n            suffixArray.push([`Resources:`, ...this.resources.map((x) => `- ${x}`)].join(\"\\n\"));\n        }\n        let suffix = suffixArray.join(\"\\n\");\n        prefix = [prefix, this.statement].join(\"\\n\\n\");\n        if (this.statement) {\n            prefix += \"\\n\";\n        }\n        return [prefix, suffix].join(\"\\n\");\n    }\n    /** @deprecated\n     * signMessage method is deprecated, use prepareMessage instead.\n     *\n     * This method parses all the fields in the object and creates a sign\n     * message according with the type defined.\n     * @returns {string} Returns a message ready to be signed according with the\n     * type defined in the object.\n     */\n    signMessage() {\n        console &&\n            console.warn &&\n            console.warn(\"signMessage method is deprecated, use prepareMessage instead.\");\n        return this.prepareMessage();\n    }\n    /**\n     * This method parses all the fields in the object and creates a sign\n     * message according with the type defined.\n     * @returns {string} Returns a message ready to be signed according with the\n     * type defined in the object.\n     */\n    prepareMessage() {\n        let message;\n        switch (this.version) {\n            case \"1\": {\n                message = this.toMessage();\n                break;\n            }\n            default: {\n                message = this.toMessage();\n                break;\n            }\n        }\n        return message;\n    }\n    /**\n     * Validates the integrity of the fields of this objects by matching it's\n     * signature.\n     * @param provider A Web3 provider able to perform a contract check, this is\n     * required if support for Smart Contract Wallets that implement EIP-1271 is\n     * needed.\n     * @returns {Promise<SiweMessage>} This object if valid.\n     */\n    validate(signature = this.signature, provider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const message = this.prepareMessage();\n                try {\n                    let missing = [];\n                    if (!message) {\n                        missing.push(\"`message`\");\n                    }\n                    if (!signature) {\n                        missing.push(\"`signature`\");\n                    }\n                    if (!this.address) {\n                        missing.push(\"`address`\");\n                    }\n                    if (missing.length > 0) {\n                        throw new Error(`${ErrorTypes.MALFORMED_SESSION} missing: ${missing.join(\", \")}.`);\n                    }\n                    let addr;\n                    try {\n                        addr = (0, wallet_1.verifyMessage)(message, signature);\n                    }\n                    catch (_) {\n                    }\n                    finally {\n                        if (addr !== this.address) {\n                            try {\n                                //EIP-1271\n                                const isValidSignature = yield (0, exports.checkContractWalletSignature)(this, signature, provider);\n                                if (!isValidSignature) {\n                                    throw new Error(`${ErrorTypes.INVALID_SIGNATURE}: ${addr} !== ${this.address}`);\n                                }\n                            }\n                            catch (e) {\n                                throw e;\n                            }\n                        }\n                    }\n                    const parsedMessage = new SiweMessage(message);\n                    if (parsedMessage.expirationTime) {\n                        const exp = new Date(parsedMessage.expirationTime).getTime();\n                        if (isNaN(exp)) {\n                            throw new Error(`${ErrorTypes.MALFORMED_SESSION} invalid expiration date.`);\n                        }\n                        if (new Date().getTime() >= exp) {\n                            throw new Error(ErrorTypes.EXPIRED_MESSAGE);\n                        }\n                    }\n                    resolve(parsedMessage);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }));\n        });\n    }\n}\nexports.SiweMessage = SiweMessage;\n/**\n * This method calls the EIP-1271 method for Smart Contract wallets\n * @param message The EIP-4361 parsed message\n * @param provider Web3 provider able to perform a contract check (Web3/EthersJS).\n * @returns {Promise<boolean>} Checks for the smart contract (if it exists) if\n * the signature is valid for given address.\n */\nconst checkContractWalletSignature = (message, signature, provider) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!provider) {\n        return false;\n    }\n    const abi = [\n        \"function isValidSignature(bytes32 _message, bytes _signature) public view returns (bool)\",\n    ];\n    try {\n        const walletContract = new contracts_1.Contract(message.address, abi, provider);\n        const hashMessage = (0, hash_1.hashMessage)(message.signMessage());\n        return yield walletContract.isValidSignature(hashMessage, signature);\n    }\n    catch (e) {\n        throw e;\n    }\n});\nexports.checkContractWalletSignature = checkContractWalletSignature;\n/**\n * This method leverages a native CSPRNG with support for both browser and Node.js\n * environments in order generate a cryptographically secure nonce for use in the\n * SiweMessage in order to prevent replay attacks.\n *\n * 96 bits has been chosen as a number to sufficiently balance size and security considerations\n * relative to the lifespan of it's usage.\n *\n * @returns cryptographically generated random nonce with 96 bits of entropy encoded with\n * an alphanumeric character set.\n */\nconst generateNonce = () => {\n    return (0, random_1.randomStringForEntropy)(96);\n};\nexports.generateNonce = generateNonce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGl0LXNpd2UvZGlzdC9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG9DQUFvQyxHQUFHLG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQjtBQUMvSCxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBbUI7QUFDNUM7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBMEI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMsMEZBQXVCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDNUMsc0JBQXNCLG1CQUFPLENBQUMseUZBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDLHFCQUFxQixLQUFLO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMERBQTBELENBQUc7QUFDN0QscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBLDhFQUE4RSxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QixXQUFXLG1CQUFtQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw2QkFBNkIsSUFBSSxNQUFNLE1BQU0sYUFBYTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDhCQUE4QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvbGl0LXNpd2UvZGlzdC9jbGllbnQuanM/YmRhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZW5lcmF0ZU5vbmNlID0gZXhwb3J0cy5jaGVja0NvbnRyYWN0V2FsbGV0U2lnbmF0dXJlID0gZXhwb3J0cy5TaXdlTWVzc2FnZSA9IGV4cG9ydHMuU2lnbmF0dXJlVHlwZSA9IGV4cG9ydHMuRXJyb3JUeXBlcyA9IHZvaWQgMDtcbmNvbnN0IHJhbmRvbV8xID0gcmVxdWlyZShcIkBzdGFibGVsaWIvcmFuZG9tXCIpO1xuLy8gVE9ETzogRmlndXJlIG91dCBob3cgdG8gZ2V0IHR5cGVzIGZyb20gdGhpcyBsaWI6XG4vLyBpbXBvcnQgeyBDb250cmFjdCwgZXRoZXJzLCB1dGlscyB9IGZyb20gJ2V0aGVycyc7XG5jb25zdCBjb250cmFjdHNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9jb250cmFjdHNcIik7XG5jb25zdCB3YWxsZXRfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC93YWxsZXRcIik7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiKTtcbmNvbnN0IHNpd2VfcGFyc2VyXzEgPSByZXF1aXJlKFwiQHNwcnVjZWlkL3Npd2UtcGFyc2VyXCIpO1xuLyoqXG4gKiBQb3NzaWJsZSBtZXNzYWdlIGVycm9yIHR5cGVzLlxuICovXG52YXIgRXJyb3JUeXBlcztcbihmdW5jdGlvbiAoRXJyb3JUeXBlcykge1xuICAgIC8qKlRocm93biB3aGVuIHRoZSBgdmFsaWRhdGUoKWAgZnVuY3Rpb24gY2FuIHZlcmlmeSB0aGUgbWVzc2FnZS4gKi9cbiAgICBFcnJvclR5cGVzW1wiSU5WQUxJRF9TSUdOQVRVUkVcIl0gPSBcIkludmFsaWQgc2lnbmF0dXJlLlwiO1xuICAgIC8qKlRocm93biB3aGVuIHRoZSBgZXhwaXJhdGlvblRpbWVgIGlzIHByZXNlbnQgYW5kIGluIHRoZSBwYXN0LiAqL1xuICAgIEVycm9yVHlwZXNbXCJFWFBJUkVEX01FU1NBR0VcIl0gPSBcIkV4cGlyZWQgbWVzc2FnZS5cIjtcbiAgICAvKipUaHJvd24gd2hlbiBzb21lIHJlcXVpcmVkIGZpZWxkIGlzIG1pc3NpbmcuICovXG4gICAgRXJyb3JUeXBlc1tcIk1BTEZPUk1FRF9TRVNTSU9OXCJdID0gXCJNYWxmb3JtZWQgc2Vzc2lvbi5cIjtcbn0pKEVycm9yVHlwZXMgPSBleHBvcnRzLkVycm9yVHlwZXMgfHwgKGV4cG9ydHMuRXJyb3JUeXBlcyA9IHt9KSk7XG4vKipAZGVwcmVjYXRlZFxuICogUG9zc2libGUgc2lnbmF0dXJlIHR5cGVzIHRoYXQgdGhpcyBsaWJyYXJ5IHN1cHBvcnRzLlxuICpcbiAqIFRoaXMgZW51bSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLiBBbmQgc2lnbmF0dXJlIHR5cGUgd2lsbCBiZVxuICogaW5mZXJyZWQgZnJvbSB2ZXJzaW9uLlxuICovXG52YXIgU2lnbmF0dXJlVHlwZTtcbihmdW5jdGlvbiAoU2lnbmF0dXJlVHlwZSkge1xuICAgIC8qKkVJUC0xOTEgc2lnbmF0dXJlIHNjaGVtZSAqL1xuICAgIFNpZ25hdHVyZVR5cGVbXCJQRVJTT05BTF9TSUdOQVRVUkVcIl0gPSBcIlBlcnNvbmFsIHNpZ25hdHVyZVwiO1xufSkoU2lnbmF0dXJlVHlwZSA9IGV4cG9ydHMuU2lnbmF0dXJlVHlwZSB8fCAoZXhwb3J0cy5TaWduYXR1cmVUeXBlID0ge30pKTtcbmNsYXNzIFNpd2VNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFyc2VkIFNpZ24tSW4gd2l0aCBFdGhlcmV1bSBNZXNzYWdlIChFSVAtNDM2MSkgb2JqZWN0IGZyb20gYVxuICAgICAqIHN0cmluZyBvciBhbiBvYmplY3QuIElmIGEgc3RyaW5nIGlzIHVzZWQgYW4gQUJORiBwYXJzZXIgaXMgY2FsbGVkIHRvXG4gICAgICogdmFsaWRhdGUgdGhlIHBhcmFtZXRlciwgb3RoZXJ3aXNlIHRoZSBmaWVsZHMgYXJlIGF0dHJpYnV0ZWQuXG4gICAgICogQHBhcmFtIHBhcmFtIHtzdHJpbmcgfCBTaXdlTWVzc2FnZX0gU2lnbiBtZXNzYWdlIGFzIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gbmV3IHNpd2VfcGFyc2VyXzEuUGFyc2VkTWVzc2FnZShwYXJhbSk7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbiA9IHBhcnNlZE1lc3NhZ2UuZG9tYWluO1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzID0gcGFyc2VkTWVzc2FnZS5hZGRyZXNzO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnQgPSBwYXJzZWRNZXNzYWdlLnN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMudXJpID0gcGFyc2VkTWVzc2FnZS51cmk7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSBwYXJzZWRNZXNzYWdlLnZlcnNpb247XG4gICAgICAgICAgICB0aGlzLm5vbmNlID0gcGFyc2VkTWVzc2FnZS5ub25jZTtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVkQXQgPSBwYXJzZWRNZXNzYWdlLmlzc3VlZEF0O1xuICAgICAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IHBhcnNlZE1lc3NhZ2UuZXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICB0aGlzLm5vdEJlZm9yZSA9IHBhcnNlZE1lc3NhZ2Uubm90QmVmb3JlO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSBwYXJzZWRNZXNzYWdlLnJlcXVlc3RJZDtcbiAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IHBhcnNlZE1lc3NhZ2UuY2hhaW5JZDtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzID0gcGFyc2VkTWVzc2FnZS5yZXNvdXJjZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHBhcmFtKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jaGFpbklkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gcGFyc2VJbnQodGhpcy5jaGFpbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNpZ24gbWVzc2FnZSAoRUlQLTQzNjEpIHJldHVybnMgdGhlIGNvcnJlY3QgbWF0Y2hpbmcgZ3JvdXBzLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIHtzdHJpbmd9XG4gICAgICogQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheX0gVGhlIG1hdGNoaW5nIGdyb3VwcyBmb3IgdGhlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICByZWdleEZyb21NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IG5ldyBzaXdlX3BhcnNlcl8xLlBhcnNlZE1lc3NhZ2VSZWdFeHAobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBwYXJzZWRNZXNzYWdlLm1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlIGFuIEVJUC00MzYxIGZvcm1hdGVkIG1lc3NhZ2UgZm9yXG4gICAgICogc2lnbmF0dXJlLCBhbHRob3VnaCB5b3UgY2FuIGNhbGwgaXQgZGlyZWN0bHkgaXQncyBhZHZpc2VkIHRvIHVzZVxuICAgICAqIFtzaWduTWVzc2FnZSgpXSBpbnN0ZWFkIHdoaWNoIHdpbGwgcmVzb2x2ZSB0byB0aGUgY29ycmVjdCBtZXRob2QgYmFzZWRcbiAgICAgKiBvbiB0aGUgW3R5cGVdIGF0dHJpYnV0ZSBvZiB0aGlzIG9iamVjdCwgaW4gY2FzZSBvZiBvdGhlciBmb3JtYXRzIGJlaW5nXG4gICAgICogaW1wbGVtZW50ZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gRUlQLTQzNjEgZm9ybWF0ZWQgbWVzc2FnZSwgcmVhZHkgZm9yIEVJUC0xOTEgc2lnbmluZy5cbiAgICAgKi9cbiAgICB0b01lc3NhZ2UoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGAke3RoaXMuZG9tYWlufSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpgO1xuICAgICAgICBjb25zdCB1cmlGaWVsZCA9IGBVUkk6ICR7dGhpcy51cml9YDtcbiAgICAgICAgbGV0IHByZWZpeCA9IFtoZWFkZXIsIHRoaXMuYWRkcmVzc10uam9pbihcIlxcblwiKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbkZpZWxkID0gYFZlcnNpb246ICR7dGhpcy52ZXJzaW9ufWA7XG4gICAgICAgIGlmICghdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgdGhpcy5ub25jZSA9ICgwLCBleHBvcnRzLmdlbmVyYXRlTm9uY2UpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhaW5GaWVsZCA9IGBDaGFpbiBJRDogYCArIHRoaXMuY2hhaW5JZCB8fCBcIjFcIjtcbiAgICAgICAgY29uc3Qgbm9uY2VGaWVsZCA9IGBOb25jZTogJHt0aGlzLm5vbmNlfWA7XG4gICAgICAgIGNvbnN0IHN1ZmZpeEFycmF5ID0gW3VyaUZpZWxkLCB2ZXJzaW9uRmllbGQsIGNoYWluRmllbGQsIG5vbmNlRmllbGRdO1xuICAgICAgICBpZiAodGhpcy5pc3N1ZWRBdCkge1xuICAgICAgICAgICAgRGF0ZS5wYXJzZSh0aGlzLmlzc3VlZEF0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzc3VlZEF0ID0gdGhpcy5pc3N1ZWRBdCA/IHRoaXMuaXNzdWVkQXQgOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIHN1ZmZpeEFycmF5LnB1c2goYElzc3VlZCBBdDogJHt0aGlzLmlzc3VlZEF0fWApO1xuICAgICAgICBpZiAodGhpcy5leHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgY29uc3QgZXhwaXJ5RmllbGQgPSBgRXhwaXJhdGlvbiBUaW1lOiAke3RoaXMuZXhwaXJhdGlvblRpbWV9YDtcbiAgICAgICAgICAgIHN1ZmZpeEFycmF5LnB1c2goZXhwaXJ5RmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vdEJlZm9yZSkge1xuICAgICAgICAgICAgc3VmZml4QXJyYXkucHVzaChgTm90IEJlZm9yZTogJHt0aGlzLm5vdEJlZm9yZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgIHN1ZmZpeEFycmF5LnB1c2goYFJlcXVlc3QgSUQ6ICR7dGhpcy5yZXF1ZXN0SWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBzdWZmaXhBcnJheS5wdXNoKFtgUmVzb3VyY2VzOmAsIC4uLnRoaXMucmVzb3VyY2VzLm1hcCgoeCkgPT4gYC0gJHt4fWApXS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VmZml4ID0gc3VmZml4QXJyYXkuam9pbihcIlxcblwiKTtcbiAgICAgICAgcHJlZml4ID0gW3ByZWZpeCwgdGhpcy5zdGF0ZW1lbnRdLmpvaW4oXCJcXG5cXG5cIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlbWVudCkge1xuICAgICAgICAgICAgcHJlZml4ICs9IFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHN1ZmZpeF0uam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkXG4gICAgICogc2lnbk1lc3NhZ2UgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIHVzZSBwcmVwYXJlTWVzc2FnZSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcGFyc2VzIGFsbCB0aGUgZmllbGRzIGluIHRoZSBvYmplY3QgYW5kIGNyZWF0ZXMgYSBzaWduXG4gICAgICogbWVzc2FnZSBhY2NvcmRpbmcgd2l0aCB0aGUgdHlwZSBkZWZpbmVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYSBtZXNzYWdlIHJlYWR5IHRvIGJlIHNpZ25lZCBhY2NvcmRpbmcgd2l0aCB0aGVcbiAgICAgKiB0eXBlIGRlZmluZWQgaW4gdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzaWduTWVzc2FnZSgpIHtcbiAgICAgICAgY29uc29sZSAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzaWduTWVzc2FnZSBtZXRob2QgaXMgZGVwcmVjYXRlZCwgdXNlIHByZXBhcmVNZXNzYWdlIGluc3RlYWQuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlTWVzc2FnZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBwYXJzZXMgYWxsIHRoZSBmaWVsZHMgaW4gdGhlIG9iamVjdCBhbmQgY3JlYXRlcyBhIHNpZ25cbiAgICAgKiBtZXNzYWdlIGFjY29yZGluZyB3aXRoIHRoZSB0eXBlIGRlZmluZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIG1lc3NhZ2UgcmVhZHkgdG8gYmUgc2lnbmVkIGFjY29yZGluZyB3aXRoIHRoZVxuICAgICAqIHR5cGUgZGVmaW5lZCBpbiB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHByZXBhcmVNZXNzYWdlKCkge1xuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCIxXCI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGhpcy50b01lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGhpcy50b01lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIGZpZWxkcyBvZiB0aGlzIG9iamVjdHMgYnkgbWF0Y2hpbmcgaXQnc1xuICAgICAqIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgQSBXZWIzIHByb3ZpZGVyIGFibGUgdG8gcGVyZm9ybSBhIGNvbnRyYWN0IGNoZWNrLCB0aGlzIGlzXG4gICAgICogcmVxdWlyZWQgaWYgc3VwcG9ydCBmb3IgU21hcnQgQ29udHJhY3QgV2FsbGV0cyB0aGF0IGltcGxlbWVudCBFSVAtMTI3MSBpc1xuICAgICAqIG5lZWRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaXdlTWVzc2FnZT59IFRoaXMgb2JqZWN0IGlmIHZhbGlkLlxuICAgICAqL1xuICAgIHZhbGlkYXRlKHNpZ25hdHVyZSA9IHRoaXMuc2lnbmF0dXJlLCBwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5wcmVwYXJlTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaXNzaW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKFwiYG1lc3NhZ2VgXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goXCJgc2lnbmF0dXJlYFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKFwiYGFkZHJlc3NgXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtFcnJvclR5cGVzLk1BTEZPUk1FRF9TRVNTSU9OfSBtaXNzaW5nOiAke21pc3Npbmcuam9pbihcIiwgXCIpfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkcjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHIgPSAoMCwgd2FsbGV0XzEudmVyaWZ5TWVzc2FnZSkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgIT09IHRoaXMuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRUlQLTEyNzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZSA9IHlpZWxkICgwLCBleHBvcnRzLmNoZWNrQ29udHJhY3RXYWxsZXRTaWduYXR1cmUpKHRoaXMsIHNpZ25hdHVyZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRTaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtFcnJvclR5cGVzLklOVkFMSURfU0lHTkFUVVJFfTogJHthZGRyfSAhPT0gJHt0aGlzLmFkZHJlc3N9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IG5ldyBTaXdlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cCA9IG5ldyBEYXRlKHBhcnNlZE1lc3NhZ2UuZXhwaXJhdGlvblRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihleHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0Vycm9yVHlwZXMuTUFMRk9STUVEX1NFU1NJT059IGludmFsaWQgZXhwaXJhdGlvbiBkYXRlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpID49IGV4cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFcnJvclR5cGVzLkVYUElSRURfTUVTU0FHRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaXdlTWVzc2FnZSA9IFNpd2VNZXNzYWdlO1xuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgRUlQLTEyNzEgbWV0aG9kIGZvciBTbWFydCBDb250cmFjdCB3YWxsZXRzXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgRUlQLTQzNjEgcGFyc2VkIG1lc3NhZ2VcbiAqIEBwYXJhbSBwcm92aWRlciBXZWIzIHByb3ZpZGVyIGFibGUgdG8gcGVyZm9ybSBhIGNvbnRyYWN0IGNoZWNrIChXZWIzL0V0aGVyc0pTKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBDaGVja3MgZm9yIHRoZSBzbWFydCBjb250cmFjdCAoaWYgaXQgZXhpc3RzKSBpZlxuICogdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCBmb3IgZ2l2ZW4gYWRkcmVzcy5cbiAqL1xuY29uc3QgY2hlY2tDb250cmFjdFdhbGxldFNpZ25hdHVyZSA9IChtZXNzYWdlLCBzaWduYXR1cmUsIHByb3ZpZGVyKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYWJpID0gW1xuICAgICAgICBcImZ1bmN0aW9uIGlzVmFsaWRTaWduYXR1cmUoYnl0ZXMzMiBfbWVzc2FnZSwgYnl0ZXMgX3NpZ25hdHVyZSkgcHVibGljIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgICBdO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHdhbGxldENvbnRyYWN0ID0gbmV3IGNvbnRyYWN0c18xLkNvbnRyYWN0KG1lc3NhZ2UuYWRkcmVzcywgYWJpLCBwcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGhhc2hNZXNzYWdlID0gKDAsIGhhc2hfMS5oYXNoTWVzc2FnZSkobWVzc2FnZS5zaWduTWVzc2FnZSgpKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHdhbGxldENvbnRyYWN0LmlzVmFsaWRTaWduYXR1cmUoaGFzaE1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufSk7XG5leHBvcnRzLmNoZWNrQ29udHJhY3RXYWxsZXRTaWduYXR1cmUgPSBjaGVja0NvbnRyYWN0V2FsbGV0U2lnbmF0dXJlO1xuLyoqXG4gKiBUaGlzIG1ldGhvZCBsZXZlcmFnZXMgYSBuYXRpdmUgQ1NQUk5HIHdpdGggc3VwcG9ydCBmb3IgYm90aCBicm93c2VyIGFuZCBOb2RlLmpzXG4gKiBlbnZpcm9ubWVudHMgaW4gb3JkZXIgZ2VuZXJhdGUgYSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgbm9uY2UgZm9yIHVzZSBpbiB0aGVcbiAqIFNpd2VNZXNzYWdlIGluIG9yZGVyIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MuXG4gKlxuICogOTYgYml0cyBoYXMgYmVlbiBjaG9zZW4gYXMgYSBudW1iZXIgdG8gc3VmZmljaWVudGx5IGJhbGFuY2Ugc2l6ZSBhbmQgc2VjdXJpdHkgY29uc2lkZXJhdGlvbnNcbiAqIHJlbGF0aXZlIHRvIHRoZSBsaWZlc3BhbiBvZiBpdCdzIHVzYWdlLlxuICpcbiAqIEByZXR1cm5zIGNyeXB0b2dyYXBoaWNhbGx5IGdlbmVyYXRlZCByYW5kb20gbm9uY2Ugd2l0aCA5NiBiaXRzIG9mIGVudHJvcHkgZW5jb2RlZCB3aXRoXG4gKiBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyIHNldC5cbiAqL1xuY29uc3QgZ2VuZXJhdGVOb25jZSA9ICgpID0+IHtcbiAgICByZXR1cm4gKDAsIHJhbmRvbV8xLnJhbmRvbVN0cmluZ0ZvckVudHJvcHkpKDk2KTtcbn07XG5leHBvcnRzLmdlbmVyYXRlTm9uY2UgPSBnZW5lcmF0ZU5vbmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lit-siwe/dist/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/lit-siwe/dist/siwe.js":
/*!********************************************!*\
  !*** ./node_modules/lit-siwe/dist/siwe.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./client */ \"(ssr)/./node_modules/lit-siwe/dist/client.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGl0LXNpd2UvZGlzdC9zaXdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw4REFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9saXQtc2l3ZS9kaXN0L3Npd2UuanM/ZGNiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NsaWVudFwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lit-siwe/dist/siwe.js\n");

/***/ })

};
;