/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/apg-js";
exports.ids = ["vendor-chunks/apg-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/api.js":
/*!************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/api.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is Application Programming Interface (API) for **APG** - the ABNF Parser Generator.\n//\n// *Note on teminology.*\n// APG is a parser generator.\n// However, it really only generates a \"grammar object\" (see below) from the defining SABNF grammar.\n// The generated parser is incomplete at this stage.\n// Remaining, it is the job of the user to develop the generated parser from the grammar object and the **APG** Library (**apg-lib**).\n//\n// The following terminology my help clear up any confusion between the idea of a \"generated parser\" versus a \"generated grammar object\".\n\n// - The generating parser: **APG** is an **APG** parser (yes, there is a circular dependence between **apg-api** and **apg-lib**). We'll call it the generating parser.\n// - The target parser: **APG**'s goal is to generate a parser. We'll call it the target parser.\n// - The target grammar: this is the (ASCII) SABNF grammar defining the target parser.\n// - The target grammar object: **APG** parses the SABNF grammar and generates the JavaScript source for a target grammar object constructor function\n// and/or an actual grammar object.\n// - The final target parser: The user then develops the final target parser using the generated target grammar\n// object and the **APG** parsing library, **apg-lib**.\n// Throws execeptions on fatal errors.\n//\n// src: the input SABNF grammar<br>\n// may be one of:\n// - Buffer of bytes\n// - JavaScript string\n// - Array of integer character codes\nmodule.exports = function api(src) {\n  const { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n  const thisFileName = 'api.js: ';\n  const thisObject = this;\n\n  /* PRIVATE PROPERTIES */\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"(ssr)/./node_modules/apg-js/src/apg-conv-api/converter.js\");\n  const scanner = __webpack_require__(/*! ./scanner */ \"(ssr)/./node_modules/apg-js/src/apg-api/scanner.js\");\n  const parser = new (__webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/apg-js/src/apg-api/parser.js\"))();\n  const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = __webpack_require__(/*! ./attributes */ \"(ssr)/./node_modules/apg-js/src/apg-api/attributes.js\");\n  const showRules = __webpack_require__(/*! ./show-rules */ \"(ssr)/./node_modules/apg-js/src/apg-api/show-rules.js\");\n\n  /* PRIVATE MEMBERS (FUNCTIONS) */\n  /* Convert a phrase (array of character codes) to HTML. */\n  const abnfToHtml = function abnfToHtml(chars, beg, len) {\n    const NORMAL = 0;\n    const CONTROL = 1;\n    const INVALID = 2;\n    const CONTROL_BEG = `<span class=\"${apglib.style.CLASS_CTRLCHAR}\">`;\n    const CONTROL_END = '</span>';\n    const INVALID_BEG = `<span class=\"${apglib.style.CLASS_NOMATCH}\">`;\n    const INVALID_END = '</span>';\n    let end;\n    let html = '';\n    const TRUE = true;\n    while (TRUE) {\n      if (!Array.isArray(chars) || chars.length === 0) {\n        break;\n      }\n      if (typeof beg !== 'number') {\n        throw new Error('abnfToHtml: beg must be type number');\n      }\n      if (beg >= chars.length) {\n        break;\n      }\n      if (typeof len !== 'number' || beg + len >= chars.length) {\n        end = chars.length;\n      } else {\n        end = beg + len;\n      }\n      let state = NORMAL;\n      for (let i = beg; i < end; i += 1) {\n        const ch = chars[i];\n        if (ch >= 32 && ch <= 126) {\n          /* normal - printable ASCII characters */\n          if (state === CONTROL) {\n            html += CONTROL_END;\n            state = NORMAL;\n          } else if (state === INVALID) {\n            html += INVALID_END;\n            state = NORMAL;\n          }\n          /* handle reserved HTML entity characters */\n          switch (ch) {\n            case 32:\n              html += '&nbsp;';\n              break;\n            case 60:\n              html += '&lt;';\n              break;\n            case 62:\n              html += '&gt;';\n              break;\n            case 38:\n              html += '&amp;';\n              break;\n            case 34:\n              html += '&quot;';\n              break;\n            case 39:\n              html += '&#039;';\n              break;\n            case 92:\n              html += '&#092;';\n              break;\n            default:\n              html += String.fromCharCode(ch);\n              break;\n          }\n        } else if (ch === 9 || ch === 10 || ch === 13) {\n          /* control characters */\n          if (state === NORMAL) {\n            html += CONTROL_BEG;\n            state = CONTROL;\n          } else if (state === INVALID) {\n            html += INVALID_END + CONTROL_BEG;\n            state = CONTROL;\n          }\n          if (ch === 9) {\n            html += 'TAB';\n          }\n          if (ch === 10) {\n            html += 'LF';\n          }\n          if (ch === 13) {\n            html += 'CR';\n          }\n        } else {\n          /* invalid characters */\n          if (state === NORMAL) {\n            html += INVALID_BEG;\n            state = INVALID;\n          } else if (state === CONTROL) {\n            html += CONTROL_END + INVALID_BEG;\n            state = INVALID;\n          }\n          /* display character as hexadecimal value */\n          html += `\\\\x${apglib.utils.charToHex(ch)}`;\n        }\n      }\n      if (state === INVALID) {\n        html += INVALID_END;\n      }\n      if (state === CONTROL) {\n        html += CONTROL_END;\n      }\n      break;\n    }\n    return html;\n  };\n  /* Convert a phrase (array of character codes) to ASCII text. */\n  const abnfToAscii = function abnfToAscii(chars, beg, len) {\n    let str = '';\n    for (let i = beg; i < beg + len; i += 1) {\n      const ch = chars[i];\n      if (ch >= 32 && ch <= 126) {\n        str += String.fromCharCode(ch);\n      } else {\n        switch (ch) {\n          case 9:\n            str += '\\\\t';\n            break;\n          case 10:\n            str += '\\\\n';\n            break;\n          case 13:\n            str += '\\\\r';\n            break;\n          default:\n            str += '\\\\unknown';\n            break;\n        }\n      }\n    }\n    return str;\n  };\n  /* translate lines (SABNF grammar) to ASCII text */\n  const linesToAscii = function linesToAscii(lines) {\n    let str = 'Annotated Input Grammar';\n    lines.forEach((val) => {\n      str += '\\n';\n      str += `line no: ${val.lineNo}`;\n      str += ` : char index: ${val.beginChar}`;\n      str += ` : length: ${val.length}`;\n      str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;\n    });\n    str += '\\n';\n    return str;\n  };\n  /* translate lines (SABNF grammar) to HTML */\n  const linesToHtml = function linesToHtml(lines) {\n    let html = '';\n    html += `<table class=\"${apglib.style.CLASS_GRAMMAR}\">\\n`;\n    const title = 'Annotated Input Grammar';\n    html += `<caption>${title}</caption>\\n`;\n    html += '<tr>';\n    html += '<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>';\n    html += '</tr>\\n';\n    lines.forEach((val) => {\n      html += '<tr>';\n      html += `<td>${val.lineNo}`;\n      html += `</td><td>${val.beginChar}`;\n      html += `</td><td>${val.length}`;\n      html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;\n      html += '</td>';\n      html += '</tr>\\n';\n    });\n\n    html += '</table>\\n';\n    return html;\n  };\n  /* Format the error messages to HTML, for page display. */\n  const errorsToHtml = function errorsToHtml(errors, lines, chars, title) {\n    const [style] = apglib;\n    let html = '';\n    const errorArrow = `<span class=\"${style.CLASS_NOMATCH}\">&raquo;</span>`;\n    html += `<p><table class=\"${style.CLASS_GRAMMAR}\">\\n`;\n    if (title && typeof title === 'string') {\n      html += `<caption>${title}</caption>\\n`;\n    }\n    html += '<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\\n';\n    errors.forEach((val) => {\n      let line;\n      let relchar;\n      let beg;\n      let end;\n      let text;\n      let prefix = '';\n      let suffix = '';\n      if (lines.length === 0) {\n        text = errorArrow;\n        relchar = 0;\n      } else {\n        line = lines[val.line];\n        beg = line.beginChar;\n        if (val.char > beg) {\n          prefix = abnfToHtml(chars, beg, val.char - beg);\n        }\n        beg = val.char;\n        end = line.beginChar + line.length;\n        if (beg < end) {\n          suffix = abnfToHtml(chars, beg, end - beg);\n        }\n        text = prefix + errorArrow + suffix;\n        relchar = val.char - line.beginChar;\n        html += '<tr>';\n        html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;\n        html += '</tr>\\n';\n        html += '<tr>';\n        html += `<td colspan=\"3\"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;\n        html += '</tr>\\n';\n      }\n    });\n    html += '</table></p>\\n';\n    return html;\n  };\n  /* Display an array of errors in ASCII text */\n  const errorsToAscii = function errorsToAscii(errors, lines, chars) {\n    let str;\n    let line;\n    let beg;\n    let len;\n    str = '';\n    errors.forEach((error) => {\n      line = lines[error.line];\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      beg = line.beginChar;\n      len = error.char - line.beginChar;\n      str += abnfToAscii(chars, beg, len);\n      str += ' >> ';\n      beg = error.char;\n      len = line.beginChar + line.length - error.char;\n      str += abnfToAscii(chars, beg, len);\n      str += '\\n';\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      str += 'error: ';\n      str += error.msg;\n      str += '\\n';\n    });\n    return str;\n  };\n  let isScanned = false;\n  let isParsed = false;\n  let isTranslated = false;\n  let haveAttributes = false;\n  let attributeErrors = 0;\n  let lineMap;\n\n  /* PUBLIC PROPERTIES */\n  // The input SABNF grammar as a JavaScript string.\n  // this.sabnf;\n  // The input SABNF grammar as an array of character codes.\n  // this.chars;\n  // An array of line objects, defining each line of the input SABNF grammar\n  // - lineNo : the zero-based line number\n  // - beginChar : offset (into `this.chars`) of the first character in the line\n  // - length : the number of characters in the line\n  // - textLength : the number of characters of text in the line, excluding the line ending characters\n  // - endType : \"CRLF\", \"LF\", \"CR\" or \"none\" if the last line has no line ending characters\n  // - invalidChars : `true` if the line contains invalid characters, `false` otherwise\n  // this.lines;\n  // An array of rule names and data.\n  // - name : the rule name\n  // - lower : the rule name in lower case\n  // - index : the index of the rule (ordered by appearance in SABNF grammar)\n  // - isBkr : `true` if this rule has been back referenced, `false` otherwise\n  // - opcodes : array of opcodes for this rule\n  // - attrs : the rule attributes\n  // - ctrl : system data\n  // this.rules;\n  // An array of UDT names and data.\n  // this.udts;\n  // An array of errors, if any.\n  // - line : the line number containing the error\n  // - char : the character offset of the error\n  // - msg : the error message\n  this.errors = [];\n\n  /* CONSTRUCTOR */\n  if (Buffer.isBuffer(src)) {\n    this.chars = converter.decode('BINARY', src);\n  } else if (Array.isArray(src)) {\n    this.chars = src.slice();\n  } else if (typeof src === 'string') {\n    this.chars = converter.decode('STRING', src);\n  } else {\n    throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);\n  }\n  this.sabnf = converter.encode('STRING', this.chars);\n\n  /* PUBLIC MEMBERS (FUNCTIONS) */\n  // Scan the input SABNF grammar for invalid characters and catalog the lines via `this.lines`.\n  // - strict : (optional) if `true`, all lines, including the last must end with CRLF (\\r\\n),\n  // if `false` (in any JavaScript sense) then line endings may be any mix of CRLF, LF, CR, or end-of-file.\n  // - trace (*) : (optional) a parser trace object, which will trace the parser that does the scan\n  this.scan = function scan(strict, trace) {\n    this.lines = scanner(this.chars, this.errors, strict, trace);\n    isScanned = true;\n  };\n  // Parse the input SABNF grammar for correct syntax.\n  // - strict : (optional) if `true`, the input grammar must be strict ABNF, conforming to [RFC 5234](https://tools.ietf.org/html/rfc5234)\n  // and [RFC 7405](https://tools.ietf.org/html/rfc7405). No superset features allowed.\n  // - trace (\\*) : (optional) a parser trace object, which will trace the syntax parser\n  //\n  // <i>(*)NOTE: the trace option was used primarily during development.\n  // Error detection and reporting is now fairly robust and tracing should be unnecessary. Use at your own peril.</i>\n  this.parse = function parse(strict, lite, trace) {\n    if (!isScanned) {\n      throw new Error(`${thisFileName}grammar not scanned`);\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict, lite, trace);\n    isParsed = true;\n  };\n  // Translate the SABNF grammar syntax into the opcodes that will guide the parser for this grammar.\n  this.translate = function translate() {\n    if (!isParsed) {\n      throw new Error(`${thisFileName}grammar not scanned and parsed`);\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length === 0) {\n      this.rules = ret.rules;\n      this.udts = ret.udts;\n      lineMap = ret.lineMap;\n      isTranslated = true;\n    }\n  };\n  // Compute the attributes of each rule.\n  this.attributes = function attrs() {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n    return attributeErrors;\n  };\n  // This function will perform the full suite of steps required to generate a parser grammar object\n  // from the input SABNF grammar.\n  this.generate = function generate(strict) {\n    this.lines = scanner(this.chars, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length) {\n      return;\n    }\n    this.rules = ret.rules;\n    this.udts = ret.udts;\n    lineMap = ret.lineMap;\n\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n  };\n  // Display the rules.\n  // Must scan, parse and translate before calling this function, otherwise there are no rules to display.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  this.displayRules = function displayRules(order = 'index') {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    return showRules(this.rules, this.udts, order);\n  };\n  // Display the rule dependencies.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // Otherwise the rule dependencies are not known.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  this.displayRuleDependencies = function displayRuleDependencies(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showRuleDependencies(order);\n  };\n  // Display the attributes.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, type order (default)\n  this.displayAttributes = function displayAttributes(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      showAttributeErrors(order);\n    }\n    return showAttributes(order);\n  };\n  this.displayAttributeErrors = function displayAttributeErrors() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showAttributeErrors();\n  };\n  // Returns a parser grammar object constructor function as a JavaScript string.\n  // This object can then be used to construct a parser.\n  this.toSource = function toSource(lite, name) {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateSource(this.chars, this.lines, this.rules, this.udts, lite, name);\n  };\n  // Returns a parser grammar object.\n  // This grammar object may be used by the application to construct a parser.\n  this.toObject = function toObject() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateObject(this.sabnf, this.rules, this.udts);\n  };\n  // Display errors in text format, suitable for `console.log()`.\n  this.errorsToAscii = function errorsToAsciiFunc() {\n    return errorsToAscii(this.errors, this.lines, this.chars);\n  };\n  // Display errors in HTML format, suitable for web page display.\n  // (`apg-lib.css` required for proper styling)\n  this.errorsToHtml = function errorsToHtmlFunc(title) {\n    return errorsToHtml(this.errors, this.lines, this.chars, title);\n  };\n  // Generate an annotated the SABNF grammar display in text format.\n  this.linesToAscii = function linesToAsciiFunc() {\n    return linesToAscii(this.lines);\n  };\n  // Generate an annotated the SABNF grammar display in HTML format.\n  // (`apg-lib.css` required for proper styling)\n  this.linesToHtml = function linesToHtmlFunc() {\n    return linesToHtml(this.lines);\n  };\n  // This function was only used by apg.html which has been abandoned.\n  /*\n    this.getAttributesObject = function () {\n        return null;\n    };\n    */\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx3RkFBeUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsNEZBQTJCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHFFQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLG1FQUFVO0FBQ3hDLFVBQVUsd0VBQXdFLEVBQUUsbUJBQU8sQ0FBQywyRUFBYztBQUMxRyxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBYzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FB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QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0EseUJBQXlCLGFBQWEsaURBQWlELGlCQUFpQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYSxpREFBaUQsaUJBQWlCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9hcGkuanM/OWZiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBpcyBBcHBsaWNhdGlvbiBQcm9ncmFtbWluZyBJbnRlcmZhY2UgKEFQSSkgZm9yICoqQVBHKiogLSB0aGUgQUJORiBQYXJzZXIgR2VuZXJhdG9yLlxuLy9cbi8vICpOb3RlIG9uIHRlbWlub2xvZ3kuKlxuLy8gQVBHIGlzIGEgcGFyc2VyIGdlbmVyYXRvci5cbi8vIEhvd2V2ZXIsIGl0IHJlYWxseSBvbmx5IGdlbmVyYXRlcyBhIFwiZ3JhbW1hciBvYmplY3RcIiAoc2VlIGJlbG93KSBmcm9tIHRoZSBkZWZpbmluZyBTQUJORiBncmFtbWFyLlxuLy8gVGhlIGdlbmVyYXRlZCBwYXJzZXIgaXMgaW5jb21wbGV0ZSBhdCB0aGlzIHN0YWdlLlxuLy8gUmVtYWluaW5nLCBpdCBpcyB0aGUgam9iIG9mIHRoZSB1c2VyIHRvIGRldmVsb3AgdGhlIGdlbmVyYXRlZCBwYXJzZXIgZnJvbSB0aGUgZ3JhbW1hciBvYmplY3QgYW5kIHRoZSAqKkFQRyoqIExpYnJhcnkgKCoqYXBnLWxpYioqKS5cbi8vXG4vLyBUaGUgZm9sbG93aW5nIHRlcm1pbm9sb2d5IG15IGhlbHAgY2xlYXIgdXAgYW55IGNvbmZ1c2lvbiBiZXR3ZWVuIHRoZSBpZGVhIG9mIGEgXCJnZW5lcmF0ZWQgcGFyc2VyXCIgdmVyc3VzIGEgXCJnZW5lcmF0ZWQgZ3JhbW1hciBvYmplY3RcIi5cblxuLy8gLSBUaGUgZ2VuZXJhdGluZyBwYXJzZXI6ICoqQVBHKiogaXMgYW4gKipBUEcqKiBwYXJzZXIgKHllcywgdGhlcmUgaXMgYSBjaXJjdWxhciBkZXBlbmRlbmNlIGJldHdlZW4gKiphcGctYXBpKiogYW5kICoqYXBnLWxpYioqKS4gV2UnbGwgY2FsbCBpdCB0aGUgZ2VuZXJhdGluZyBwYXJzZXIuXG4vLyAtIFRoZSB0YXJnZXQgcGFyc2VyOiAqKkFQRyoqJ3MgZ29hbCBpcyB0byBnZW5lcmF0ZSBhIHBhcnNlci4gV2UnbGwgY2FsbCBpdCB0aGUgdGFyZ2V0IHBhcnNlci5cbi8vIC0gVGhlIHRhcmdldCBncmFtbWFyOiB0aGlzIGlzIHRoZSAoQVNDSUkpIFNBQk5GIGdyYW1tYXIgZGVmaW5pbmcgdGhlIHRhcmdldCBwYXJzZXIuXG4vLyAtIFRoZSB0YXJnZXQgZ3JhbW1hciBvYmplY3Q6ICoqQVBHKiogcGFyc2VzIHRoZSBTQUJORiBncmFtbWFyIGFuZCBnZW5lcmF0ZXMgdGhlIEphdmFTY3JpcHQgc291cmNlIGZvciBhIHRhcmdldCBncmFtbWFyIG9iamVjdCBjb25zdHJ1Y3RvciBmdW5jdGlvblxuLy8gYW5kL29yIGFuIGFjdHVhbCBncmFtbWFyIG9iamVjdC5cbi8vIC0gVGhlIGZpbmFsIHRhcmdldCBwYXJzZXI6IFRoZSB1c2VyIHRoZW4gZGV2ZWxvcHMgdGhlIGZpbmFsIHRhcmdldCBwYXJzZXIgdXNpbmcgdGhlIGdlbmVyYXRlZCB0YXJnZXQgZ3JhbW1hclxuLy8gb2JqZWN0IGFuZCB0aGUgKipBUEcqKiBwYXJzaW5nIGxpYnJhcnksICoqYXBnLWxpYioqLlxuLy8gVGhyb3dzIGV4ZWNlcHRpb25zIG9uIGZhdGFsIGVycm9ycy5cbi8vXG4vLyBzcmM6IHRoZSBpbnB1dCBTQUJORiBncmFtbWFyPGJyPlxuLy8gbWF5IGJlIG9uZSBvZjpcbi8vIC0gQnVmZmVyIG9mIGJ5dGVzXG4vLyAtIEphdmFTY3JpcHQgc3RyaW5nXG4vLyAtIEFycmF5IG9mIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwaShzcmMpIHtcbiAgY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnYXBpLmpzOiAnO1xuICBjb25zdCB0aGlzT2JqZWN0ID0gdGhpcztcblxuICAvKiBQUklWQVRFIFBST1BFUlRJRVMgKi9cbiAgY29uc3QgYXBnbGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgY29udmVydGVyID0gcmVxdWlyZSgnLi4vYXBnLWNvbnYtYXBpL2NvbnZlcnRlcicpO1xuICBjb25zdCBzY2FubmVyID0gcmVxdWlyZSgnLi9zY2FubmVyJyk7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyAocmVxdWlyZSgnLi9wYXJzZXInKSkoKTtcbiAgY29uc3QgeyBhdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZUVycm9ycywgc2hvd1J1bGVEZXBlbmRlbmNpZXMgfSA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xuICBjb25zdCBzaG93UnVsZXMgPSByZXF1aXJlKCcuL3Nob3ctcnVsZXMnKTtcblxuICAvKiBQUklWQVRFIE1FTUJFUlMgKEZVTkNUSU9OUykgKi9cbiAgLyogQ29udmVydCBhIHBocmFzZSAoYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzKSB0byBIVE1MLiAqL1xuICBjb25zdCBhYm5mVG9IdG1sID0gZnVuY3Rpb24gYWJuZlRvSHRtbChjaGFycywgYmVnLCBsZW4pIHtcbiAgICBjb25zdCBOT1JNQUwgPSAwO1xuICAgIGNvbnN0IENPTlRST0wgPSAxO1xuICAgIGNvbnN0IElOVkFMSUQgPSAyO1xuICAgIGNvbnN0IENPTlRST0xfQkVHID0gYDxzcGFuIGNsYXNzPVwiJHthcGdsaWIuc3R5bGUuQ0xBU1NfQ1RSTENIQVJ9XCI+YDtcbiAgICBjb25zdCBDT05UUk9MX0VORCA9ICc8L3NwYW4+JztcbiAgICBjb25zdCBJTlZBTElEX0JFRyA9IGA8c3BhbiBjbGFzcz1cIiR7YXBnbGliLnN0eWxlLkNMQVNTX05PTUFUQ0h9XCI+YDtcbiAgICBjb25zdCBJTlZBTElEX0VORCA9ICc8L3NwYW4+JztcbiAgICBsZXQgZW5kO1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGFycykgfHwgY2hhcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiZWcgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWJuZlRvSHRtbDogYmVnIG11c3QgYmUgdHlwZSBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmIChiZWcgPj0gY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInIHx8IGJlZyArIGxlbiA+PSBjaGFycy5sZW5ndGgpIHtcbiAgICAgICAgZW5kID0gY2hhcnMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gYmVnICsgbGVuO1xuICAgICAgfVxuICAgICAgbGV0IHN0YXRlID0gTk9STUFMO1xuICAgICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoID0gY2hhcnNbaV07XG4gICAgICAgIGlmIChjaCA+PSAzMiAmJiBjaCA8PSAxMjYpIHtcbiAgICAgICAgICAvKiBub3JtYWwgLSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVycyAqL1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgaHRtbCArPSBDT05UUk9MX0VORDtcbiAgICAgICAgICAgIHN0YXRlID0gTk9STUFMO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IElOVkFMSUQpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gSU5WQUxJRF9FTkQ7XG4gICAgICAgICAgICBzdGF0ZSA9IE5PUk1BTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogaGFuZGxlIHJlc2VydmVkIEhUTUwgZW50aXR5IGNoYXJhY3RlcnMgKi9cbiAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICBodG1sICs9ICcmbmJzcDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZsdDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZndDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZhbXA7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICBodG1sICs9ICcmcXVvdDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyYjMDM5Oyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJiMwOTI7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBodG1sICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkgfHwgY2ggPT09IDEwIHx8IGNoID09PSAxMykge1xuICAgICAgICAgIC8qIGNvbnRyb2wgY2hhcmFjdGVycyAqL1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gTk9STUFMKSB7XG4gICAgICAgICAgICBodG1sICs9IENPTlRST0xfQkVHO1xuICAgICAgICAgICAgc3RhdGUgPSBDT05UUk9MO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IElOVkFMSUQpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gSU5WQUxJRF9FTkQgKyBDT05UUk9MX0JFRztcbiAgICAgICAgICAgIHN0YXRlID0gQ09OVFJPTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoID09PSA5KSB7XG4gICAgICAgICAgICBodG1sICs9ICdUQUInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2ggPT09IDEwKSB7XG4gICAgICAgICAgICBodG1sICs9ICdMRic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaCA9PT0gMTMpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJ0NSJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaW52YWxpZCBjaGFyYWN0ZXJzICovXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBOT1JNQUwpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gSU5WQUxJRF9CRUc7XG4gICAgICAgICAgICBzdGF0ZSA9IElOVkFMSUQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgaHRtbCArPSBDT05UUk9MX0VORCArIElOVkFMSURfQkVHO1xuICAgICAgICAgICAgc3RhdGUgPSBJTlZBTElEO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBkaXNwbGF5IGNoYXJhY3RlciBhcyBoZXhhZGVjaW1hbCB2YWx1ZSAqL1xuICAgICAgICAgIGh0bWwgKz0gYFxcXFx4JHthcGdsaWIudXRpbHMuY2hhclRvSGV4KGNoKX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IElOVkFMSUQpIHtcbiAgICAgICAgaHRtbCArPSBJTlZBTElEX0VORDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gQ09OVFJPTCkge1xuICAgICAgICBodG1sICs9IENPTlRST0xfRU5EO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBDb252ZXJ0IGEgcGhyYXNlIChhcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMpIHRvIEFTQ0lJIHRleHQuICovXG4gIGNvbnN0IGFibmZUb0FzY2lpID0gZnVuY3Rpb24gYWJuZlRvQXNjaWkoY2hhcnMsIGJlZywgbGVuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBiZWcgKyBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgY2ggPSBjaGFyc1tpXTtcbiAgICAgIGlmIChjaCA+PSAzMiAmJiBjaCA8PSAxMjYpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHN0ciArPSAnXFxcXHQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHN0ciArPSAnXFxcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxcXHInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN0ciArPSAnXFxcXHVua25vd24nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgLyogdHJhbnNsYXRlIGxpbmVzIChTQUJORiBncmFtbWFyKSB0byBBU0NJSSB0ZXh0ICovXG4gIGNvbnN0IGxpbmVzVG9Bc2NpaSA9IGZ1bmN0aW9uIGxpbmVzVG9Bc2NpaShsaW5lcykge1xuICAgIGxldCBzdHIgPSAnQW5ub3RhdGVkIElucHV0IEdyYW1tYXInO1xuICAgIGxpbmVzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgc3RyICs9IGBsaW5lIG5vOiAke3ZhbC5saW5lTm99YDtcbiAgICAgIHN0ciArPSBgIDogY2hhciBpbmRleDogJHt2YWwuYmVnaW5DaGFyfWA7XG4gICAgICBzdHIgKz0gYCA6IGxlbmd0aDogJHt2YWwubGVuZ3RofWA7XG4gICAgICBzdHIgKz0gYCA6IGFibmY6ICR7YWJuZlRvQXNjaWkodGhpc09iamVjdC5jaGFycywgdmFsLmJlZ2luQ2hhciwgdmFsLmxlbmd0aCl9YDtcbiAgICB9KTtcbiAgICBzdHIgKz0gJ1xcbic7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgLyogdHJhbnNsYXRlIGxpbmVzIChTQUJORiBncmFtbWFyKSB0byBIVE1MICovXG4gIGNvbnN0IGxpbmVzVG9IdG1sID0gZnVuY3Rpb24gbGluZXNUb0h0bWwobGluZXMpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGh0bWwgKz0gYDx0YWJsZSBjbGFzcz1cIiR7YXBnbGliLnN0eWxlLkNMQVNTX0dSQU1NQVJ9XCI+XFxuYDtcbiAgICBjb25zdCB0aXRsZSA9ICdBbm5vdGF0ZWQgSW5wdXQgR3JhbW1hcic7XG4gICAgaHRtbCArPSBgPGNhcHRpb24+JHt0aXRsZX08L2NhcHRpb24+XFxuYDtcbiAgICBodG1sICs9ICc8dHI+JztcbiAgICBodG1sICs9ICc8dGg+bGluZTxicj5uby48L3RoPjx0aD5maXJzdDxicj5jaGFyPC90aD48dGg+PGJyPmxlbmd0aDwvdGg+PHRoPjxicj50ZXh0PC90aD4nO1xuICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICBsaW5lcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgaHRtbCArPSBgPHRkPiR7dmFsLmxpbmVOb31gO1xuICAgICAgaHRtbCArPSBgPC90ZD48dGQ+JHt2YWwuYmVnaW5DaGFyfWA7XG4gICAgICBodG1sICs9IGA8L3RkPjx0ZD4ke3ZhbC5sZW5ndGh9YDtcbiAgICAgIGh0bWwgKz0gYDwvdGQ+PHRkPiR7YWJuZlRvSHRtbCh0aGlzT2JqZWN0LmNoYXJzLCB2YWwuYmVnaW5DaGFyLCB2YWwubGVuZ3RoKX1gO1xuICAgICAgaHRtbCArPSAnPC90ZD4nO1xuICAgICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgIH0pO1xuXG4gICAgaHRtbCArPSAnPC90YWJsZT5cXG4nO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBGb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2VzIHRvIEhUTUwsIGZvciBwYWdlIGRpc3BsYXkuICovXG4gIGNvbnN0IGVycm9yc1RvSHRtbCA9IGZ1bmN0aW9uIGVycm9yc1RvSHRtbChlcnJvcnMsIGxpbmVzLCBjaGFycywgdGl0bGUpIHtcbiAgICBjb25zdCBbc3R5bGVdID0gYXBnbGliO1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgY29uc3QgZXJyb3JBcnJvdyA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4mcmFxdW87PC9zcGFuPmA7XG4gICAgaHRtbCArPSBgPHA+PHRhYmxlIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19HUkFNTUFSfVwiPlxcbmA7XG4gICAgaWYgKHRpdGxlICYmIHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGh0bWwgKz0gYDxjYXB0aW9uPiR7dGl0bGV9PC9jYXB0aW9uPlxcbmA7XG4gICAgfVxuICAgIGh0bWwgKz0gJzx0cj48dGg+bGluZTxicj5uby48L3RoPjx0aD5saW5lPGJyPm9mZnNldDwvdGg+PHRoPmVycm9yPGJyPm9mZnNldDwvdGg+PHRoPjxicj50ZXh0PC90aD48L3RyPlxcbic7XG4gICAgZXJyb3JzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgbGV0IGxpbmU7XG4gICAgICBsZXQgcmVsY2hhcjtcbiAgICAgIGxldCBiZWc7XG4gICAgICBsZXQgZW5kO1xuICAgICAgbGV0IHRleHQ7XG4gICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICBsZXQgc3VmZml4ID0gJyc7XG4gICAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRleHQgPSBlcnJvckFycm93O1xuICAgICAgICByZWxjaGFyID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUgPSBsaW5lc1t2YWwubGluZV07XG4gICAgICAgIGJlZyA9IGxpbmUuYmVnaW5DaGFyO1xuICAgICAgICBpZiAodmFsLmNoYXIgPiBiZWcpIHtcbiAgICAgICAgICBwcmVmaXggPSBhYm5mVG9IdG1sKGNoYXJzLCBiZWcsIHZhbC5jaGFyIC0gYmVnKTtcbiAgICAgICAgfVxuICAgICAgICBiZWcgPSB2YWwuY2hhcjtcbiAgICAgICAgZW5kID0gbGluZS5iZWdpbkNoYXIgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgaWYgKGJlZyA8IGVuZCkge1xuICAgICAgICAgIHN1ZmZpeCA9IGFibmZUb0h0bWwoY2hhcnMsIGJlZywgZW5kIC0gYmVnKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gcHJlZml4ICsgZXJyb3JBcnJvdyArIHN1ZmZpeDtcbiAgICAgICAgcmVsY2hhciA9IHZhbC5jaGFyIC0gbGluZS5iZWdpbkNoYXI7XG4gICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICBodG1sICs9IGA8dGQ+JHt2YWwubGluZX08L3RkPjx0ZD4ke2xpbmUuYmVnaW5DaGFyfTwvdGQ+PHRkPiR7cmVsY2hhcn08L3RkPjx0ZD4ke3RleHR9PC90ZD5gO1xuICAgICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICBodG1sICs9IGA8dGQgY29sc3Bhbj1cIjNcIj48L3RkPjx0ZD4mdWFycjs6Jm5ic3A7JHthcGdsaWIudXRpbHMuc3RyaW5nVG9Bc2NpaUh0bWwodmFsLm1zZyl9PC90ZD5gO1xuICAgICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaHRtbCArPSAnPC90YWJsZT48L3A+XFxuJztcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogRGlzcGxheSBhbiBhcnJheSBvZiBlcnJvcnMgaW4gQVNDSUkgdGV4dCAqL1xuICBjb25zdCBlcnJvcnNUb0FzY2lpID0gZnVuY3Rpb24gZXJyb3JzVG9Bc2NpaShlcnJvcnMsIGxpbmVzLCBjaGFycykge1xuICAgIGxldCBzdHI7XG4gICAgbGV0IGxpbmU7XG4gICAgbGV0IGJlZztcbiAgICBsZXQgbGVuO1xuICAgIHN0ciA9ICcnO1xuICAgIGVycm9ycy5mb3JFYWNoKChlcnJvcikgPT4ge1xuICAgICAgbGluZSA9IGxpbmVzW2Vycm9yLmxpbmVdO1xuICAgICAgc3RyICs9IGAke2xpbmUubGluZU5vfTogYDtcbiAgICAgIHN0ciArPSBgJHtsaW5lLmJlZ2luQ2hhcn06IGA7XG4gICAgICBzdHIgKz0gYCR7ZXJyb3IuY2hhciAtIGxpbmUuYmVnaW5DaGFyfTogYDtcbiAgICAgIGJlZyA9IGxpbmUuYmVnaW5DaGFyO1xuICAgICAgbGVuID0gZXJyb3IuY2hhciAtIGxpbmUuYmVnaW5DaGFyO1xuICAgICAgc3RyICs9IGFibmZUb0FzY2lpKGNoYXJzLCBiZWcsIGxlbik7XG4gICAgICBzdHIgKz0gJyA+PiAnO1xuICAgICAgYmVnID0gZXJyb3IuY2hhcjtcbiAgICAgIGxlbiA9IGxpbmUuYmVnaW5DaGFyICsgbGluZS5sZW5ndGggLSBlcnJvci5jaGFyO1xuICAgICAgc3RyICs9IGFibmZUb0FzY2lpKGNoYXJzLCBiZWcsIGxlbik7XG4gICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICBzdHIgKz0gYCR7bGluZS5saW5lTm99OiBgO1xuICAgICAgc3RyICs9IGAke2xpbmUuYmVnaW5DaGFyfTogYDtcbiAgICAgIHN0ciArPSBgJHtlcnJvci5jaGFyIC0gbGluZS5iZWdpbkNoYXJ9OiBgO1xuICAgICAgc3RyICs9ICdlcnJvcjogJztcbiAgICAgIHN0ciArPSBlcnJvci5tc2c7XG4gICAgICBzdHIgKz0gJ1xcbic7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgbGV0IGlzU2Nhbm5lZCA9IGZhbHNlO1xuICBsZXQgaXNQYXJzZWQgPSBmYWxzZTtcbiAgbGV0IGlzVHJhbnNsYXRlZCA9IGZhbHNlO1xuICBsZXQgaGF2ZUF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgbGV0IGF0dHJpYnV0ZUVycm9ycyA9IDA7XG4gIGxldCBsaW5lTWFwO1xuXG4gIC8qIFBVQkxJQyBQUk9QRVJUSUVTICovXG4gIC8vIFRoZSBpbnB1dCBTQUJORiBncmFtbWFyIGFzIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gIC8vIHRoaXMuc2FibmY7XG4gIC8vIFRoZSBpbnB1dCBTQUJORiBncmFtbWFyIGFzIGFuIGFycmF5IG9mIGNoYXJhY3RlciBjb2Rlcy5cbiAgLy8gdGhpcy5jaGFycztcbiAgLy8gQW4gYXJyYXkgb2YgbGluZSBvYmplY3RzLCBkZWZpbmluZyBlYWNoIGxpbmUgb2YgdGhlIGlucHV0IFNBQk5GIGdyYW1tYXJcbiAgLy8gLSBsaW5lTm8gOiB0aGUgemVyby1iYXNlZCBsaW5lIG51bWJlclxuICAvLyAtIGJlZ2luQ2hhciA6IG9mZnNldCAoaW50byBgdGhpcy5jaGFyc2ApIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIGxpbmVcbiAgLy8gLSBsZW5ndGggOiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGxpbmVcbiAgLy8gLSB0ZXh0TGVuZ3RoIDogdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHRleHQgaW4gdGhlIGxpbmUsIGV4Y2x1ZGluZyB0aGUgbGluZSBlbmRpbmcgY2hhcmFjdGVyc1xuICAvLyAtIGVuZFR5cGUgOiBcIkNSTEZcIiwgXCJMRlwiLCBcIkNSXCIgb3IgXCJub25lXCIgaWYgdGhlIGxhc3QgbGluZSBoYXMgbm8gbGluZSBlbmRpbmcgY2hhcmFjdGVyc1xuICAvLyAtIGludmFsaWRDaGFycyA6IGB0cnVlYCBpZiB0aGUgbGluZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gIC8vIHRoaXMubGluZXM7XG4gIC8vIEFuIGFycmF5IG9mIHJ1bGUgbmFtZXMgYW5kIGRhdGEuXG4gIC8vIC0gbmFtZSA6IHRoZSBydWxlIG5hbWVcbiAgLy8gLSBsb3dlciA6IHRoZSBydWxlIG5hbWUgaW4gbG93ZXIgY2FzZVxuICAvLyAtIGluZGV4IDogdGhlIGluZGV4IG9mIHRoZSBydWxlIChvcmRlcmVkIGJ5IGFwcGVhcmFuY2UgaW4gU0FCTkYgZ3JhbW1hcilcbiAgLy8gLSBpc0JrciA6IGB0cnVlYCBpZiB0aGlzIHJ1bGUgaGFzIGJlZW4gYmFjayByZWZlcmVuY2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAvLyAtIG9wY29kZXMgOiBhcnJheSBvZiBvcGNvZGVzIGZvciB0aGlzIHJ1bGVcbiAgLy8gLSBhdHRycyA6IHRoZSBydWxlIGF0dHJpYnV0ZXNcbiAgLy8gLSBjdHJsIDogc3lzdGVtIGRhdGFcbiAgLy8gdGhpcy5ydWxlcztcbiAgLy8gQW4gYXJyYXkgb2YgVURUIG5hbWVzIGFuZCBkYXRhLlxuICAvLyB0aGlzLnVkdHM7XG4gIC8vIEFuIGFycmF5IG9mIGVycm9ycywgaWYgYW55LlxuICAvLyAtIGxpbmUgOiB0aGUgbGluZSBudW1iZXIgY29udGFpbmluZyB0aGUgZXJyb3JcbiAgLy8gLSBjaGFyIDogdGhlIGNoYXJhY3RlciBvZmZzZXQgb2YgdGhlIGVycm9yXG4gIC8vIC0gbXNnIDogdGhlIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lcnJvcnMgPSBbXTtcblxuICAvKiBDT05TVFJVQ1RPUiAqL1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNyYykpIHtcbiAgICB0aGlzLmNoYXJzID0gY29udmVydGVyLmRlY29kZSgnQklOQVJZJywgc3JjKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICB0aGlzLmNoYXJzID0gc3JjLnNsaWNlKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoYXJzID0gY29udmVydGVyLmRlY29kZSgnU1RSSU5HJywgc3JjKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWlucHV0IHNvdXJjZSBpcyBub3QgYSBzdHJpbmcsIGJ5dGUgQnVmZmVyIG9yIGNoYXJhY3RlciBhcnJheWApO1xuICB9XG4gIHRoaXMuc2FibmYgPSBjb252ZXJ0ZXIuZW5jb2RlKCdTVFJJTkcnLCB0aGlzLmNoYXJzKTtcblxuICAvKiBQVUJMSUMgTUVNQkVSUyAoRlVOQ1RJT05TKSAqL1xuICAvLyBTY2FuIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMgYW5kIGNhdGFsb2cgdGhlIGxpbmVzIHZpYSBgdGhpcy5saW5lc2AuXG4gIC8vIC0gc3RyaWN0IDogKG9wdGlvbmFsKSBpZiBgdHJ1ZWAsIGFsbCBsaW5lcywgaW5jbHVkaW5nIHRoZSBsYXN0IG11c3QgZW5kIHdpdGggQ1JMRiAoXFxyXFxuKSxcbiAgLy8gaWYgYGZhbHNlYCAoaW4gYW55IEphdmFTY3JpcHQgc2Vuc2UpIHRoZW4gbGluZSBlbmRpbmdzIG1heSBiZSBhbnkgbWl4IG9mIENSTEYsIExGLCBDUiwgb3IgZW5kLW9mLWZpbGUuXG4gIC8vIC0gdHJhY2UgKCopIDogKG9wdGlvbmFsKSBhIHBhcnNlciB0cmFjZSBvYmplY3QsIHdoaWNoIHdpbGwgdHJhY2UgdGhlIHBhcnNlciB0aGF0IGRvZXMgdGhlIHNjYW5cbiAgdGhpcy5zY2FuID0gZnVuY3Rpb24gc2NhbihzdHJpY3QsIHRyYWNlKSB7XG4gICAgdGhpcy5saW5lcyA9IHNjYW5uZXIodGhpcy5jaGFycywgdGhpcy5lcnJvcnMsIHN0cmljdCwgdHJhY2UpO1xuICAgIGlzU2Nhbm5lZCA9IHRydWU7XG4gIH07XG4gIC8vIFBhcnNlIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyIGZvciBjb3JyZWN0IHN5bnRheC5cbiAgLy8gLSBzdHJpY3QgOiAob3B0aW9uYWwpIGlmIGB0cnVlYCwgdGhlIGlucHV0IGdyYW1tYXIgbXVzdCBiZSBzdHJpY3QgQUJORiwgY29uZm9ybWluZyB0byBbUkZDIDUyMzRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MjM0KVxuICAvLyBhbmQgW1JGQyA3NDA1XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzQwNSkuIE5vIHN1cGVyc2V0IGZlYXR1cmVzIGFsbG93ZWQuXG4gIC8vIC0gdHJhY2UgKFxcKikgOiAob3B0aW9uYWwpIGEgcGFyc2VyIHRyYWNlIG9iamVjdCwgd2hpY2ggd2lsbCB0cmFjZSB0aGUgc3ludGF4IHBhcnNlclxuICAvL1xuICAvLyA8aT4oKilOT1RFOiB0aGUgdHJhY2Ugb3B0aW9uIHdhcyB1c2VkIHByaW1hcmlseSBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gIC8vIEVycm9yIGRldGVjdGlvbiBhbmQgcmVwb3J0aW5nIGlzIG5vdyBmYWlybHkgcm9idXN0IGFuZCB0cmFjaW5nIHNob3VsZCBiZSB1bm5lY2Vzc2FyeS4gVXNlIGF0IHlvdXIgb3duIHBlcmlsLjwvaT5cbiAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHN0cmljdCwgbGl0ZSwgdHJhY2UpIHtcbiAgICBpZiAoIWlzU2Nhbm5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ncmFtbWFyIG5vdCBzY2FubmVkYCk7XG4gICAgfVxuICAgIHBhcnNlci5zeW50YXgodGhpcy5jaGFycywgdGhpcy5saW5lcywgdGhpcy5lcnJvcnMsIHN0cmljdCwgbGl0ZSwgdHJhY2UpO1xuICAgIGlzUGFyc2VkID0gdHJ1ZTtcbiAgfTtcbiAgLy8gVHJhbnNsYXRlIHRoZSBTQUJORiBncmFtbWFyIHN5bnRheCBpbnRvIHRoZSBvcGNvZGVzIHRoYXQgd2lsbCBndWlkZSB0aGUgcGFyc2VyIGZvciB0aGlzIGdyYW1tYXIuXG4gIHRoaXMudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlKCkge1xuICAgIGlmICghaXNQYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Z3JhbW1hciBub3Qgc2Nhbm5lZCBhbmQgcGFyc2VkYCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHBhcnNlci5zZW1hbnRpYyh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLmVycm9ycyk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5ydWxlcyA9IHJldC5ydWxlcztcbiAgICAgIHRoaXMudWR0cyA9IHJldC51ZHRzO1xuICAgICAgbGluZU1hcCA9IHJldC5saW5lTWFwO1xuICAgICAgaXNUcmFuc2xhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8vIENvbXB1dGUgdGhlIGF0dHJpYnV0ZXMgb2YgZWFjaCBydWxlLlxuICB0aGlzLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBhdHRycygpIHtcbiAgICBpZiAoIWlzVHJhbnNsYXRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ncmFtbWFyIG5vdCBzY2FubmVkLCBwYXJzZWQgYW5kIHRyYW5zbGF0ZWRgKTtcbiAgICB9XG4gICAgYXR0cmlidXRlRXJyb3JzID0gYXR0cmlidXRlcyh0aGlzLnJ1bGVzLCB0aGlzLnVkdHMsIGxpbmVNYXAsIHRoaXMuZXJyb3JzKTtcbiAgICBoYXZlQXR0cmlidXRlcyA9IHRydWU7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZUVycm9ycztcbiAgfTtcbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gdGhlIGZ1bGwgc3VpdGUgb2Ygc3RlcHMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgYSBwYXJzZXIgZ3JhbW1hciBvYmplY3RcbiAgLy8gZnJvbSB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hci5cbiAgdGhpcy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKHN0cmljdCkge1xuICAgIHRoaXMubGluZXMgPSBzY2FubmVyKHRoaXMuY2hhcnMsIHRoaXMuZXJyb3JzLCBzdHJpY3QpO1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyc2VyLnN5bnRheCh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLmVycm9ycywgc3RyaWN0KTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHBhcnNlci5zZW1hbnRpYyh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLmVycm9ycyk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJ1bGVzID0gcmV0LnJ1bGVzO1xuICAgIHRoaXMudWR0cyA9IHJldC51ZHRzO1xuICAgIGxpbmVNYXAgPSByZXQubGluZU1hcDtcblxuICAgIGF0dHJpYnV0ZUVycm9ycyA9IGF0dHJpYnV0ZXModGhpcy5ydWxlcywgdGhpcy51ZHRzLCBsaW5lTWFwLCB0aGlzLmVycm9ycyk7XG4gICAgaGF2ZUF0dHJpYnV0ZXMgPSB0cnVlO1xuICB9O1xuICAvLyBEaXNwbGF5IHRoZSBydWxlcy5cbiAgLy8gTXVzdCBzY2FuLCBwYXJzZSBhbmQgdHJhbnNsYXRlIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIG90aGVyd2lzZSB0aGVyZSBhcmUgbm8gcnVsZXMgdG8gZGlzcGxheS5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgdGhpcy5kaXNwbGF5UnVsZXMgPSBmdW5jdGlvbiBkaXNwbGF5UnVsZXMob3JkZXIgPSAnaW5kZXgnKSB7XG4gICAgaWYgKCFpc1RyYW5zbGF0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Z3JhbW1hciBub3Qgc2Nhbm5lZCwgcGFyc2VkIGFuZCB0cmFuc2xhdGVkYCk7XG4gICAgfVxuICAgIHJldHVybiBzaG93UnVsZXModGhpcy5ydWxlcywgdGhpcy51ZHRzLCBvcmRlcik7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzLlxuICAvLyBNdXN0IHNjYW4sIHBhcnNlLCB0cmFuc2xhdGUgYW5kIGNvbXB1dGUgYXR0cmlidXRlcyBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAvLyBPdGhlcndpc2UgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzIGFyZSBub3Qga25vd24uXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gXCJ0eXBlXCIgb3IgXCJ0XCIsIG9yZGVyZWQgYnkgdHlwZSAoYWxwaGFiZXRpY2FsIHdpdGhpbiBlYWNoIHR5cGUvZ3JvdXApXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgdGhpcy5kaXNwbGF5UnVsZURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIGRpc3BsYXlSdWxlRGVwZW5kZW5jaWVzKG9yZGVyID0gJ2luZGV4Jykge1xuICAgIGlmICghaGF2ZUF0dHJpYnV0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9bm8gYXR0cmlidXRlcyAtIG11c3QgYmUgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYXR0cmlidXRlcygpYCk7XG4gICAgfVxuICAgIHJldHVybiBzaG93UnVsZURlcGVuZGVuY2llcyhvcmRlcik7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIGF0dHJpYnV0ZXMuXG4gIC8vIE11c3Qgc2NhbiwgcGFyc2UsIHRyYW5zbGF0ZSBhbmQgY29tcHV0ZSBhdHRyaWJ1dGVzIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gXCJ0eXBlXCIgb3IgXCJ0XCIsIG9yZGVyZWQgYnkgdHlwZSAoYWxwaGFiZXRpY2FsIHdpdGhpbiBlYWNoIHR5cGUvZ3JvdXApXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCB0eXBlIG9yZGVyIChkZWZhdWx0KVxuICB0aGlzLmRpc3BsYXlBdHRyaWJ1dGVzID0gZnVuY3Rpb24gZGlzcGxheUF0dHJpYnV0ZXMob3JkZXIgPSAnaW5kZXgnKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ubyBhdHRyaWJ1dGVzIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZUVycm9ycykge1xuICAgICAgc2hvd0F0dHJpYnV0ZUVycm9ycyhvcmRlcik7XG4gICAgfVxuICAgIHJldHVybiBzaG93QXR0cmlidXRlcyhvcmRlcik7XG4gIH07XG4gIHRoaXMuZGlzcGxheUF0dHJpYnV0ZUVycm9ycyA9IGZ1bmN0aW9uIGRpc3BsYXlBdHRyaWJ1dGVFcnJvcnMoKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ubyBhdHRyaWJ1dGVzIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dBdHRyaWJ1dGVFcnJvcnMoKTtcbiAgfTtcbiAgLy8gUmV0dXJucyBhIHBhcnNlciBncmFtbWFyIG9iamVjdCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBhcyBhIEphdmFTY3JpcHQgc3RyaW5nLlxuICAvLyBUaGlzIG9iamVjdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIHBhcnNlci5cbiAgdGhpcy50b1NvdXJjZSA9IGZ1bmN0aW9uIHRvU291cmNlKGxpdGUsIG5hbWUpIHtcbiAgICBpZiAoIWhhdmVBdHRyaWJ1dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNhbid0IGdlbmVyYXRlIHBhcnNlciBzb3VyY2UgLSBtdXN0IGJlIHByZWNlZWRlZCBieSBjYWxsIHRvIGF0dHJpYnV0ZXMoKWApO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlRXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNhbid0IGdlbmVyYXRlIHBhcnNlciBzb3VyY2UgLSBhdHRyaWJ1dGVzIGhhdmUgJHthdHRyaWJ1dGVFcnJvcnN9IGVycm9yc2ApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdlbmVyYXRlU291cmNlKHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMucnVsZXMsIHRoaXMudWR0cywgbGl0ZSwgbmFtZSk7XG4gIH07XG4gIC8vIFJldHVybnMgYSBwYXJzZXIgZ3JhbW1hciBvYmplY3QuXG4gIC8vIFRoaXMgZ3JhbW1hciBvYmplY3QgbWF5IGJlIHVzZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnN0cnVjdCBhIHBhcnNlci5cbiAgdGhpcy50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgIGlmICghaGF2ZUF0dHJpYnV0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2FuJ3QgZ2VuZXJhdGUgcGFyc2VyIHNvdXJjZSAtIG11c3QgYmUgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYXR0cmlidXRlcygpYCk7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVFcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2FuJ3QgZ2VuZXJhdGUgcGFyc2VyIHNvdXJjZSAtIGF0dHJpYnV0ZXMgaGF2ZSAke2F0dHJpYnV0ZUVycm9yc30gZXJyb3JzYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIuZ2VuZXJhdGVPYmplY3QodGhpcy5zYWJuZiwgdGhpcy5ydWxlcywgdGhpcy51ZHRzKTtcbiAgfTtcbiAgLy8gRGlzcGxheSBlcnJvcnMgaW4gdGV4dCBmb3JtYXQsIHN1aXRhYmxlIGZvciBgY29uc29sZS5sb2coKWAuXG4gIHRoaXMuZXJyb3JzVG9Bc2NpaSA9IGZ1bmN0aW9uIGVycm9yc1RvQXNjaWlGdW5jKCkge1xuICAgIHJldHVybiBlcnJvcnNUb0FzY2lpKHRoaXMuZXJyb3JzLCB0aGlzLmxpbmVzLCB0aGlzLmNoYXJzKTtcbiAgfTtcbiAgLy8gRGlzcGxheSBlcnJvcnMgaW4gSFRNTCBmb3JtYXQsIHN1aXRhYmxlIGZvciB3ZWIgcGFnZSBkaXNwbGF5LlxuICAvLyAoYGFwZy1saWIuY3NzYCByZXF1aXJlZCBmb3IgcHJvcGVyIHN0eWxpbmcpXG4gIHRoaXMuZXJyb3JzVG9IdG1sID0gZnVuY3Rpb24gZXJyb3JzVG9IdG1sRnVuYyh0aXRsZSkge1xuICAgIHJldHVybiBlcnJvcnNUb0h0bWwodGhpcy5lcnJvcnMsIHRoaXMubGluZXMsIHRoaXMuY2hhcnMsIHRpdGxlKTtcbiAgfTtcbiAgLy8gR2VuZXJhdGUgYW4gYW5ub3RhdGVkIHRoZSBTQUJORiBncmFtbWFyIGRpc3BsYXkgaW4gdGV4dCBmb3JtYXQuXG4gIHRoaXMubGluZXNUb0FzY2lpID0gZnVuY3Rpb24gbGluZXNUb0FzY2lpRnVuYygpIHtcbiAgICByZXR1cm4gbGluZXNUb0FzY2lpKHRoaXMubGluZXMpO1xuICB9O1xuICAvLyBHZW5lcmF0ZSBhbiBhbm5vdGF0ZWQgdGhlIFNBQk5GIGdyYW1tYXIgZGlzcGxheSBpbiBIVE1MIGZvcm1hdC5cbiAgLy8gKGBhcGctbGliLmNzc2AgcmVxdWlyZWQgZm9yIHByb3BlciBzdHlsaW5nKVxuICB0aGlzLmxpbmVzVG9IdG1sID0gZnVuY3Rpb24gbGluZXNUb0h0bWxGdW5jKCkge1xuICAgIHJldHVybiBsaW5lc1RvSHRtbCh0aGlzLmxpbmVzKTtcbiAgfTtcbiAgLy8gVGhpcyBmdW5jdGlvbiB3YXMgb25seSB1c2VkIGJ5IGFwZy5odG1sIHdoaWNoIGhhcyBiZWVuIGFiYW5kb25lZC5cbiAgLypcbiAgICB0aGlzLmdldEF0dHJpYnV0ZXNPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgKi9cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/attributes.js":
/*!*******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/attributes.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable class-methods-use-this */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Attributes Validation\n//\n// It is well known that recursive-descent parsers will fail if a rule is left recursive.\n// Besides left recursion, there are a couple of other fatal attributes that need to be disclosed as well.\n// There are several non-fatal attributes that are of interest also.\n// This module will determine six different attributes listed here with simple examples.\n//\n// **fatal attributes**<br>\n// left recursion<br>\n// S = S \"x\" / \"y\"\n//\n// cyclic<br>\n// S = S\n//\n// infinite<br>\n// S = \"y\" S\n//\n// **non-fatal attributes** (but nice to know)<br>\n// nested recursion<br>\n// S = \"a\" S \"b\" / \"y\"\n//\n// right recursion<br>\n// S = \"x\" S / \"y\"\n//\n// empty string<br>\n// S = \"x\" S / \"\"\n//\n// Note that these are “aggregate” attributes, in that if the attribute is true it only means that it can be true,\n// not that it will always be true for every input string.\n// In the simple examples above the attributes may be obvious and definite – always true or false.\n// However, for a large grammar with possibly hundreds of rules and parse tree branches,\n// it can be obscure which branches lead to which attributes.\n// Furthermore, different input strings will lead the parser down different branches.\n// One input string may parse perfectly while another will hit a left-recursive branch and bottom out the call stack.\n//\n// It is for this reason that the APG parser generator computes these attributes.\n// When using the API the attributes call is optional but generating a parser without checking the attributes - proceed at your own peril.\n//\n// Additionally, the attribute phase will identify rule dependencies and mutually-recursive groups. For example,\n//\n// S = \"a\" A \"b\" / \"y\"<br>\n// A = \"x\"\n//\n// S is dependent on A but A is not dependent on S.\n//\n// S = \"a\" A \"b\" / \"c\"<br>\n// A = \"x\" S \"y\" / \"z\"\n//\n// S and A are dependent on one another and are mutually recursive.\nmodule.exports = (function exportAttributes() {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const { ruleAttributes, showAttributes, showAttributeErrors } = __webpack_require__(/*! ./rule-attributes */ \"(ssr)/./node_modules/apg-js/src/apg-api/rule-attributes.js\");\n  const { ruleDependencies, showRuleDependencies } = __webpack_require__(/*! ./rule-dependencies */ \"(ssr)/./node_modules/apg-js/src/apg-api/rule-dependencies.js\");\n  class State {\n    constructor(rules, udts) {\n      this.rules = rules;\n      this.udts = udts;\n      this.ruleCount = rules.length;\n      this.udtCount = udts.length;\n      this.startRule = 0;\n      this.dependenciesComplete = false;\n      this.attributesComplete = false;\n      this.isMutuallyRecursive = false;\n      this.ruleIndexes = this.indexArray(this.ruleCount);\n      this.ruleAlphaIndexes = this.indexArray(this.ruleCount);\n      this.ruleTypeIndexes = this.indexArray(this.ruleCount);\n      this.udtIndexes = this.indexArray(this.udtCount);\n      this.udtAlphaIndexes = this.indexArray(this.udtCount);\n      this.attrsErrorCount = 0;\n      this.attrs = [];\n      this.attrsErrors = [];\n      this.attrsWorking = [];\n      this.ruleDeps = [];\n      for (let i = 0; i < this.ruleCount; i += 1) {\n        this.attrs.push(this.attrGen(this.rules[i]));\n        this.attrsWorking.push(this.attrGen(this.rules[i]));\n        this.ruleDeps.push(this.rdGen(rules[i], this.ruleCount, this.udtCount));\n      }\n      this.compRulesAlpha = this.compRulesAlpha.bind(this);\n      this.compUdtsAlpha = this.compUdtsAlpha.bind(this);\n      this.compRulesType = this.compRulesType.bind(this);\n      this.compRulesGroup = this.compRulesGroup.bind(this);\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrGen(rule) {\n      return {\n        left: false,\n        nested: false,\n        right: false,\n        empty: false,\n        finite: false,\n        cyclic: false,\n        leaf: false,\n        isOpen: false,\n        isComplete: false,\n        rule,\n      };\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrInit(attr) {\n      attr.left = false;\n      attr.nested = false;\n      attr.right = false;\n      attr.empty = false;\n      attr.finite = false;\n      attr.cyclic = false;\n      attr.leaf = false;\n      attr.isOpen = false;\n      attr.isComplete = false;\n    }\n\n    attrCopy(dst, src) {\n      dst.left = src.left;\n      dst.nested = src.nested;\n      dst.right = src.right;\n      dst.empty = src.empty;\n      dst.finite = src.finite;\n      dst.cyclic = src.cyclic;\n      dst.leaf = src.leaf;\n      dst.isOpen = src.isOpen;\n      dst.isComplete = src.isComplete;\n      dst.rule = src.rule;\n    }\n\n    rdGen(rule, ruleCount, udtCount) {\n      const ret = {\n        rule,\n        recursiveType: id.ATTR_N,\n        groupNumber: -1,\n        refersTo: this.falseArray(ruleCount),\n        refersToUdt: this.falseArray(udtCount),\n        referencedBy: this.falseArray(ruleCount),\n      };\n      return ret;\n    }\n\n    typeToString(recursiveType) {\n      switch (recursiveType) {\n        case id.ATTR_N:\n          return ' N';\n        case id.ATTR_R:\n          return ' R';\n        case id.ATTR_MR:\n          return 'MR';\n        default:\n          return 'UNKNOWN';\n      }\n    }\n\n    falseArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(false);\n        }\n      }\n      return ret;\n    }\n\n    falsifyArray(a) {\n      for (let i = 0; i < a.length; i += 1) {\n        a[i] = false;\n      }\n    }\n\n    indexArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(i);\n        }\n      }\n      return ret;\n    }\n\n    compRulesAlpha(left, right) {\n      if (this.rules[left].lower < this.rules[right].lower) {\n        return -1;\n      }\n      if (this.rules[left].lower > this.rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compUdtsAlpha(left, right) {\n      if (this.udts[left].lower < this.udts[right].lower) {\n        return -1;\n      }\n      if (this.udts[left].lower > this.udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesType(left, right) {\n      if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {\n        return -1;\n      }\n      if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesGroup(left, right) {\n      if (this.ruleDeps[left].recursiveType === id.ATTR_MR && this.ruleDeps[right].recursiveType === id.ATTR_MR) {\n        if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {\n          return -1;\n        }\n        if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n  }\n  // eslint-disable-next-line no-unused-vars\n  const attributes = function attributes(rules = [], udts = [], lineMap = [], errors = []) {\n    // let i = 0;\n    // Initialize the state. The state of the computation get passed around to multiple functions in multiple files.\n    const state = new State(rules, udts);\n\n    // Determine all rule dependencies\n    //  - which rules each rule refers to\n    //  - which rules reference each rule\n    ruleDependencies(state);\n\n    // Determine the attributes for each rule.\n    ruleAttributes(state);\n    if (state.attrsErrorCount) {\n      errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });\n    }\n\n    // Return the number of attribute errors to the caller.\n    return state.attrsErrorCount;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2F0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0ZBQXdCO0FBQzdDLFVBQVUsc0RBQXNELEVBQUUsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDN0YsVUFBVSx5Q0FBeUMsRUFBRSxtQkFBTyxDQUFDLHlGQUFxQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQix1QkFBdUIsbUJBQW1CO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9hdHRyaWJ1dGVzLmpzPzU0YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gQXR0cmlidXRlcyBWYWxpZGF0aW9uXG4vL1xuLy8gSXQgaXMgd2VsbCBrbm93biB0aGF0IHJlY3Vyc2l2ZS1kZXNjZW50IHBhcnNlcnMgd2lsbCBmYWlsIGlmIGEgcnVsZSBpcyBsZWZ0IHJlY3Vyc2l2ZS5cbi8vIEJlc2lkZXMgbGVmdCByZWN1cnNpb24sIHRoZXJlIGFyZSBhIGNvdXBsZSBvZiBvdGhlciBmYXRhbCBhdHRyaWJ1dGVzIHRoYXQgbmVlZCB0byBiZSBkaXNjbG9zZWQgYXMgd2VsbC5cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIG5vbi1mYXRhbCBhdHRyaWJ1dGVzIHRoYXQgYXJlIG9mIGludGVyZXN0IGFsc28uXG4vLyBUaGlzIG1vZHVsZSB3aWxsIGRldGVybWluZSBzaXggZGlmZmVyZW50IGF0dHJpYnV0ZXMgbGlzdGVkIGhlcmUgd2l0aCBzaW1wbGUgZXhhbXBsZXMuXG4vL1xuLy8gKipmYXRhbCBhdHRyaWJ1dGVzKio8YnI+XG4vLyBsZWZ0IHJlY3Vyc2lvbjxicj5cbi8vIFMgPSBTIFwieFwiIC8gXCJ5XCJcbi8vXG4vLyBjeWNsaWM8YnI+XG4vLyBTID0gU1xuLy9cbi8vIGluZmluaXRlPGJyPlxuLy8gUyA9IFwieVwiIFNcbi8vXG4vLyAqKm5vbi1mYXRhbCBhdHRyaWJ1dGVzKiogKGJ1dCBuaWNlIHRvIGtub3cpPGJyPlxuLy8gbmVzdGVkIHJlY3Vyc2lvbjxicj5cbi8vIFMgPSBcImFcIiBTIFwiYlwiIC8gXCJ5XCJcbi8vXG4vLyByaWdodCByZWN1cnNpb248YnI+XG4vLyBTID0gXCJ4XCIgUyAvIFwieVwiXG4vL1xuLy8gZW1wdHkgc3RyaW5nPGJyPlxuLy8gUyA9IFwieFwiIFMgLyBcIlwiXG4vL1xuLy8gTm90ZSB0aGF0IHRoZXNlIGFyZSDigJxhZ2dyZWdhdGXigJ0gYXR0cmlidXRlcywgaW4gdGhhdCBpZiB0aGUgYXR0cmlidXRlIGlzIHRydWUgaXQgb25seSBtZWFucyB0aGF0IGl0IGNhbiBiZSB0cnVlLFxuLy8gbm90IHRoYXQgaXQgd2lsbCBhbHdheXMgYmUgdHJ1ZSBmb3IgZXZlcnkgaW5wdXQgc3RyaW5nLlxuLy8gSW4gdGhlIHNpbXBsZSBleGFtcGxlcyBhYm92ZSB0aGUgYXR0cmlidXRlcyBtYXkgYmUgb2J2aW91cyBhbmQgZGVmaW5pdGUg4oCTIGFsd2F5cyB0cnVlIG9yIGZhbHNlLlxuLy8gSG93ZXZlciwgZm9yIGEgbGFyZ2UgZ3JhbW1hciB3aXRoIHBvc3NpYmx5IGh1bmRyZWRzIG9mIHJ1bGVzIGFuZCBwYXJzZSB0cmVlIGJyYW5jaGVzLFxuLy8gaXQgY2FuIGJlIG9ic2N1cmUgd2hpY2ggYnJhbmNoZXMgbGVhZCB0byB3aGljaCBhdHRyaWJ1dGVzLlxuLy8gRnVydGhlcm1vcmUsIGRpZmZlcmVudCBpbnB1dCBzdHJpbmdzIHdpbGwgbGVhZCB0aGUgcGFyc2VyIGRvd24gZGlmZmVyZW50IGJyYW5jaGVzLlxuLy8gT25lIGlucHV0IHN0cmluZyBtYXkgcGFyc2UgcGVyZmVjdGx5IHdoaWxlIGFub3RoZXIgd2lsbCBoaXQgYSBsZWZ0LXJlY3Vyc2l2ZSBicmFuY2ggYW5kIGJvdHRvbSBvdXQgdGhlIGNhbGwgc3RhY2suXG4vL1xuLy8gSXQgaXMgZm9yIHRoaXMgcmVhc29uIHRoYXQgdGhlIEFQRyBwYXJzZXIgZ2VuZXJhdG9yIGNvbXB1dGVzIHRoZXNlIGF0dHJpYnV0ZXMuXG4vLyBXaGVuIHVzaW5nIHRoZSBBUEkgdGhlIGF0dHJpYnV0ZXMgY2FsbCBpcyBvcHRpb25hbCBidXQgZ2VuZXJhdGluZyBhIHBhcnNlciB3aXRob3V0IGNoZWNraW5nIHRoZSBhdHRyaWJ1dGVzIC0gcHJvY2VlZCBhdCB5b3VyIG93biBwZXJpbC5cbi8vXG4vLyBBZGRpdGlvbmFsbHksIHRoZSBhdHRyaWJ1dGUgcGhhc2Ugd2lsbCBpZGVudGlmeSBydWxlIGRlcGVuZGVuY2llcyBhbmQgbXV0dWFsbHktcmVjdXJzaXZlIGdyb3Vwcy4gRm9yIGV4YW1wbGUsXG4vL1xuLy8gUyA9IFwiYVwiIEEgXCJiXCIgLyBcInlcIjxicj5cbi8vIEEgPSBcInhcIlxuLy9cbi8vIFMgaXMgZGVwZW5kZW50IG9uIEEgYnV0IEEgaXMgbm90IGRlcGVuZGVudCBvbiBTLlxuLy9cbi8vIFMgPSBcImFcIiBBIFwiYlwiIC8gXCJjXCI8YnI+XG4vLyBBID0gXCJ4XCIgUyBcInlcIiAvIFwielwiXG4vL1xuLy8gUyBhbmQgQSBhcmUgZGVwZW5kZW50IG9uIG9uZSBhbm90aGVyIGFuZCBhcmUgbXV0dWFsbHkgcmVjdXJzaXZlLlxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gZXhwb3J0QXR0cmlidXRlcygpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuLi9hcGctbGliL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHsgcnVsZUF0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlRXJyb3JzIH0gPSByZXF1aXJlKCcuL3J1bGUtYXR0cmlidXRlcycpO1xuICBjb25zdCB7IHJ1bGVEZXBlbmRlbmNpZXMsIHNob3dSdWxlRGVwZW5kZW5jaWVzIH0gPSByZXF1aXJlKCcuL3J1bGUtZGVwZW5kZW5jaWVzJyk7XG4gIGNsYXNzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihydWxlcywgdWR0cykge1xuICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgdGhpcy51ZHRzID0gdWR0cztcbiAgICAgIHRoaXMucnVsZUNvdW50ID0gcnVsZXMubGVuZ3RoO1xuICAgICAgdGhpcy51ZHRDb3VudCA9IHVkdHMubGVuZ3RoO1xuICAgICAgdGhpcy5zdGFydFJ1bGUgPSAwO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNNdXR1YWxseVJlY3Vyc2l2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5ydWxlSW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnJ1bGVDb3VudCk7XG4gICAgICB0aGlzLnJ1bGVBbHBoYUluZGV4ZXMgPSB0aGlzLmluZGV4QXJyYXkodGhpcy5ydWxlQ291bnQpO1xuICAgICAgdGhpcy5ydWxlVHlwZUluZGV4ZXMgPSB0aGlzLmluZGV4QXJyYXkodGhpcy5ydWxlQ291bnQpO1xuICAgICAgdGhpcy51ZHRJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMudWR0Q291bnQpO1xuICAgICAgdGhpcy51ZHRBbHBoYUluZGV4ZXMgPSB0aGlzLmluZGV4QXJyYXkodGhpcy51ZHRDb3VudCk7XG4gICAgICB0aGlzLmF0dHJzRXJyb3JDb3VudCA9IDA7XG4gICAgICB0aGlzLmF0dHJzID0gW107XG4gICAgICB0aGlzLmF0dHJzRXJyb3JzID0gW107XG4gICAgICB0aGlzLmF0dHJzV29ya2luZyA9IFtdO1xuICAgICAgdGhpcy5ydWxlRGVwcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuYXR0cnMucHVzaCh0aGlzLmF0dHJHZW4odGhpcy5ydWxlc1tpXSkpO1xuICAgICAgICB0aGlzLmF0dHJzV29ya2luZy5wdXNoKHRoaXMuYXR0ckdlbih0aGlzLnJ1bGVzW2ldKSk7XG4gICAgICAgIHRoaXMucnVsZURlcHMucHVzaCh0aGlzLnJkR2VuKHJ1bGVzW2ldLCB0aGlzLnJ1bGVDb3VudCwgdGhpcy51ZHRDb3VudCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wUnVsZXNBbHBoYSA9IHRoaXMuY29tcFJ1bGVzQWxwaGEuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY29tcFVkdHNBbHBoYSA9IHRoaXMuY29tcFVkdHNBbHBoYS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jb21wUnVsZXNUeXBlID0gdGhpcy5jb21wUnVsZXNUeXBlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNvbXBSdWxlc0dyb3VwID0gdGhpcy5jb21wUnVsZXNHcm91cC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgYXR0ckdlbihydWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgbmVzdGVkOiBmYWxzZSxcbiAgICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgICBlbXB0eTogZmFsc2UsXG4gICAgICAgIGZpbml0ZTogZmFsc2UsXG4gICAgICAgIGN5Y2xpYzogZmFsc2UsXG4gICAgICAgIGxlYWY6IGZhbHNlLFxuICAgICAgICBpc09wZW46IGZhbHNlLFxuICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgcnVsZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBhdHRySW5pdChhdHRyKSB7XG4gICAgICBhdHRyLmxlZnQgPSBmYWxzZTtcbiAgICAgIGF0dHIubmVzdGVkID0gZmFsc2U7XG4gICAgICBhdHRyLnJpZ2h0ID0gZmFsc2U7XG4gICAgICBhdHRyLmVtcHR5ID0gZmFsc2U7XG4gICAgICBhdHRyLmZpbml0ZSA9IGZhbHNlO1xuICAgICAgYXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICAgIGF0dHIubGVhZiA9IGZhbHNlO1xuICAgICAgYXR0ci5pc09wZW4gPSBmYWxzZTtcbiAgICAgIGF0dHIuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGF0dHJDb3B5KGRzdCwgc3JjKSB7XG4gICAgICBkc3QubGVmdCA9IHNyYy5sZWZ0O1xuICAgICAgZHN0Lm5lc3RlZCA9IHNyYy5uZXN0ZWQ7XG4gICAgICBkc3QucmlnaHQgPSBzcmMucmlnaHQ7XG4gICAgICBkc3QuZW1wdHkgPSBzcmMuZW1wdHk7XG4gICAgICBkc3QuZmluaXRlID0gc3JjLmZpbml0ZTtcbiAgICAgIGRzdC5jeWNsaWMgPSBzcmMuY3ljbGljO1xuICAgICAgZHN0LmxlYWYgPSBzcmMubGVhZjtcbiAgICAgIGRzdC5pc09wZW4gPSBzcmMuaXNPcGVuO1xuICAgICAgZHN0LmlzQ29tcGxldGUgPSBzcmMuaXNDb21wbGV0ZTtcbiAgICAgIGRzdC5ydWxlID0gc3JjLnJ1bGU7XG4gICAgfVxuXG4gICAgcmRHZW4ocnVsZSwgcnVsZUNvdW50LCB1ZHRDb3VudCkge1xuICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICBydWxlLFxuICAgICAgICByZWN1cnNpdmVUeXBlOiBpZC5BVFRSX04sXG4gICAgICAgIGdyb3VwTnVtYmVyOiAtMSxcbiAgICAgICAgcmVmZXJzVG86IHRoaXMuZmFsc2VBcnJheShydWxlQ291bnQpLFxuICAgICAgICByZWZlcnNUb1VkdDogdGhpcy5mYWxzZUFycmF5KHVkdENvdW50KSxcbiAgICAgICAgcmVmZXJlbmNlZEJ5OiB0aGlzLmZhbHNlQXJyYXkocnVsZUNvdW50KSxcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHR5cGVUb1N0cmluZyhyZWN1cnNpdmVUeXBlKSB7XG4gICAgICBzd2l0Y2ggKHJlY3Vyc2l2ZVR5cGUpIHtcbiAgICAgICAgY2FzZSBpZC5BVFRSX046XG4gICAgICAgICAgcmV0dXJuICcgTic7XG4gICAgICAgIGNhc2UgaWQuQVRUUl9SOlxuICAgICAgICAgIHJldHVybiAnIFInO1xuICAgICAgICBjYXNlIGlkLkFUVFJfTVI6XG4gICAgICAgICAgcmV0dXJuICdNUic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICdVTktOT1dOJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmYWxzZUFycmF5KGxlbmd0aCkge1xuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgcmV0LnB1c2goZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZhbHNpZnlBcnJheShhKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYVtpXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4QXJyYXkobGVuZ3RoKSB7XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICByZXQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjb21wUnVsZXNBbHBoYShsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHRoaXMucnVsZXNbbGVmdF0ubG93ZXIgPCB0aGlzLnJ1bGVzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ydWxlc1tsZWZ0XS5sb3dlciA+IHRoaXMucnVsZXNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29tcFVkdHNBbHBoYShsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHRoaXMudWR0c1tsZWZ0XS5sb3dlciA8IHRoaXMudWR0c1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudWR0c1tsZWZ0XS5sb3dlciA+IHRoaXMudWR0c1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb21wUnVsZXNUeXBlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5ydWxlRGVwc1tsZWZ0XS5yZWN1cnNpdmVUeXBlIDwgdGhpcy5ydWxlRGVwc1tyaWdodF0ucmVjdXJzaXZlVHlwZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ydWxlRGVwc1tsZWZ0XS5yZWN1cnNpdmVUeXBlID4gdGhpcy5ydWxlRGVwc1tyaWdodF0ucmVjdXJzaXZlVHlwZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbXBSdWxlc0dyb3VwKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5ydWxlRGVwc1tsZWZ0XS5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX01SICYmIHRoaXMucnVsZURlcHNbcmlnaHRdLnJlY3Vyc2l2ZVR5cGUgPT09IGlkLkFUVFJfTVIpIHtcbiAgICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0uZ3JvdXBOdW1iZXIgPCB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5ncm91cE51bWJlcikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydWxlRGVwc1tsZWZ0XS5ncm91cE51bWJlciA+IHRoaXMucnVsZURlcHNbcmlnaHRdLmdyb3VwTnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgYXR0cmlidXRlcyA9IGZ1bmN0aW9uIGF0dHJpYnV0ZXMocnVsZXMgPSBbXSwgdWR0cyA9IFtdLCBsaW5lTWFwID0gW10sIGVycm9ycyA9IFtdKSB7XG4gICAgLy8gbGV0IGkgPSAwO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlLiBUaGUgc3RhdGUgb2YgdGhlIGNvbXB1dGF0aW9uIGdldCBwYXNzZWQgYXJvdW5kIHRvIG11bHRpcGxlIGZ1bmN0aW9ucyBpbiBtdWx0aXBsZSBmaWxlcy5cbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBTdGF0ZShydWxlcywgdWR0cyk7XG5cbiAgICAvLyBEZXRlcm1pbmUgYWxsIHJ1bGUgZGVwZW5kZW5jaWVzXG4gICAgLy8gIC0gd2hpY2ggcnVsZXMgZWFjaCBydWxlIHJlZmVycyB0b1xuICAgIC8vICAtIHdoaWNoIHJ1bGVzIHJlZmVyZW5jZSBlYWNoIHJ1bGVcbiAgICBydWxlRGVwZW5kZW5jaWVzKHN0YXRlKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgYXR0cmlidXRlcyBmb3IgZWFjaCBydWxlLlxuICAgIHJ1bGVBdHRyaWJ1dGVzKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuYXR0cnNFcnJvckNvdW50KSB7XG4gICAgICBlcnJvcnMucHVzaCh7IGxpbmU6IDAsIGNoYXI6IDAsIG1zZzogYCR7c3RhdGUuYXR0cnNFcnJvckNvdW50fSBhdHRyaWJ1dGUgZXJyb3JzYCB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBhdHRyaWJ1dGUgZXJyb3JzIHRvIHRoZSBjYWxsZXIuXG4gICAgcmV0dXJuIHN0YXRlLmF0dHJzRXJyb3JDb3VudDtcbiAgfTtcblxuICAvKiBEZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgLSBzZWUgTUROIFdlYiBEb2NzICovXG4gIHJldHVybiB7IGF0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlRXJyb3JzLCBzaG93UnVsZURlcGVuZGVuY2llcyB9O1xufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/attributes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/parser.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module converts an input SABNF grammar text file into a\n// grammar object that can be used with `apg-lib` in an application parser.\n// **apg** is, in fact itself, an ABNF parser that generates an SABNF parser.\n// It is based on the grammar<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`.<br>\n// In its syntax phase, **apg** analyzes the user's input SABNF grammar for correct syntax, generating an AST as it goes.\n// In its semantic phase, **apg** translates the AST to generate the parser for the input grammar.\nmodule.exports = function exportParser() {\n  const thisFileName = 'parser: ';\n  const ApgLib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = ApgLib.ids;\n  const syn = new (__webpack_require__(/*! ./syntax-callbacks */ \"(ssr)/./node_modules/apg-js/src/apg-api/syntax-callbacks.js\"))();\n  const sem = new (__webpack_require__(/*! ./semantic-callbacks */ \"(ssr)/./node_modules/apg-js/src/apg-api/semantic-callbacks.js\"))();\n  const sabnfGrammar = new (__webpack_require__(/*! ./sabnf-grammar */ \"(ssr)/./node_modules/apg-js/src/apg-api/sabnf-grammar.js\"))();\n  // eslint-disable-next-line new-cap\n  const parser = new ApgLib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new ApgLib.ast();\n  parser.callbacks = syn.callbacks;\n  parser.ast.callbacks = sem.callbacks;\n\n  /* find the line containing the given character index */\n  const findLine = function findLine(lines, charIndex, charLength) {\n    if (charIndex < 0 || charIndex >= charLength) {\n      /* return error if out of range */\n      return -1;\n    }\n    for (let i = 0; i < lines.length; i += 1) {\n      if (charIndex >= lines[i].beginChar && charIndex < lines[i].beginChar + lines[i].length) {\n        return i;\n      }\n    }\n    /* should never reach here */\n    return -1;\n  };\n  const translateIndex = function translateIndex(map, index) {\n    let ret = -1;\n    if (index < map.length) {\n      for (let i = index; i < map.length; i += 1) {\n        if (map[i] !== null) {\n          ret = map[i];\n          break;\n        }\n      }\n    }\n    return ret;\n  };\n  /* helper function when removing redundant opcodes */\n  const reduceOpcodes = function reduceOpcodes(rules) {\n    rules.forEach((rule) => {\n      const opcodes = [];\n      const map = [];\n      let reducedIndex = 0;\n      rule.opcodes.forEach((op) => {\n        if (op.type === id.ALT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.CAT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.REP && op.min === 1 && op.max === 1) {\n          map.push(null);\n        } else {\n          map.push(reducedIndex);\n          opcodes.push(op);\n          reducedIndex += 1;\n        }\n      });\n      map.push(reducedIndex);\n      /* translate original opcode indexes to the reduced set. */\n      opcodes.forEach((op) => {\n        if (op.type === id.ALT || op.type === id.CAT) {\n          for (let i = 0; i < op.children.length; i += 1) {\n            op.children[i] = translateIndex(map, op.children[i]);\n          }\n        }\n      });\n      rule.opcodes = opcodes;\n    });\n  };\n  /* Parse the grammar - the syntax phase. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.syntax = function syntax(chars, lines, errors, strict, lite, trace) {\n    if (trace) {\n      if (trace.traceObject !== 'traceObject') {\n        throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n      }\n      parser.trace = trace;\n    }\n    const data = {};\n    data.errors = errors;\n    data.strict = !!strict;\n    data.lite = !!lite;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    data.ruleCount = 0;\n    const result = parser.parse(sabnfGrammar, 'file', chars, data);\n    if (!result.success) {\n      errors.push({\n        line: 0,\n        char: 0,\n        msg: 'syntax analysis of input grammar failed',\n      });\n    }\n  };\n  /* Parse the grammar - the semantic phase, translates the AST. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.semantic = function semantic(chars, lines, errors) {\n    const data = {};\n    data.errors = errors;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    parser.ast.translate(data);\n    if (errors.length) {\n      return null;\n    }\n    /* Remove unneeded operators. */\n    /* ALT operators with a single alternate */\n    /* CAT operators with a single phrase to concatenate */\n    /* REP(1,1) operators (`1*1RuleName` or `1RuleName` is the same as just `RuleName`.) */\n    reduceOpcodes(data.rules);\n    return {\n      rules: data.rules,\n      udts: data.udts,\n      lineMap: data.rulesLineMap,\n    };\n  };\n  // Generate a grammar constructor function.\n  // An object instantiated from this constructor is used with the `apg-lib` `parser()` function.\n  this.generateSource = function generateSource(chars, lines, rules, udts, lite, name) {\n    let source = '';\n    let i;\n    let bkrname;\n    let bkrlower;\n    let opcodeCount = 0;\n    let charCodeMin = Infinity;\n    let charCodeMax = 0;\n    const ruleNames = [];\n    const udtNames = [];\n    let alt = 0;\n    let cat = 0;\n    let rnm = 0;\n    let udt = 0;\n    let rep = 0;\n    let and = 0;\n    let not = 0;\n    let tls = 0;\n    let tbs = 0;\n    let trg = 0;\n    let bkr = 0;\n    let bka = 0;\n    let bkn = 0;\n    let abg = 0;\n    let aen = 0;\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n      opcodeCount += rule.opcodes.length;\n      rule.opcodes.forEach((op) => {\n        switch (op.type) {\n          case id.ALT:\n            alt += 1;\n            break;\n          case id.CAT:\n            cat += 1;\n            break;\n          case id.RNM:\n            rnm += 1;\n            break;\n          case id.UDT:\n            udt += 1;\n            break;\n          case id.REP:\n            rep += 1;\n            break;\n          case id.AND:\n            and += 1;\n            break;\n          case id.NOT:\n            not += 1;\n            break;\n          case id.BKA:\n            bka += 1;\n            break;\n          case id.BKN:\n            bkn += 1;\n            break;\n          case id.BKR:\n            bkr += 1;\n            break;\n          case id.ABG:\n            abg += 1;\n            break;\n          case id.AEN:\n            aen += 1;\n            break;\n          case id.TLS:\n            tls += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TBS:\n            tbs += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TRG:\n            trg += 1;\n            if (op.min < charCodeMin) {\n              charCodeMin = op.min;\n            }\n            if (op.max > charCodeMax) {\n              charCodeMax = op.max;\n            }\n            break;\n          default:\n            throw new Error('generateSource: unrecognized opcode');\n        }\n      });\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    source += '// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\\n';\n    source += '//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\\n';\n    source += '//\\n';\n    source += '// Generated by apg-js, Version 4.3.0 [apg-js](https://github.com/ldthomas/apg-js)\\n';\n    if (name && typeof name === 'string') {\n      source += `const ${name} = function grammar(){\\n`;\n    } else if (lite) {\n      source += 'export default function grammar(){\\n';\n    } else {\n      source += `module.exports = function grammar(){\\n`;\n    }\n    source += '  // ```\\n';\n    source += '  // SUMMARY\\n';\n    source += `  //      rules = ${rules.length}\\n`;\n    source += `  //       udts = ${udts.length}\\n`;\n    source += `  //    opcodes = ${opcodeCount}\\n`;\n    source += '  //        ---   ABNF original opcodes\\n';\n    source += `  //        ALT = ${alt}\\n`;\n    source += `  //        CAT = ${cat}\\n`;\n    source += `  //        REP = ${rep}\\n`;\n    source += `  //        RNM = ${rnm}\\n`;\n    source += `  //        TLS = ${tls}\\n`;\n    source += `  //        TBS = ${tbs}\\n`;\n    source += `  //        TRG = ${trg}\\n`;\n    source += '  //        ---   SABNF superset opcodes\\n';\n    source += `  //        UDT = ${udt}\\n`;\n    source += `  //        AND = ${and}\\n`;\n    source += `  //        NOT = ${not}\\n`;\n    if (!lite) {\n      source += `  //        BKA = ${bka}\\n`;\n      source += `  //        BKN = ${bkn}\\n`;\n      source += `  //        BKR = ${bkr}\\n`;\n      source += `  //        ABG = ${abg}\\n`;\n      source += `  //        AEN = ${aen}\\n`;\n    }\n    source += '  // characters = [';\n    if (tls + tbs + trg === 0) {\n      source += ' none defined ]';\n    } else {\n      source += `${charCodeMin} - ${charCodeMax}]`;\n    }\n    if (udt > 0) {\n      source += ' + user defined';\n    }\n    source += '\\n';\n    source += '  // ```\\n';\n    if (!lite) {\n      source += '  /* OBJECT IDENTIFIER (for internal parser use) */\\n';\n      source += \"  this.grammarObject = 'grammarObject';\\n\";\n    }\n    source += '\\n';\n    source += '  /* RULES */\\n';\n    source += '  this.rules = [];\\n';\n    rules.forEach((rule, ii) => {\n      let thisRule = '  this.rules[';\n      thisRule += ii;\n      thisRule += \"] = {name: '\";\n      thisRule += rule.name;\n      thisRule += \"', lower: '\";\n      thisRule += rule.lower;\n      thisRule += \"', index: \";\n      thisRule += rule.index;\n      thisRule += ', isBkr: ';\n      thisRule += rule.isBkr;\n      thisRule += '};\\n';\n      source += thisRule;\n    });\n    source += '\\n';\n    source += '  /* UDTS */\\n';\n    source += '  this.udts = [];\\n';\n    if (udts.length > 0) {\n      udts.forEach((udtFunc, ii) => {\n        let thisUdt = '  this.udts[';\n        thisUdt += ii;\n        thisUdt += \"] = {name: '\";\n        thisUdt += udtFunc.name;\n        thisUdt += \"', lower: '\";\n        thisUdt += udtFunc.lower;\n        thisUdt += \"', index: \";\n        thisUdt += udtFunc.index;\n        thisUdt += ', empty: ';\n        thisUdt += udtFunc.empty;\n        thisUdt += ', isBkr: ';\n        thisUdt += udtFunc.isBkr;\n        thisUdt += '};\\n';\n        source += thisUdt;\n      });\n    }\n    source += '\\n';\n    source += '  /* OPCODES */\\n';\n    rules.forEach((rule, ruleIndex) => {\n      if (ruleIndex > 0) {\n        source += '\\n';\n      }\n      source += `  /* ${rule.name} */\\n`;\n      source += `  this.rules[${ruleIndex}].opcodes = [];\\n`;\n      rule.opcodes.forEach((op, opIndex) => {\n        let prefix;\n        switch (op.type) {\n          case id.ALT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, children: [${op.children.toString()}]};// ALT\\n`;\n            break;\n          case id.CAT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, children: [${op.children.toString()}]};// CAT\\n`;\n            break;\n          case id.RNM:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}};// RNM(${\n              rules[op.index].name\n            })\\n`;\n            break;\n          case id.BKR:\n            if (op.index >= rules.length) {\n              bkrname = udts[op.index - rules.length].name;\n              bkrlower = udts[op.index - rules.length].lower;\n            } else {\n              bkrname = rules[op.index].name;\n              bkrlower = rules[op.index].lower;\n            }\n            prefix = '%i';\n            if (op.bkrCase === id.BKR_MODE_CS) {\n              prefix = '%s';\n            }\n            if (op.bkrMode === id.BKR_MODE_UM) {\n              prefix += '%u';\n            } else {\n              prefix += '%p';\n            }\n            bkrname = prefix + bkrname;\n            source +=\n              `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}, lower: '${bkrlower}'` +\n              `, bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode}};// BKR(\\\\${bkrname})\\n`;\n            break;\n          case id.UDT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, empty: ${op.empty}, index: ${\n              op.index\n            }};// UDT(${udts[op.index].name})\\n`;\n            break;\n          case id.REP:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// REP\\n`;\n            break;\n          case id.AND:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AND\\n`;\n            break;\n          case id.NOT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// NOT\\n`;\n            break;\n          case id.ABG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// ABG(%^)\\n`;\n            break;\n          case id.AEN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AEN(%$)\\n`;\n            break;\n          case id.BKA:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKA\\n`;\n            break;\n          case id.BKN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKN\\n`;\n            break;\n          case id.TLS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, string: [${op.string.toString()}]};// TLS\\n`;\n            break;\n          case id.TBS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, string: [${op.string.toString()}]};// TBS\\n`;\n            break;\n          case id.TRG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// TRG\\n`;\n            break;\n          default:\n            throw new Error('parser.js: ~143: unrecognized opcode');\n        }\n      });\n    });\n    source += '\\n';\n    source += '  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\\n';\n    source += '  this.toString = function toString(){\\n';\n    source += '    let str = \"\";\\n';\n    let str;\n    lines.forEach((line) => {\n      const end = line.beginChar + line.length;\n      str = '';\n      source += '    str += \"';\n      for (let ii = line.beginChar; ii < end; ii += 1) {\n        switch (chars[ii]) {\n          case 9:\n            str = ' ';\n            break;\n          case 10:\n            str = '\\\\n';\n            break;\n          case 13:\n            str = '\\\\r';\n            break;\n          case 34:\n            str = '\\\\\"';\n            break;\n          case 92:\n            str = '\\\\\\\\';\n            break;\n          default:\n            str = String.fromCharCode(chars[ii]);\n            break;\n        }\n        source += str;\n      }\n      source += '\";\\n';\n    });\n    source += '    return str;\\n';\n    source += '  }\\n';\n    source += '}\\n';\n    return source;\n  };\n  // Generate a grammar file object.\n  // Returns the same object as instantiating the constructor function returned by<br>\n  // `this.generateSource()`.<br>\n  this.generateObject = function generateObject(stringArg, rules, udts) {\n    const obj = {};\n    const ruleNames = [];\n    const udtNames = [];\n    const string = stringArg.slice(0);\n    obj.grammarObject = 'grammarObject';\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    obj.callbacks = [];\n    ruleNames.forEach((name) => {\n      obj.callbacks[name] = false;\n    });\n    if (udts.length > 0) {\n      udtNames.forEach((name) => {\n        obj.callbacks[name] = false;\n      });\n    }\n    obj.rules = rules;\n    obj.udts = udts;\n    obj.toString = function toStringFunc() {\n      return string;\n    };\n    return obj;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNsRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBc0I7QUFDakQsNEJBQTRCLG1CQUFPLENBQUMsaUZBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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T0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvcGFyc2VyLmpzPzJmZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgY29udmVydHMgYW4gaW5wdXQgU0FCTkYgZ3JhbW1hciB0ZXh0IGZpbGUgaW50byBhXG4vLyBncmFtbWFyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYGFwZy1saWJgIGluIGFuIGFwcGxpY2F0aW9uIHBhcnNlci5cbi8vICoqYXBnKiogaXMsIGluIGZhY3QgaXRzZWxmLCBhbiBBQk5GIHBhcnNlciB0aGF0IGdlbmVyYXRlcyBhbiBTQUJORiBwYXJzZXIuXG4vLyBJdCBpcyBiYXNlZCBvbiB0aGUgZ3JhbW1hcjxicj5cbi8vIGAuL2Rpc3QvYWJuZi1mb3Itc2FibmYtZ3JhbW1hci5ibmZgLjxicj5cbi8vIEluIGl0cyBzeW50YXggcGhhc2UsICoqYXBnKiogYW5hbHl6ZXMgdGhlIHVzZXIncyBpbnB1dCBTQUJORiBncmFtbWFyIGZvciBjb3JyZWN0IHN5bnRheCwgZ2VuZXJhdGluZyBhbiBBU1QgYXMgaXQgZ29lcy5cbi8vIEluIGl0cyBzZW1hbnRpYyBwaGFzZSwgKiphcGcqKiB0cmFuc2xhdGVzIHRoZSBBU1QgdG8gZ2VuZXJhdGUgdGhlIHBhcnNlciBmb3IgdGhlIGlucHV0IGdyYW1tYXIuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cG9ydFBhcnNlcigpIHtcbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3BhcnNlcjogJztcbiAgY29uc3QgQXBnTGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgaWQgPSBBcGdMaWIuaWRzO1xuICBjb25zdCBzeW4gPSBuZXcgKHJlcXVpcmUoJy4vc3ludGF4LWNhbGxiYWNrcycpKSgpO1xuICBjb25zdCBzZW0gPSBuZXcgKHJlcXVpcmUoJy4vc2VtYW50aWMtY2FsbGJhY2tzJykpKCk7XG4gIGNvbnN0IHNhYm5mR3JhbW1hciA9IG5ldyAocmVxdWlyZSgnLi9zYWJuZi1ncmFtbWFyJykpKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gIGNvbnN0IHBhcnNlciA9IG5ldyBBcGdMaWIucGFyc2VyKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gIHBhcnNlci5hc3QgPSBuZXcgQXBnTGliLmFzdCgpO1xuICBwYXJzZXIuY2FsbGJhY2tzID0gc3luLmNhbGxiYWNrcztcbiAgcGFyc2VyLmFzdC5jYWxsYmFja3MgPSBzZW0uY2FsbGJhY2tzO1xuXG4gIC8qIGZpbmQgdGhlIGxpbmUgY29udGFpbmluZyB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGluZGV4ICovXG4gIGNvbnN0IGZpbmRMaW5lID0gZnVuY3Rpb24gZmluZExpbmUobGluZXMsIGNoYXJJbmRleCwgY2hhckxlbmd0aCkge1xuICAgIGlmIChjaGFySW5kZXggPCAwIHx8IGNoYXJJbmRleCA+PSBjaGFyTGVuZ3RoKSB7XG4gICAgICAvKiByZXR1cm4gZXJyb3IgaWYgb3V0IG9mIHJhbmdlICovXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChjaGFySW5kZXggPj0gbGluZXNbaV0uYmVnaW5DaGFyICYmIGNoYXJJbmRleCA8IGxpbmVzW2ldLmJlZ2luQ2hhciArIGxpbmVzW2ldLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUgKi9cbiAgICByZXR1cm4gLTE7XG4gIH07XG4gIGNvbnN0IHRyYW5zbGF0ZUluZGV4ID0gZnVuY3Rpb24gdHJhbnNsYXRlSW5kZXgobWFwLCBpbmRleCkge1xuICAgIGxldCByZXQgPSAtMTtcbiAgICBpZiAoaW5kZXggPCBtYXAubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCBtYXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG1hcFtpXSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldCA9IG1hcFtpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICAvKiBoZWxwZXIgZnVuY3Rpb24gd2hlbiByZW1vdmluZyByZWR1bmRhbnQgb3Bjb2RlcyAqL1xuICBjb25zdCByZWR1Y2VPcGNvZGVzID0gZnVuY3Rpb24gcmVkdWNlT3Bjb2RlcyhydWxlcykge1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgIGNvbnN0IG9wY29kZXMgPSBbXTtcbiAgICAgIGNvbnN0IG1hcCA9IFtdO1xuICAgICAgbGV0IHJlZHVjZWRJbmRleCA9IDA7XG4gICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09IGlkLkFMVCAmJiBvcC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBtYXAucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcC50eXBlID09PSBpZC5DQVQgJiYgb3AuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbWFwLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gaWQuUkVQICYmIG9wLm1pbiA9PT0gMSAmJiBvcC5tYXggPT09IDEpIHtcbiAgICAgICAgICBtYXAucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXAucHVzaChyZWR1Y2VkSW5kZXgpO1xuICAgICAgICAgIG9wY29kZXMucHVzaChvcCk7XG4gICAgICAgICAgcmVkdWNlZEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbWFwLnB1c2gocmVkdWNlZEluZGV4KTtcbiAgICAgIC8qIHRyYW5zbGF0ZSBvcmlnaW5hbCBvcGNvZGUgaW5kZXhlcyB0byB0aGUgcmVkdWNlZCBzZXQuICovXG4gICAgICBvcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIGlmIChvcC50eXBlID09PSBpZC5BTFQgfHwgb3AudHlwZSA9PT0gaWQuQ0FUKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgb3AuY2hpbGRyZW5baV0gPSB0cmFuc2xhdGVJbmRleChtYXAsIG9wLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcnVsZS5vcGNvZGVzID0gb3Bjb2RlcztcbiAgICB9KTtcbiAgfTtcbiAgLyogUGFyc2UgdGhlIGdyYW1tYXIgLSB0aGUgc3ludGF4IHBoYXNlLiAqL1xuICAvKiBTQUJORiBncmFtbWFyIHN5bnRheCBlcnJvcnMgYXJlIGNhdWdodCBhbmQgcmVwb3J0ZWQgaGVyZS4gKi9cbiAgdGhpcy5zeW50YXggPSBmdW5jdGlvbiBzeW50YXgoY2hhcnMsIGxpbmVzLCBlcnJvcnMsIHN0cmljdCwgbGl0ZSwgdHJhY2UpIHtcbiAgICBpZiAodHJhY2UpIHtcbiAgICAgIGlmICh0cmFjZS50cmFjZU9iamVjdCAhPT0gJ3RyYWNlT2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3RoaXNGaWxlTmFtZX10cmFjZSBhcmd1bWVudCBpcyBub3QgYSB0cmFjZSBvYmplY3RgKTtcbiAgICAgIH1cbiAgICAgIHBhcnNlci50cmFjZSA9IHRyYWNlO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZGF0YS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgZGF0YS5zdHJpY3QgPSAhIXN0cmljdDtcbiAgICBkYXRhLmxpdGUgPSAhIWxpdGU7XG4gICAgZGF0YS5saW5lcyA9IGxpbmVzO1xuICAgIGRhdGEuZmluZExpbmUgPSBmaW5kTGluZTtcbiAgICBkYXRhLmNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgIGRhdGEucnVsZUNvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2Uoc2FibmZHcmFtbWFyLCAnZmlsZScsIGNoYXJzLCBkYXRhKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIGxpbmU6IDAsXG4gICAgICAgIGNoYXI6IDAsXG4gICAgICAgIG1zZzogJ3N5bnRheCBhbmFseXNpcyBvZiBpbnB1dCBncmFtbWFyIGZhaWxlZCcsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qIFBhcnNlIHRoZSBncmFtbWFyIC0gdGhlIHNlbWFudGljIHBoYXNlLCB0cmFuc2xhdGVzIHRoZSBBU1QuICovXG4gIC8qIFNBQk5GIGdyYW1tYXIgc3ludGF4IGVycm9ycyBhcmUgY2F1Z2h0IGFuZCByZXBvcnRlZCBoZXJlLiAqL1xuICB0aGlzLnNlbWFudGljID0gZnVuY3Rpb24gc2VtYW50aWMoY2hhcnMsIGxpbmVzLCBlcnJvcnMpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZGF0YS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgZGF0YS5saW5lcyA9IGxpbmVzO1xuICAgIGRhdGEuZmluZExpbmUgPSBmaW5kTGluZTtcbiAgICBkYXRhLmNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgIHBhcnNlci5hc3QudHJhbnNsYXRlKGRhdGEpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyogUmVtb3ZlIHVubmVlZGVkIG9wZXJhdG9ycy4gKi9cbiAgICAvKiBBTFQgb3BlcmF0b3JzIHdpdGggYSBzaW5nbGUgYWx0ZXJuYXRlICovXG4gICAgLyogQ0FUIG9wZXJhdG9ycyB3aXRoIGEgc2luZ2xlIHBocmFzZSB0byBjb25jYXRlbmF0ZSAqL1xuICAgIC8qIFJFUCgxLDEpIG9wZXJhdG9ycyAoYDEqMVJ1bGVOYW1lYCBvciBgMVJ1bGVOYW1lYCBpcyB0aGUgc2FtZSBhcyBqdXN0IGBSdWxlTmFtZWAuKSAqL1xuICAgIHJlZHVjZU9wY29kZXMoZGF0YS5ydWxlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bGVzOiBkYXRhLnJ1bGVzLFxuICAgICAgdWR0czogZGF0YS51ZHRzLFxuICAgICAgbGluZU1hcDogZGF0YS5ydWxlc0xpbmVNYXAsXG4gICAgfTtcbiAgfTtcbiAgLy8gR2VuZXJhdGUgYSBncmFtbWFyIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAvLyBBbiBvYmplY3QgaW5zdGFudGlhdGVkIGZyb20gdGhpcyBjb25zdHJ1Y3RvciBpcyB1c2VkIHdpdGggdGhlIGBhcGctbGliYCBgcGFyc2VyKClgIGZ1bmN0aW9uLlxuICB0aGlzLmdlbmVyYXRlU291cmNlID0gZnVuY3Rpb24gZ2VuZXJhdGVTb3VyY2UoY2hhcnMsIGxpbmVzLCBydWxlcywgdWR0cywgbGl0ZSwgbmFtZSkge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBsZXQgaTtcbiAgICBsZXQgYmtybmFtZTtcbiAgICBsZXQgYmtybG93ZXI7XG4gICAgbGV0IG9wY29kZUNvdW50ID0gMDtcbiAgICBsZXQgY2hhckNvZGVNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgY2hhckNvZGVNYXggPSAwO1xuICAgIGNvbnN0IHJ1bGVOYW1lcyA9IFtdO1xuICAgIGNvbnN0IHVkdE5hbWVzID0gW107XG4gICAgbGV0IGFsdCA9IDA7XG4gICAgbGV0IGNhdCA9IDA7XG4gICAgbGV0IHJubSA9IDA7XG4gICAgbGV0IHVkdCA9IDA7XG4gICAgbGV0IHJlcCA9IDA7XG4gICAgbGV0IGFuZCA9IDA7XG4gICAgbGV0IG5vdCA9IDA7XG4gICAgbGV0IHRscyA9IDA7XG4gICAgbGV0IHRicyA9IDA7XG4gICAgbGV0IHRyZyA9IDA7XG4gICAgbGV0IGJrciA9IDA7XG4gICAgbGV0IGJrYSA9IDA7XG4gICAgbGV0IGJrbiA9IDA7XG4gICAgbGV0IGFiZyA9IDA7XG4gICAgbGV0IGFlbiA9IDA7XG4gICAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgcnVsZU5hbWVzLnB1c2gocnVsZS5sb3dlcik7XG4gICAgICBvcGNvZGVDb3VudCArPSBydWxlLm9wY29kZXMubGVuZ3RoO1xuICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgICAgYWx0ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICAgIGNhdCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgICBybm0gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICAgICAgdWR0ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICAgIHJlcCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BTkQ6XG4gICAgICAgICAgICBhbmQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgICAgICAgbm90ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLQTpcbiAgICAgICAgICAgIGJrYSArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS046XG4gICAgICAgICAgICBia24gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgICAgYmtyICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFCRzpcbiAgICAgICAgICAgIGFiZyArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgICAgICBhZW4gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgICAgdGxzICs9IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3Auc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPCBjaGFyQ29kZU1pbikge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWluID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPiBjaGFyQ29kZU1heCkge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWF4ID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICAgIHRicyArPSAxO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wLnN0cmluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAob3Auc3RyaW5nW2ldIDwgY2hhckNvZGVNaW4pIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZU1pbiA9IG9wLnN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3Auc3RyaW5nW2ldID4gY2hhckNvZGVNYXgpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZU1heCA9IG9wLnN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgICB0cmcgKz0gMTtcbiAgICAgICAgICAgIGlmIChvcC5taW4gPCBjaGFyQ29kZU1pbikge1xuICAgICAgICAgICAgICBjaGFyQ29kZU1pbiA9IG9wLm1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcC5tYXggPiBjaGFyQ29kZU1heCkge1xuICAgICAgICAgICAgICBjaGFyQ29kZU1heCA9IG9wLm1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlU291cmNlOiB1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJ1bGVOYW1lcy5zb3J0KCk7XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgdWR0cy5mb3JFYWNoKCh1ZHRGdW5jKSA9PiB7XG4gICAgICAgIHVkdE5hbWVzLnB1c2godWR0RnVuYy5sb3dlcik7XG4gICAgICB9KTtcbiAgICAgIHVkdE5hbWVzLnNvcnQoKTtcbiAgICB9XG4gICAgc291cmNlICs9ICcvLyBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMyBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkPGJyPlxcbic7XG4gICAgc291cmNlICs9ICcvLyAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpPGJyPlxcbic7XG4gICAgc291cmNlICs9ICcvL1xcbic7XG4gICAgc291cmNlICs9ICcvLyBHZW5lcmF0ZWQgYnkgYXBnLWpzLCBWZXJzaW9uIDQuMy4wIFthcGctanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMpXFxuJztcbiAgICBpZiAobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZSArPSBgY29uc3QgJHtuYW1lfSA9IGZ1bmN0aW9uIGdyYW1tYXIoKXtcXG5gO1xuICAgIH0gZWxzZSBpZiAobGl0ZSkge1xuICAgICAgc291cmNlICs9ICdleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncmFtbWFyKCl7XFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlICs9IGBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdyYW1tYXIoKXtcXG5gO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJyAgLy8gYGBgXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLy8gU1VNTUFSWVxcbic7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgcnVsZXMgPSAke3J1bGVzLmxlbmd0aH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICB1ZHRzID0gJHt1ZHRzLmxlbmd0aH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICBvcGNvZGVzID0gJHtvcGNvZGVDb3VudH1cXG5gO1xuICAgIHNvdXJjZSArPSAnICAvLyAgICAgICAgLS0tICAgQUJORiBvcmlnaW5hbCBvcGNvZGVzXFxuJztcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIEFMVCA9ICR7YWx0fVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBDQVQgPSAke2NhdH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgUkVQID0gJHtyZXB9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFJOTSA9ICR7cm5tfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBUTFMgPSAke3Rsc31cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgVEJTID0gJHt0YnN9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFRSRyA9ICR7dHJnfVxcbmA7XG4gICAgc291cmNlICs9ICcgIC8vICAgICAgICAtLS0gICBTQUJORiBzdXBlcnNldCBvcGNvZGVzXFxuJztcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFVEVCA9ICR7dWR0fVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBBTkQgPSAke2FuZH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgTk9UID0gJHtub3R9XFxuYDtcbiAgICBpZiAoIWxpdGUpIHtcbiAgICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQktBID0gJHtia2F9XFxuYDtcbiAgICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQktOID0gJHtia259XFxuYDtcbiAgICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQktSID0gJHtia3J9XFxuYDtcbiAgICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQUJHID0gJHthYmd9XFxuYDtcbiAgICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQUVOID0gJHthZW59XFxuYDtcbiAgICB9XG4gICAgc291cmNlICs9ICcgIC8vIGNoYXJhY3RlcnMgPSBbJztcbiAgICBpZiAodGxzICsgdGJzICsgdHJnID09PSAwKSB7XG4gICAgICBzb3VyY2UgKz0gJyBub25lIGRlZmluZWQgXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSArPSBgJHtjaGFyQ29kZU1pbn0gLSAke2NoYXJDb2RlTWF4fV1gO1xuICAgIH1cbiAgICBpZiAodWR0ID4gMCkge1xuICAgICAgc291cmNlICs9ICcgKyB1c2VyIGRlZmluZWQnO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8vIGBgYFxcbic7XG4gICAgaWYgKCFsaXRlKSB7XG4gICAgICBzb3VyY2UgKz0gJyAgLyogT0JKRUNUIElERU5USUZJRVIgKGZvciBpbnRlcm5hbCBwYXJzZXIgdXNlKSAqL1xcbic7XG4gICAgICBzb3VyY2UgKz0gXCIgIHRoaXMuZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcXG5cIjtcbiAgICB9XG4gICAgc291cmNlICs9ICdcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvKiBSVUxFUyAqL1xcbic7XG4gICAgc291cmNlICs9ICcgIHRoaXMucnVsZXMgPSBbXTtcXG4nO1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUsIGlpKSA9PiB7XG4gICAgICBsZXQgdGhpc1J1bGUgPSAnICB0aGlzLnJ1bGVzWyc7XG4gICAgICB0aGlzUnVsZSArPSBpaTtcbiAgICAgIHRoaXNSdWxlICs9IFwiXSA9IHtuYW1lOiAnXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLm5hbWU7XG4gICAgICB0aGlzUnVsZSArPSBcIicsIGxvd2VyOiAnXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmxvd2VyO1xuICAgICAgdGhpc1J1bGUgKz0gXCInLCBpbmRleDogXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmluZGV4O1xuICAgICAgdGhpc1J1bGUgKz0gJywgaXNCa3I6ICc7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmlzQmtyO1xuICAgICAgdGhpc1J1bGUgKz0gJ307XFxuJztcbiAgICAgIHNvdXJjZSArPSB0aGlzUnVsZTtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8qIFVEVFMgKi9cXG4nO1xuICAgIHNvdXJjZSArPSAnICB0aGlzLnVkdHMgPSBbXTtcXG4nO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdHMuZm9yRWFjaCgodWR0RnVuYywgaWkpID0+IHtcbiAgICAgICAgbGV0IHRoaXNVZHQgPSAnICB0aGlzLnVkdHNbJztcbiAgICAgICAgdGhpc1VkdCArPSBpaTtcbiAgICAgICAgdGhpc1VkdCArPSBcIl0gPSB7bmFtZTogJ1wiO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMubmFtZTtcbiAgICAgICAgdGhpc1VkdCArPSBcIicsIGxvd2VyOiAnXCI7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5sb3dlcjtcbiAgICAgICAgdGhpc1VkdCArPSBcIicsIGluZGV4OiBcIjtcbiAgICAgICAgdGhpc1VkdCArPSB1ZHRGdW5jLmluZGV4O1xuICAgICAgICB0aGlzVWR0ICs9ICcsIGVtcHR5OiAnO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMuZW1wdHk7XG4gICAgICAgIHRoaXNVZHQgKz0gJywgaXNCa3I6ICc7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5pc0JrcjtcbiAgICAgICAgdGhpc1VkdCArPSAnfTtcXG4nO1xuICAgICAgICBzb3VyY2UgKz0gdGhpc1VkdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8qIE9QQ09ERVMgKi9cXG4nO1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUsIHJ1bGVJbmRleCkgPT4ge1xuICAgICAgaWYgKHJ1bGVJbmRleCA+IDApIHtcbiAgICAgICAgc291cmNlICs9ICdcXG4nO1xuICAgICAgfVxuICAgICAgc291cmNlICs9IGAgIC8qICR7cnVsZS5uYW1lfSAqL1xcbmA7XG4gICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXMgPSBbXTtcXG5gO1xuICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wLCBvcEluZGV4KSA9PiB7XG4gICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7XG4gICAgICAgICAgICAgIG9wLnR5cGVcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbJHtvcC5jaGlsZHJlbi50b1N0cmluZygpfV19Oy8vIEFMVFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke1xuICAgICAgICAgICAgICBvcC50eXBlXG4gICAgICAgICAgICB9LCBjaGlsZHJlbjogWyR7b3AuY2hpbGRyZW4udG9TdHJpbmcoKX1dfTsvLyBDQVRcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfSwgaW5kZXg6ICR7b3AuaW5kZXh9fTsvLyBSTk0oJHtcbiAgICAgICAgICAgICAgcnVsZXNbb3AuaW5kZXhdLm5hbWVcbiAgICAgICAgICAgIH0pXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgICAgaWYgKG9wLmluZGV4ID49IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBia3JuYW1lID0gdWR0c1tvcC5pbmRleCAtIHJ1bGVzLmxlbmd0aF0ubmFtZTtcbiAgICAgICAgICAgICAgYmtybG93ZXIgPSB1ZHRzW29wLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5sb3dlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJrcm5hbWUgPSBydWxlc1tvcC5pbmRleF0ubmFtZTtcbiAgICAgICAgICAgICAgYmtybG93ZXIgPSBydWxlc1tvcC5pbmRleF0ubG93ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmaXggPSAnJWknO1xuICAgICAgICAgICAgaWYgKG9wLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NTKSB7XG4gICAgICAgICAgICAgIHByZWZpeCA9ICclcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3AuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0pIHtcbiAgICAgICAgICAgICAgcHJlZml4ICs9ICcldSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmVmaXggKz0gJyVwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJrcm5hbWUgPSBwcmVmaXggKyBia3JuYW1lO1xuICAgICAgICAgICAgc291cmNlICs9XG4gICAgICAgICAgICAgIGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX0sIGluZGV4OiAke29wLmluZGV4fSwgbG93ZXI6ICcke2Jrcmxvd2VyfSdgICtcbiAgICAgICAgICAgICAgYCwgYmtyQ2FzZTogJHtvcC5ia3JDYXNlfSwgYmtyTW9kZTogJHtvcC5ia3JNb2RlfX07Ly8gQktSKFxcXFwke2Jrcm5hbWV9KVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9LCBlbXB0eTogJHtvcC5lbXB0eX0sIGluZGV4OiAke1xuICAgICAgICAgICAgICBvcC5pbmRleFxuICAgICAgICAgICAgfX07Ly8gVURUKCR7dWR0c1tvcC5pbmRleF0ubmFtZX0pXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX0sIG1pbjogJHtvcC5taW59LCBtYXg6ICR7b3AubWF4fX07Ly8gUkVQXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQU5EOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIEFORFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLk5PVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBOT1RcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BQkc6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfX07Ly8gQUJHKCVeKVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBBRU4oJSQpXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIEJLQVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBCS05cXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgc3RyaW5nOiBbJHtvcC5zdHJpbmcudG9TdHJpbmcoKX1dfTsvLyBUTFNcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgc3RyaW5nOiBbJHtvcC5zdHJpbmcudG9TdHJpbmcoKX1dfTsvLyBUQlNcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfSwgbWluOiAke29wLm1pbn0sIG1heDogJHtvcC5tYXh9fTsvLyBUUkdcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyc2VyLmpzOiB+MTQzOiB1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XFxuJztcbiAgICBzb3VyY2UgKz0gJyAgICBsZXQgc3RyID0gXCJcIjtcXG4nO1xuICAgIGxldCBzdHI7XG4gICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgY29uc3QgZW5kID0gbGluZS5iZWdpbkNoYXIgKyBsaW5lLmxlbmd0aDtcbiAgICAgIHN0ciA9ICcnO1xuICAgICAgc291cmNlICs9ICcgICAgc3RyICs9IFwiJztcbiAgICAgIGZvciAobGV0IGlpID0gbGluZS5iZWdpbkNoYXI7IGlpIDwgZW5kOyBpaSArPSAxKSB7XG4gICAgICAgIHN3aXRjaCAoY2hhcnNbaWldKSB7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgc3RyID0gJyAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHN0ciA9ICdcXFxcbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgc3RyID0gJ1xcXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBzdHIgPSAnXFxcXFwiJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgICBzdHIgPSAnXFxcXFxcXFwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcnNbaWldKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSArPSBzdHI7XG4gICAgICB9XG4gICAgICBzb3VyY2UgKz0gJ1wiO1xcbic7XG4gICAgfSk7XG4gICAgc291cmNlICs9ICcgICAgcmV0dXJuIHN0cjtcXG4nO1xuICAgIHNvdXJjZSArPSAnICB9XFxuJztcbiAgICBzb3VyY2UgKz0gJ31cXG4nO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH07XG4gIC8vIEdlbmVyYXRlIGEgZ3JhbW1hciBmaWxlIG9iamVjdC5cbiAgLy8gUmV0dXJucyB0aGUgc2FtZSBvYmplY3QgYXMgaW5zdGFudGlhdGluZyB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gcmV0dXJuZWQgYnk8YnI+XG4gIC8vIGB0aGlzLmdlbmVyYXRlU291cmNlKClgLjxicj5cbiAgdGhpcy5nZW5lcmF0ZU9iamVjdCA9IGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KHN0cmluZ0FyZywgcnVsZXMsIHVkdHMpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBbXTtcbiAgICBjb25zdCB1ZHROYW1lcyA9IFtdO1xuICAgIGNvbnN0IHN0cmluZyA9IHN0cmluZ0FyZy5zbGljZSgwKTtcbiAgICBvYmouZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcbiAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICBydWxlTmFtZXMucHVzaChydWxlLmxvd2VyKTtcbiAgICB9KTtcbiAgICBydWxlTmFtZXMuc29ydCgpO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdHMuZm9yRWFjaCgodWR0RnVuYykgPT4ge1xuICAgICAgICB1ZHROYW1lcy5wdXNoKHVkdEZ1bmMubG93ZXIpO1xuICAgICAgfSk7XG4gICAgICB1ZHROYW1lcy5zb3J0KCk7XG4gICAgfVxuICAgIG9iai5jYWxsYmFja3MgPSBbXTtcbiAgICBydWxlTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgb2JqLmNhbGxiYWNrc1tuYW1lXSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgb2JqLmNhbGxiYWNrc1tuYW1lXSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIG9iai5ydWxlcyA9IHJ1bGVzO1xuICAgIG9iai51ZHRzID0gdWR0cztcbiAgICBvYmoudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZ0Z1bmMoKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/rule-attributes.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/rule-attributes.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module does the heavy lifting for attribute generation.\nmodule.exports = (function exportRuleAttributes() {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const thisFile = 'rule-attributes.js';\n  let state = null;\n  function isEmptyOnly(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return false;\n    }\n    return attr.empty;\n  }\n  function isRecursive(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return true;\n    }\n    return false;\n  }\n  function isCatNested(attrs, count) {\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    /* 1. if any child is nested, CAT is nested */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].nested) {\n        return true;\n      }\n    }\n    /* 2.) the left-most right recursive child\n               is followed by at least one non-empty child */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].right && !attrs[i].leaf) {\n        for (j = i + 1; j < count; j += 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 3.) the right-most left recursive child\n               is preceded by at least one non-empty child */\n    for (i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].left && !attrs[i].leaf) {\n        for (j = i - 1; j >= 0; j -= 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 4. there is at lease one recursive child between\n              the left-most and right-most non-recursive, non-empty children */\n    for (i = 0; i < count; i += 1) {\n      if (!attrs[i].empty && !isRecursive(attrs[i])) {\n        for (j = i + 1; j < count; j += 1) {\n          if (isRecursive(attrs[j])) {\n            for (k = j + 1; k < count; k += 1) {\n              if (!attrs[k].empty && !isRecursive(attrs[k])) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /* none of the above */\n    return false;\n  }\n  function isCatCyclic(attrs, count) {\n    /* if all children are cyclic, CAT is cyclic */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].cyclic) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatLeft(attrs, count) {\n    /* if the left-most non-empty is left, CAT is left */\n    for (let i = 0; i < count; i += 1) {\n      if (attrs[i].left) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false; /* all left-most are empty */\n  }\n  function isCatRight(attrs, count) {\n    /* if the right-most non-empty is right, CAT is right */\n    for (let i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].right) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false;\n  }\n  function isCatEmpty(attrs, count) {\n    /* if all children are empty, CAT is empty */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].empty) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatFinite(attrs, count) {\n    /* if all children are finite, CAT is finite */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].finite) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function cat(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opCat = opcodes[opIndex];\n    const count = opCat.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opCat.children[i], childAttrs[i]);\n    }\n    iAttr.left = isCatLeft(childAttrs, count);\n    iAttr.right = isCatRight(childAttrs, count);\n    iAttr.nested = isCatNested(childAttrs, count);\n    iAttr.empty = isCatEmpty(childAttrs, count);\n    iAttr.finite = isCatFinite(childAttrs, count);\n    iAttr.cyclic = isCatCyclic(childAttrs, count);\n  }\n  function alt(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opAlt = opcodes[opIndex];\n    const count = opAlt.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opAlt.children[i], childAttrs[i]);\n    }\n\n    /* if any child attribute is true, ALT is true */\n    iAttr.left = false;\n    iAttr.right = false;\n    iAttr.nested = false;\n    iAttr.empty = false;\n    iAttr.finite = false;\n    iAttr.cyclic = false;\n    for (i = 0; i < count; i += 1) {\n      if (childAttrs[i].left) {\n        iAttr.left = true;\n      }\n      if (childAttrs[i].nested) {\n        iAttr.nested = true;\n      }\n      if (childAttrs[i].right) {\n        iAttr.right = true;\n      }\n      if (childAttrs[i].empty) {\n        iAttr.empty = true;\n      }\n      if (childAttrs[i].finite) {\n        iAttr.finite = true;\n      }\n      if (childAttrs[i].cyclic) {\n        iAttr.cyclic = true;\n      }\n    }\n  }\n  function bkr(stateArg, opcodes, opIndex, iAttr) {\n    const opBkr = opcodes[opIndex];\n    if (opBkr.index >= stateArg.ruleCount) {\n      /* use UDT values */\n      iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;\n      iAttr.finite = true;\n    } else {\n      /* use the empty and finite values from the back referenced rule */\n      // eslint-disable-next-line no-use-before-define\n      ruleAttrsEval(stateArg, opBkr.index, iAttr);\n\n      /* however, this is a terminal node like TLS */\n      iAttr.left = false;\n      iAttr.nested = false;\n      iAttr.right = false;\n      iAttr.cyclic = false;\n    }\n  }\n\n  function opEval(stateArg, opcodes, opIndex, iAttr) {\n    stateArg.attrInit(iAttr);\n    const opi = opcodes[opIndex];\n    switch (opi.type) {\n      case id.ALT:\n        alt(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.CAT:\n        cat(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.REP:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        if (opi.min === 0) {\n          iAttr.empty = true;\n          iAttr.finite = true;\n        }\n        break;\n      case id.RNM:\n        // eslint-disable-next-line no-use-before-define\n        ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);\n        break;\n      case id.BKR:\n        bkr(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.AND:\n      case id.NOT:\n      case id.BKA:\n      case id.BKN:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        iAttr.empty = true;\n        break;\n      case id.TLS:\n        iAttr.empty = !opcodes[opIndex].string.length;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.TBS:\n      case id.TRG:\n        iAttr.empty = false;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.UDT:\n        iAttr.empty = opi.empty;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.ABG:\n      case id.AEN:\n        iAttr.empty = true;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      default:\n        throw new Error(`unknown opcode type: ${opi}`);\n    }\n  }\n  // The main logic for handling rules that:\n  //  - have already be evaluated\n  //  - have not been evaluated and is the first occurrence on this branch\n  //  - second occurrence on this branch for the start rule\n  //  - second occurrence on this branch for non-start rules\n  function ruleAttrsEval(stateArg, ruleIndex, iAttr) {\n    const attri = stateArg.attrsWorking[ruleIndex];\n    if (attri.isComplete) {\n      /* just use the completed values */\n      stateArg.attrCopy(iAttr, attri);\n    } else if (!attri.isOpen) {\n      /* open the rule and traverse it */\n      attri.isOpen = true;\n      opEval(stateArg, attri.rule.opcodes, 0, iAttr);\n      /* complete this rule's attributes */\n      attri.left = iAttr.left;\n      attri.right = iAttr.right;\n      attri.nested = iAttr.nested;\n      attri.empty = iAttr.empty;\n      attri.finite = iAttr.finite;\n      attri.cyclic = iAttr.cyclic;\n      attri.leaf = false;\n      attri.isOpen = false;\n      attri.isComplete = true;\n    } else if (ruleIndex === stateArg.startRule) {\n      /* use recursive leaf values */\n      if (ruleIndex === stateArg.startRule) {\n        iAttr.left = true;\n        iAttr.right = true;\n        iAttr.cyclic = true;\n        iAttr.leaf = true;\n      }\n    } else {\n      /* non-start rule terminal leaf */\n      iAttr.finite = true;\n    }\n  }\n  // The main driver for the attribute generation.\n  const ruleAttributes = (stateArg) => {\n    state = stateArg;\n    let i = 0;\n    let j = 0;\n    const iAttr = state.attrGen();\n    for (i = 0; i < state.ruleCount; i += 1) {\n      /* initialize working attributes */\n      for (j = 0; j < state.ruleCount; j += 1) {\n        state.attrInit(state.attrsWorking[j]);\n      }\n      state.startRule = i;\n      ruleAttrsEval(state, i, iAttr);\n\n      /* save off the working attributes for this rule */\n      state.attrCopy(state.attrs[i], state.attrsWorking[i]);\n    }\n    state.attributesComplete = true;\n    let attri = null;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      attri = state.attrs[i];\n      if (attri.left || !attri.finite || attri.cyclic) {\n        const temp = state.attrGen(attri.rule);\n        state.attrCopy(temp, attri);\n        state.attrsErrors.push(temp);\n        state.attrsErrorCount += 1;\n      }\n    }\n  };\n  const truth = (val) => (val ? 't' : 'f');\n  const tError = (val) => (val ? 'e' : 'f');\n  const fError = (val) => (val ? 't' : 'e');\n  const showAttr = (seq, index, attr, dep) => {\n    let str = `${seq}:${index}:`;\n    str += `${tError(attr.left)} `;\n    str += `${truth(attr.nested)} `;\n    str += `${truth(attr.right)} `;\n    str += `${tError(attr.cyclic)} `;\n    str += `${fError(attr.finite)} `;\n    str += `${truth(attr.empty)}:`;\n    str += `${state.typeToString(dep.recursiveType)}:`;\n    str += dep.recursiveType === id.ATTR_MR ? dep.groupNumber : '-';\n    str += `:${attr.rule.name}\\n`;\n    return str;\n  };\n\n  const showLegend = () => {\n    let str = 'LEGEND - t=true, f=false, e=error\\n';\n    str += 'sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\\n';\n    return str;\n  };\n  const showAttributeErrors = () => {\n    let attri = null;\n    let depi = null;\n    let str = '';\n    str += 'RULE ATTRIBUTES WITH ERRORS\\n';\n    str += showLegend();\n    if (state.attrsErrorCount) {\n      for (let i = 0; i < state.attrsErrorCount; i += 1) {\n        attri = state.attrsErrors[i];\n        depi = state.ruleDeps[attri.rule.index];\n        str += showAttr(i, attri.rule.index, attri, depi);\n      }\n    } else {\n      str += '<none>\\n';\n    }\n    return str;\n  };\n\n  const show = (type) => {\n    let i = 0;\n    let ii = 0;\n    let attri = null;\n    let depi = null;\n    let str = '';\n    let { ruleIndexes } = state;\n    // let udtIndexes = state.udtIndexes;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    }\n    /* show all attributes */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      ii = ruleIndexes[i];\n      attri = state.attrs[ii];\n      depi = state.ruleDeps[ii];\n      str += showAttr(i, ii, attri, depi);\n    }\n    return str;\n  };\n\n  // Display the rule attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showAttributes = (order = 'index') => {\n    if (!state.attributesComplete) {\n      throw new Error(`${thisFile}:showAttributes: attributes not available`);\n    }\n    let str = '';\n    const leader = 'RULE ATTRIBUTES\\n';\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += leader;\n      str += showLegend();\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += leader;\n      str += showLegend();\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += leader;\n      str += showLegend();\n      str += show();\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleAttributes, showAttributes, showAttributeErrors };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtYXR0cmlidXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0ZBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLEdBQUcsTUFBTTtBQUM5QixjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLHNDQUFzQztBQUNwRDtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9ydWxlLWF0dHJpYnV0ZXMuanM/NWIzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBkb2VzIHRoZSBoZWF2eSBsaWZ0aW5nIGZvciBhdHRyaWJ1dGUgZ2VuZXJhdGlvbi5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIGV4cG9ydFJ1bGVBdHRyaWJ1dGVzKCkge1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4uL2FwZy1saWIvaWRlbnRpZmllcnMnKTtcbiAgY29uc3QgdGhpc0ZpbGUgPSAncnVsZS1hdHRyaWJ1dGVzLmpzJztcbiAgbGV0IHN0YXRlID0gbnVsbDtcbiAgZnVuY3Rpb24gaXNFbXB0eU9ubHkoYXR0cikge1xuICAgIGlmIChhdHRyLmxlZnQgfHwgYXR0ci5uZXN0ZWQgfHwgYXR0ci5yaWdodCB8fCBhdHRyLmN5Y2xpYykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0ci5lbXB0eTtcbiAgfVxuICBmdW5jdGlvbiBpc1JlY3Vyc2l2ZShhdHRyKSB7XG4gICAgaWYgKGF0dHIubGVmdCB8fCBhdHRyLm5lc3RlZCB8fCBhdHRyLnJpZ2h0IHx8IGF0dHIuY3ljbGljKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0TmVzdGVkKGF0dHJzLCBjb3VudCkge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGsgPSAwO1xuICAgIC8qIDEuIGlmIGFueSBjaGlsZCBpcyBuZXN0ZWQsIENBVCBpcyBuZXN0ZWQgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKGF0dHJzW2ldLm5lc3RlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogMi4pIHRoZSBsZWZ0LW1vc3QgcmlnaHQgcmVjdXJzaXZlIGNoaWxkXG4gICAgICAgICAgICAgICBpcyBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgbm9uLWVtcHR5IGNoaWxkICovXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmIChhdHRyc1tpXS5yaWdodCAmJiAhYXR0cnNbaV0ubGVhZikge1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAoIWlzRW1wdHlPbmx5KGF0dHJzW2pdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIDMuKSB0aGUgcmlnaHQtbW9zdCBsZWZ0IHJlY3Vyc2l2ZSBjaGlsZFxuICAgICAgICAgICAgICAgaXMgcHJlY2VkZWQgYnkgYXQgbGVhc3Qgb25lIG5vbi1lbXB0eSBjaGlsZCAqL1xuICAgIGZvciAoaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmIChhdHRyc1tpXS5sZWZ0ICYmICFhdHRyc1tpXS5sZWFmKSB7XG4gICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGogLT0gMSkge1xuICAgICAgICAgIGlmICghaXNFbXB0eU9ubHkoYXR0cnNbal0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogNC4gdGhlcmUgaXMgYXQgbGVhc2Ugb25lIHJlY3Vyc2l2ZSBjaGlsZCBiZXR3ZWVuXG4gICAgICAgICAgICAgIHRoZSBsZWZ0LW1vc3QgYW5kIHJpZ2h0LW1vc3Qgbm9uLXJlY3Vyc2l2ZSwgbm9uLWVtcHR5IGNoaWxkcmVuICovXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmICghYXR0cnNbaV0uZW1wdHkgJiYgIWlzUmVjdXJzaXZlKGF0dHJzW2ldKSkge1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAoaXNSZWN1cnNpdmUoYXR0cnNbal0pKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSBqICsgMTsgayA8IGNvdW50OyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKCFhdHRyc1trXS5lbXB0eSAmJiAhaXNSZWN1cnNpdmUoYXR0cnNba10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBub25lIG9mIHRoZSBhYm92ZSAqL1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NhdEN5Y2xpYyhhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiBhbGwgY2hpbGRyZW4gYXJlIGN5Y2xpYywgQ0FUIGlzIGN5Y2xpYyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKCFhdHRyc1tpXS5jeWNsaWMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NhdExlZnQoYXR0cnMsIGNvdW50KSB7XG4gICAgLyogaWYgdGhlIGxlZnQtbW9zdCBub24tZW1wdHkgaXMgbGVmdCwgQ0FUIGlzIGxlZnQgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmIChhdHRyc1tpXS5sZWZ0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRyc1tpXS5lbXB0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvKiBrZWVwIGxvb2tpbmcgKi9cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlOyAvKiBhbGwgbGVmdC1tb3N0IGFyZSBlbXB0eSAqL1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0UmlnaHQoYXR0cnMsIGNvdW50KSB7XG4gICAgLyogaWYgdGhlIHJpZ2h0LW1vc3Qgbm9uLWVtcHR5IGlzIHJpZ2h0LCBDQVQgaXMgcmlnaHQgKi9cbiAgICBmb3IgKGxldCBpID0gY291bnQgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKGF0dHJzW2ldLnJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRyc1tpXS5lbXB0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvKiBrZWVwIGxvb2tpbmcgKi9cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0RW1wdHkoYXR0cnMsIGNvdW50KSB7XG4gICAgLyogaWYgYWxsIGNoaWxkcmVuIGFyZSBlbXB0eSwgQ0FUIGlzIGVtcHR5ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoIWF0dHJzW2ldLmVtcHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRGaW5pdGUoYXR0cnMsIGNvdW50KSB7XG4gICAgLyogaWYgYWxsIGNoaWxkcmVuIGFyZSBmaW5pdGUsIENBVCBpcyBmaW5pdGUgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmICghYXR0cnNbaV0uZmluaXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY2F0KHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBvcENhdCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgY291bnQgPSBvcENhdC5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAvKiBnZW5lcmF0ZSBhbiBlbXB0eSBhcnJheSBvZiBjaGlsZCBhdHRyaWJ1dGVzICovXG4gICAgY29uc3QgY2hpbGRBdHRycyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBjaGlsZEF0dHJzLnB1c2goc3RhdGVBcmcuYXR0ckdlbigpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcENhdC5jaGlsZHJlbltpXSwgY2hpbGRBdHRyc1tpXSk7XG4gICAgfVxuICAgIGlBdHRyLmxlZnQgPSBpc0NhdExlZnQoY2hpbGRBdHRycywgY291bnQpO1xuICAgIGlBdHRyLnJpZ2h0ID0gaXNDYXRSaWdodChjaGlsZEF0dHJzLCBjb3VudCk7XG4gICAgaUF0dHIubmVzdGVkID0gaXNDYXROZXN0ZWQoY2hpbGRBdHRycywgY291bnQpO1xuICAgIGlBdHRyLmVtcHR5ID0gaXNDYXRFbXB0eShjaGlsZEF0dHJzLCBjb3VudCk7XG4gICAgaUF0dHIuZmluaXRlID0gaXNDYXRGaW5pdGUoY2hpbGRBdHRycywgY291bnQpO1xuICAgIGlBdHRyLmN5Y2xpYyA9IGlzQ2F0Q3ljbGljKGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgfVxuICBmdW5jdGlvbiBhbHQoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IG9wQWx0ID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCBjb3VudCA9IG9wQWx0LmNoaWxkcmVuLmxlbmd0aDtcblxuICAgIC8qIGdlbmVyYXRlIGFuIGVtcHR5IGFycmF5IG9mIGNoaWxkIGF0dHJpYnV0ZXMgKi9cbiAgICBjb25zdCBjaGlsZEF0dHJzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGNoaWxkQXR0cnMucHVzaChzdGF0ZUFyZy5hdHRyR2VuKCkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBvcEV2YWwoc3RhdGVBcmcsIG9wY29kZXMsIG9wQWx0LmNoaWxkcmVuW2ldLCBjaGlsZEF0dHJzW2ldKTtcbiAgICB9XG5cbiAgICAvKiBpZiBhbnkgY2hpbGQgYXR0cmlidXRlIGlzIHRydWUsIEFMVCBpcyB0cnVlICovXG4gICAgaUF0dHIubGVmdCA9IGZhbHNlO1xuICAgIGlBdHRyLnJpZ2h0ID0gZmFsc2U7XG4gICAgaUF0dHIubmVzdGVkID0gZmFsc2U7XG4gICAgaUF0dHIuZW1wdHkgPSBmYWxzZTtcbiAgICBpQXR0ci5maW5pdGUgPSBmYWxzZTtcbiAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKGNoaWxkQXR0cnNbaV0ubGVmdCkge1xuICAgICAgICBpQXR0ci5sZWZ0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLm5lc3RlZCkge1xuICAgICAgICBpQXR0ci5uZXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQXR0cnNbaV0ucmlnaHQpIHtcbiAgICAgICAgaUF0dHIucmlnaHQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQXR0cnNbaV0uZW1wdHkpIHtcbiAgICAgICAgaUF0dHIuZW1wdHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQXR0cnNbaV0uZmluaXRlKSB7XG4gICAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5jeWNsaWMpIHtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmtyKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cikge1xuICAgIGNvbnN0IG9wQmtyID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBpZiAob3BCa3IuaW5kZXggPj0gc3RhdGVBcmcucnVsZUNvdW50KSB7XG4gICAgICAvKiB1c2UgVURUIHZhbHVlcyAqL1xuICAgICAgaUF0dHIuZW1wdHkgPSBzdGF0ZUFyZy51ZHRzW29wQmtyLmluZGV4IC0gc3RhdGVBcmcucnVsZUNvdW50XS5lbXB0eTtcbiAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIHVzZSB0aGUgZW1wdHkgYW5kIGZpbml0ZSB2YWx1ZXMgZnJvbSB0aGUgYmFjayByZWZlcmVuY2VkIHJ1bGUgKi9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgcnVsZUF0dHJzRXZhbChzdGF0ZUFyZywgb3BCa3IuaW5kZXgsIGlBdHRyKTtcblxuICAgICAgLyogaG93ZXZlciwgdGhpcyBpcyBhIHRlcm1pbmFsIG5vZGUgbGlrZSBUTFMgKi9cbiAgICAgIGlBdHRyLmxlZnQgPSBmYWxzZTtcbiAgICAgIGlBdHRyLm5lc3RlZCA9IGZhbHNlO1xuICAgICAgaUF0dHIucmlnaHQgPSBmYWxzZTtcbiAgICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9wRXZhbChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpIHtcbiAgICBzdGF0ZUFyZy5hdHRySW5pdChpQXR0cik7XG4gICAgY29uc3Qgb3BpID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzd2l0Y2ggKG9waS50eXBlKSB7XG4gICAgICBjYXNlIGlkLkFMVDpcbiAgICAgICAgYWx0KHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5DQVQ6XG4gICAgICAgIGNhdChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICBvcEV2YWwoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXggKyAxLCBpQXR0cik7XG4gICAgICAgIGlmIChvcGkubWluID09PSAwKSB7XG4gICAgICAgICAgaUF0dHIuZW1wdHkgPSB0cnVlO1xuICAgICAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJ1bGVBdHRyc0V2YWwoc3RhdGVBcmcsIG9wY29kZXNbb3BJbmRleF0uaW5kZXgsIGlBdHRyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkJLUjpcbiAgICAgICAgYmtyKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5BTkQ6XG4gICAgICBjYXNlIGlkLk5PVDpcbiAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgY2FzZSBpZC5CS046XG4gICAgICAgIG9wRXZhbChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCArIDEsIGlBdHRyKTtcbiAgICAgICAgaUF0dHIuZW1wdHkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICBpQXR0ci5lbXB0eSA9ICFvcGNvZGVzW29wSW5kZXhdLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuVEJTOlxuICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICBpQXR0ci5lbXB0eSA9IG9waS5lbXB0eTtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5BQkc6XG4gICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgaUF0dHIuZW1wdHkgPSB0cnVlO1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gb3Bjb2RlIHR5cGU6ICR7b3BpfWApO1xuICAgIH1cbiAgfVxuICAvLyBUaGUgbWFpbiBsb2dpYyBmb3IgaGFuZGxpbmcgcnVsZXMgdGhhdDpcbiAgLy8gIC0gaGF2ZSBhbHJlYWR5IGJlIGV2YWx1YXRlZFxuICAvLyAgLSBoYXZlIG5vdCBiZWVuIGV2YWx1YXRlZCBhbmQgaXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb24gdGhpcyBicmFuY2hcbiAgLy8gIC0gc2Vjb25kIG9jY3VycmVuY2Ugb24gdGhpcyBicmFuY2ggZm9yIHRoZSBzdGFydCBydWxlXG4gIC8vICAtIHNlY29uZCBvY2N1cnJlbmNlIG9uIHRoaXMgYnJhbmNoIGZvciBub24tc3RhcnQgcnVsZXNcbiAgZnVuY3Rpb24gcnVsZUF0dHJzRXZhbChzdGF0ZUFyZywgcnVsZUluZGV4LCBpQXR0cikge1xuICAgIGNvbnN0IGF0dHJpID0gc3RhdGVBcmcuYXR0cnNXb3JraW5nW3J1bGVJbmRleF07XG4gICAgaWYgKGF0dHJpLmlzQ29tcGxldGUpIHtcbiAgICAgIC8qIGp1c3QgdXNlIHRoZSBjb21wbGV0ZWQgdmFsdWVzICovXG4gICAgICBzdGF0ZUFyZy5hdHRyQ29weShpQXR0ciwgYXR0cmkpO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpLmlzT3Blbikge1xuICAgICAgLyogb3BlbiB0aGUgcnVsZSBhbmQgdHJhdmVyc2UgaXQgKi9cbiAgICAgIGF0dHJpLmlzT3BlbiA9IHRydWU7XG4gICAgICBvcEV2YWwoc3RhdGVBcmcsIGF0dHJpLnJ1bGUub3Bjb2RlcywgMCwgaUF0dHIpO1xuICAgICAgLyogY29tcGxldGUgdGhpcyBydWxlJ3MgYXR0cmlidXRlcyAqL1xuICAgICAgYXR0cmkubGVmdCA9IGlBdHRyLmxlZnQ7XG4gICAgICBhdHRyaS5yaWdodCA9IGlBdHRyLnJpZ2h0O1xuICAgICAgYXR0cmkubmVzdGVkID0gaUF0dHIubmVzdGVkO1xuICAgICAgYXR0cmkuZW1wdHkgPSBpQXR0ci5lbXB0eTtcbiAgICAgIGF0dHJpLmZpbml0ZSA9IGlBdHRyLmZpbml0ZTtcbiAgICAgIGF0dHJpLmN5Y2xpYyA9IGlBdHRyLmN5Y2xpYztcbiAgICAgIGF0dHJpLmxlYWYgPSBmYWxzZTtcbiAgICAgIGF0dHJpLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgYXR0cmkuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChydWxlSW5kZXggPT09IHN0YXRlQXJnLnN0YXJ0UnVsZSkge1xuICAgICAgLyogdXNlIHJlY3Vyc2l2ZSBsZWFmIHZhbHVlcyAqL1xuICAgICAgaWYgKHJ1bGVJbmRleCA9PT0gc3RhdGVBcmcuc3RhcnRSdWxlKSB7XG4gICAgICAgIGlBdHRyLmxlZnQgPSB0cnVlO1xuICAgICAgICBpQXR0ci5yaWdodCA9IHRydWU7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IHRydWU7XG4gICAgICAgIGlBdHRyLmxlYWYgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBub24tc3RhcnQgcnVsZSB0ZXJtaW5hbCBsZWFmICovXG4gICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBUaGUgbWFpbiBkcml2ZXIgZm9yIHRoZSBhdHRyaWJ1dGUgZ2VuZXJhdGlvbi5cbiAgY29uc3QgcnVsZUF0dHJpYnV0ZXMgPSAoc3RhdGVBcmcpID0+IHtcbiAgICBzdGF0ZSA9IHN0YXRlQXJnO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgaUF0dHIgPSBzdGF0ZS5hdHRyR2VuKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICAvKiBpbml0aWFsaXplIHdvcmtpbmcgYXR0cmlidXRlcyAqL1xuICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgIHN0YXRlLmF0dHJJbml0KHN0YXRlLmF0dHJzV29ya2luZ1tqXSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5zdGFydFJ1bGUgPSBpO1xuICAgICAgcnVsZUF0dHJzRXZhbChzdGF0ZSwgaSwgaUF0dHIpO1xuXG4gICAgICAvKiBzYXZlIG9mZiB0aGUgd29ya2luZyBhdHRyaWJ1dGVzIGZvciB0aGlzIHJ1bGUgKi9cbiAgICAgIHN0YXRlLmF0dHJDb3B5KHN0YXRlLmF0dHJzW2ldLCBzdGF0ZS5hdHRyc1dvcmtpbmdbaV0pO1xuICAgIH1cbiAgICBzdGF0ZS5hdHRyaWJ1dGVzQ29tcGxldGUgPSB0cnVlO1xuICAgIGxldCBhdHRyaSA9IG51bGw7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBhdHRyaSA9IHN0YXRlLmF0dHJzW2ldO1xuICAgICAgaWYgKGF0dHJpLmxlZnQgfHwgIWF0dHJpLmZpbml0ZSB8fCBhdHRyaS5jeWNsaWMpIHtcbiAgICAgICAgY29uc3QgdGVtcCA9IHN0YXRlLmF0dHJHZW4oYXR0cmkucnVsZSk7XG4gICAgICAgIHN0YXRlLmF0dHJDb3B5KHRlbXAsIGF0dHJpKTtcbiAgICAgICAgc3RhdGUuYXR0cnNFcnJvcnMucHVzaCh0ZW1wKTtcbiAgICAgICAgc3RhdGUuYXR0cnNFcnJvckNvdW50ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB0cnV0aCA9ICh2YWwpID0+ICh2YWwgPyAndCcgOiAnZicpO1xuICBjb25zdCB0RXJyb3IgPSAodmFsKSA9PiAodmFsID8gJ2UnIDogJ2YnKTtcbiAgY29uc3QgZkVycm9yID0gKHZhbCkgPT4gKHZhbCA/ICd0JyA6ICdlJyk7XG4gIGNvbnN0IHNob3dBdHRyID0gKHNlcSwgaW5kZXgsIGF0dHIsIGRlcCkgPT4ge1xuICAgIGxldCBzdHIgPSBgJHtzZXF9OiR7aW5kZXh9OmA7XG4gICAgc3RyICs9IGAke3RFcnJvcihhdHRyLmxlZnQpfSBgO1xuICAgIHN0ciArPSBgJHt0cnV0aChhdHRyLm5lc3RlZCl9IGA7XG4gICAgc3RyICs9IGAke3RydXRoKGF0dHIucmlnaHQpfSBgO1xuICAgIHN0ciArPSBgJHt0RXJyb3IoYXR0ci5jeWNsaWMpfSBgO1xuICAgIHN0ciArPSBgJHtmRXJyb3IoYXR0ci5maW5pdGUpfSBgO1xuICAgIHN0ciArPSBgJHt0cnV0aChhdHRyLmVtcHR5KX06YDtcbiAgICBzdHIgKz0gYCR7c3RhdGUudHlwZVRvU3RyaW5nKGRlcC5yZWN1cnNpdmVUeXBlKX06YDtcbiAgICBzdHIgKz0gZGVwLnJlY3Vyc2l2ZVR5cGUgPT09IGlkLkFUVFJfTVIgPyBkZXAuZ3JvdXBOdW1iZXIgOiAnLSc7XG4gICAgc3RyICs9IGA6JHthdHRyLnJ1bGUubmFtZX1cXG5gO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgY29uc3Qgc2hvd0xlZ2VuZCA9ICgpID0+IHtcbiAgICBsZXQgc3RyID0gJ0xFR0VORCAtIHQ9dHJ1ZSwgZj1mYWxzZSwgZT1lcnJvclxcbic7XG4gICAgc3RyICs9ICdzZXF1ZW5jZTpydWxlIGluZGV4OmxlZnQgbmVzdGVkIHJpZ2h0IGN5Y2xpYyBmaW5pdGUgZW1wdHk6dHlwZTpncm91cCBudW1iZXI6cnVsZSBuYW1lXFxuJztcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBjb25zdCBzaG93QXR0cmlidXRlRXJyb3JzID0gKCkgPT4ge1xuICAgIGxldCBhdHRyaSA9IG51bGw7XG4gICAgbGV0IGRlcGkgPSBudWxsO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBzdHIgKz0gJ1JVTEUgQVRUUklCVVRFUyBXSVRIIEVSUk9SU1xcbic7XG4gICAgc3RyICs9IHNob3dMZWdlbmQoKTtcbiAgICBpZiAoc3RhdGUuYXR0cnNFcnJvckNvdW50KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmF0dHJzRXJyb3JDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGF0dHJpID0gc3RhdGUuYXR0cnNFcnJvcnNbaV07XG4gICAgICAgIGRlcGkgPSBzdGF0ZS5ydWxlRGVwc1thdHRyaS5ydWxlLmluZGV4XTtcbiAgICAgICAgc3RyICs9IHNob3dBdHRyKGksIGF0dHJpLnJ1bGUuaW5kZXgsIGF0dHJpLCBkZXBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICc8bm9uZT5cXG4nO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIGNvbnN0IHNob3cgPSAodHlwZSkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaWkgPSAwO1xuICAgIGxldCBhdHRyaSA9IG51bGw7XG4gICAgbGV0IGRlcGkgPSBudWxsO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgeyBydWxlSW5kZXhlcyB9ID0gc3RhdGU7XG4gICAgLy8gbGV0IHVkdEluZGV4ZXMgPSBzdGF0ZS51ZHRJbmRleGVzO1xuICAgIGlmICh0eXBlID09PSA5Nykge1xuICAgICAgcnVsZUluZGV4ZXMgPSBzdGF0ZS5ydWxlQWxwaGFJbmRleGVzO1xuICAgICAgLy8gdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEFscGhhSW5kZXhlcztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDExNikge1xuICAgICAgcnVsZUluZGV4ZXMgPSBzdGF0ZS5ydWxlVHlwZUluZGV4ZXM7XG4gICAgICAvLyB1ZHRJbmRleGVzID0gc3RhdGUudWR0QWxwaGFJbmRleGVzO1xuICAgIH1cbiAgICAvKiBzaG93IGFsbCBhdHRyaWJ1dGVzICovXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBpaSA9IHJ1bGVJbmRleGVzW2ldO1xuICAgICAgYXR0cmkgPSBzdGF0ZS5hdHRyc1tpaV07XG4gICAgICBkZXBpID0gc3RhdGUucnVsZURlcHNbaWldO1xuICAgICAgc3RyICs9IHNob3dBdHRyKGksIGlpLCBhdHRyaSwgZGVwaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLy8gRGlzcGxheSB0aGUgcnVsZSBhdHRyaWJ1dGVzLlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIFwidHlwZVwiIG9yIFwidFwiLCBvcmRlcmVkIGJ5IHR5cGUgKGFscGhhYmV0aWNhbCB3aXRoaW4gZWFjaCB0eXBlL2dyb3VwKVxuICAvLyAgICAgIC0gbm9uZSBvZiBhYm92ZSwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIGNvbnN0IHNob3dBdHRyaWJ1dGVzID0gKG9yZGVyID0gJ2luZGV4JykgPT4ge1xuICAgIGlmICghc3RhdGUuYXR0cmlidXRlc0NvbXBsZXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGV9OnNob3dBdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzIG5vdCBhdmFpbGFibGVgKTtcbiAgICB9XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGNvbnN0IGxlYWRlciA9ICdSVUxFIEFUVFJJQlVURVNcXG4nO1xuICAgIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSA5Nykge1xuICAgICAgc3RyICs9ICdhbHBoYWJldGljYWwgYnkgcnVsZSBuYW1lXFxuJztcbiAgICAgIHN0ciArPSBsZWFkZXI7XG4gICAgICBzdHIgKz0gc2hvd0xlZ2VuZCgpO1xuICAgICAgc3RyICs9IHNob3coOTcpO1xuICAgIH0gZWxzZSBpZiAob3JkZXIuY2hhckNvZGVBdCgwKSA9PT0gMTE2KSB7XG4gICAgICBzdHIgKz0gJ29yZGVyZWQgYnkgcnVsZSB0eXBlXFxuJztcbiAgICAgIHN0ciArPSBsZWFkZXI7XG4gICAgICBzdHIgKz0gc2hvd0xlZ2VuZCgpO1xuICAgICAgc3RyICs9IHNob3coMTE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICdvcmRlcmVkIGJ5IHJ1bGUgaW5kZXhcXG4nO1xuICAgICAgc3RyICs9IGxlYWRlcjtcbiAgICAgIHN0ciArPSBzaG93TGVnZW5kKCk7XG4gICAgICBzdHIgKz0gc2hvdygpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qIERlc3RydWN0dXJpbmcgYXNzaWdubWVudCAtIHNlZSBNRE4gV2ViIERvY3MgKi9cbiAgcmV0dXJuIHsgcnVsZUF0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlRXJyb3JzIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/rule-attributes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/rule-dependencies.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/rule-dependencies.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Determine rule dependencies and types.\n// For each rule, determine which other rules it refers to\n// and which of the other rules refer back to it.\n//\n// Rule types are:\n//  - non-recursive - the rule never refers to itself, even indirectly\n//  - recursive - the rule refers to itself, possibly indirectly\n//  - mutually-recursive - belongs to a group of two or more rules, each of which refers to every other rule in the group, including itself.\nmodule.exports = (() => {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  let state = null; /* keep a global reference to the state for the show functions */\n\n  /* scan the opcodes of the indexed rule and discover which rules it references and which rule refer back to it */\n  const scan = (ruleCount, ruleDeps, index, isScanned) => {\n    let i = 0;\n    let j = 0;\n    const rdi = ruleDeps[index];\n    isScanned[index] = true;\n    const op = rdi.rule.opcodes;\n    for (i = 0; i < op.length; i += 1) {\n      const opi = op[i];\n      if (opi.type === id.RNM) {\n        rdi.refersTo[opi.index] = true;\n        if (!isScanned[opi.index]) {\n          scan(ruleCount, ruleDeps, opi.index, isScanned);\n        }\n        for (j = 0; j < ruleCount; j += 1) {\n          if (ruleDeps[opi.index].refersTo[j]) {\n            rdi.refersTo[j] = true;\n          }\n        }\n      } else if (opi.type === id.UDT) {\n        rdi.refersToUdt[opi.index] = true;\n      } else if (opi.type === id.BKR) {\n        if (opi.index < ruleCount) {\n          rdi.refersTo[opi.index] = true;\n          if (!isScanned[opi.index]) {\n            scan(ruleCount, ruleDeps, opi.index, isScanned);\n          }\n        } else {\n          rdi.refersToUdt[ruleCount - opi.index] = true;\n        }\n      }\n    }\n  };\n  // Determine the rule dependencies, types and mutually recursive groups.\n  const ruleDependencies = (stateArg) => {\n    state = stateArg; /* make it global */\n    let i = 0;\n    let j = 0;\n    let groupCount = 0;\n    let rdi = null;\n    let rdj = null;\n    let newGroup = false;\n    state.dependenciesComplete = false;\n\n    /* make a working array of rule scanned markers */\n    const isScanned = state.falseArray(state.ruleCount);\n\n    /* discover the rule dependencies */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.falsifyArray(isScanned);\n      scan(state.ruleCount, state.ruleDeps, i, isScanned);\n    }\n    /* discover all rules referencing each rule */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (i !== j) {\n          if (state.ruleDeps[j].refersTo[i]) {\n            state.ruleDeps[i].referencedBy[j] = true;\n          }\n        }\n      }\n    }\n    /* find the non-recursive and recursive types */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.ruleDeps[i].recursiveType = id.ATTR_N;\n      if (state.ruleDeps[i].refersTo[i]) {\n        state.ruleDeps[i].recursiveType = id.ATTR_R;\n      }\n    }\n\n    /* find the mutually-recursive groups, if any */\n    groupCount = -1;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[i];\n      if (rdi.recursiveType === id.ATTR_R) {\n        newGroup = true;\n        for (j = 0; j < state.ruleCount; j += 1) {\n          if (i !== j) {\n            rdj = state.ruleDeps[j];\n            if (rdj.recursiveType === id.ATTR_R) {\n              if (rdi.refersTo[j] && rdj.refersTo[i]) {\n                if (newGroup) {\n                  groupCount += 1;\n                  rdi.recursiveType = id.ATTR_MR;\n                  rdi.groupNumber = groupCount;\n                  newGroup = false;\n                }\n                rdj.recursiveType = id.ATTR_MR;\n                rdj.groupNumber = groupCount;\n              }\n            }\n          }\n        }\n      }\n    }\n    state.isMutuallyRecursive = groupCount > -1;\n\n    /* sort the rules/UDTS */\n    state.ruleAlphaIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesType);\n    if (state.isMutuallyRecursive) {\n      state.ruleTypeIndexes.sort(state.compRulesGroup);\n    }\n    if (state.udtCount) {\n      state.udtAlphaIndexes.sort(state.compUdtsAlpha);\n    }\n\n    state.dependenciesComplete = true;\n  };\n  const show = (type = null) => {\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    let startSeg = 0;\n    const maxRule = state.ruleCount - 1;\n    const maxUdt = state.udtCount - 1;\n    const lineLength = 100;\n    let str = '';\n    let pre = '';\n    const toArrow = '=> ';\n    const byArrow = '<= ';\n    let first = false;\n    let rdi = null;\n    let { ruleIndexes } = state;\n    let { udtIndexes } = state;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    }\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[ruleIndexes[i]];\n      pre = `${ruleIndexes[i]}:${state.typeToString(rdi.recursiveType)}:`;\n      if (state.isMutuallyRecursive) {\n        pre += rdi.groupNumber > -1 ? rdi.groupNumber : '-';\n        pre += ':';\n      }\n      pre += ' ';\n      str += `${pre + state.rules[ruleIndexes[i]].name}\\n`;\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.refersTo[ruleIndexes[j]]) {\n          if (first) {\n            str += toArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (state.udtCount) {\n        for (j = 0; j < state.udtCount; j += 1) {\n          if (rdi.refersToUdt[udtIndexes[j]]) {\n            if (first) {\n              str += toArrow;\n              first = false;\n              str += state.udts[udtIndexes[j]].name;\n            } else {\n              str += `, ${state.udts[udtIndexes[j]].name}`;\n            }\n            count += 1;\n          }\n          if (str.length - startSeg > lineLength && j !== maxUdt) {\n            str += `\\n${pre}${toArrow}`;\n            startSeg = str.length;\n          }\n        }\n      }\n      if (count === 0) {\n        str += '=> <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.referencedBy[ruleIndexes[j]]) {\n          if (first) {\n            str += byArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (count === 0) {\n        str += '<= <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      str += '\\n';\n    }\n    return str;\n  };\n  // Display the rule dependencies.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showRuleDependencies = (order = 'index') => {\n    let str = 'RULE DEPENDENCIES(index:type:[group number:])\\n';\n    str += '=> refers to rule names\\n';\n    str += '<= referenced by rule names\\n';\n    if (!state.dependenciesComplete) {\n      return str;\n    }\n\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += show(null);\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleDependencies, showRuleDependencies };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtZGVwZW5kZW5jaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNGQUF3QjtBQUM3QyxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0EsZUFBZSxlQUFlLEdBQUcsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLEVBQUUsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtZGVwZW5kZW5jaWVzLmpzPzJjNzciXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gRGV0ZXJtaW5lIHJ1bGUgZGVwZW5kZW5jaWVzIGFuZCB0eXBlcy5cbi8vIEZvciBlYWNoIHJ1bGUsIGRldGVybWluZSB3aGljaCBvdGhlciBydWxlcyBpdCByZWZlcnMgdG9cbi8vIGFuZCB3aGljaCBvZiB0aGUgb3RoZXIgcnVsZXMgcmVmZXIgYmFjayB0byBpdC5cbi8vXG4vLyBSdWxlIHR5cGVzIGFyZTpcbi8vICAtIG5vbi1yZWN1cnNpdmUgLSB0aGUgcnVsZSBuZXZlciByZWZlcnMgdG8gaXRzZWxmLCBldmVuIGluZGlyZWN0bHlcbi8vICAtIHJlY3Vyc2l2ZSAtIHRoZSBydWxlIHJlZmVycyB0byBpdHNlbGYsIHBvc3NpYmx5IGluZGlyZWN0bHlcbi8vICAtIG11dHVhbGx5LXJlY3Vyc2l2ZSAtIGJlbG9uZ3MgdG8gYSBncm91cCBvZiB0d28gb3IgbW9yZSBydWxlcywgZWFjaCBvZiB3aGljaCByZWZlcnMgdG8gZXZlcnkgb3RoZXIgcnVsZSBpbiB0aGUgZ3JvdXAsIGluY2x1ZGluZyBpdHNlbGYuXG5tb2R1bGUuZXhwb3J0cyA9ICgoKSA9PiB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9pZGVudGlmaWVycycpO1xuICBsZXQgc3RhdGUgPSBudWxsOyAvKiBrZWVwIGEgZ2xvYmFsIHJlZmVyZW5jZSB0byB0aGUgc3RhdGUgZm9yIHRoZSBzaG93IGZ1bmN0aW9ucyAqL1xuXG4gIC8qIHNjYW4gdGhlIG9wY29kZXMgb2YgdGhlIGluZGV4ZWQgcnVsZSBhbmQgZGlzY292ZXIgd2hpY2ggcnVsZXMgaXQgcmVmZXJlbmNlcyBhbmQgd2hpY2ggcnVsZSByZWZlciBiYWNrIHRvIGl0ICovXG4gIGNvbnN0IHNjYW4gPSAocnVsZUNvdW50LCBydWxlRGVwcywgaW5kZXgsIGlzU2Nhbm5lZCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgcmRpID0gcnVsZURlcHNbaW5kZXhdO1xuICAgIGlzU2Nhbm5lZFtpbmRleF0gPSB0cnVlO1xuICAgIGNvbnN0IG9wID0gcmRpLnJ1bGUub3Bjb2RlcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IG9waSA9IG9wW2ldO1xuICAgICAgaWYgKG9waS50eXBlID09PSBpZC5STk0pIHtcbiAgICAgICAgcmRpLnJlZmVyc1RvW29waS5pbmRleF0gPSB0cnVlO1xuICAgICAgICBpZiAoIWlzU2Nhbm5lZFtvcGkuaW5kZXhdKSB7XG4gICAgICAgICAgc2NhbihydWxlQ291bnQsIHJ1bGVEZXBzLCBvcGkuaW5kZXgsIGlzU2Nhbm5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKHJ1bGVEZXBzW29waS5pbmRleF0ucmVmZXJzVG9bal0pIHtcbiAgICAgICAgICAgIHJkaS5yZWZlcnNUb1tqXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9waS50eXBlID09PSBpZC5VRFQpIHtcbiAgICAgICAgcmRpLnJlZmVyc1RvVWR0W29waS5pbmRleF0gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChvcGkudHlwZSA9PT0gaWQuQktSKSB7XG4gICAgICAgIGlmIChvcGkuaW5kZXggPCBydWxlQ291bnQpIHtcbiAgICAgICAgICByZGkucmVmZXJzVG9bb3BpLmluZGV4XSA9IHRydWU7XG4gICAgICAgICAgaWYgKCFpc1NjYW5uZWRbb3BpLmluZGV4XSkge1xuICAgICAgICAgICAgc2NhbihydWxlQ291bnQsIHJ1bGVEZXBzLCBvcGkuaW5kZXgsIGlzU2Nhbm5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJkaS5yZWZlcnNUb1VkdFtydWxlQ291bnQgLSBvcGkuaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gRGV0ZXJtaW5lIHRoZSBydWxlIGRlcGVuZGVuY2llcywgdHlwZXMgYW5kIG11dHVhbGx5IHJlY3Vyc2l2ZSBncm91cHMuXG4gIGNvbnN0IHJ1bGVEZXBlbmRlbmNpZXMgPSAoc3RhdGVBcmcpID0+IHtcbiAgICBzdGF0ZSA9IHN0YXRlQXJnOyAvKiBtYWtlIGl0IGdsb2JhbCAqL1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGdyb3VwQ291bnQgPSAwO1xuICAgIGxldCByZGkgPSBudWxsO1xuICAgIGxldCByZGogPSBudWxsO1xuICAgIGxldCBuZXdHcm91cCA9IGZhbHNlO1xuICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAvKiBtYWtlIGEgd29ya2luZyBhcnJheSBvZiBydWxlIHNjYW5uZWQgbWFya2VycyAqL1xuICAgIGNvbnN0IGlzU2Nhbm5lZCA9IHN0YXRlLmZhbHNlQXJyYXkoc3RhdGUucnVsZUNvdW50KTtcblxuICAgIC8qIGRpc2NvdmVyIHRoZSBydWxlIGRlcGVuZGVuY2llcyAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgc3RhdGUuZmFsc2lmeUFycmF5KGlzU2Nhbm5lZCk7XG4gICAgICBzY2FuKHN0YXRlLnJ1bGVDb3VudCwgc3RhdGUucnVsZURlcHMsIGksIGlzU2Nhbm5lZCk7XG4gICAgfVxuICAgIC8qIGRpc2NvdmVyIGFsbCBydWxlcyByZWZlcmVuY2luZyBlYWNoIHJ1bGUgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5ydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgIGlmIChzdGF0ZS5ydWxlRGVwc1tqXS5yZWZlcnNUb1tpXSkge1xuICAgICAgICAgICAgc3RhdGUucnVsZURlcHNbaV0ucmVmZXJlbmNlZEJ5W2pdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogZmluZCB0aGUgbm9uLXJlY3Vyc2l2ZSBhbmQgcmVjdXJzaXZlIHR5cGVzICovXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBzdGF0ZS5ydWxlRGVwc1tpXS5yZWN1cnNpdmVUeXBlID0gaWQuQVRUUl9OO1xuICAgICAgaWYgKHN0YXRlLnJ1bGVEZXBzW2ldLnJlZmVyc1RvW2ldKSB7XG4gICAgICAgIHN0YXRlLnJ1bGVEZXBzW2ldLnJlY3Vyc2l2ZVR5cGUgPSBpZC5BVFRSX1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogZmluZCB0aGUgbXV0dWFsbHktcmVjdXJzaXZlIGdyb3VwcywgaWYgYW55ICovXG4gICAgZ3JvdXBDb3VudCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgcmRpID0gc3RhdGUucnVsZURlcHNbaV07XG4gICAgICBpZiAocmRpLnJlY3Vyc2l2ZVR5cGUgPT09IGlkLkFUVFJfUikge1xuICAgICAgICBuZXdHcm91cCA9IHRydWU7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5ydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZGogPSBzdGF0ZS5ydWxlRGVwc1tqXTtcbiAgICAgICAgICAgIGlmIChyZGoucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9SKSB7XG4gICAgICAgICAgICAgIGlmIChyZGkucmVmZXJzVG9bal0gJiYgcmRqLnJlZmVyc1RvW2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICBncm91cENvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICByZGkucmVjdXJzaXZlVHlwZSA9IGlkLkFUVFJfTVI7XG4gICAgICAgICAgICAgICAgICByZGkuZ3JvdXBOdW1iZXIgPSBncm91cENvdW50O1xuICAgICAgICAgICAgICAgICAgbmV3R3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmRqLnJlY3Vyc2l2ZVR5cGUgPSBpZC5BVFRSX01SO1xuICAgICAgICAgICAgICAgIHJkai5ncm91cE51bWJlciA9IGdyb3VwQ291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuaXNNdXR1YWxseVJlY3Vyc2l2ZSA9IGdyb3VwQ291bnQgPiAtMTtcblxuICAgIC8qIHNvcnQgdGhlIHJ1bGVzL1VEVFMgKi9cbiAgICBzdGF0ZS5ydWxlQWxwaGFJbmRleGVzLnNvcnQoc3RhdGUuY29tcFJ1bGVzQWxwaGEpO1xuICAgIHN0YXRlLnJ1bGVUeXBlSW5kZXhlcy5zb3J0KHN0YXRlLmNvbXBSdWxlc0FscGhhKTtcbiAgICBzdGF0ZS5ydWxlVHlwZUluZGV4ZXMuc29ydChzdGF0ZS5jb21wUnVsZXNUeXBlKTtcbiAgICBpZiAoc3RhdGUuaXNNdXR1YWxseVJlY3Vyc2l2ZSkge1xuICAgICAgc3RhdGUucnVsZVR5cGVJbmRleGVzLnNvcnQoc3RhdGUuY29tcFJ1bGVzR3JvdXApO1xuICAgIH1cbiAgICBpZiAoc3RhdGUudWR0Q291bnQpIHtcbiAgICAgIHN0YXRlLnVkdEFscGhhSW5kZXhlcy5zb3J0KHN0YXRlLmNvbXBVZHRzQWxwaGEpO1xuICAgIH1cblxuICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvbXBsZXRlID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3Qgc2hvdyA9ICh0eXBlID0gbnVsbCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgc3RhcnRTZWcgPSAwO1xuICAgIGNvbnN0IG1heFJ1bGUgPSBzdGF0ZS5ydWxlQ291bnQgLSAxO1xuICAgIGNvbnN0IG1heFVkdCA9IHN0YXRlLnVkdENvdW50IC0gMTtcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gMTAwO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgcHJlID0gJyc7XG4gICAgY29uc3QgdG9BcnJvdyA9ICc9PiAnO1xuICAgIGNvbnN0IGJ5QXJyb3cgPSAnPD0gJztcbiAgICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgICBsZXQgcmRpID0gbnVsbDtcbiAgICBsZXQgeyBydWxlSW5kZXhlcyB9ID0gc3RhdGU7XG4gICAgbGV0IHsgdWR0SW5kZXhlcyB9ID0gc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDk3KSB7XG4gICAgICBydWxlSW5kZXhlcyA9IHN0YXRlLnJ1bGVBbHBoYUluZGV4ZXM7XG4gICAgICB1ZHRJbmRleGVzID0gc3RhdGUudWR0QWxwaGFJbmRleGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMTE2KSB7XG4gICAgICBydWxlSW5kZXhlcyA9IHN0YXRlLnJ1bGVUeXBlSW5kZXhlcztcbiAgICAgIHVkdEluZGV4ZXMgPSBzdGF0ZS51ZHRBbHBoYUluZGV4ZXM7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgcmRpID0gc3RhdGUucnVsZURlcHNbcnVsZUluZGV4ZXNbaV1dO1xuICAgICAgcHJlID0gYCR7cnVsZUluZGV4ZXNbaV19OiR7c3RhdGUudHlwZVRvU3RyaW5nKHJkaS5yZWN1cnNpdmVUeXBlKX06YDtcbiAgICAgIGlmIChzdGF0ZS5pc011dHVhbGx5UmVjdXJzaXZlKSB7XG4gICAgICAgIHByZSArPSByZGkuZ3JvdXBOdW1iZXIgPiAtMSA/IHJkaS5ncm91cE51bWJlciA6ICctJztcbiAgICAgICAgcHJlICs9ICc6JztcbiAgICAgIH1cbiAgICAgIHByZSArPSAnICc7XG4gICAgICBzdHIgKz0gYCR7cHJlICsgc3RhdGUucnVsZXNbcnVsZUluZGV4ZXNbaV1dLm5hbWV9XFxuYDtcbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIGNvdW50ID0gMDtcbiAgICAgIHN0YXJ0U2VnID0gc3RyLmxlbmd0aDtcbiAgICAgIHN0ciArPSBwcmU7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUucnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgaWYgKHJkaS5yZWZlcnNUb1tydWxlSW5kZXhlc1tqXV0pIHtcbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIHN0ciArPSB0b0Fycm93O1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0ciArPSBzdGF0ZS5ydWxlRGVwc1tydWxlSW5kZXhlc1tqXV0ucnVsZS5uYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgKz0gYCwgJHtzdGF0ZS5ydWxlRGVwc1tydWxlSW5kZXhlc1tqXV0ucnVsZS5uYW1lfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggLSBzdGFydFNlZyA+IGxpbmVMZW5ndGggJiYgaiAhPT0gbWF4UnVsZSkge1xuICAgICAgICAgIHN0ciArPSBgXFxuJHtwcmV9JHt0b0Fycm93fWA7XG4gICAgICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUudWR0Q291bnQpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnVkdENvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAocmRpLnJlZmVyc1RvVWR0W3VkdEluZGV4ZXNbal1dKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgc3RyICs9IHRvQXJyb3c7XG4gICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIHN0ciArPSBzdGF0ZS51ZHRzW3VkdEluZGV4ZXNbal1dLm5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgKz0gYCwgJHtzdGF0ZS51ZHRzW3VkdEluZGV4ZXNbal1dLm5hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHIubGVuZ3RoIC0gc3RhcnRTZWcgPiBsaW5lTGVuZ3RoICYmIGogIT09IG1heFVkdCkge1xuICAgICAgICAgICAgc3RyICs9IGBcXG4ke3ByZX0ke3RvQXJyb3d9YDtcbiAgICAgICAgICAgIHN0YXJ0U2VnID0gc3RyLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICBzdHIgKz0gJz0+IDxub25lPlxcbic7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgIH1cbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIGNvdW50ID0gMDtcbiAgICAgIHN0YXJ0U2VnID0gc3RyLmxlbmd0aDtcbiAgICAgIHN0ciArPSBwcmU7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUucnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgaWYgKHJkaS5yZWZlcmVuY2VkQnlbcnVsZUluZGV4ZXNbal1dKSB7XG4gICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICBzdHIgKz0gYnlBcnJvdztcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBzdHIgKz0gc3RhdGUucnVsZURlcHNbcnVsZUluZGV4ZXNbal1dLnJ1bGUubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IGAsICR7c3RhdGUucnVsZURlcHNbcnVsZUluZGV4ZXNbal1dLnJ1bGUubmFtZX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIC0gc3RhcnRTZWcgPiBsaW5lTGVuZ3RoICYmIGogIT09IG1heFJ1bGUpIHtcbiAgICAgICAgICBzdHIgKz0gYFxcbiR7cHJlfSR7dG9BcnJvd31gO1xuICAgICAgICAgIHN0YXJ0U2VnID0gc3RyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHN0ciArPSAnPD0gPG5vbmU+XFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuICAgICAgc3RyICs9ICdcXG4nO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICAvLyBEaXNwbGF5IHRoZSBydWxlIGRlcGVuZGVuY2llcy5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBcInR5cGVcIiBvciBcInRcIiwgb3JkZXJlZCBieSB0eXBlIChhbHBoYWJldGljYWwgd2l0aGluIGVhY2ggdHlwZS9ncm91cClcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICBjb25zdCBzaG93UnVsZURlcGVuZGVuY2llcyA9IChvcmRlciA9ICdpbmRleCcpID0+IHtcbiAgICBsZXQgc3RyID0gJ1JVTEUgREVQRU5ERU5DSUVTKGluZGV4OnR5cGU6W2dyb3VwIG51bWJlcjpdKVxcbic7XG4gICAgc3RyICs9ICc9PiByZWZlcnMgdG8gcnVsZSBuYW1lc1xcbic7XG4gICAgc3RyICs9ICc8PSByZWZlcmVuY2VkIGJ5IHJ1bGUgbmFtZXNcXG4nO1xuICAgIGlmICghc3RhdGUuZGVwZW5kZW5jaWVzQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgaWYgKG9yZGVyLmNoYXJDb2RlQXQoMCkgPT09IDk3KSB7XG4gICAgICBzdHIgKz0gJ2FscGhhYmV0aWNhbCBieSBydWxlIG5hbWVcXG4nO1xuICAgICAgc3RyICs9IHNob3coOTcpO1xuICAgIH0gZWxzZSBpZiAob3JkZXIuY2hhckNvZGVBdCgwKSA9PT0gMTE2KSB7XG4gICAgICBzdHIgKz0gJ29yZGVyZWQgYnkgcnVsZSB0eXBlXFxuJztcbiAgICAgIHN0ciArPSBzaG93KDExNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnb3JkZXJlZCBieSBydWxlIGluZGV4XFxuJztcbiAgICAgIHN0ciArPSBzaG93KG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qIERlc3RydWN0dXJpbmcgYXNzaWdubWVudCAtIHNlZSBNRE4gV2ViIERvY3MgKi9cbiAgcmV0dXJuIHsgcnVsZURlcGVuZGVuY2llcywgc2hvd1J1bGVEZXBlbmRlbmNpZXMgfTtcbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/rule-dependencies.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/sabnf-grammar.js":
/*!**********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/sabnf-grammar.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 95\n  //       udts = 0\n  //    opcodes = 372\n  //        ---   ABNF original opcodes\n  //        ALT = 43\n  //        CAT = 48\n  //        REP = 34\n  //        RNM = 149\n  //        TLS = 2\n  //        TBS = 61\n  //        TRG = 35\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [9 - 126]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = {name: 'File', lower: 'file', index: 0, isBkr: false};\n  this.rules[1] = {name: 'BlankLine', lower: 'blankline', index: 1, isBkr: false};\n  this.rules[2] = {name: 'Rule', lower: 'rule', index: 2, isBkr: false};\n  this.rules[3] = {name: 'RuleLookup', lower: 'rulelookup', index: 3, isBkr: false};\n  this.rules[4] = {name: 'RuleNameTest', lower: 'rulenametest', index: 4, isBkr: false};\n  this.rules[5] = {name: 'RuleName', lower: 'rulename', index: 5, isBkr: false};\n  this.rules[6] = {name: 'RuleNameError', lower: 'rulenameerror', index: 6, isBkr: false};\n  this.rules[7] = {name: 'DefinedAsTest', lower: 'definedastest', index: 7, isBkr: false};\n  this.rules[8] = {name: 'DefinedAsError', lower: 'definedaserror', index: 8, isBkr: false};\n  this.rules[9] = {name: 'DefinedAs', lower: 'definedas', index: 9, isBkr: false};\n  this.rules[10] = {name: 'Defined', lower: 'defined', index: 10, isBkr: false};\n  this.rules[11] = {name: 'IncAlt', lower: 'incalt', index: 11, isBkr: false};\n  this.rules[12] = {name: 'RuleError', lower: 'ruleerror', index: 12, isBkr: false};\n  this.rules[13] = {name: 'LineEndError', lower: 'lineenderror', index: 13, isBkr: false};\n  this.rules[14] = {name: 'Alternation', lower: 'alternation', index: 14, isBkr: false};\n  this.rules[15] = {name: 'Concatenation', lower: 'concatenation', index: 15, isBkr: false};\n  this.rules[16] = {name: 'Repetition', lower: 'repetition', index: 16, isBkr: false};\n  this.rules[17] = {name: 'Modifier', lower: 'modifier', index: 17, isBkr: false};\n  this.rules[18] = {name: 'Predicate', lower: 'predicate', index: 18, isBkr: false};\n  this.rules[19] = {name: 'BasicElement', lower: 'basicelement', index: 19, isBkr: false};\n  this.rules[20] = {name: 'BasicElementErr', lower: 'basicelementerr', index: 20, isBkr: false};\n  this.rules[21] = {name: 'Group', lower: 'group', index: 21, isBkr: false};\n  this.rules[22] = {name: 'GroupError', lower: 'grouperror', index: 22, isBkr: false};\n  this.rules[23] = {name: 'GroupOpen', lower: 'groupopen', index: 23, isBkr: false};\n  this.rules[24] = {name: 'GroupClose', lower: 'groupclose', index: 24, isBkr: false};\n  this.rules[25] = {name: 'Option', lower: 'option', index: 25, isBkr: false};\n  this.rules[26] = {name: 'OptionError', lower: 'optionerror', index: 26, isBkr: false};\n  this.rules[27] = {name: 'OptionOpen', lower: 'optionopen', index: 27, isBkr: false};\n  this.rules[28] = {name: 'OptionClose', lower: 'optionclose', index: 28, isBkr: false};\n  this.rules[29] = {name: 'RnmOp', lower: 'rnmop', index: 29, isBkr: false};\n  this.rules[30] = {name: 'BkrOp', lower: 'bkrop', index: 30, isBkr: false};\n  this.rules[31] = {name: 'bkrModifier', lower: 'bkrmodifier', index: 31, isBkr: false};\n  this.rules[32] = {name: 'cs', lower: 'cs', index: 32, isBkr: false};\n  this.rules[33] = {name: 'ci', lower: 'ci', index: 33, isBkr: false};\n  this.rules[34] = {name: 'um', lower: 'um', index: 34, isBkr: false};\n  this.rules[35] = {name: 'pm', lower: 'pm', index: 35, isBkr: false};\n  this.rules[36] = {name: 'bkr-name', lower: 'bkr-name', index: 36, isBkr: false};\n  this.rules[37] = {name: 'rname', lower: 'rname', index: 37, isBkr: false};\n  this.rules[38] = {name: 'uname', lower: 'uname', index: 38, isBkr: false};\n  this.rules[39] = {name: 'ename', lower: 'ename', index: 39, isBkr: false};\n  this.rules[40] = {name: 'UdtOp', lower: 'udtop', index: 40, isBkr: false};\n  this.rules[41] = {name: 'udt-non-empty', lower: 'udt-non-empty', index: 41, isBkr: false};\n  this.rules[42] = {name: 'udt-empty', lower: 'udt-empty', index: 42, isBkr: false};\n  this.rules[43] = {name: 'RepOp', lower: 'repop', index: 43, isBkr: false};\n  this.rules[44] = {name: 'AltOp', lower: 'altop', index: 44, isBkr: false};\n  this.rules[45] = {name: 'CatOp', lower: 'catop', index: 45, isBkr: false};\n  this.rules[46] = {name: 'StarOp', lower: 'starop', index: 46, isBkr: false};\n  this.rules[47] = {name: 'AndOp', lower: 'andop', index: 47, isBkr: false};\n  this.rules[48] = {name: 'NotOp', lower: 'notop', index: 48, isBkr: false};\n  this.rules[49] = {name: 'BkaOp', lower: 'bkaop', index: 49, isBkr: false};\n  this.rules[50] = {name: 'BknOp', lower: 'bknop', index: 50, isBkr: false};\n  this.rules[51] = {name: 'AbgOp', lower: 'abgop', index: 51, isBkr: false};\n  this.rules[52] = {name: 'AenOp', lower: 'aenop', index: 52, isBkr: false};\n  this.rules[53] = {name: 'TrgOp', lower: 'trgop', index: 53, isBkr: false};\n  this.rules[54] = {name: 'TbsOp', lower: 'tbsop', index: 54, isBkr: false};\n  this.rules[55] = {name: 'TlsOp', lower: 'tlsop', index: 55, isBkr: false};\n  this.rules[56] = {name: 'TlsCase', lower: 'tlscase', index: 56, isBkr: false};\n  this.rules[57] = {name: 'TlsOpen', lower: 'tlsopen', index: 57, isBkr: false};\n  this.rules[58] = {name: 'TlsClose', lower: 'tlsclose', index: 58, isBkr: false};\n  this.rules[59] = {name: 'TlsString', lower: 'tlsstring', index: 59, isBkr: false};\n  this.rules[60] = {name: 'StringTab', lower: 'stringtab', index: 60, isBkr: false};\n  this.rules[61] = {name: 'ClsOp', lower: 'clsop', index: 61, isBkr: false};\n  this.rules[62] = {name: 'ClsOpen', lower: 'clsopen', index: 62, isBkr: false};\n  this.rules[63] = {name: 'ClsClose', lower: 'clsclose', index: 63, isBkr: false};\n  this.rules[64] = {name: 'ClsString', lower: 'clsstring', index: 64, isBkr: false};\n  this.rules[65] = {name: 'ProsVal', lower: 'prosval', index: 65, isBkr: false};\n  this.rules[66] = {name: 'ProsValOpen', lower: 'prosvalopen', index: 66, isBkr: false};\n  this.rules[67] = {name: 'ProsValString', lower: 'prosvalstring', index: 67, isBkr: false};\n  this.rules[68] = {name: 'ProsValClose', lower: 'prosvalclose', index: 68, isBkr: false};\n  this.rules[69] = {name: 'rep-min', lower: 'rep-min', index: 69, isBkr: false};\n  this.rules[70] = {name: 'rep-min-max', lower: 'rep-min-max', index: 70, isBkr: false};\n  this.rules[71] = {name: 'rep-max', lower: 'rep-max', index: 71, isBkr: false};\n  this.rules[72] = {name: 'rep-num', lower: 'rep-num', index: 72, isBkr: false};\n  this.rules[73] = {name: 'dString', lower: 'dstring', index: 73, isBkr: false};\n  this.rules[74] = {name: 'xString', lower: 'xstring', index: 74, isBkr: false};\n  this.rules[75] = {name: 'bString', lower: 'bstring', index: 75, isBkr: false};\n  this.rules[76] = {name: 'Dec', lower: 'dec', index: 76, isBkr: false};\n  this.rules[77] = {name: 'Hex', lower: 'hex', index: 77, isBkr: false};\n  this.rules[78] = {name: 'Bin', lower: 'bin', index: 78, isBkr: false};\n  this.rules[79] = {name: 'dmin', lower: 'dmin', index: 79, isBkr: false};\n  this.rules[80] = {name: 'dmax', lower: 'dmax', index: 80, isBkr: false};\n  this.rules[81] = {name: 'bmin', lower: 'bmin', index: 81, isBkr: false};\n  this.rules[82] = {name: 'bmax', lower: 'bmax', index: 82, isBkr: false};\n  this.rules[83] = {name: 'xmin', lower: 'xmin', index: 83, isBkr: false};\n  this.rules[84] = {name: 'xmax', lower: 'xmax', index: 84, isBkr: false};\n  this.rules[85] = {name: 'dnum', lower: 'dnum', index: 85, isBkr: false};\n  this.rules[86] = {name: 'bnum', lower: 'bnum', index: 86, isBkr: false};\n  this.rules[87] = {name: 'xnum', lower: 'xnum', index: 87, isBkr: false};\n  this.rules[88] = {name: 'alphanum', lower: 'alphanum', index: 88, isBkr: false};\n  this.rules[89] = {name: 'owsp', lower: 'owsp', index: 89, isBkr: false};\n  this.rules[90] = {name: 'wsp', lower: 'wsp', index: 90, isBkr: false};\n  this.rules[91] = {name: 'space', lower: 'space', index: 91, isBkr: false};\n  this.rules[92] = {name: 'comment', lower: 'comment', index: 92, isBkr: false};\n  this.rules[93] = {name: 'LineEnd', lower: 'lineend', index: 93, isBkr: false};\n  this.rules[94] = {name: 'LineContinue', lower: 'linecontinue', index: 94, isBkr: false};\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* File */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[0].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[0].opcodes[2] = {type: 4, index: 1};// RNM(BlankLine)\n  this.rules[0].opcodes[3] = {type: 4, index: 2};// RNM(Rule)\n  this.rules[0].opcodes[4] = {type: 4, index: 12};// RNM(RuleError)\n\n  /* BlankLine */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = {type: 2, children: [1,5,7]};// CAT\n  this.rules[1].opcodes[1] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[1].opcodes[2] = {type: 1, children: [3,4]};// ALT\n  this.rules[1].opcodes[3] = {type: 6, string: [32]};// TBS\n  this.rules[1].opcodes[4] = {type: 6, string: [9]};// TBS\n  this.rules[1].opcodes[5] = {type: 3, min: 0, max: 1};// REP\n  this.rules[1].opcodes[6] = {type: 4, index: 92};// RNM(comment)\n  this.rules[1].opcodes[7] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* Rule */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = {type: 2, children: [1,2,3,4]};// CAT\n  this.rules[2].opcodes[1] = {type: 4, index: 3};// RNM(RuleLookup)\n  this.rules[2].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[2].opcodes[3] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[2].opcodes[4] = {type: 1, children: [5,8]};// ALT\n  this.rules[2].opcodes[5] = {type: 2, children: [6,7]};// CAT\n  this.rules[2].opcodes[6] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[2].opcodes[7] = {type: 4, index: 93};// RNM(LineEnd)\n  this.rules[2].opcodes[8] = {type: 2, children: [9,10]};// CAT\n  this.rules[2].opcodes[9] = {type: 4, index: 13};// RNM(LineEndError)\n  this.rules[2].opcodes[10] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* RuleLookup */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[3].opcodes[1] = {type: 4, index: 4};// RNM(RuleNameTest)\n  this.rules[3].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[3].opcodes[3] = {type: 4, index: 7};// RNM(DefinedAsTest)\n\n  /* RuleNameTest */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[4].opcodes[1] = {type: 4, index: 5};// RNM(RuleName)\n  this.rules[4].opcodes[2] = {type: 4, index: 6};// RNM(RuleNameError)\n\n  /* RuleName */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* RuleNameError */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[6].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[6].opcodes[2] = {type: 5, min: 33, max: 60};// TRG\n  this.rules[6].opcodes[3] = {type: 5, min: 62, max: 126};// TRG\n\n  /* DefinedAsTest */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[7].opcodes[1] = {type: 4, index: 9};// RNM(DefinedAs)\n  this.rules[7].opcodes[2] = {type: 4, index: 8};// RNM(DefinedAsError)\n\n  /* DefinedAsError */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = {type: 3, min: 1, max: 2};// REP\n  this.rules[8].opcodes[1] = {type: 5, min: 33, max: 126};// TRG\n\n  /* DefinedAs */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[9].opcodes[1] = {type: 4, index: 11};// RNM(IncAlt)\n  this.rules[9].opcodes[2] = {type: 4, index: 10};// RNM(Defined)\n\n  /* Defined */\n  this.rules[10].opcodes = [];\n  this.rules[10].opcodes[0] = {type: 6, string: [61]};// TBS\n\n  /* IncAlt */\n  this.rules[11].opcodes = [];\n  this.rules[11].opcodes[0] = {type: 6, string: [61,47]};// TBS\n\n  /* RuleError */\n  this.rules[12].opcodes = [];\n  this.rules[12].opcodes[0] = {type: 2, children: [1,6]};// CAT\n  this.rules[12].opcodes[1] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[12].opcodes[2] = {type: 1, children: [3,4,5]};// ALT\n  this.rules[12].opcodes[3] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[12].opcodes[4] = {type: 6, string: [9]};// TBS\n  this.rules[12].opcodes[5] = {type: 4, index: 94};// RNM(LineContinue)\n  this.rules[12].opcodes[6] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* LineEndError */\n  this.rules[13].opcodes = [];\n  this.rules[13].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[13].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[13].opcodes[2] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[13].opcodes[3] = {type: 6, string: [9]};// TBS\n  this.rules[13].opcodes[4] = {type: 4, index: 94};// RNM(LineContinue)\n\n  /* Alternation */\n  this.rules[14].opcodes = [];\n  this.rules[14].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[14].opcodes[1] = {type: 4, index: 15};// RNM(Concatenation)\n  this.rules[14].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[14].opcodes[3] = {type: 2, children: [4,5,6]};// CAT\n  this.rules[14].opcodes[4] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[14].opcodes[5] = {type: 4, index: 44};// RNM(AltOp)\n  this.rules[14].opcodes[6] = {type: 4, index: 15};// RNM(Concatenation)\n\n  /* Concatenation */\n  this.rules[15].opcodes = [];\n  this.rules[15].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[15].opcodes[1] = {type: 4, index: 16};// RNM(Repetition)\n  this.rules[15].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[15].opcodes[3] = {type: 2, children: [4,5]};// CAT\n  this.rules[15].opcodes[4] = {type: 4, index: 45};// RNM(CatOp)\n  this.rules[15].opcodes[5] = {type: 4, index: 16};// RNM(Repetition)\n\n  /* Repetition */\n  this.rules[16].opcodes = [];\n  this.rules[16].opcodes[0] = {type: 2, children: [1,3]};// CAT\n  this.rules[16].opcodes[1] = {type: 3, min: 0, max: 1};// REP\n  this.rules[16].opcodes[2] = {type: 4, index: 17};// RNM(Modifier)\n  this.rules[16].opcodes[3] = {type: 1, children: [4,5,6,7]};// ALT\n  this.rules[16].opcodes[4] = {type: 4, index: 21};// RNM(Group)\n  this.rules[16].opcodes[5] = {type: 4, index: 25};// RNM(Option)\n  this.rules[16].opcodes[6] = {type: 4, index: 19};// RNM(BasicElement)\n  this.rules[16].opcodes[7] = {type: 4, index: 20};// RNM(BasicElementErr)\n\n  /* Modifier */\n  this.rules[17].opcodes = [];\n  this.rules[17].opcodes[0] = {type: 1, children: [1,5]};// ALT\n  this.rules[17].opcodes[1] = {type: 2, children: [2,3]};// CAT\n  this.rules[17].opcodes[2] = {type: 4, index: 18};// RNM(Predicate)\n  this.rules[17].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[17].opcodes[4] = {type: 4, index: 43};// RNM(RepOp)\n  this.rules[17].opcodes[5] = {type: 4, index: 43};// RNM(RepOp)\n\n  /* Predicate */\n  this.rules[18].opcodes = [];\n  this.rules[18].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[18].opcodes[1] = {type: 4, index: 49};// RNM(BkaOp)\n  this.rules[18].opcodes[2] = {type: 4, index: 50};// RNM(BknOp)\n  this.rules[18].opcodes[3] = {type: 4, index: 47};// RNM(AndOp)\n  this.rules[18].opcodes[4] = {type: 4, index: 48};// RNM(NotOp)\n\n  /* BasicElement */\n  this.rules[19].opcodes = [];\n  this.rules[19].opcodes[0] = {type: 1, children: [1,2,3,4,5,6,7,8,9,10]};// ALT\n  this.rules[19].opcodes[1] = {type: 4, index: 40};// RNM(UdtOp)\n  this.rules[19].opcodes[2] = {type: 4, index: 29};// RNM(RnmOp)\n  this.rules[19].opcodes[3] = {type: 4, index: 53};// RNM(TrgOp)\n  this.rules[19].opcodes[4] = {type: 4, index: 54};// RNM(TbsOp)\n  this.rules[19].opcodes[5] = {type: 4, index: 55};// RNM(TlsOp)\n  this.rules[19].opcodes[6] = {type: 4, index: 61};// RNM(ClsOp)\n  this.rules[19].opcodes[7] = {type: 4, index: 30};// RNM(BkrOp)\n  this.rules[19].opcodes[8] = {type: 4, index: 51};// RNM(AbgOp)\n  this.rules[19].opcodes[9] = {type: 4, index: 52};// RNM(AenOp)\n  this.rules[19].opcodes[10] = {type: 4, index: 65};// RNM(ProsVal)\n\n  /* BasicElementErr */\n  this.rules[20].opcodes = [];\n  this.rules[20].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[20].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[20].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[20].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[20].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[20].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* Group */\n  this.rules[21].opcodes = [];\n  this.rules[21].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[21].opcodes[1] = {type: 4, index: 23};// RNM(GroupOpen)\n  this.rules[21].opcodes[2] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[21].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[21].opcodes[4] = {type: 4, index: 24};// RNM(GroupClose)\n  this.rules[21].opcodes[5] = {type: 4, index: 22};// RNM(GroupError)\n\n  /* GroupError */\n  this.rules[22].opcodes = [];\n  this.rules[22].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[22].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[22].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[22].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[22].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[22].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* GroupOpen */\n  this.rules[23].opcodes = [];\n  this.rules[23].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[23].opcodes[1] = {type: 6, string: [40]};// TBS\n  this.rules[23].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* GroupClose */\n  this.rules[24].opcodes = [];\n  this.rules[24].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[24].opcodes[1] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[24].opcodes[2] = {type: 6, string: [41]};// TBS\n\n  /* Option */\n  this.rules[25].opcodes = [];\n  this.rules[25].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[25].opcodes[1] = {type: 4, index: 27};// RNM(OptionOpen)\n  this.rules[25].opcodes[2] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[25].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[25].opcodes[4] = {type: 4, index: 28};// RNM(OptionClose)\n  this.rules[25].opcodes[5] = {type: 4, index: 26};// RNM(OptionError)\n\n  /* OptionError */\n  this.rules[26].opcodes = [];\n  this.rules[26].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[26].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[26].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[26].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[26].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[26].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* OptionOpen */\n  this.rules[27].opcodes = [];\n  this.rules[27].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[27].opcodes[1] = {type: 6, string: [91]};// TBS\n  this.rules[27].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* OptionClose */\n  this.rules[28].opcodes = [];\n  this.rules[28].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[28].opcodes[1] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[28].opcodes[2] = {type: 6, string: [93]};// TBS\n\n  /* RnmOp */\n  this.rules[29].opcodes = [];\n  this.rules[29].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* BkrOp */\n  this.rules[30].opcodes = [];\n  this.rules[30].opcodes[0] = {type: 2, children: [1,2,4]};// CAT\n  this.rules[30].opcodes[1] = {type: 6, string: [92]};// TBS\n  this.rules[30].opcodes[2] = {type: 3, min: 0, max: 1};// REP\n  this.rules[30].opcodes[3] = {type: 4, index: 31};// RNM(bkrModifier)\n  this.rules[30].opcodes[4] = {type: 4, index: 36};// RNM(bkr-name)\n\n  /* bkrModifier */\n  this.rules[31].opcodes = [];\n  this.rules[31].opcodes[0] = {type: 1, children: [1,7,13,19]};// ALT\n  this.rules[31].opcodes[1] = {type: 2, children: [2,3]};// CAT\n  this.rules[31].opcodes[2] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[4] = {type: 1, children: [5,6]};// ALT\n  this.rules[31].opcodes[5] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[6] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[7] = {type: 2, children: [8,9]};// CAT\n  this.rules[31].opcodes[8] = {type: 4, index: 33};// RNM(ci)\n  this.rules[31].opcodes[9] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[10] = {type: 1, children: [11,12]};// ALT\n  this.rules[31].opcodes[11] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[12] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[13] = {type: 2, children: [14,15]};// CAT\n  this.rules[31].opcodes[14] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[15] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[16] = {type: 1, children: [17,18]};// ALT\n  this.rules[31].opcodes[17] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[18] = {type: 4, index: 33};// RNM(ci)\n  this.rules[31].opcodes[19] = {type: 2, children: [20,21]};// CAT\n  this.rules[31].opcodes[20] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[21] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[22] = {type: 1, children: [23,24]};// ALT\n  this.rules[31].opcodes[23] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[24] = {type: 4, index: 33};// RNM(ci)\n\n  /* cs */\n  this.rules[32].opcodes = [];\n  this.rules[32].opcodes[0] = {type: 6, string: [37,115]};// TBS\n\n  /* ci */\n  this.rules[33].opcodes = [];\n  this.rules[33].opcodes[0] = {type: 6, string: [37,105]};// TBS\n\n  /* um */\n  this.rules[34].opcodes = [];\n  this.rules[34].opcodes[0] = {type: 6, string: [37,117]};// TBS\n\n  /* pm */\n  this.rules[35].opcodes = [];\n  this.rules[35].opcodes[0] = {type: 6, string: [37,112]};// TBS\n\n  /* bkr-name */\n  this.rules[36].opcodes = [];\n  this.rules[36].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[36].opcodes[1] = {type: 4, index: 38};// RNM(uname)\n  this.rules[36].opcodes[2] = {type: 4, index: 39};// RNM(ename)\n  this.rules[36].opcodes[3] = {type: 4, index: 37};// RNM(rname)\n\n  /* rname */\n  this.rules[37].opcodes = [];\n  this.rules[37].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* uname */\n  this.rules[38].opcodes = [];\n  this.rules[38].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[38].opcodes[1] = {type: 6, string: [117,95]};// TBS\n  this.rules[38].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* ename */\n  this.rules[39].opcodes = [];\n  this.rules[39].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[39].opcodes[1] = {type: 6, string: [101,95]};// TBS\n  this.rules[39].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* UdtOp */\n  this.rules[40].opcodes = [];\n  this.rules[40].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[40].opcodes[1] = {type: 4, index: 42};// RNM(udt-empty)\n  this.rules[40].opcodes[2] = {type: 4, index: 41};// RNM(udt-non-empty)\n\n  /* udt-non-empty */\n  this.rules[41].opcodes = [];\n  this.rules[41].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[41].opcodes[1] = {type: 6, string: [117,95]};// TBS\n  this.rules[41].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* udt-empty */\n  this.rules[42].opcodes = [];\n  this.rules[42].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[42].opcodes[1] = {type: 6, string: [101,95]};// TBS\n  this.rules[42].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* RepOp */\n  this.rules[43].opcodes = [];\n  this.rules[43].opcodes[0] = {type: 1, children: [1,5,8,11,12]};// ALT\n  this.rules[43].opcodes[1] = {type: 2, children: [2,3,4]};// CAT\n  this.rules[43].opcodes[2] = {type: 4, index: 69};// RNM(rep-min)\n  this.rules[43].opcodes[3] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[4] = {type: 4, index: 71};// RNM(rep-max)\n  this.rules[43].opcodes[5] = {type: 2, children: [6,7]};// CAT\n  this.rules[43].opcodes[6] = {type: 4, index: 69};// RNM(rep-min)\n  this.rules[43].opcodes[7] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[8] = {type: 2, children: [9,10]};// CAT\n  this.rules[43].opcodes[9] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[10] = {type: 4, index: 71};// RNM(rep-max)\n  this.rules[43].opcodes[11] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[12] = {type: 4, index: 70};// RNM(rep-min-max)\n\n  /* AltOp */\n  this.rules[44].opcodes = [];\n  this.rules[44].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[44].opcodes[1] = {type: 6, string: [47]};// TBS\n  this.rules[44].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* CatOp */\n  this.rules[45].opcodes = [];\n  this.rules[45].opcodes[0] = {type: 4, index: 90};// RNM(wsp)\n\n  /* StarOp */\n  this.rules[46].opcodes = [];\n  this.rules[46].opcodes[0] = {type: 6, string: [42]};// TBS\n\n  /* AndOp */\n  this.rules[47].opcodes = [];\n  this.rules[47].opcodes[0] = {type: 6, string: [38]};// TBS\n\n  /* NotOp */\n  this.rules[48].opcodes = [];\n  this.rules[48].opcodes[0] = {type: 6, string: [33]};// TBS\n\n  /* BkaOp */\n  this.rules[49].opcodes = [];\n  this.rules[49].opcodes[0] = {type: 6, string: [38,38]};// TBS\n\n  /* BknOp */\n  this.rules[50].opcodes = [];\n  this.rules[50].opcodes[0] = {type: 6, string: [33,33]};// TBS\n\n  /* AbgOp */\n  this.rules[51].opcodes = [];\n  this.rules[51].opcodes[0] = {type: 6, string: [37,94]};// TBS\n\n  /* AenOp */\n  this.rules[52].opcodes = [];\n  this.rules[52].opcodes[0] = {type: 6, string: [37,36]};// TBS\n\n  /* TrgOp */\n  this.rules[53].opcodes = [];\n  this.rules[53].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[53].opcodes[1] = {type: 6, string: [37]};// TBS\n  this.rules[53].opcodes[2] = {type: 1, children: [3,8,13]};// ALT\n  this.rules[53].opcodes[3] = {type: 2, children: [4,5,6,7]};// CAT\n  this.rules[53].opcodes[4] = {type: 4, index: 76};// RNM(Dec)\n  this.rules[53].opcodes[5] = {type: 4, index: 79};// RNM(dmin)\n  this.rules[53].opcodes[6] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[7] = {type: 4, index: 80};// RNM(dmax)\n  this.rules[53].opcodes[8] = {type: 2, children: [9,10,11,12]};// CAT\n  this.rules[53].opcodes[9] = {type: 4, index: 77};// RNM(Hex)\n  this.rules[53].opcodes[10] = {type: 4, index: 83};// RNM(xmin)\n  this.rules[53].opcodes[11] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[12] = {type: 4, index: 84};// RNM(xmax)\n  this.rules[53].opcodes[13] = {type: 2, children: [14,15,16,17]};// CAT\n  this.rules[53].opcodes[14] = {type: 4, index: 78};// RNM(Bin)\n  this.rules[53].opcodes[15] = {type: 4, index: 81};// RNM(bmin)\n  this.rules[53].opcodes[16] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[17] = {type: 4, index: 82};// RNM(bmax)\n\n  /* TbsOp */\n  this.rules[54].opcodes = [];\n  this.rules[54].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[54].opcodes[1] = {type: 6, string: [37]};// TBS\n  this.rules[54].opcodes[2] = {type: 1, children: [3,10,17]};// ALT\n  this.rules[54].opcodes[3] = {type: 2, children: [4,5,6]};// CAT\n  this.rules[54].opcodes[4] = {type: 4, index: 76};// RNM(Dec)\n  this.rules[54].opcodes[5] = {type: 4, index: 73};// RNM(dString)\n  this.rules[54].opcodes[6] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[7] = {type: 2, children: [8,9]};// CAT\n  this.rules[54].opcodes[8] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[9] = {type: 4, index: 73};// RNM(dString)\n  this.rules[54].opcodes[10] = {type: 2, children: [11,12,13]};// CAT\n  this.rules[54].opcodes[11] = {type: 4, index: 77};// RNM(Hex)\n  this.rules[54].opcodes[12] = {type: 4, index: 74};// RNM(xString)\n  this.rules[54].opcodes[13] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[14] = {type: 2, children: [15,16]};// CAT\n  this.rules[54].opcodes[15] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[16] = {type: 4, index: 74};// RNM(xString)\n  this.rules[54].opcodes[17] = {type: 2, children: [18,19,20]};// CAT\n  this.rules[54].opcodes[18] = {type: 4, index: 78};// RNM(Bin)\n  this.rules[54].opcodes[19] = {type: 4, index: 75};// RNM(bString)\n  this.rules[54].opcodes[20] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[21] = {type: 2, children: [22,23]};// CAT\n  this.rules[54].opcodes[22] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[23] = {type: 4, index: 75};// RNM(bString)\n\n  /* TlsOp */\n  this.rules[55].opcodes = [];\n  this.rules[55].opcodes[0] = {type: 2, children: [1,2,3,4]};// CAT\n  this.rules[55].opcodes[1] = {type: 4, index: 56};// RNM(TlsCase)\n  this.rules[55].opcodes[2] = {type: 4, index: 57};// RNM(TlsOpen)\n  this.rules[55].opcodes[3] = {type: 4, index: 59};// RNM(TlsString)\n  this.rules[55].opcodes[4] = {type: 4, index: 58};// RNM(TlsClose)\n\n  /* TlsCase */\n  this.rules[56].opcodes = [];\n  this.rules[56].opcodes[0] = {type: 3, min: 0, max: 1};// REP\n  this.rules[56].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[56].opcodes[2] = {type: 7, string: [37,105]};// TLS\n  this.rules[56].opcodes[3] = {type: 7, string: [37,115]};// TLS\n\n  /* TlsOpen */\n  this.rules[57].opcodes = [];\n  this.rules[57].opcodes[0] = {type: 6, string: [34]};// TBS\n\n  /* TlsClose */\n  this.rules[58].opcodes = [];\n  this.rules[58].opcodes[0] = {type: 6, string: [34]};// TBS\n\n  /* TlsString */\n  this.rules[59].opcodes = [];\n  this.rules[59].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[59].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[59].opcodes[2] = {type: 5, min: 32, max: 33};// TRG\n  this.rules[59].opcodes[3] = {type: 5, min: 35, max: 126};// TRG\n  this.rules[59].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* StringTab */\n  this.rules[60].opcodes = [];\n  this.rules[60].opcodes[0] = {type: 6, string: [9]};// TBS\n\n  /* ClsOp */\n  this.rules[61].opcodes = [];\n  this.rules[61].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[61].opcodes[1] = {type: 4, index: 62};// RNM(ClsOpen)\n  this.rules[61].opcodes[2] = {type: 4, index: 64};// RNM(ClsString)\n  this.rules[61].opcodes[3] = {type: 4, index: 63};// RNM(ClsClose)\n\n  /* ClsOpen */\n  this.rules[62].opcodes = [];\n  this.rules[62].opcodes[0] = {type: 6, string: [39]};// TBS\n\n  /* ClsClose */\n  this.rules[63].opcodes = [];\n  this.rules[63].opcodes[0] = {type: 6, string: [39]};// TBS\n\n  /* ClsString */\n  this.rules[64].opcodes = [];\n  this.rules[64].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[64].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[64].opcodes[2] = {type: 5, min: 32, max: 38};// TRG\n  this.rules[64].opcodes[3] = {type: 5, min: 40, max: 126};// TRG\n  this.rules[64].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* ProsVal */\n  this.rules[65].opcodes = [];\n  this.rules[65].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[65].opcodes[1] = {type: 4, index: 66};// RNM(ProsValOpen)\n  this.rules[65].opcodes[2] = {type: 4, index: 67};// RNM(ProsValString)\n  this.rules[65].opcodes[3] = {type: 4, index: 68};// RNM(ProsValClose)\n\n  /* ProsValOpen */\n  this.rules[66].opcodes = [];\n  this.rules[66].opcodes[0] = {type: 6, string: [60]};// TBS\n\n  /* ProsValString */\n  this.rules[67].opcodes = [];\n  this.rules[67].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[67].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[67].opcodes[2] = {type: 5, min: 32, max: 61};// TRG\n  this.rules[67].opcodes[3] = {type: 5, min: 63, max: 126};// TRG\n  this.rules[67].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* ProsValClose */\n  this.rules[68].opcodes = [];\n  this.rules[68].opcodes[0] = {type: 6, string: [62]};// TBS\n\n  /* rep-min */\n  this.rules[69].opcodes = [];\n  this.rules[69].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-min-max */\n  this.rules[70].opcodes = [];\n  this.rules[70].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-max */\n  this.rules[71].opcodes = [];\n  this.rules[71].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-num */\n  this.rules[72].opcodes = [];\n  this.rules[72].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[72].opcodes[1] = {type: 5, min: 48, max: 57};// TRG\n\n  /* dString */\n  this.rules[73].opcodes = [];\n  this.rules[73].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* xString */\n  this.rules[74].opcodes = [];\n  this.rules[74].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* bString */\n  this.rules[75].opcodes = [];\n  this.rules[75].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* Dec */\n  this.rules[76].opcodes = [];\n  this.rules[76].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[76].opcodes[1] = {type: 6, string: [68]};// TBS\n  this.rules[76].opcodes[2] = {type: 6, string: [100]};// TBS\n\n  /* Hex */\n  this.rules[77].opcodes = [];\n  this.rules[77].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[77].opcodes[1] = {type: 6, string: [88]};// TBS\n  this.rules[77].opcodes[2] = {type: 6, string: [120]};// TBS\n\n  /* Bin */\n  this.rules[78].opcodes = [];\n  this.rules[78].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[78].opcodes[1] = {type: 6, string: [66]};// TBS\n  this.rules[78].opcodes[2] = {type: 6, string: [98]};// TBS\n\n  /* dmin */\n  this.rules[79].opcodes = [];\n  this.rules[79].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* dmax */\n  this.rules[80].opcodes = [];\n  this.rules[80].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* bmin */\n  this.rules[81].opcodes = [];\n  this.rules[81].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* bmax */\n  this.rules[82].opcodes = [];\n  this.rules[82].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* xmin */\n  this.rules[83].opcodes = [];\n  this.rules[83].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* xmax */\n  this.rules[84].opcodes = [];\n  this.rules[84].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* dnum */\n  this.rules[85].opcodes = [];\n  this.rules[85].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[85].opcodes[1] = {type: 5, min: 48, max: 57};// TRG\n\n  /* bnum */\n  this.rules[86].opcodes = [];\n  this.rules[86].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[86].opcodes[1] = {type: 5, min: 48, max: 49};// TRG\n\n  /* xnum */\n  this.rules[87].opcodes = [];\n  this.rules[87].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[87].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[87].opcodes[2] = {type: 5, min: 48, max: 57};// TRG\n  this.rules[87].opcodes[3] = {type: 5, min: 65, max: 70};// TRG\n  this.rules[87].opcodes[4] = {type: 5, min: 97, max: 102};// TRG\n\n  /* alphanum */\n  this.rules[88].opcodes = [];\n  this.rules[88].opcodes[0] = {type: 2, children: [1,4]};// CAT\n  this.rules[88].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[88].opcodes[2] = {type: 5, min: 97, max: 122};// TRG\n  this.rules[88].opcodes[3] = {type: 5, min: 65, max: 90};// TRG\n  this.rules[88].opcodes[4] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[88].opcodes[5] = {type: 1, children: [6,7,8,9]};// ALT\n  this.rules[88].opcodes[6] = {type: 5, min: 97, max: 122};// TRG\n  this.rules[88].opcodes[7] = {type: 5, min: 65, max: 90};// TRG\n  this.rules[88].opcodes[8] = {type: 5, min: 48, max: 57};// TRG\n  this.rules[88].opcodes[9] = {type: 6, string: [45]};// TBS\n\n  /* owsp */\n  this.rules[89].opcodes = [];\n  this.rules[89].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[89].opcodes[1] = {type: 4, index: 91};// RNM(space)\n\n  /* wsp */\n  this.rules[90].opcodes = [];\n  this.rules[90].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[90].opcodes[1] = {type: 4, index: 91};// RNM(space)\n\n  /* space */\n  this.rules[91].opcodes = [];\n  this.rules[91].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[91].opcodes[1] = {type: 6, string: [32]};// TBS\n  this.rules[91].opcodes[2] = {type: 6, string: [9]};// TBS\n  this.rules[91].opcodes[3] = {type: 4, index: 92};// RNM(comment)\n  this.rules[91].opcodes[4] = {type: 4, index: 94};// RNM(LineContinue)\n\n  /* comment */\n  this.rules[92].opcodes = [];\n  this.rules[92].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[92].opcodes[1] = {type: 6, string: [59]};// TBS\n  this.rules[92].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[92].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[92].opcodes[4] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[92].opcodes[5] = {type: 6, string: [9]};// TBS\n\n  /* LineEnd */\n  this.rules[93].opcodes = [];\n  this.rules[93].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[93].opcodes[1] = {type: 6, string: [13,10]};// TBS\n  this.rules[93].opcodes[2] = {type: 6, string: [10]};// TBS\n  this.rules[93].opcodes[3] = {type: 6, string: [13]};// TBS\n\n  /* LineContinue */\n  this.rules[94].opcodes = [];\n  this.rules[94].opcodes[0] = {type: 2, children: [1,5]};// CAT\n  this.rules[94].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[94].opcodes[2] = {type: 6, string: [13,10]};// TBS\n  this.rules[94].opcodes[3] = {type: 6, string: [10]};// TBS\n  this.rules[94].opcodes[4] = {type: 6, string: [13]};// TBS\n  this.rules[94].opcodes[5] = {type: 1, children: [6,7]};// ALT\n  this.rules[94].opcodes[6] = {type: 6, string: [32]};// TBS\n  this.rules[94].opcodes[7] = {type: 6, string: [9]};// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \";\\n\";\n    str += \"; ABNF for JavaScript APG 2.0 SABNF\\n\";\n    str += \"; RFC 5234 with some restrictions and additions.\\n\";\n    str += \"; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\\n\";\n    str += \";  - accepts %s\\\"string\\\" as a case-sensitive string\\n\";\n    str += \";  - accepts %i\\\"string\\\" as a case-insensitive string\\n\";\n    str += \";  - accepts \\\"string\\\" as a case-insensitive string\\n\";\n    str += \";\\n\";\n    str += \"; Some restrictions:\\n\";\n    str += \";   1. Rules must begin at first character of each line.\\n\";\n    str += \";      Indentations on first rule and rules thereafter are not allowed.\\n\";\n    str += \";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\\n\";\n    str += \";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\\n\";\n    str += \";      However, a working parser cannot be generated from them.\\n\";\n    str += \";\\n\";\n    str += \"; Super set (SABNF) additions:\\n\";\n    str += \";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\\n\";\n    str += \";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\\n\";\n    str += \";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\\n\";\n    str += \";      e.g. &%d13 or &rule or !(A / B)\\n\";\n    str += \";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\\n\";\n    str += \";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\\n\";\n    str += \";      u_name may be used as an element but no rule definition is given.\\n\";\n    str += \";      e.g. rule = A / u_myUdt\\n\";\n    str += \";           A = \\\"a\\\"\\n\";\n    str += \";      would be a valid grammar.\\n\";\n    str += \";   3. Case-sensitive, single-quoted strings are accepted.\\n\";\n    str += \";      e.g. 'abc' would be equivalent to %d97.98.99\\n\";\n    str += \";      (kept for backward compatibility, but superseded by %s\\\"abc\\\")  \\n\";\n    str += \"; New 12/26/2015\\n\";\n    str += \";   4. Look-behind operators are accepted as element prefixes.\\n\";\n    str += \";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\\n\";\n    str += \";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\\n\";\n    str += \";      e.g. &&%d13 or &&rule or !!(A / B)\\n\";\n    str += \";   5. Back reference operators, i.e. \\\\rulename, are accepted.\\n\";\n    str += \";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\\n\";\n    str += \";      to match is a phrase previously matched by the rule 'rulename'.\\n\";\n    str += \";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\\n\";\n    str += \";      In universal mode, \\\\rulename matches the last match to 'rulename' regardless of where it was found.\\n\";\n    str += \";      In parent-frame mode, \\\\rulename matches only the last match found on the parent's frame or parse tree level.\\n\";\n    str += \";      Back reference modifiers can be used to specify case and mode.\\n\";\n    str += \";      \\\\A defaults to case-insensitive and universal mode, e.g. \\\\A === \\\\%i%uA\\n\";\n    str += \";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\\n\";\n    str += \";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\\n\";\n    str += \";      Case and mode modifiers can appear in any order, e.g. \\\\%s%pA === \\\\%p%sA. \\n\";\n    str += \";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";   8. String end anchor, AEN(%$) matches the end of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";\\n\";\n    str += \"File            = *(BlankLine / Rule / RuleError)\\n\";\n    str += \"BlankLine       = *(%d32/%d9) [comment] LineEnd\\n\";\n    str += \"Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\\n\";\n    str += \"                / (LineEndError LineEnd))\\n\";\n    str += \"RuleLookup      = RuleNameTest owsp DefinedAsTest\\n\";\n    str += \"RuleNameTest    = RuleName/RuleNameError\\n\";\n    str += \"RuleName        = alphanum\\n\";\n    str += \"RuleNameError   = 1*(%d33-60/%d62-126)\\n\";\n    str += \"DefinedAsTest   = DefinedAs / DefinedAsError\\n\";\n    str += \"DefinedAsError  = 1*2%d33-126\\n\";\n    str += \"DefinedAs       = IncAlt / Defined\\n\";\n    str += \"Defined         = %d61\\n\";\n    str += \"IncAlt          = %d61.47\\n\";\n    str += \"RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\\n\";\n    str += \"LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\\n\";\n    str += \"Alternation     = Concatenation *(owsp AltOp Concatenation)\\n\";\n    str += \"Concatenation   = Repetition *(CatOp Repetition)\\n\";\n    str += \"Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\\n\";\n    str += \"Modifier        = (Predicate [RepOp])\\n\";\n    str += \"                / RepOp\\n\";\n    str += \"Predicate       = BkaOp\\n\";\n    str += \"                / BknOp\\n\";\n    str += \"                / AndOp\\n\";\n    str += \"                / NotOp\\n\";\n    str += \"BasicElement    = UdtOp\\n\";\n    str += \"                / RnmOp\\n\";\n    str += \"                / TrgOp\\n\";\n    str += \"                / TbsOp\\n\";\n    str += \"                / TlsOp\\n\";\n    str += \"                / ClsOp\\n\";\n    str += \"                / BkrOp\\n\";\n    str += \"                / AbgOp\\n\";\n    str += \"                / AenOp\\n\";\n    str += \"                / ProsVal\\n\";\n    str += \"BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\\n\";\n    str += \"Group           = GroupOpen  Alternation (GroupClose / GroupError)\\n\";\n    str += \"GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"GroupOpen       = %d40 owsp\\n\";\n    str += \"GroupClose      = owsp %d41\\n\";\n    str += \"Option          = OptionOpen Alternation (OptionClose / OptionError)\\n\";\n    str += \"OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"OptionOpen      = %d91 owsp\\n\";\n    str += \"OptionClose     = owsp %d93\\n\";\n    str += \"RnmOp           = alphanum\\n\";\n    str += \"BkrOp           = %d92 [bkrModifier] bkr-name\\n\";\n    str += \"bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\\n\";\n    str += \"cs              = '%s'\\n\";\n    str += \"ci              = '%i'\\n\";\n    str += \"um              = '%u'\\n\";\n    str += \"pm              = '%p'\\n\";\n    str += \"bkr-name        = uname / ename / rname\\n\";\n    str += \"rname           = alphanum\\n\";\n    str += \"uname           = %d117.95 alphanum\\n\";\n    str += \"ename           = %d101.95 alphanum\\n\";\n    str += \"UdtOp           = udt-empty\\n\";\n    str += \"                / udt-non-empty\\n\";\n    str += \"udt-non-empty   = %d117.95 alphanum\\n\";\n    str += \"udt-empty       = %d101.95 alphanum\\n\";\n    str += \"RepOp           = (rep-min StarOp rep-max)\\n\";\n    str += \"                / (rep-min StarOp)\\n\";\n    str += \"                / (StarOp rep-max)\\n\";\n    str += \"                / StarOp\\n\";\n    str += \"                / rep-min-max\\n\";\n    str += \"AltOp           = %d47 owsp\\n\";\n    str += \"CatOp           = wsp\\n\";\n    str += \"StarOp          = %d42\\n\";\n    str += \"AndOp           = %d38\\n\";\n    str += \"NotOp           = %d33\\n\";\n    str += \"BkaOp           = %d38.38\\n\";\n    str += \"BknOp           = %d33.33\\n\";\n    str += \"AbgOp           = %d37.94\\n\";\n    str += \"AenOp           = %d37.36\\n\";\n    str += \"TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\\n\";\n    str += \"TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\\n\";\n    str += \"TlsOp           = TlsCase TlsOpen TlsString TlsClose\\n\";\n    str += \"TlsCase         = [\\\"%i\\\" / \\\"%s\\\"]\\n\";\n    str += \"TlsOpen         = %d34\\n\";\n    str += \"TlsClose        = %d34\\n\";\n    str += \"TlsString       = *(%d32-33/%d35-126/StringTab)\\n\";\n    str += \"StringTab       = %d9\\n\";\n    str += \"ClsOp           = ClsOpen ClsString ClsClose\\n\";\n    str += \"ClsOpen         = %d39\\n\";\n    str += \"ClsClose        = %d39\\n\";\n    str += \"ClsString       = *(%d32-38/%d40-126/StringTab)\\n\";\n    str += \"ProsVal         = ProsValOpen ProsValString ProsValClose\\n\";\n    str += \"ProsValOpen     = %d60\\n\";\n    str += \"ProsValString   = *(%d32-61/%d63-126/StringTab)\\n\";\n    str += \"ProsValClose    = %d62\\n\";\n    str += \"rep-min         = rep-num\\n\";\n    str += \"rep-min-max     = rep-num\\n\";\n    str += \"rep-max         = rep-num\\n\";\n    str += \"rep-num         = 1*(%d48-57)\\n\";\n    str += \"dString         = dnum\\n\";\n    str += \"xString         = xnum\\n\";\n    str += \"bString         = bnum\\n\";\n    str += \"Dec             = (%d68/%d100)\\n\";\n    str += \"Hex             = (%d88/%d120)\\n\";\n    str += \"Bin             = (%d66/%d98)\\n\";\n    str += \"dmin            = dnum\\n\";\n    str += \"dmax            = dnum\\n\";\n    str += \"bmin            = bnum\\n\";\n    str += \"bmax            = bnum\\n\";\n    str += \"xmin            = xnum\\n\";\n    str += \"xmax            = xnum\\n\";\n    str += \"dnum            = 1*(%d48-57)\\n\";\n    str += \"bnum            = 1*%d48-49\\n\";\n    str += \"xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\\n\";\n    str += \";\\n\";\n    str += \"; Basics\\n\";\n    str += \"alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\\n\";\n    str += \"owsp            = *space\\n\";\n    str += \"wsp             = 1*space\\n\";\n    str += \"space           = %d32\\n\";\n    str += \"                / %d9\\n\";\n    str += \"                / comment\\n\";\n    str += \"                / LineContinue\\n\";\n    str += \"comment         = %d59 *(%d32-126 / %d9)\\n\";\n    str += \"LineEnd         = %d13.10\\n\";\n    str += \"                / %d10\\n\";\n    str += \"                / %d13\\n\";\n    str += \"LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\\n\";\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NhYm5mLWdyYW1tYXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixv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QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zYWJuZi1ncmFtbWFyLmpzP2FlNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjMgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZDxicj5cbi8vICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSk8YnI+XG4vL1xuLy8gR2VuZXJhdGVkIGJ5IGFwZy1qcywgVmVyc2lvbiA0LjIuMSBbYXBnLWpzXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBncmFtbWFyKCl7XG4gIC8vIGBgYFxuICAvLyBTVU1NQVJZXG4gIC8vICAgICAgcnVsZXMgPSA5NVxuICAvLyAgICAgICB1ZHRzID0gMFxuICAvLyAgICBvcGNvZGVzID0gMzcyXG4gIC8vICAgICAgICAtLS0gICBBQk5GIG9yaWdpbmFsIG9wY29kZXNcbiAgLy8gICAgICAgIEFMVCA9IDQzXG4gIC8vICAgICAgICBDQVQgPSA0OFxuICAvLyAgICAgICAgUkVQID0gMzRcbiAgLy8gICAgICAgIFJOTSA9IDE0OVxuICAvLyAgICAgICAgVExTID0gMlxuICAvLyAgICAgICAgVEJTID0gNjFcbiAgLy8gICAgICAgIFRSRyA9IDM1XG4gIC8vICAgICAgICAtLS0gICBTQUJORiBzdXBlcnNldCBvcGNvZGVzXG4gIC8vICAgICAgICBVRFQgPSAwXG4gIC8vICAgICAgICBBTkQgPSAwXG4gIC8vICAgICAgICBOT1QgPSAwXG4gIC8vICAgICAgICBCS0EgPSAwXG4gIC8vICAgICAgICBCS04gPSAwXG4gIC8vICAgICAgICBCS1IgPSAwXG4gIC8vICAgICAgICBBQkcgPSAwXG4gIC8vICAgICAgICBBRU4gPSAwXG4gIC8vIGNoYXJhY3RlcnMgPSBbOSAtIDEyNl1cbiAgLy8gYGBgXG4gIC8qIE9CSkVDVCBJREVOVElGSUVSIChmb3IgaW50ZXJuYWwgcGFyc2VyIHVzZSkgKi9cbiAgdGhpcy5ncmFtbWFyT2JqZWN0ID0gJ2dyYW1tYXJPYmplY3QnO1xuXG4gIC8qIFJVTEVTICovXG4gIHRoaXMucnVsZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1swXSA9IHtuYW1lOiAnRmlsZScsIGxvd2VyOiAnZmlsZScsIGluZGV4OiAwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzFdID0ge25hbWU6ICdCbGFua0xpbmUnLCBsb3dlcjogJ2JsYW5rbGluZScsIGluZGV4OiAxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzJdID0ge25hbWU6ICdSdWxlJywgbG93ZXI6ICdydWxlJywgaW5kZXg6IDIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbM10gPSB7bmFtZTogJ1J1bGVMb29rdXAnLCBsb3dlcjogJ3J1bGVsb29rdXAnLCBpbmRleDogMywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s0XSA9IHtuYW1lOiAnUnVsZU5hbWVUZXN0JywgbG93ZXI6ICdydWxlbmFtZXRlc3QnLCBpbmRleDogNCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1XSA9IHtuYW1lOiAnUnVsZU5hbWUnLCBsb3dlcjogJ3J1bGVuYW1lJywgaW5kZXg6IDUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNl0gPSB7bmFtZTogJ1J1bGVOYW1lRXJyb3InLCBsb3dlcjogJ3J1bGVuYW1lZXJyb3InLCBpbmRleDogNiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3XSA9IHtuYW1lOiAnRGVmaW5lZEFzVGVzdCcsIGxvd2VyOiAnZGVmaW5lZGFzdGVzdCcsIGluZGV4OiA3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzhdID0ge25hbWU6ICdEZWZpbmVkQXNFcnJvcicsIGxvd2VyOiAnZGVmaW5lZGFzZXJyb3InLCBpbmRleDogOCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5XSA9IHtuYW1lOiAnRGVmaW5lZEFzJywgbG93ZXI6ICdkZWZpbmVkYXMnLCBpbmRleDogOSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxMF0gPSB7bmFtZTogJ0RlZmluZWQnLCBsb3dlcjogJ2RlZmluZWQnLCBpbmRleDogMTAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTFdID0ge25hbWU6ICdJbmNBbHQnLCBsb3dlcjogJ2luY2FsdCcsIGluZGV4OiAxMSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxMl0gPSB7bmFtZTogJ1J1bGVFcnJvcicsIGxvd2VyOiAncnVsZWVycm9yJywgaW5kZXg6IDEyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzEzXSA9IHtuYW1lOiAnTGluZUVuZEVycm9yJywgbG93ZXI6ICdsaW5lZW5kZXJyb3InLCBpbmRleDogMTMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTRdID0ge25hbWU6ICdBbHRlcm5hdGlvbicsIGxvd2VyOiAnYWx0ZXJuYXRpb24nLCBpbmRleDogMTQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTVdID0ge25hbWU6ICdDb25jYXRlbmF0aW9uJywgbG93ZXI6ICdjb25jYXRlbmF0aW9uJywgaW5kZXg6IDE1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzE2XSA9IHtuYW1lOiAnUmVwZXRpdGlvbicsIGxvd2VyOiAncmVwZXRpdGlvbicsIGluZGV4OiAxNiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxN10gPSB7bmFtZTogJ01vZGlmaWVyJywgbG93ZXI6ICdtb2RpZmllcicsIGluZGV4OiAxNywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxOF0gPSB7bmFtZTogJ1ByZWRpY2F0ZScsIGxvd2VyOiAncHJlZGljYXRlJywgaW5kZXg6IDE4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzE5XSA9IHtuYW1lOiAnQmFzaWNFbGVtZW50JywgbG93ZXI6ICdiYXNpY2VsZW1lbnQnLCBpbmRleDogMTksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjBdID0ge25hbWU6ICdCYXNpY0VsZW1lbnRFcnInLCBsb3dlcjogJ2Jhc2ljZWxlbWVudGVycicsIGluZGV4OiAyMCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syMV0gPSB7bmFtZTogJ0dyb3VwJywgbG93ZXI6ICdncm91cCcsIGluZGV4OiAyMSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syMl0gPSB7bmFtZTogJ0dyb3VwRXJyb3InLCBsb3dlcjogJ2dyb3VwZXJyb3InLCBpbmRleDogMjIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjNdID0ge25hbWU6ICdHcm91cE9wZW4nLCBsb3dlcjogJ2dyb3Vwb3BlbicsIGluZGV4OiAyMywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syNF0gPSB7bmFtZTogJ0dyb3VwQ2xvc2UnLCBsb3dlcjogJ2dyb3VwY2xvc2UnLCBpbmRleDogMjQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjVdID0ge25hbWU6ICdPcHRpb24nLCBsb3dlcjogJ29wdGlvbicsIGluZGV4OiAyNSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syNl0gPSB7bmFtZTogJ09wdGlvbkVycm9yJywgbG93ZXI6ICdvcHRpb25lcnJvcicsIGluZGV4OiAyNiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syN10gPSB7bmFtZTogJ09wdGlvbk9wZW4nLCBsb3dlcjogJ29wdGlvbm9wZW4nLCBpbmRleDogMjcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjhdID0ge25hbWU6ICdPcHRpb25DbG9zZScsIGxvd2VyOiAnb3B0aW9uY2xvc2UnLCBpbmRleDogMjgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjldID0ge25hbWU6ICdSbm1PcCcsIGxvd2VyOiAncm5tb3AnLCBpbmRleDogMjksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzBdID0ge25hbWU6ICdCa3JPcCcsIGxvd2VyOiAnYmtyb3AnLCBpbmRleDogMzAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzFdID0ge25hbWU6ICdia3JNb2RpZmllcicsIGxvd2VyOiAnYmtybW9kaWZpZXInLCBpbmRleDogMzEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzJdID0ge25hbWU6ICdjcycsIGxvd2VyOiAnY3MnLCBpbmRleDogMzIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzNdID0ge25hbWU6ICdjaScsIGxvd2VyOiAnY2knLCBpbmRleDogMzMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzRdID0ge25hbWU6ICd1bScsIGxvd2VyOiAndW0nLCBpbmRleDogMzQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzVdID0ge25hbWU6ICdwbScsIGxvd2VyOiAncG0nLCBpbmRleDogMzUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzZdID0ge25hbWU6ICdia3ItbmFtZScsIGxvd2VyOiAnYmtyLW5hbWUnLCBpbmRleDogMzYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzddID0ge25hbWU6ICdybmFtZScsIGxvd2VyOiAncm5hbWUnLCBpbmRleDogMzcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzhdID0ge25hbWU6ICd1bmFtZScsIGxvd2VyOiAndW5hbWUnLCBpbmRleDogMzgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMzldID0ge25hbWU6ICdlbmFtZScsIGxvd2VyOiAnZW5hbWUnLCBpbmRleDogMzksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDBdID0ge25hbWU6ICdVZHRPcCcsIGxvd2VyOiAndWR0b3AnLCBpbmRleDogNDAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDFdID0ge25hbWU6ICd1ZHQtbm9uLWVtcHR5JywgbG93ZXI6ICd1ZHQtbm9uLWVtcHR5JywgaW5kZXg6IDQxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQyXSA9IHtuYW1lOiAndWR0LWVtcHR5JywgbG93ZXI6ICd1ZHQtZW1wdHknLCBpbmRleDogNDIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDNdID0ge25hbWU6ICdSZXBPcCcsIGxvd2VyOiAncmVwb3AnLCBpbmRleDogNDMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDRdID0ge25hbWU6ICdBbHRPcCcsIGxvd2VyOiAnYWx0b3AnLCBpbmRleDogNDQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDVdID0ge25hbWU6ICdDYXRPcCcsIGxvd2VyOiAnY2F0b3AnLCBpbmRleDogNDUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDZdID0ge25hbWU6ICdTdGFyT3AnLCBsb3dlcjogJ3N0YXJvcCcsIGluZGV4OiA0NiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s0N10gPSB7bmFtZTogJ0FuZE9wJywgbG93ZXI6ICdhbmRvcCcsIGluZGV4OiA0NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s0OF0gPSB7bmFtZTogJ05vdE9wJywgbG93ZXI6ICdub3RvcCcsIGluZGV4OiA0OCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s0OV0gPSB7bmFtZTogJ0JrYU9wJywgbG93ZXI6ICdia2FvcCcsIGluZGV4OiA0OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1MF0gPSB7bmFtZTogJ0Jrbk9wJywgbG93ZXI6ICdia25vcCcsIGluZGV4OiA1MCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1MV0gPSB7bmFtZTogJ0FiZ09wJywgbG93ZXI6ICdhYmdvcCcsIGluZGV4OiA1MSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1Ml0gPSB7bmFtZTogJ0Flbk9wJywgbG93ZXI6ICdhZW5vcCcsIGluZGV4OiA1MiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1M10gPSB7bmFtZTogJ1RyZ09wJywgbG93ZXI6ICd0cmdvcCcsIGluZGV4OiA1MywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1NF0gPSB7bmFtZTogJ1Ric09wJywgbG93ZXI6ICd0YnNvcCcsIGluZGV4OiA1NCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1NV0gPSB7bmFtZTogJ1Rsc09wJywgbG93ZXI6ICd0bHNvcCcsIGluZGV4OiA1NSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1Nl0gPSB7bmFtZTogJ1Rsc0Nhc2UnLCBsb3dlcjogJ3Rsc2Nhc2UnLCBpbmRleDogNTYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTddID0ge25hbWU6ICdUbHNPcGVuJywgbG93ZXI6ICd0bHNvcGVuJywgaW5kZXg6IDU3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzU4XSA9IHtuYW1lOiAnVGxzQ2xvc2UnLCBsb3dlcjogJ3Rsc2Nsb3NlJywgaW5kZXg6IDU4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzU5XSA9IHtuYW1lOiAnVGxzU3RyaW5nJywgbG93ZXI6ICd0bHNzdHJpbmcnLCBpbmRleDogNTksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjBdID0ge25hbWU6ICdTdHJpbmdUYWInLCBsb3dlcjogJ3N0cmluZ3RhYicsIGluZGV4OiA2MCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s2MV0gPSB7bmFtZTogJ0Nsc09wJywgbG93ZXI6ICdjbHNvcCcsIGluZGV4OiA2MSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s2Ml0gPSB7bmFtZTogJ0Nsc09wZW4nLCBsb3dlcjogJ2Nsc29wZW4nLCBpbmRleDogNjIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjNdID0ge25hbWU6ICdDbHNDbG9zZScsIGxvd2VyOiAnY2xzY2xvc2UnLCBpbmRleDogNjMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjRdID0ge25hbWU6ICdDbHNTdHJpbmcnLCBsb3dlcjogJ2Nsc3N0cmluZycsIGluZGV4OiA2NCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s2NV0gPSB7bmFtZTogJ1Byb3NWYWwnLCBsb3dlcjogJ3Byb3N2YWwnLCBpbmRleDogNjUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjZdID0ge25hbWU6ICdQcm9zVmFsT3BlbicsIGxvd2VyOiAncHJvc3ZhbG9wZW4nLCBpbmRleDogNjYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjddID0ge25hbWU6ICdQcm9zVmFsU3RyaW5nJywgbG93ZXI6ICdwcm9zdmFsc3RyaW5nJywgaW5kZXg6IDY3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY4XSA9IHtuYW1lOiAnUHJvc1ZhbENsb3NlJywgbG93ZXI6ICdwcm9zdmFsY2xvc2UnLCBpbmRleDogNjgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjldID0ge25hbWU6ICdyZXAtbWluJywgbG93ZXI6ICdyZXAtbWluJywgaW5kZXg6IDY5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzcwXSA9IHtuYW1lOiAncmVwLW1pbi1tYXgnLCBsb3dlcjogJ3JlcC1taW4tbWF4JywgaW5kZXg6IDcwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzcxXSA9IHtuYW1lOiAncmVwLW1heCcsIGxvd2VyOiAncmVwLW1heCcsIGluZGV4OiA3MSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3Ml0gPSB7bmFtZTogJ3JlcC1udW0nLCBsb3dlcjogJ3JlcC1udW0nLCBpbmRleDogNzIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzNdID0ge25hbWU6ICdkU3RyaW5nJywgbG93ZXI6ICdkc3RyaW5nJywgaW5kZXg6IDczLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzc0XSA9IHtuYW1lOiAneFN0cmluZycsIGxvd2VyOiAneHN0cmluZycsIGluZGV4OiA3NCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3NV0gPSB7bmFtZTogJ2JTdHJpbmcnLCBsb3dlcjogJ2JzdHJpbmcnLCBpbmRleDogNzUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzZdID0ge25hbWU6ICdEZWMnLCBsb3dlcjogJ2RlYycsIGluZGV4OiA3NiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3N10gPSB7bmFtZTogJ0hleCcsIGxvd2VyOiAnaGV4JywgaW5kZXg6IDc3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzc4XSA9IHtuYW1lOiAnQmluJywgbG93ZXI6ICdiaW4nLCBpbmRleDogNzgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzldID0ge25hbWU6ICdkbWluJywgbG93ZXI6ICdkbWluJywgaW5kZXg6IDc5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzgwXSA9IHtuYW1lOiAnZG1heCcsIGxvd2VyOiAnZG1heCcsIGluZGV4OiA4MCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4MV0gPSB7bmFtZTogJ2JtaW4nLCBsb3dlcjogJ2JtaW4nLCBpbmRleDogODEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODJdID0ge25hbWU6ICdibWF4JywgbG93ZXI6ICdibWF4JywgaW5kZXg6IDgyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzgzXSA9IHtuYW1lOiAneG1pbicsIGxvd2VyOiAneG1pbicsIGluZGV4OiA4MywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4NF0gPSB7bmFtZTogJ3htYXgnLCBsb3dlcjogJ3htYXgnLCBpbmRleDogODQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODVdID0ge25hbWU6ICdkbnVtJywgbG93ZXI6ICdkbnVtJywgaW5kZXg6IDg1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg2XSA9IHtuYW1lOiAnYm51bScsIGxvd2VyOiAnYm51bScsIGluZGV4OiA4NiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4N10gPSB7bmFtZTogJ3hudW0nLCBsb3dlcjogJ3hudW0nLCBpbmRleDogODcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODhdID0ge25hbWU6ICdhbHBoYW51bScsIGxvd2VyOiAnYWxwaGFudW0nLCBpbmRleDogODgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODldID0ge25hbWU6ICdvd3NwJywgbG93ZXI6ICdvd3NwJywgaW5kZXg6IDg5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzkwXSA9IHtuYW1lOiAnd3NwJywgbG93ZXI6ICd3c3AnLCBpbmRleDogOTAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOTFdID0ge25hbWU6ICdzcGFjZScsIGxvd2VyOiAnc3BhY2UnLCBpbmRleDogOTEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOTJdID0ge25hbWU6ICdjb21tZW50JywgbG93ZXI6ICdjb21tZW50JywgaW5kZXg6IDkyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzkzXSA9IHtuYW1lOiAnTGluZUVuZCcsIGxvd2VyOiAnbGluZWVuZCcsIGluZGV4OiA5MywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5NF0gPSB7bmFtZTogJ0xpbmVDb250aW51ZScsIGxvd2VyOiAnbGluZWNvbnRpbnVlJywgaW5kZXg6IDk0LCBpc0JrcjogZmFsc2V9O1xuXG4gIC8qIFVEVFMgKi9cbiAgdGhpcy51ZHRzID0gW107XG5cbiAgLyogT1BDT0RFUyAqL1xuICAvKiBGaWxlICovXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAxfTsvLyBSTk0oQmxhbmtMaW5lKVxuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDJ9Oy8vIFJOTShSdWxlKVxuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDEyfTsvLyBSTk0oUnVsZUVycm9yKVxuXG4gIC8qIEJsYW5rTGluZSAqL1xuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSw1LDddfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzJdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzRdID0ge3R5cGU6IDYsIHN0cmluZzogWzldfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzVdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiAxfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiA5Mn07Ly8gUk5NKGNvbW1lbnQpXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogOTN9Oy8vIFJOTShMaW5lRW5kKVxuXG4gIC8qIFJ1bGUgKi9cbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMiwzLDRdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAzfTsvLyBSTk0oUnVsZUxvb2t1cClcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogMTR9Oy8vIFJOTShBbHRlcm5hdGlvbilcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzRdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNSw4XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzYsN119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzddID0ge3R5cGU6IDQsIGluZGV4OiA5M307Ly8gUk5NKExpbmVFbmQpXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s4XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzksMTBdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzldID0ge3R5cGU6IDQsIGluZGV4OiAxM307Ly8gUk5NKExpbmVFbmRFcnJvcilcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzEwXSA9IHt0eXBlOiA0LCBpbmRleDogOTN9Oy8vIFJOTShMaW5lRW5kKVxuXG4gIC8qIFJ1bGVMb29rdXAgKi9cbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMiwzXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNH07Ly8gUk5NKFJ1bGVOYW1lVGVzdClcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogN307Ly8gUk5NKERlZmluZWRBc1Rlc3QpXG5cbiAgLyogUnVsZU5hbWVUZXN0ICovXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA1fTsvLyBSTk0oUnVsZU5hbWUpXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNn07Ly8gUk5NKFJ1bGVOYW1lRXJyb3IpXG5cbiAgLyogUnVsZU5hbWUgKi9cbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBSdWxlTmFtZUVycm9yICovXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMzLCBtYXg6IDYwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNjIsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBEZWZpbmVkQXNUZXN0ICovXG4gIHRoaXMucnVsZXNbN10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzddLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA5fTsvLyBSTk0oRGVmaW5lZEFzKVxuICB0aGlzLnJ1bGVzWzddLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDh9Oy8vIFJOTShEZWZpbmVkQXNFcnJvcilcblxuICAvKiBEZWZpbmVkQXNFcnJvciAqL1xuICB0aGlzLnJ1bGVzWzhdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiAyfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4XS5vcGNvZGVzWzFdID0ge3R5cGU6IDUsIG1pbjogMzMsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBEZWZpbmVkQXMgKi9cbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsMl19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzldLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDExfTsvLyBSTk0oSW5jQWx0KVxuICB0aGlzLnJ1bGVzWzldLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDEwfTsvLyBSTk0oRGVmaW5lZClcblxuICAvKiBEZWZpbmVkICovXG4gIHRoaXMucnVsZXNbMTBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxMF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs2MV19Oy8vIFRCU1xuXG4gIC8qIEluY0FsdCAqL1xuICB0aGlzLnJ1bGVzWzExXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTFdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjEsNDddfTsvLyBUQlNcblxuICAvKiBSdWxlRXJyb3IgKi9cbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSw2XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbMV0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzMsNCw1XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiAzMiwgbWF4OiAxMjZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzRdID0ge3R5cGU6IDYsIHN0cmluZzogWzldfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogOTR9Oy8vIFJOTShMaW5lQ29udGludWUpXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDkzfTsvLyBSTk0oTGluZUVuZClcblxuICAvKiBMaW5lRW5kRXJyb3IgKi9cbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzEzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzEzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDk0fTsvLyBSTk0oTGluZUNvbnRpbnVlKVxuXG4gIC8qIEFsdGVybmF0aW9uICovXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAxNX07Ly8gUk5NKENvbmNhdGVuYXRpb24pXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbMl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzQsNSw2XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogNDR9Oy8vIFJOTShBbHRPcClcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA0LCBpbmRleDogMTV9Oy8vIFJOTShDb25jYXRlbmF0aW9uKVxuXG4gIC8qIENvbmNhdGVuYXRpb24gKi9cbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDE2fTsvLyBSTk0oUmVwZXRpdGlvbilcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzNdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbNCw1XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDQ1fTsvLyBSTk0oQ2F0T3ApXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDE2fTsvLyBSTk0oUmVwZXRpdGlvbilcblxuICAvKiBSZXBldGl0aW9uICovXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiAxfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMTd9Oy8vIFJOTShNb2RpZmllcilcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzQsNSw2LDddfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogMjF9Oy8vIFJOTShHcm91cClcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogMjV9Oy8vIFJOTShPcHRpb24pXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDE5fTsvLyBSTk0oQmFzaWNFbGVtZW50KVxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzddID0ge3R5cGU6IDQsIGluZGV4OiAyMH07Ly8gUk5NKEJhc2ljRWxlbWVudEVycilcblxuICAvKiBNb2RpZmllciAqL1xuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAxOH07Ly8gUk5NKFByZWRpY2F0ZSlcbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2Rlc1szXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDQzfTsvLyBSTk0oUmVwT3ApXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDQzfTsvLyBSTk0oUmVwT3ApXG5cbiAgLyogUHJlZGljYXRlICovXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxOF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxOF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNDl9Oy8vIFJOTShCa2FPcClcbiAgdGhpcy5ydWxlc1sxOF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNTB9Oy8vIFJOTShCa25PcClcbiAgdGhpcy5ydWxlc1sxOF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogNDd9Oy8vIFJOTShBbmRPcClcbiAgdGhpcy5ydWxlc1sxOF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNDh9Oy8vIFJOTShOb3RPcClcblxuICAvKiBCYXNpY0VsZW1lbnQgKi9cbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzE5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDMsNCw1LDYsNyw4LDksMTBdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNDB9Oy8vIFJOTShVZHRPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMjl9Oy8vIFJOTShSbm1PcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogNTN9Oy8vIFJOTShUcmdPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNTR9Oy8vIFJOTShUYnNPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogNTV9Oy8vIFJOTShUbHNPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA0LCBpbmRleDogNjF9Oy8vIFJOTShDbHNPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogMzB9Oy8vIFJOTShCa3JPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1s4XSA9IHt0eXBlOiA0LCBpbmRleDogNTF9Oy8vIFJOTShBYmdPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiA0LCBpbmRleDogNTJ9Oy8vIFJOTShBZW5PcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogNCwgaW5kZXg6IDY1fTsvLyBSTk0oUHJvc1ZhbClcblxuICAvKiBCYXNpY0VsZW1lbnRFcnIgKi9cbiAgdGhpcy5ydWxlc1syMF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNCw1XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAzMywgbWF4OiA0MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiA0MiwgbWF4OiA0Nn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXNbNF0gPSB7dHlwZTogNSwgbWluOiA0OCwgbWF4OiA5Mn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXNbNV0gPSB7dHlwZTogNSwgbWluOiA5NCwgbWF4OiAxMjZ9Oy8vIFRSR1xuXG4gIC8qIEdyb3VwICovXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMiwzXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDIzfTsvLyBSTk0oR3JvdXBPcGVuKVxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAxNH07Ly8gUk5NKEFsdGVybmF0aW9uKVxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzNdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNCw1XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDI0fTsvLyBSTk0oR3JvdXBDbG9zZSlcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogMjJ9Oy8vIFJOTShHcm91cEVycm9yKVxuXG4gIC8qIEdyb3VwRXJyb3IgKi9cbiAgdGhpcy5ydWxlc1syMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNCw1XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAzMywgbWF4OiA0MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiA0MiwgbWF4OiA0Nn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXNbNF0gPSB7dHlwZTogNSwgbWluOiA0OCwgbWF4OiA5Mn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXNbNV0gPSB7dHlwZTogNSwgbWluOiA5NCwgbWF4OiAxMjZ9Oy8vIFRSR1xuXG4gIC8qIEdyb3VwT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzIzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjNdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syM10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0MF19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzIzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG5cbiAgLyogR3JvdXBDbG9zZSAqL1xuICB0aGlzLnJ1bGVzWzI0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjRdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuICB0aGlzLnJ1bGVzWzI0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzQxXX07Ly8gVEJTXG5cbiAgLyogT3B0aW9uICovXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMiwzXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDI3fTsvLyBSTk0oT3B0aW9uT3BlbilcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMTR9Oy8vIFJOTShBbHRlcm5hdGlvbilcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAyOH07Ly8gUk5NKE9wdGlvbkNsb3NlKVxuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiAyNn07Ly8gUk5NKE9wdGlvbkVycm9yKVxuXG4gIC8qIE9wdGlvbkVycm9yICovXG4gIHRoaXMucnVsZXNbMjZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzMsIG1heDogNDB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNDIsIG1heDogNDZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogOTJ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzWzVdID0ge3R5cGU6IDUsIG1pbjogOTQsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBPcHRpb25PcGVuICovXG4gIHRoaXMucnVsZXNbMjddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syN10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzkxXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMjddLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcblxuICAvKiBPcHRpb25DbG9zZSAqL1xuICB0aGlzLnJ1bGVzWzI4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjhdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuICB0aGlzLnJ1bGVzWzI4XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzkzXX07Ly8gVEJTXG5cbiAgLyogUm5tT3AgKi9cbiAgdGhpcy5ydWxlc1syOV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4OH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIEJrck9wICovXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMiw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbOTJdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szMF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDMxfTsvLyBSTk0oYmtyTW9kaWZpZXIpXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDM2fTsvLyBSTk0oYmtyLW5hbWUpXG5cbiAgLyogYmtyTW9kaWZpZXIgKi9cbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSw3LDEzLDE5XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsyLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMzJ9Oy8vIFJOTShjcylcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs1LDZdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogMzR9Oy8vIFJOTSh1bSlcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA0LCBpbmRleDogMzV9Oy8vIFJOTShwbSlcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzgsOV19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzhdID0ge3R5cGU6IDQsIGluZGV4OiAzM307Ly8gUk5NKGNpKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzldID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiAxfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxMSwxMl19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzExXSA9IHt0eXBlOiA0LCBpbmRleDogMzR9Oy8vIFJOTSh1bSlcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxMl0gPSB7dHlwZTogNCwgaW5kZXg6IDM1fTsvLyBSTk0ocG0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTNdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMTQsMTVdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxNF0gPSB7dHlwZTogNCwgaW5kZXg6IDM0fTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTVdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiAxfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxNl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxNywxOF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE3XSA9IHt0eXBlOiA0LCBpbmRleDogMzJ9Oy8vIFJOTShjcylcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxOF0gPSB7dHlwZTogNCwgaW5kZXg6IDMzfTsvLyBSTk0oY2kpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTldID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMjAsMjFdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1syMF0gPSB7dHlwZTogNCwgaW5kZXg6IDM1fTsvLyBSTk0ocG0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjFdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiAxfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1syMl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyMywyNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzIzXSA9IHt0eXBlOiA0LCBpbmRleDogMzJ9Oy8vIFJOTShjcylcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1syNF0gPSB7dHlwZTogNCwgaW5kZXg6IDMzfTsvLyBSTk0oY2kpXG5cbiAgLyogY3MgKi9cbiAgdGhpcy5ydWxlc1szMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzMyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM3LDExNV19Oy8vIFRCU1xuXG4gIC8qIGNpICovXG4gIHRoaXMucnVsZXNbMzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szM10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNywxMDVdfTsvLyBUQlNcblxuICAvKiB1bSAqL1xuICB0aGlzLnJ1bGVzWzM0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzRdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsMTE3XX07Ly8gVEJTXG5cbiAgLyogcG0gKi9cbiAgdGhpcy5ydWxlc1szNV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzM1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM3LDExMl19Oy8vIFRCU1xuXG4gIC8qIGJrci1uYW1lICovXG4gIHRoaXMucnVsZXNbMzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szNl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzZdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDM4fTsvLyBSTk0odW5hbWUpXG4gIHRoaXMucnVsZXNbMzZdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDM5fTsvLyBSTk0oZW5hbWUpXG4gIHRoaXMucnVsZXNbMzZdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDM3fTsvLyBSTk0ocm5hbWUpXG5cbiAgLyogcm5hbWUgKi9cbiAgdGhpcy5ydWxlc1szN10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzM3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4OH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIHVuYW1lICovXG4gIHRoaXMucnVsZXNbMzhdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzM4XS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzExNyw5NV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzM4XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIGVuYW1lICovXG4gIHRoaXMucnVsZXNbMzldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzM5XS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzEwMSw5NV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzM5XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIFVkdE9wICovXG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0MF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsMl19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzQwXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA0Mn07Ly8gUk5NKHVkdC1lbXB0eSlcbiAgdGhpcy5ydWxlc1s0MF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNDF9Oy8vIFJOTSh1ZHQtbm9uLWVtcHR5KVxuXG4gIC8qIHVkdC1ub24tZW1wdHkgKi9cbiAgdGhpcy5ydWxlc1s0MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDFdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTE3LDk1XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNDFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDg4fTsvLyBSTk0oYWxwaGFudW0pXG5cbiAgLyogdWR0LWVtcHR5ICovXG4gIHRoaXMucnVsZXNbNDJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzEwMSw5NV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzQyXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIFJlcE9wICovXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsNSw4LDExLDEyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsyLDMsNF19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA2OX07Ly8gUk5NKHJlcC1taW4pXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDQ2fTsvLyBSTk0oU3Rhck9wKVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA3MX07Ly8gUk5NKHJlcC1tYXgpXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbNV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs2LDddfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA0LCBpbmRleDogNjl9Oy8vIFJOTShyZXAtbWluKVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzddID0ge3R5cGU6IDQsIGluZGV4OiA0Nn07Ly8gUk5NKFN0YXJPcClcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s4XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzksMTBdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s5XSA9IHt0eXBlOiA0LCBpbmRleDogNDZ9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMTBdID0ge3R5cGU6IDQsIGluZGV4OiA3MX07Ly8gUk5NKHJlcC1tYXgpXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMTFdID0ge3R5cGU6IDQsIGluZGV4OiA0Nn07Ly8gUk5NKFN0YXJPcClcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1sxMl0gPSB7dHlwZTogNCwgaW5kZXg6IDcwfTsvLyBSTk0ocmVwLW1pbi1tYXgpXG5cbiAgLyogQWx0T3AgKi9cbiAgdGhpcy5ydWxlc1s0NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzQ0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDRdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDddfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s0NF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuXG4gIC8qIENhdE9wICovXG4gIHRoaXMucnVsZXNbNDVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0NV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogOTB9Oy8vIFJOTSh3c3ApXG5cbiAgLyogU3Rhck9wICovXG4gIHRoaXMucnVsZXNbNDZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0Nl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0Ml19Oy8vIFRCU1xuXG4gIC8qIEFuZE9wICovXG4gIHRoaXMucnVsZXNbNDddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszOF19Oy8vIFRCU1xuXG4gIC8qIE5vdE9wICovXG4gIHRoaXMucnVsZXNbNDhdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0OF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszM119Oy8vIFRCU1xuXG4gIC8qIEJrYU9wICovXG4gIHRoaXMucnVsZXNbNDldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0OV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszOCwzOF19Oy8vIFRCU1xuXG4gIC8qIEJrbk9wICovXG4gIHRoaXMucnVsZXNbNTBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1MF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszMywzM119Oy8vIFRCU1xuXG4gIC8qIEFiZ09wICovXG4gIHRoaXMucnVsZXNbNTFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNyw5NF19Oy8vIFRCU1xuXG4gIC8qIEFlbk9wICovXG4gIHRoaXMucnVsZXNbNTJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1Ml0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNywzNl19Oy8vIFRCU1xuXG4gIC8qIFRyZ09wICovXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzM3XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFszLDgsMTNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1szXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzQsNSw2LDddfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNzZ9Oy8vIFJOTShEZWMpXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDc5fTsvLyBSTk0oZG1pbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0NV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzddID0ge3R5cGU6IDQsIGluZGV4OiA4MH07Ly8gUk5NKGRtYXgpXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbOF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs5LDEwLDExLDEyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDc3fTsvLyBSTk0oSGV4KVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzEwXSA9IHt0eXBlOiA0LCBpbmRleDogODN9Oy8vIFJOTSh4bWluKVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzExXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0NV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzEyXSA9IHt0eXBlOiA0LCBpbmRleDogODR9Oy8vIFJOTSh4bWF4KVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzEzXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzE0LDE1LDE2LDE3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTRdID0ge3R5cGU6IDQsIGluZGV4OiA3OH07Ly8gUk5NKEJpbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxNV0gPSB7dHlwZTogNCwgaW5kZXg6IDgxfTsvLyBSTk0oYm1pbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxNl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxN10gPSB7dHlwZTogNCwgaW5kZXg6IDgyfTsvLyBSTk0oYm1heClcblxuICAvKiBUYnNPcCAqL1xuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszN119Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMywxMCwxN119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzNdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbNCw1LDZdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNzZ9Oy8vIFJOTShEZWMpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDczfTsvLyBSTk0oZFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzddID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbOCw5XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbOF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiA0LCBpbmRleDogNzN9Oy8vIFJOTShkU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzEwXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzExLDEyLDEzXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTFdID0ge3R5cGU6IDQsIGluZGV4OiA3N307Ly8gUk5NKEhleClcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxMl0gPSB7dHlwZTogNCwgaW5kZXg6IDc0fTsvLyBSTk0oeFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxM10gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxNF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxNSwxNl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzE1XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0Nl19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzE2XSA9IHt0eXBlOiA0LCBpbmRleDogNzR9Oy8vIFJOTSh4U3RyaW5nKVxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzE3XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzE4LDE5LDIwXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMThdID0ge3R5cGU6IDQsIGluZGV4OiA3OH07Ly8gUk5NKEJpbilcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxOV0gPSB7dHlwZTogNCwgaW5kZXg6IDc1fTsvLyBSTk0oYlN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syMF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syMV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsyMiwyM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzIyXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0Nl19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzIzXSA9IHt0eXBlOiA0LCBpbmRleDogNzV9Oy8vIFJOTShiU3RyaW5nKVxuXG4gIC8qIFRsc09wICovXG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMiwzLDRdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNTZ9Oy8vIFJOTShUbHNDYXNlKVxuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA1N307Ly8gUk5NKFRsc09wZW4pXG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDU5fTsvLyBSTk0oVGxzU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA1OH07Ly8gUk5NKFRsc0Nsb3NlKVxuXG4gIC8qIFRsc0Nhc2UgKi9cbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzU2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiAxfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzU2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDcsIHN0cmluZzogWzM3LDEwNV19Oy8vIFRMU1xuICB0aGlzLnJ1bGVzWzU2XS5vcGNvZGVzWzNdID0ge3R5cGU6IDcsIHN0cmluZzogWzM3LDExNV19Oy8vIFRMU1xuXG4gIC8qIFRsc09wZW4gKi9cbiAgdGhpcy5ydWxlc1s1N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzU3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM0XX07Ly8gVEJTXG5cbiAgLyogVGxzQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1s1OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzU4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM0XX07Ly8gVEJTXG5cbiAgLyogVGxzU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1OV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1OV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDMzfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s1OV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDM1LCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDYwfTsvLyBSTk0oU3RyaW5nVGFiKVxuXG4gIC8qIFN0cmluZ1RhYiAqL1xuICB0aGlzLnJ1bGVzWzYwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjBdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbOV19Oy8vIFRCU1xuXG4gIC8qIENsc09wICovXG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMiwzXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDYyfTsvLyBSTk0oQ2xzT3BlbilcbiAgdGhpcy5ydWxlc1s2MV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNjR9Oy8vIFJOTShDbHNTdHJpbmcpXG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDYzfTsvLyBSTk0oQ2xzQ2xvc2UpXG5cbiAgLyogQ2xzT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzYyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjJdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzldfTsvLyBUQlNcblxuICAvKiBDbHNDbG9zZSAqL1xuICB0aGlzLnJ1bGVzWzYzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjNdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzldfTsvLyBUQlNcblxuICAvKiBDbHNTdHJpbmcgKi9cbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzY0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzY0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzIsIG1heDogMzh9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzY0XS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNDAsIG1heDogMTI2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNjB9Oy8vIFJOTShTdHJpbmdUYWIpXG5cbiAgLyogUHJvc1ZhbCAqL1xuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjVdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA2Nn07Ly8gUk5NKFByb3NWYWxPcGVuKVxuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA2N307Ly8gUk5NKFByb3NWYWxTdHJpbmcpXG4gIHRoaXMucnVsZXNbNjVdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDY4fTsvLyBSTk0oUHJvc1ZhbENsb3NlKVxuXG4gIC8qIFByb3NWYWxPcGVuICovXG4gIHRoaXMucnVsZXNbNjZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2Nl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs2MF19Oy8vIFRCU1xuXG4gIC8qIFByb3NWYWxTdHJpbmcgKi9cbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNjddLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzIsIG1heDogNjF9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNjMsIG1heDogMTI2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNjB9Oy8vIFJOTShTdHJpbmdUYWIpXG5cbiAgLyogUHJvc1ZhbENsb3NlICovXG4gIHRoaXMucnVsZXNbNjhdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2OF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs2Ml19Oy8vIFRCU1xuXG4gIC8qIHJlcC1taW4gKi9cbiAgdGhpcy5ydWxlc1s2OV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzY5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA3Mn07Ly8gUk5NKHJlcC1udW0pXG5cbiAgLyogcmVwLW1pbi1tYXggKi9cbiAgdGhpcy5ydWxlc1s3MF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzcwXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA3Mn07Ly8gUk5NKHJlcC1udW0pXG5cbiAgLyogcmVwLW1heCAqL1xuICB0aGlzLnJ1bGVzWzcxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzFdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDcyfTsvLyBSTk0ocmVwLW51bSlcblxuICAvKiByZXAtbnVtICovXG4gIHRoaXMucnVsZXNbNzJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3Ml0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzcyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogNTd9Oy8vIFRSR1xuXG4gIC8qIGRTdHJpbmcgKi9cbiAgdGhpcy5ydWxlc1s3M10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzczXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4NX07Ly8gUk5NKGRudW0pXG5cbiAgLyogeFN0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzc0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzRdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg3fTsvLyBSTk0oeG51bSlcblxuICAvKiBiU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNzVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3NV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODZ9Oy8vIFJOTShibnVtKVxuXG4gIC8qIERlYyAqL1xuICB0aGlzLnJ1bGVzWzc2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzZdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs2OF19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzc2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzEwMF19Oy8vIFRCU1xuXG4gIC8qIEhleCAqL1xuICB0aGlzLnJ1bGVzWzc3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzddLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs4OF19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzc3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzEyMF19Oy8vIFRCU1xuXG4gIC8qIEJpbiAqL1xuICB0aGlzLnJ1bGVzWzc4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzhdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs2Nl19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzc4XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzk4XX07Ly8gVEJTXG5cbiAgLyogZG1pbiAqL1xuICB0aGlzLnJ1bGVzWzc5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzldLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg1fTsvLyBSTk0oZG51bSlcblxuICAvKiBkbWF4ICovXG4gIHRoaXMucnVsZXNbODBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4MF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODV9Oy8vIFJOTShkbnVtKVxuXG4gIC8qIGJtaW4gKi9cbiAgdGhpcy5ydWxlc1s4MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzgxXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4Nn07Ly8gUk5NKGJudW0pXG5cbiAgLyogYm1heCAqL1xuICB0aGlzLnJ1bGVzWzgyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODJdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg2fTsvLyBSTk0oYm51bSlcblxuICAvKiB4bWluICovXG4gIHRoaXMucnVsZXNbODNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4M10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODd9Oy8vIFJOTSh4bnVtKVxuXG4gIC8qIHhtYXggKi9cbiAgdGhpcy5ydWxlc1s4NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4N307Ly8gUk5NKHhudW0pXG5cbiAgLyogZG51bSAqL1xuICB0aGlzLnJ1bGVzWzg1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODVdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4NV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3fTsvLyBUUkdcblxuICAvKiBibnVtICovXG4gIHRoaXMucnVsZXNbODZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4Nl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzg2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogNDl9Oy8vIFRSR1xuXG4gIC8qIHhudW0gKi9cbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbODddLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogNTd9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNjUsIG1heDogNzB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogOTcsIG1heDogMTAyfTsvLyBUUkdcblxuICAvKiBhbHBoYW51bSAqL1xuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDRdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogOTcsIG1heDogMTIyfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDY1LCBtYXg6IDkwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzWzVdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNiw3LDgsOV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzWzZdID0ge3R5cGU6IDUsIG1pbjogOTcsIG1heDogMTIyfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA1LCBtaW46IDY1LCBtYXg6IDkwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s4XSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0NV19Oy8vIFRCU1xuXG4gIC8qIG93c3AgKi9cbiAgdGhpcy5ydWxlc1s4OV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbODldLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDkxfTsvLyBSTk0oc3BhY2UpXG5cbiAgLyogd3NwICovXG4gIHRoaXMucnVsZXNbOTBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5MF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzkwXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA5MX07Ly8gUk5NKHNwYWNlKVxuXG4gIC8qIHNwYWNlICovXG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszMl19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkxXS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzldfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogOTJ9Oy8vIFJOTShjb21tZW50KVxuICB0aGlzLnJ1bGVzWzkxXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA5NH07Ly8gUk5NKExpbmVDb250aW51ZSlcblxuICAvKiBjb21tZW50ICovXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzU5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbMl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG5cbiAgLyogTGluZUVuZCAqL1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTNdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzLDEwXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTNdLm9wY29kZXNbMl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTBdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5M10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxM119Oy8vIFRCU1xuXG4gIC8qIExpbmVDb250aW51ZSAqL1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDVdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbMl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTMsMTBdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMF19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzRdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbNV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs2LDddfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszMl19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzddID0ge3R5cGU6IDYsIHN0cmluZzogWzldfTsvLyBUQlNcblxuICAvLyBUaGUgYHRvU3RyaW5nKClgIGZ1bmN0aW9uIHdpbGwgZGlzcGxheSB0aGUgb3JpZ2luYWwgZ3JhbW1hciBmaWxlKHMpIHRoYXQgcHJvZHVjZWQgdGhlc2Ugb3Bjb2Rlcy5cbiAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgQUJORiBmb3IgSmF2YVNjcmlwdCBBUEcgMi4wIFNBQk5GXFxuXCI7XG4gICAgc3RyICs9IFwiOyBSRkMgNTIzNCB3aXRoIHNvbWUgcmVzdHJpY3Rpb25zIGFuZCBhZGRpdGlvbnMuXFxuXCI7XG4gICAgc3RyICs9IFwiOyBVcGRhdGVkIDExLzI0LzIwMTUgZm9yIFJGQyA3NDA1IGNhc2Utc2Vuc2l0aXZlIGxpdGVyYWwgc3RyaW5nIG5vdGF0aW9uXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgLSBhY2NlcHRzICVzXFxcInN0cmluZ1xcXCIgYXMgYSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmdcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAtIGFjY2VwdHMgJWlcXFwic3RyaW5nXFxcIiBhcyBhIGNhc2UtaW5zZW5zaXRpdmUgc3RyaW5nXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgLSBhY2NlcHRzIFxcXCJzdHJpbmdcXFwiIGFzIGEgY2FzZS1pbnNlbnNpdGl2ZSBzdHJpbmdcXG5cIjtcbiAgICBzdHIgKz0gXCI7XFxuXCI7XG4gICAgc3RyICs9IFwiOyBTb21lIHJlc3RyaWN0aW9uczpcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgMS4gUnVsZXMgbXVzdCBiZWdpbiBhdCBmaXJzdCBjaGFyYWN0ZXIgb2YgZWFjaCBsaW5lLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBJbmRlbnRhdGlvbnMgb24gZmlyc3QgcnVsZSBhbmQgcnVsZXMgdGhlcmVhZnRlciBhcmUgbm90IGFsbG93ZWQuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDIuIFJlbGF4ZWQgbGluZSBlbmRpbmdzLiBDUkxGLCBMRiBvciBDUiBhcmUgYWNjZXB0ZWQgYXMgdmFsaWQgbGluZSBlbmRpbmcuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDMuIFByb3NlIHZhbHVlcywgaS5lLiA8cHJvc2UgdmFsdWU+LCBhcmUgYWNjZXB0ZWQgYXMgdmFsaWQgZ3JhbW1hciBzeW50YXguXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEhvd2V2ZXIsIGEgd29ya2luZyBwYXJzZXIgY2Fubm90IGJlIGdlbmVyYXRlZCBmcm9tIHRoZW0uXFxuXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgU3VwZXIgc2V0IChTQUJORikgYWRkaXRpb25zOlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAxLiBMb29rLWFoZWFkIChzeW50YWN0aWMgcHJlZGljYXRlKSBvcGVyYXRvcnMgYXJlIGFjY2VwdGVkIGFzIGVsZW1lbnQgcHJlZml4ZXMuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgICYgaXMgdGhlIHBvc2l0aXZlIGxvb2stYWhlYWQgb3BlcmF0b3IsIHN1Y2NlZWRzIGFuZCBiYWNrdHJhY2tzIGlmIHRoZSBsb29rLWFoZWFkIHBocmFzZSBpcyBmb3VuZFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAhIGlzIHRoZSBuZWdhdGl2ZSBsb29rLWFoZWFkIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1haGVhZCBwaHJhc2UgaXMgTk9UIGZvdW5kXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIGUuZy4gJiVkMTMgb3IgJnJ1bGUgb3IgIShBIC8gQilcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgMi4gVXNlci1EZWZpbmVkIFRlcm1pbmFscyAoVURUKSBvZiB0aGUgZm9ybSwgdV9uYW1lIGFuZCBlX25hbWUgYXJlIGFjY2VwdGVkLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAnbmFtZScgaXMgYWxwaGEgZm9sbG93ZWQgYnkgYWxwaGEvbnVtL2h5cGhlbiBqdXN0IGxpa2UgYSBydWxlIG5hbWUuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIHVfbmFtZSBtYXkgYmUgdXNlZCBhcyBhbiBlbGVtZW50IGJ1dCBubyBydWxlIGRlZmluaXRpb24gaXMgZ2l2ZW4uXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIGUuZy4gcnVsZSA9IEEgLyB1X215VWR0XFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgICAgICAgQSA9IFxcXCJhXFxcIlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICB3b3VsZCBiZSBhIHZhbGlkIGdyYW1tYXIuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDMuIENhc2Utc2Vuc2l0aXZlLCBzaW5nbGUtcXVvdGVkIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuICdhYmMnIHdvdWxkIGJlIGVxdWl2YWxlbnQgdG8gJWQ5Ny45OC45OVxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAoa2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgYnV0IHN1cGVyc2VkZWQgYnkgJXNcXFwiYWJjXFxcIikgIFxcblwiO1xuICAgIHN0ciArPSBcIjsgTmV3IDEyLzI2LzIwMTVcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgNC4gTG9vay1iZWhpbmQgb3BlcmF0b3JzIGFyZSBhY2NlcHRlZCBhcyBlbGVtZW50IHByZWZpeGVzLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAmJiBpcyB0aGUgcG9zaXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IsIHN1Y2NlZWRzIGFuZCBiYWNrdHJhY2tzIGlmIHRoZSBsb29rLWJlaGluZCBwaHJhc2UgaXMgZm91bmRcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgISEgaXMgdGhlIG5lZ2F0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1iZWhpbmQgcGhyYXNlIGlzIE5PVCBmb3VuZFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuICYmJWQxMyBvciAmJnJ1bGUgb3IgISEoQSAvIEIpXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDUuIEJhY2sgcmVmZXJlbmNlIG9wZXJhdG9ycywgaS5lLiBcXFxccnVsZW5hbWUsIGFyZSBhY2NlcHRlZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgQSBiYWNrIHJlZmVyZW5jZSBvcGVyYXRvciBhY3RzIGxpa2UgYSBUTFMgb3IgVEJTIHRlcm1pbmFsIGV4Y2VwdCB0aGF0IHRoZSBwaHJhc2UgaXQgYXR0ZW1wdHNcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgdG8gbWF0Y2ggaXMgYSBwaHJhc2UgcHJldmlvdXNseSBtYXRjaGVkIGJ5IHRoZSBydWxlICdydWxlbmFtZScuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIFRoZXJlIGFyZSB0d28gbW9kZXMgb2YgcHJldmlvdXMgcGhyYXNlIG1hdGNoaW5nIC0gdGhlIHBhcmVudC1mcmFtZSBtb2RlIGFuZCB0aGUgdW5pdmVyc2FsIG1vZGUuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEluIHVuaXZlcnNhbCBtb2RlLCBcXFxccnVsZW5hbWUgbWF0Y2hlcyB0aGUgbGFzdCBtYXRjaCB0byAncnVsZW5hbWUnIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgaXQgd2FzIGZvdW5kLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBJbiBwYXJlbnQtZnJhbWUgbW9kZSwgXFxcXHJ1bGVuYW1lIG1hdGNoZXMgb25seSB0aGUgbGFzdCBtYXRjaCBmb3VuZCBvbiB0aGUgcGFyZW50J3MgZnJhbWUgb3IgcGFyc2UgdHJlZSBsZXZlbC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgQmFjayByZWZlcmVuY2UgbW9kaWZpZXJzIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgY2FzZSBhbmQgbW9kZS5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgXFxcXEEgZGVmYXVsdHMgdG8gY2FzZS1pbnNlbnNpdGl2ZSBhbmQgdW5pdmVyc2FsIG1vZGUsIGUuZy4gXFxcXEEgPT09IFxcXFwlaSV1QVxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBNb2RpZmllcnMgJWkgYW5kICVzIGRldGVybWluZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYXNlLXNlbnNpdGl2ZSBtb2RlLCByZXNwZWN0aXZlbHkuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIE1vZGlmaWVycyAldSBhbmQgJXAgZGV0ZXJtaW5lIHVuaXZlcnNhbCBtb2RlIGFuZCBwYXJlbnQgZnJhbWUgbW9kZSwgcmVzcGVjdGl2ZWx5LlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBDYXNlIGFuZCBtb2RlIG1vZGlmaWVycyBjYW4gYXBwZWFyIGluIGFueSBvcmRlciwgZS5nLiBcXFxcJXMlcEEgPT09IFxcXFwlcCVzQS4gXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDcuIFN0cmluZyBiZWdpbiBhbmNob3IsIEFCRyglXikgbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dCBzdHJpbmcgbG9jYXRpb24uXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIFJldHVybnMgRU1QVFkgb3IgTk9NQVRDSC4gTmV2ZXIgY29uc3VtZXMgYW55IGNoYXJhY3RlcnMuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDguIFN0cmluZyBlbmQgYW5jaG9yLCBBRU4oJSQpIG1hdGNoZXMgdGhlIGVuZCBvZiB0aGUgaW5wdXQgc3RyaW5nIGxvY2F0aW9uLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBSZXR1cm5zIEVNUFRZIG9yIE5PTUFUQ0guIE5ldmVyIGNvbnN1bWVzIGFueSBjaGFyYWN0ZXJzLlxcblwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCJGaWxlICAgICAgICAgICAgPSAqKEJsYW5rTGluZSAvIFJ1bGUgLyBSdWxlRXJyb3IpXFxuXCI7XG4gICAgc3RyICs9IFwiQmxhbmtMaW5lICAgICAgID0gKiglZDMyLyVkOSkgW2NvbW1lbnRdIExpbmVFbmRcXG5cIjtcbiAgICBzdHIgKz0gXCJSdWxlICAgICAgICAgICAgPSBSdWxlTG9va3VwIG93c3AgQWx0ZXJuYXRpb24gKChvd3NwIExpbmVFbmQpXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gKExpbmVFbmRFcnJvciBMaW5lRW5kKSlcXG5cIjtcbiAgICBzdHIgKz0gXCJSdWxlTG9va3VwICAgICAgPSBSdWxlTmFtZVRlc3Qgb3dzcCBEZWZpbmVkQXNUZXN0XFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZU5hbWVUZXN0ICAgID0gUnVsZU5hbWUvUnVsZU5hbWVFcnJvclxcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVOYW1lICAgICAgICA9IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZU5hbWVFcnJvciAgID0gMSooJWQzMy02MC8lZDYyLTEyNilcXG5cIjtcbiAgICBzdHIgKz0gXCJEZWZpbmVkQXNUZXN0ICAgPSBEZWZpbmVkQXMgLyBEZWZpbmVkQXNFcnJvclxcblwiO1xuICAgIHN0ciArPSBcIkRlZmluZWRBc0Vycm9yICA9IDEqMiVkMzMtMTI2XFxuXCI7XG4gICAgc3RyICs9IFwiRGVmaW5lZEFzICAgICAgID0gSW5jQWx0IC8gRGVmaW5lZFxcblwiO1xuICAgIHN0ciArPSBcIkRlZmluZWQgICAgICAgICA9ICVkNjFcXG5cIjtcbiAgICBzdHIgKz0gXCJJbmNBbHQgICAgICAgICAgPSAlZDYxLjQ3XFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZUVycm9yICAgICAgID0gMSooJWQzMi0xMjYgLyAlZDkgIC8gTGluZUNvbnRpbnVlKSBMaW5lRW5kXFxuXCI7XG4gICAgc3RyICs9IFwiTGluZUVuZEVycm9yICAgID0gMSooJWQzMi0xMjYgLyAlZDkgIC8gTGluZUNvbnRpbnVlKVxcblwiO1xuICAgIHN0ciArPSBcIkFsdGVybmF0aW9uICAgICA9IENvbmNhdGVuYXRpb24gKihvd3NwIEFsdE9wIENvbmNhdGVuYXRpb24pXFxuXCI7XG4gICAgc3RyICs9IFwiQ29uY2F0ZW5hdGlvbiAgID0gUmVwZXRpdGlvbiAqKENhdE9wIFJlcGV0aXRpb24pXFxuXCI7XG4gICAgc3RyICs9IFwiUmVwZXRpdGlvbiAgICAgID0gW01vZGlmaWVyXSAoR3JvdXAgLyBPcHRpb24gLyBCYXNpY0VsZW1lbnQgLyBCYXNpY0VsZW1lbnRFcnIpXFxuXCI7XG4gICAgc3RyICs9IFwiTW9kaWZpZXIgICAgICAgID0gKFByZWRpY2F0ZSBbUmVwT3BdKVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFJlcE9wXFxuXCI7XG4gICAgc3RyICs9IFwiUHJlZGljYXRlICAgICAgID0gQmthT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBCa25PcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIEFuZE9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gTm90T3BcXG5cIjtcbiAgICBzdHIgKz0gXCJCYXNpY0VsZW1lbnQgICAgPSBVZHRPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFJubU9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gVHJnT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBUYnNPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFRsc09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQ2xzT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBCa3JPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIEFiZ09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQWVuT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBQcm9zVmFsXFxuXCI7XG4gICAgc3RyICs9IFwiQmFzaWNFbGVtZW50RXJyID0gMSooJWQzMy00MC8lZDQyLTQ2LyVkNDgtOTIvJWQ5NC0xMjYpXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXAgICAgICAgICAgID0gR3JvdXBPcGVuICBBbHRlcm5hdGlvbiAoR3JvdXBDbG9zZSAvIEdyb3VwRXJyb3IpXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXBFcnJvciAgICAgID0gMSooJWQzMy00MC8lZDQyLTQ2LyVkNDgtOTIvJWQ5NC0xMjYpIDsgc2FtZSBhcyBCYXNpY0VsZW1lbnRFcnJcXG5cIjtcbiAgICBzdHIgKz0gXCJHcm91cE9wZW4gICAgICAgPSAlZDQwIG93c3BcXG5cIjtcbiAgICBzdHIgKz0gXCJHcm91cENsb3NlICAgICAgPSBvd3NwICVkNDFcXG5cIjtcbiAgICBzdHIgKz0gXCJPcHRpb24gICAgICAgICAgPSBPcHRpb25PcGVuIEFsdGVybmF0aW9uIChPcHRpb25DbG9zZSAvIE9wdGlvbkVycm9yKVxcblwiO1xuICAgIHN0ciArPSBcIk9wdGlvbkVycm9yICAgICA9IDEqKCVkMzMtNDAvJWQ0Mi00Ni8lZDQ4LTkyLyVkOTQtMTI2KSA7IHNhbWUgYXMgQmFzaWNFbGVtZW50RXJyXFxuXCI7XG4gICAgc3RyICs9IFwiT3B0aW9uT3BlbiAgICAgID0gJWQ5MSBvd3NwXFxuXCI7XG4gICAgc3RyICs9IFwiT3B0aW9uQ2xvc2UgICAgID0gb3dzcCAlZDkzXFxuXCI7XG4gICAgc3RyICs9IFwiUm5tT3AgICAgICAgICAgID0gYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJCa3JPcCAgICAgICAgICAgPSAlZDkyIFtia3JNb2RpZmllcl0gYmtyLW5hbWVcXG5cIjtcbiAgICBzdHIgKz0gXCJia3JNb2RpZmllciAgICAgPSAoY3MgW3VtIC8gcG1dKSAvIChjaSBbdW0gLyBwbV0pIC8gKHVtIFtjcyAvY2ldKSAvIChwbSBbY3MgLyBjaV0pXFxuXCI7XG4gICAgc3RyICs9IFwiY3MgICAgICAgICAgICAgID0gJyVzJ1xcblwiO1xuICAgIHN0ciArPSBcImNpICAgICAgICAgICAgICA9ICclaSdcXG5cIjtcbiAgICBzdHIgKz0gXCJ1bSAgICAgICAgICAgICAgPSAnJXUnXFxuXCI7XG4gICAgc3RyICs9IFwicG0gICAgICAgICAgICAgID0gJyVwJ1xcblwiO1xuICAgIHN0ciArPSBcImJrci1uYW1lICAgICAgICA9IHVuYW1lIC8gZW5hbWUgLyBybmFtZVxcblwiO1xuICAgIHN0ciArPSBcInJuYW1lICAgICAgICAgICA9IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwidW5hbWUgICAgICAgICAgID0gJWQxMTcuOTUgYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJlbmFtZSAgICAgICAgICAgPSAlZDEwMS45NSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcIlVkdE9wICAgICAgICAgICA9IHVkdC1lbXB0eVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIHVkdC1ub24tZW1wdHlcXG5cIjtcbiAgICBzdHIgKz0gXCJ1ZHQtbm9uLWVtcHR5ICAgPSAlZDExNy45NSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcInVkdC1lbXB0eSAgICAgICA9ICVkMTAxLjk1IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiUmVwT3AgICAgICAgICAgID0gKHJlcC1taW4gU3Rhck9wIHJlcC1tYXgpXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gKHJlcC1taW4gU3Rhck9wKVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIChTdGFyT3AgcmVwLW1heClcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBTdGFyT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyByZXAtbWluLW1heFxcblwiO1xuICAgIHN0ciArPSBcIkFsdE9wICAgICAgICAgICA9ICVkNDcgb3dzcFxcblwiO1xuICAgIHN0ciArPSBcIkNhdE9wICAgICAgICAgICA9IHdzcFxcblwiO1xuICAgIHN0ciArPSBcIlN0YXJPcCAgICAgICAgICA9ICVkNDJcXG5cIjtcbiAgICBzdHIgKz0gXCJBbmRPcCAgICAgICAgICAgPSAlZDM4XFxuXCI7XG4gICAgc3RyICs9IFwiTm90T3AgICAgICAgICAgID0gJWQzM1xcblwiO1xuICAgIHN0ciArPSBcIkJrYU9wICAgICAgICAgICA9ICVkMzguMzhcXG5cIjtcbiAgICBzdHIgKz0gXCJCa25PcCAgICAgICAgICAgPSAlZDMzLjMzXFxuXCI7XG4gICAgc3RyICs9IFwiQWJnT3AgICAgICAgICAgID0gJWQzNy45NFxcblwiO1xuICAgIHN0ciArPSBcIkFlbk9wICAgICAgICAgICA9ICVkMzcuMzZcXG5cIjtcbiAgICBzdHIgKz0gXCJUcmdPcCAgICAgICAgICAgPSAlZDM3ICgoRGVjIGRtaW4gJWQ0NSBkbWF4KSAvIChIZXggeG1pbiAlZDQ1IHhtYXgpIC8gKEJpbiBibWluICVkNDUgYm1heCkpXFxuXCI7XG4gICAgc3RyICs9IFwiVGJzT3AgICAgICAgICAgID0gJWQzNyAoKERlYyBkU3RyaW5nICooJWQ0NiBkU3RyaW5nKSkgLyAoSGV4IHhTdHJpbmcgKiglZDQ2IHhTdHJpbmcpKSAvIChCaW4gYlN0cmluZyAqKCVkNDYgYlN0cmluZykpKVxcblwiO1xuICAgIHN0ciArPSBcIlRsc09wICAgICAgICAgICA9IFRsc0Nhc2UgVGxzT3BlbiBUbHNTdHJpbmcgVGxzQ2xvc2VcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNDYXNlICAgICAgICAgPSBbXFxcIiVpXFxcIiAvIFxcXCIlc1xcXCJdXFxuXCI7XG4gICAgc3RyICs9IFwiVGxzT3BlbiAgICAgICAgID0gJWQzNFxcblwiO1xuICAgIHN0ciArPSBcIlRsc0Nsb3NlICAgICAgICA9ICVkMzRcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNTdHJpbmcgICAgICAgPSAqKCVkMzItMzMvJWQzNS0xMjYvU3RyaW5nVGFiKVxcblwiO1xuICAgIHN0ciArPSBcIlN0cmluZ1RhYiAgICAgICA9ICVkOVxcblwiO1xuICAgIHN0ciArPSBcIkNsc09wICAgICAgICAgICA9IENsc09wZW4gQ2xzU3RyaW5nIENsc0Nsb3NlXFxuXCI7XG4gICAgc3RyICs9IFwiQ2xzT3BlbiAgICAgICAgID0gJWQzOVxcblwiO1xuICAgIHN0ciArPSBcIkNsc0Nsb3NlICAgICAgICA9ICVkMzlcXG5cIjtcbiAgICBzdHIgKz0gXCJDbHNTdHJpbmcgICAgICAgPSAqKCVkMzItMzgvJWQ0MC0xMjYvU3RyaW5nVGFiKVxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWwgICAgICAgICA9IFByb3NWYWxPcGVuIFByb3NWYWxTdHJpbmcgUHJvc1ZhbENsb3NlXFxuXCI7XG4gICAgc3RyICs9IFwiUHJvc1ZhbE9wZW4gICAgID0gJWQ2MFxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWxTdHJpbmcgICA9ICooJWQzMi02MS8lZDYzLTEyNi9TdHJpbmdUYWIpXFxuXCI7XG4gICAgc3RyICs9IFwiUHJvc1ZhbENsb3NlICAgID0gJWQ2MlxcblwiO1xuICAgIHN0ciArPSBcInJlcC1taW4gICAgICAgICA9IHJlcC1udW1cXG5cIjtcbiAgICBzdHIgKz0gXCJyZXAtbWluLW1heCAgICAgPSByZXAtbnVtXFxuXCI7XG4gICAgc3RyICs9IFwicmVwLW1heCAgICAgICAgID0gcmVwLW51bVxcblwiO1xuICAgIHN0ciArPSBcInJlcC1udW0gICAgICAgICA9IDEqKCVkNDgtNTcpXFxuXCI7XG4gICAgc3RyICs9IFwiZFN0cmluZyAgICAgICAgID0gZG51bVxcblwiO1xuICAgIHN0ciArPSBcInhTdHJpbmcgICAgICAgICA9IHhudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJiU3RyaW5nICAgICAgICAgPSBibnVtXFxuXCI7XG4gICAgc3RyICs9IFwiRGVjICAgICAgICAgICAgID0gKCVkNjgvJWQxMDApXFxuXCI7XG4gICAgc3RyICs9IFwiSGV4ICAgICAgICAgICAgID0gKCVkODgvJWQxMjApXFxuXCI7XG4gICAgc3RyICs9IFwiQmluICAgICAgICAgICAgID0gKCVkNjYvJWQ5OClcXG5cIjtcbiAgICBzdHIgKz0gXCJkbWluICAgICAgICAgICAgPSBkbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiZG1heCAgICAgICAgICAgID0gZG51bVxcblwiO1xuICAgIHN0ciArPSBcImJtaW4gICAgICAgICAgICA9IGJudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJibWF4ICAgICAgICAgICAgPSBibnVtXFxuXCI7XG4gICAgc3RyICs9IFwieG1pbiAgICAgICAgICAgID0geG51bVxcblwiO1xuICAgIHN0ciArPSBcInhtYXggICAgICAgICAgICA9IHhudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJkbnVtICAgICAgICAgICAgPSAxKiglZDQ4LTU3KVxcblwiO1xuICAgIHN0ciArPSBcImJudW0gICAgICAgICAgICA9IDEqJWQ0OC00OVxcblwiO1xuICAgIHN0ciArPSBcInhudW0gICAgICAgICAgICA9IDEqKCVkNDgtNTcgLyAlZDY1LTcwIC8gJWQ5Ny0xMDIpXFxuXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgQmFzaWNzXFxuXCI7XG4gICAgc3RyICs9IFwiYWxwaGFudW0gICAgICAgID0gKCVkOTctMTIyLyVkNjUtOTApICooJWQ5Ny0xMjIvJWQ2NS05MC8lZDQ4LTU3LyVkNDUpXFxuXCI7XG4gICAgc3RyICs9IFwib3dzcCAgICAgICAgICAgID0gKnNwYWNlXFxuXCI7XG4gICAgc3RyICs9IFwid3NwICAgICAgICAgICAgID0gMSpzcGFjZVxcblwiO1xuICAgIHN0ciArPSBcInNwYWNlICAgICAgICAgICA9ICVkMzJcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyAlZDlcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBjb21tZW50XFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gTGluZUNvbnRpbnVlXFxuXCI7XG4gICAgc3RyICs9IFwiY29tbWVudCAgICAgICAgID0gJWQ1OSAqKCVkMzItMTI2IC8gJWQ5KVxcblwiO1xuICAgIHN0ciArPSBcIkxpbmVFbmQgICAgICAgICA9ICVkMTMuMTBcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyAlZDEwXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gJWQxM1xcblwiO1xuICAgIHN0ciArPSBcIkxpbmVDb250aW51ZSAgICA9ICglZDEzLjEwIC8gJWQxMCAvICVkMTMpICglZDMyIC8gJWQ5KVxcblwiO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/sabnf-grammar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/scanner-callbacks.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner-callbacks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// These are the AST translation callback functions used by the scanner\n// to analyze the characters and lines.\nconst ids = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\nconst utils = __webpack_require__(/*! ../apg-lib/utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n\nfunction semLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: data.textLength,\n      endType: data.endType,\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semLineText(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.textLength = phraseCount;\n  }\n  return ids.SEM_OK;\n}\nfunction semLastLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else if (data.strict) {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: phraseCount,\n      endType: 'none',\n      invalidChars: data.invalidCount,\n    });\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex + phraseCount,\n      msg: 'no line end on last line - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n    });\n  } else {\n    /* add a line ender */\n    chars.push(10);\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount + 1,\n      textLength: phraseCount,\n      endType: 'LF',\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semInvalid(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex,\n      msg: `invalid character found '\\\\x${utils.charToHex(chars[phraseIndex])}'`,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semEnd(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_POST) {\n    data.lineNo += 1;\n  }\n  return ids.SEM_OK;\n}\nfunction semLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'LF';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character LF(\\\\n, \\\\x0A) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCR(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CR';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character CR(\\\\r, \\\\x0D) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCRLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CRLF';\n  }\n  return ids.SEM_OK;\n}\nconst callbacks = [];\ncallbacks.line = semLine;\ncallbacks['line-text'] = semLineText;\ncallbacks['last-line'] = semLastLine;\ncallbacks.invalid = semInvalid;\ncallbacks.end = semEnd;\ncallbacks.lf = semLF;\ncallbacks.cr = semCR;\ncallbacks.crlf = semCRLF;\nexports.callbacks = callbacks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxzRkFBd0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLGtGQUFzQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQ0FBb0M7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zY2FubmVyLWNhbGxiYWNrcy5qcz85MzAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoZXNlIGFyZSB0aGUgQVNUIHRyYW5zbGF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9ucyB1c2VkIGJ5IHRoZSBzY2FubmVyXG4vLyB0byBhbmFseXplIHRoZSBjaGFyYWN0ZXJzIGFuZCBsaW5lcy5cbmNvbnN0IGlkcyA9IHJlcXVpcmUoJy4uL2FwZy1saWIvaWRlbnRpZmllcnMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vYXBnLWxpYi91dGlsaXRpZXMnKTtcblxuZnVuY3Rpb24gc2VtTGluZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lbmRMZW5ndGggPSAwO1xuICAgIGRhdGEudGV4dExlbmd0aCA9IDA7XG4gICAgZGF0YS5pbnZhbGlkQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGRhdGEubGluZXMucHVzaCh7XG4gICAgICBsaW5lTm86IGRhdGEubGluZXMubGVuZ3RoLFxuICAgICAgYmVnaW5DaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgIGxlbmd0aDogcGhyYXNlQ291bnQsXG4gICAgICB0ZXh0TGVuZ3RoOiBkYXRhLnRleHRMZW5ndGgsXG4gICAgICBlbmRUeXBlOiBkYXRhLmVuZFR5cGUsXG4gICAgICBpbnZhbGlkQ2hhcnM6IGRhdGEuaW52YWxpZENvdW50LFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtTGluZVRleHQoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEudGV4dExlbmd0aCA9IHBocmFzZUNvdW50O1xuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtTGFzdExpbmUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kTGVuZ3RoID0gMDtcbiAgICBkYXRhLnRleHRMZW5ndGggPSAwO1xuICAgIGRhdGEuaW52YWxpZENvdW50ID0gMDtcbiAgfSBlbHNlIGlmIChkYXRhLnN0cmljdCkge1xuICAgIGRhdGEubGluZXMucHVzaCh7XG4gICAgICBsaW5lTm86IGRhdGEubGluZXMubGVuZ3RoLFxuICAgICAgYmVnaW5DaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgIGxlbmd0aDogcGhyYXNlQ291bnQsXG4gICAgICB0ZXh0TGVuZ3RoOiBwaHJhc2VDb3VudCxcbiAgICAgIGVuZFR5cGU6ICdub25lJyxcbiAgICAgIGludmFsaWRDaGFyczogZGF0YS5pbnZhbGlkQ291bnQsXG4gICAgfSk7XG4gICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICBsaW5lOiBkYXRhLmxpbmVObyxcbiAgICAgIGNoYXI6IHBocmFzZUluZGV4ICsgcGhyYXNlQ291bnQsXG4gICAgICBtc2c6ICdubyBsaW5lIGVuZCBvbiBsYXN0IGxpbmUgLSBzdHJpY3QgQUJORiBzcGVjaWZpZXMgQ1JMRihcXFxcclxcXFxuLCBcXFxceDBEXFxcXHgwQSknLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8qIGFkZCBhIGxpbmUgZW5kZXIgKi9cbiAgICBjaGFycy5wdXNoKDEwKTtcbiAgICBkYXRhLmxpbmVzLnB1c2goe1xuICAgICAgbGluZU5vOiBkYXRhLmxpbmVzLmxlbmd0aCxcbiAgICAgIGJlZ2luQ2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICBsZW5ndGg6IHBocmFzZUNvdW50ICsgMSxcbiAgICAgIHRleHRMZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgZW5kVHlwZTogJ0xGJyxcbiAgICAgIGludmFsaWRDaGFyczogZGF0YS5pbnZhbGlkQ291bnQsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1JbnZhbGlkKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgIGxpbmU6IGRhdGEubGluZU5vLFxuICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICBtc2c6IGBpbnZhbGlkIGNoYXJhY3RlciBmb3VuZCAnXFxcXHgke3V0aWxzLmNoYXJUb0hleChjaGFyc1twaHJhc2VJbmRleF0pfSdgLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtRW5kKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QT1NUKSB7XG4gICAgZGF0YS5saW5lTm8gKz0gMTtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUxGKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLmVuZFR5cGUgPSAnTEYnO1xuICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgIGxpbmU6IGRhdGEubGluZU5vLFxuICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgbXNnOiAnbGluZSBlbmQgY2hhcmFjdGVyIExGKFxcXFxuLCBcXFxceDBBKSAtIHN0cmljdCBBQk5GIHNwZWNpZmllcyBDUkxGKFxcXFxyXFxcXG4sIFxcXFx4MERcXFxceDBBKScsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1DUihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lbmRUeXBlID0gJ0NSJztcbiAgICBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICBsaW5lOiBkYXRhLmxpbmVObyxcbiAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgIG1zZzogJ2xpbmUgZW5kIGNoYXJhY3RlciBDUihcXFxcciwgXFxcXHgwRCkgLSBzdHJpY3QgQUJORiBzcGVjaWZpZXMgQ1JMRihcXFxcclxcXFxuLCBcXFxceDBEXFxcXHgwQSknLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtQ1JMRihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lbmRUeXBlID0gJ0NSTEYnO1xuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuY29uc3QgY2FsbGJhY2tzID0gW107XG5jYWxsYmFja3MubGluZSA9IHNlbUxpbmU7XG5jYWxsYmFja3NbJ2xpbmUtdGV4dCddID0gc2VtTGluZVRleHQ7XG5jYWxsYmFja3NbJ2xhc3QtbGluZSddID0gc2VtTGFzdExpbmU7XG5jYWxsYmFja3MuaW52YWxpZCA9IHNlbUludmFsaWQ7XG5jYWxsYmFja3MuZW5kID0gc2VtRW5kO1xuY2FsbGJhY2tzLmxmID0gc2VtTEY7XG5jYWxsYmFja3MuY3IgPSBzZW1DUjtcbmNhbGxiYWNrcy5jcmxmID0gc2VtQ1JMRjtcbmV4cG9ydHMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/scanner-callbacks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/scanner-grammar.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner-grammar.js ***!
  \************************************************************/
/***/ ((module) => {

eval("// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 10\n  //       udts = 0\n  //    opcodes = 31\n  //        ---   ABNF original opcodes\n  //        ALT = 5\n  //        CAT = 2\n  //        REP = 4\n  //        RNM = 11\n  //        TLS = 0\n  //        TBS = 4\n  //        TRG = 5\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [0 - 4294967295]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = {name: 'file', lower: 'file', index: 0, isBkr: false};\n  this.rules[1] = {name: 'line', lower: 'line', index: 1, isBkr: false};\n  this.rules[2] = {name: 'line-text', lower: 'line-text', index: 2, isBkr: false};\n  this.rules[3] = {name: 'last-line', lower: 'last-line', index: 3, isBkr: false};\n  this.rules[4] = {name: 'valid', lower: 'valid', index: 4, isBkr: false};\n  this.rules[5] = {name: 'invalid', lower: 'invalid', index: 5, isBkr: false};\n  this.rules[6] = {name: 'end', lower: 'end', index: 6, isBkr: false};\n  this.rules[7] = {name: 'CRLF', lower: 'crlf', index: 7, isBkr: false};\n  this.rules[8] = {name: 'LF', lower: 'lf', index: 8, isBkr: false};\n  this.rules[9] = {name: 'CR', lower: 'cr', index: 9, isBkr: false};\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* file */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = {type: 2, children: [1,3]};// CAT\n  this.rules[0].opcodes[1] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[0].opcodes[2] = {type: 4, index: 1};// RNM(line)\n  this.rules[0].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[0].opcodes[4] = {type: 4, index: 3};// RNM(last-line)\n\n  /* line */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[1].opcodes[1] = {type: 4, index: 2};// RNM(line-text)\n  this.rules[1].opcodes[2] = {type: 4, index: 6};// RNM(end)\n\n  /* line-text */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[2].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[2].opcodes[2] = {type: 4, index: 4};// RNM(valid)\n  this.rules[2].opcodes[3] = {type: 4, index: 5};// RNM(invalid)\n\n  /* last-line */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[3].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[3].opcodes[2] = {type: 4, index: 4};// RNM(valid)\n  this.rules[3].opcodes[3] = {type: 4, index: 5};// RNM(invalid)\n\n  /* valid */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[4].opcodes[1] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[4].opcodes[2] = {type: 6, string: [9]};// TBS\n\n  /* invalid */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[5].opcodes[1] = {type: 5, min: 0, max: 8};// TRG\n  this.rules[5].opcodes[2] = {type: 5, min: 11, max: 12};// TRG\n  this.rules[5].opcodes[3] = {type: 5, min: 14, max: 31};// TRG\n  this.rules[5].opcodes[4] = {type: 5, min: 127, max: 4294967295};// TRG\n\n  /* end */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[6].opcodes[1] = {type: 4, index: 7};// RNM(CRLF)\n  this.rules[6].opcodes[2] = {type: 4, index: 8};// RNM(LF)\n  this.rules[6].opcodes[3] = {type: 4, index: 9};// RNM(CR)\n\n  /* CRLF */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = {type: 6, string: [13,10]};// TBS\n\n  /* LF */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = {type: 6, string: [10]};// TBS\n\n  /* CR */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = {type: 6, string: [13]};// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \"file = *line [last-line]\\n\";\n    str += \"line = line-text end\\n\";\n    str += \"line-text = *(valid/invalid)\\n\";\n    str += \"last-line = 1*(valid/invalid)\\n\";\n    str += \"valid = %d32-126 / %d9\\n\";\n    str += \"invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\\n\";\n    str += \"end = CRLF / LF / CR\\n\";\n    str += \"CRLF = %d13.10\\n\";\n    str += \"LF = %d10\\n\";\n    str += \"CR = %d13\\n\";\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItZ3JhbW1hci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLGdDQUFnQztBQUM5RCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4Qix5QkFBeUI7QUFDdkQsOEJBQThCLG1CQUFtQjs7QUFFakQ7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLG1CQUFtQjtBQUNqRCw4QkFBOEIsbUJBQW1COztBQUVqRDtBQUNBO0FBQ0EsOEJBQThCLGdDQUFnQztBQUM5RCw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4QixtQkFBbUI7QUFDakQsOEJBQThCLG1CQUFtQjs7QUFFakQ7QUFDQTtBQUNBLDhCQUE4QixnQ0FBZ0M7QUFDOUQsOEJBQThCLDBCQUEwQjtBQUN4RCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4QixtQkFBbUI7O0FBRWpEO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4Qiw0QkFBNEI7QUFDMUQsOEJBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQsOEJBQThCLHlCQUF5QjtBQUN2RCw4QkFBOEIsMkJBQTJCO0FBQ3pELDhCQUE4QiwyQkFBMkI7QUFDekQsOEJBQThCLG9DQUFvQzs7QUFFbEU7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQsOEJBQThCLG1CQUFtQjtBQUNqRCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4QixtQkFBbUI7O0FBRWpEO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCOztBQUV4RDtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1Qjs7QUFFckQ7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zY2FubmVyLWdyYW1tYXIuanM/OWQxMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMyBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkPGJyPlxuLy8gICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKTxicj5cbi8vXG4vLyBHZW5lcmF0ZWQgYnkgYXBnLWpzLCBWZXJzaW9uIDQuMi4xIFthcGctanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdyYW1tYXIoKXtcbiAgLy8gYGBgXG4gIC8vIFNVTU1BUllcbiAgLy8gICAgICBydWxlcyA9IDEwXG4gIC8vICAgICAgIHVkdHMgPSAwXG4gIC8vICAgIG9wY29kZXMgPSAzMVxuICAvLyAgICAgICAgLS0tICAgQUJORiBvcmlnaW5hbCBvcGNvZGVzXG4gIC8vICAgICAgICBBTFQgPSA1XG4gIC8vICAgICAgICBDQVQgPSAyXG4gIC8vICAgICAgICBSRVAgPSA0XG4gIC8vICAgICAgICBSTk0gPSAxMVxuICAvLyAgICAgICAgVExTID0gMFxuICAvLyAgICAgICAgVEJTID0gNFxuICAvLyAgICAgICAgVFJHID0gNVxuICAvLyAgICAgICAgLS0tICAgU0FCTkYgc3VwZXJzZXQgb3Bjb2Rlc1xuICAvLyAgICAgICAgVURUID0gMFxuICAvLyAgICAgICAgQU5EID0gMFxuICAvLyAgICAgICAgTk9UID0gMFxuICAvLyAgICAgICAgQktBID0gMFxuICAvLyAgICAgICAgQktOID0gMFxuICAvLyAgICAgICAgQktSID0gMFxuICAvLyAgICAgICAgQUJHID0gMFxuICAvLyAgICAgICAgQUVOID0gMFxuICAvLyBjaGFyYWN0ZXJzID0gWzAgLSA0Mjk0OTY3Mjk1XVxuICAvLyBgYGBcbiAgLyogT0JKRUNUIElERU5USUZJRVIgKGZvciBpbnRlcm5hbCBwYXJzZXIgdXNlKSAqL1xuICB0aGlzLmdyYW1tYXJPYmplY3QgPSAnZ3JhbW1hck9iamVjdCc7XG5cbiAgLyogUlVMRVMgKi9cbiAgdGhpcy5ydWxlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzBdID0ge25hbWU6ICdmaWxlJywgbG93ZXI6ICdmaWxlJywgaW5kZXg6IDAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMV0gPSB7bmFtZTogJ2xpbmUnLCBsb3dlcjogJ2xpbmUnLCBpbmRleDogMSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syXSA9IHtuYW1lOiAnbGluZS10ZXh0JywgbG93ZXI6ICdsaW5lLXRleHQnLCBpbmRleDogMiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1szXSA9IHtuYW1lOiAnbGFzdC1saW5lJywgbG93ZXI6ICdsYXN0LWxpbmUnLCBpbmRleDogMywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s0XSA9IHtuYW1lOiAndmFsaWQnLCBsb3dlcjogJ3ZhbGlkJywgaW5kZXg6IDQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNV0gPSB7bmFtZTogJ2ludmFsaWQnLCBsb3dlcjogJ2ludmFsaWQnLCBpbmRleDogNSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s2XSA9IHtuYW1lOiAnZW5kJywgbG93ZXI6ICdlbmQnLCBpbmRleDogNiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3XSA9IHtuYW1lOiAnQ1JMRicsIGxvd2VyOiAnY3JsZicsIGluZGV4OiA3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzhdID0ge25hbWU6ICdMRicsIGxvd2VyOiAnbGYnLCBpbmRleDogOCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5XSA9IHtuYW1lOiAnQ1InLCBsb3dlcjogJ2NyJywgaW5kZXg6IDksIGlzQmtyOiBmYWxzZX07XG5cbiAgLyogVURUUyAqL1xuICB0aGlzLnVkdHMgPSBbXTtcblxuICAvKiBPUENPREVTICovXG4gIC8qIGZpbGUgKi9cbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMV0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAxfTsvLyBSTk0obGluZSlcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzNdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiAxfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAzfTsvLyBSTk0obGFzdC1saW5lKVxuXG4gIC8qIGxpbmUgKi9cbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDJ9Oy8vIFJOTShsaW5lLXRleHQpXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNn07Ly8gUk5NKGVuZClcblxuICAvKiBsaW5lLXRleHQgKi9cbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA0fTsvLyBSTk0odmFsaWQpXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogNX07Ly8gUk5NKGludmFsaWQpXG5cbiAgLyogbGFzdC1saW5lICovXG4gIHRoaXMucnVsZXNbM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNH07Ly8gUk5NKHZhbGlkKVxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDV9Oy8vIFJOTShpbnZhbGlkKVxuXG4gIC8qIHZhbGlkICovXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzldfTsvLyBUQlNcblxuICAvKiBpbnZhbGlkICovXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDAsIG1heDogOH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDExLCBtYXg6IDEyfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogMTQsIG1heDogMzF9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbNF0gPSB7dHlwZTogNSwgbWluOiAxMjcsIG1heDogNDI5NDk2NzI5NX07Ly8gVFJHXG5cbiAgLyogZW5kICovXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDd9Oy8vIFJOTShDUkxGKVxuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDh9Oy8vIFJOTShMRilcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA5fTsvLyBSTk0oQ1IpXG5cbiAgLyogQ1JMRiAqL1xuICB0aGlzLnJ1bGVzWzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzLDEwXX07Ly8gVEJTXG5cbiAgLyogTEYgKi9cbiAgdGhpcy5ydWxlc1s4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMF19Oy8vIFRCU1xuXG4gIC8qIENSICovXG4gIHRoaXMucnVsZXNbOV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTNdfTsvLyBUQlNcblxuICAvLyBUaGUgYHRvU3RyaW5nKClgIGZ1bmN0aW9uIHdpbGwgZGlzcGxheSB0aGUgb3JpZ2luYWwgZ3JhbW1hciBmaWxlKHMpIHRoYXQgcHJvZHVjZWQgdGhlc2Ugb3Bjb2Rlcy5cbiAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgc3RyICs9IFwiZmlsZSA9ICpsaW5lIFtsYXN0LWxpbmVdXFxuXCI7XG4gICAgc3RyICs9IFwibGluZSA9IGxpbmUtdGV4dCBlbmRcXG5cIjtcbiAgICBzdHIgKz0gXCJsaW5lLXRleHQgPSAqKHZhbGlkL2ludmFsaWQpXFxuXCI7XG4gICAgc3RyICs9IFwibGFzdC1saW5lID0gMSoodmFsaWQvaW52YWxpZClcXG5cIjtcbiAgICBzdHIgKz0gXCJ2YWxpZCA9ICVkMzItMTI2IC8gJWQ5XFxuXCI7XG4gICAgc3RyICs9IFwiaW52YWxpZCA9ICVkMC04IC8gJWQxMS0xMiAvJWQxNC0zMSAvICV4N2YtZmZmZmZmZmZcXG5cIjtcbiAgICBzdHIgKz0gXCJlbmQgPSBDUkxGIC8gTEYgLyBDUlxcblwiO1xuICAgIHN0ciArPSBcIkNSTEYgPSAlZDEzLjEwXFxuXCI7XG4gICAgc3RyICs9IFwiTEYgPSAlZDEwXFxuXCI7XG4gICAgc3RyICs9IFwiQ1IgPSAlZDEzXFxuXCI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/scanner-grammar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/scanner.js":
/*!****************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module reads the input grammar file and does a preliminary analysis\n// before attempting to parse it into a grammar object.\n// See:<br>\n// `./dist/scanner-grammar.bnf`<br>\n// for the grammar file this parser is based on.\n//\n// It has two primary functions.\n// - verify the character codes - no non-printing ASCII characters\n// - catalog the lines - create an array with a line object for each line.\n// The object carries information about the line number and character length which is used\n// by the parser generator primarily for error reporting.\nmodule.exports = function exfn(chars, errors, strict, trace) {\n  const thisFileName = 'scanner.js: ';\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const grammar = new (__webpack_require__(/*! ./scanner-grammar */ \"(ssr)/./node_modules/apg-js/src/apg-api/scanner-grammar.js\"))();\n  const { callbacks } = __webpack_require__(/*! ./scanner-callbacks */ \"(ssr)/./node_modules/apg-js/src/apg-api/scanner-callbacks.js\");\n\n  /* Scan the grammar for character code errors and catalog the lines. */\n  const lines = [];\n  // eslint-disable-next-line new-cap\n  const parser = new apglib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new apglib.ast();\n  parser.ast.callbacks = callbacks;\n  if (trace) {\n    if (trace.traceObject !== 'traceObject') {\n      throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n    }\n    parser.trace = trace;\n  }\n\n  /* parse the input SABNF grammar */\n  const test = parser.parse(grammar, 'file', chars);\n  if (test.success !== true) {\n    errors.push({\n      line: 0,\n      char: 0,\n      msg: 'syntax analysis error analyzing input SABNF grammar',\n    });\n    return;\n  }\n  const data = {\n    lines,\n    lineNo: 0,\n    errors,\n    strict: !!strict,\n  };\n\n  /* translate (analyze) the input SABNF grammar */\n  parser.ast.translate(data);\n  // eslint-disable-next-line consistent-return\n  return lines;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNsRCx1QkFBdUIsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDbEQsVUFBVSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyx5RkFBcUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXIuanM/YjA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSByZWFkcyB0aGUgaW5wdXQgZ3JhbW1hciBmaWxlIGFuZCBkb2VzIGEgcHJlbGltaW5hcnkgYW5hbHlzaXNcbi8vIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHBhcnNlIGl0IGludG8gYSBncmFtbWFyIG9iamVjdC5cbi8vIFNlZTo8YnI+XG4vLyBgLi9kaXN0L3NjYW5uZXItZ3JhbW1hci5ibmZgPGJyPlxuLy8gZm9yIHRoZSBncmFtbWFyIGZpbGUgdGhpcyBwYXJzZXIgaXMgYmFzZWQgb24uXG4vL1xuLy8gSXQgaGFzIHR3byBwcmltYXJ5IGZ1bmN0aW9ucy5cbi8vIC0gdmVyaWZ5IHRoZSBjaGFyYWN0ZXIgY29kZXMgLSBubyBub24tcHJpbnRpbmcgQVNDSUkgY2hhcmFjdGVyc1xuLy8gLSBjYXRhbG9nIHRoZSBsaW5lcyAtIGNyZWF0ZSBhbiBhcnJheSB3aXRoIGEgbGluZSBvYmplY3QgZm9yIGVhY2ggbGluZS5cbi8vIFRoZSBvYmplY3QgY2FycmllcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluZSBudW1iZXIgYW5kIGNoYXJhY3RlciBsZW5ndGggd2hpY2ggaXMgdXNlZFxuLy8gYnkgdGhlIHBhcnNlciBnZW5lcmF0b3IgcHJpbWFyaWx5IGZvciBlcnJvciByZXBvcnRpbmcuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4Zm4oY2hhcnMsIGVycm9ycywgc3RyaWN0LCB0cmFjZSkge1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnc2Nhbm5lci5qczogJztcbiAgY29uc3QgYXBnbGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgZ3JhbW1hciA9IG5ldyAocmVxdWlyZSgnLi9zY2FubmVyLWdyYW1tYXInKSkoKTtcbiAgY29uc3QgeyBjYWxsYmFja3MgfSA9IHJlcXVpcmUoJy4vc2Nhbm5lci1jYWxsYmFja3MnKTtcblxuICAvKiBTY2FuIHRoZSBncmFtbWFyIGZvciBjaGFyYWN0ZXIgY29kZSBlcnJvcnMgYW5kIGNhdGFsb2cgdGhlIGxpbmVzLiAqL1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICBjb25zdCBwYXJzZXIgPSBuZXcgYXBnbGliLnBhcnNlcigpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICBwYXJzZXIuYXN0ID0gbmV3IGFwZ2xpYi5hc3QoKTtcbiAgcGFyc2VyLmFzdC5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gIGlmICh0cmFjZSkge1xuICAgIGlmICh0cmFjZS50cmFjZU9iamVjdCAhPT0gJ3RyYWNlT2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzRmlsZU5hbWV9dHJhY2UgYXJndW1lbnQgaXMgbm90IGEgdHJhY2Ugb2JqZWN0YCk7XG4gICAgfVxuICAgIHBhcnNlci50cmFjZSA9IHRyYWNlO1xuICB9XG5cbiAgLyogcGFyc2UgdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgKi9cbiAgY29uc3QgdGVzdCA9IHBhcnNlci5wYXJzZShncmFtbWFyLCAnZmlsZScsIGNoYXJzKTtcbiAgaWYgKHRlc3Quc3VjY2VzcyAhPT0gdHJ1ZSkge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIGxpbmU6IDAsXG4gICAgICBjaGFyOiAwLFxuICAgICAgbXNnOiAnc3ludGF4IGFuYWx5c2lzIGVycm9yIGFuYWx5emluZyBpbnB1dCBTQUJORiBncmFtbWFyJyxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGF0YSA9IHtcbiAgICBsaW5lcyxcbiAgICBsaW5lTm86IDAsXG4gICAgZXJyb3JzLFxuICAgIHN0cmljdDogISFzdHJpY3QsXG4gIH07XG5cbiAgLyogdHJhbnNsYXRlIChhbmFseXplKSB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hciAqL1xuICBwYXJzZXIuYXN0LnRyYW5zbGF0ZShkYXRhKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIHJldHVybiBsaW5lcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/scanner.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/semantic-callbacks.js":
/*!***************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/semantic-callbacks.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the AST translation callback functions for the semantic analysis\n// phase of the generator.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = apglib.ids;\n\n  /* Some helper functions. */\n  const NameList = function NameList() {\n    this.names = [];\n    /* Adds a new rule name object to the list. Returns -1 if the name already exists. */\n    /* Returns the added name object if the name does not already exist. */\n    this.add = function add(name) {\n      let ret = -1;\n      const find = this.get(name);\n      if (find === -1) {\n        ret = {\n          name,\n          lower: name.toLowerCase(),\n          index: this.names.length,\n        };\n        this.names.push(ret);\n      }\n      return ret;\n    };\n    /* Brute-force look up. */\n    this.get = function get(name) {\n      let ret = -1;\n      const lower = name.toLowerCase();\n      for (let i = 0; i < this.names.length; i += 1) {\n        if (this.names[i].lower === lower) {\n          ret = this.names[i];\n          break;\n        }\n      }\n      return ret;\n    };\n  };\n  /* converts text decimal numbers from, e.g. %d99, to an integer */\n  const decnum = function decnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 10 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text binary numbers from, e.g. %b10, to an integer */\n  const binnum = function binnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 2 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text hexadecimal numbers from, e.g. %xff, to an integer */\n  const hexnum = function hexnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      let digit = chars[i];\n      if (digit >= 48 && digit <= 57) {\n        digit -= 48;\n      } else if (digit >= 65 && digit <= 70) {\n        digit -= 55;\n      } else if (digit >= 97 && digit <= 102) {\n        digit -= 87;\n      } else {\n        throw new Error('hexnum out of range');\n      }\n      num = 16 * num + digit;\n    }\n    return num;\n  };\n\n  // This is the prototype for all semantic analysis callback functions.\n  // ````\n  // state - the translator state\n  //   id.SEM_PRE for downward (pre-branch) traversal of the AST\n  //   id.SEM_POST for upward (post branch) traversal of the AST\n  // chars - the array of character codes for the input string\n  // phraseIndex - index into the chars array to the first\n  //               character of the phrase\n  // phraseCount - the number of characters in the phrase\n  // data - user-defined data passed to the translator\n  //        for use by the callback functions.\n  // @return id.SEM_OK, normal return.\n  //         id.SEM_SKIP in state id.SEM_PRE will\n  //         skip the branch below.\n  //         Any thing else is an error which will\n  //         stop the translation.\n  // ````\n  /*\n  function semCallbackPrototype(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n    } else if (state === id.SEM_POST) {\n    }\n    return ret;\n  }\n  */\n  // The AST callback functions.\n  function semFile(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleNames = new NameList();\n      data.udtNames = new NameList();\n      data.rules = [];\n      data.udts = [];\n      data.rulesLineMap = [];\n      data.opcodes = [];\n      data.altStack = [];\n      data.topStack = null;\n      data.topRule = null;\n    } else if (state === id.SEM_POST) {\n      /* validate RNM rule names and set opcode rule index */\n      let nameObj;\n      data.rules.forEach((rule) => {\n        rule.isBkr = false;\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.RNM) {\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj === -1) {\n              data.errors.push({\n                line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                char: op.index.phraseIndex,\n                msg: `Rule name '${op.index.name}' used but not defined.`,\n              });\n              op.index = -1;\n            } else {\n              op.index = nameObj.index;\n            }\n          }\n        });\n      });\n      /* validate BKR rule names and set opcode rule index */\n      data.udts.forEach((udt) => {\n        udt.isBkr = false;\n      });\n      data.rules.forEach((rule) => {\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.BKR) {\n            rule.hasBkr = true;\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj !== -1) {\n              data.rules[nameObj.index].isBkr = true;\n              op.index = nameObj.index;\n            } else {\n              nameObj = data.udtNames.get(op.index.name);\n              if (nameObj !== -1) {\n                data.udts[nameObj.index].isBkr = true;\n                op.index = data.rules.length + nameObj.index;\n              } else {\n                data.errors.push({\n                  line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                  char: op.index.phraseIndex,\n                  msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`,\n                });\n                op.index = -1;\n              }\n            }\n          }\n        });\n      });\n    }\n    return ret;\n  }\n  function semRule(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.altStack.length = 0;\n      data.topStack = null;\n      data.rulesLineMap.push({\n        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = '';\n      data.definedas = '';\n    } else if (state === id.SEM_POST) {\n      let ruleName;\n      if (data.definedas === '=') {\n        ruleName = data.ruleNames.add(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' previously defined.`,\n          });\n        } else {\n          /* start a new rule */\n          data.topRule = {\n            name: ruleName.name,\n            lower: ruleName.lower,\n            opcodes: [],\n            index: ruleName.index,\n          };\n          data.rules.push(data.topRule);\n          data.opcodes = data.topRule.opcodes;\n        }\n      } else {\n        ruleName = data.ruleNames.get(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`,\n          });\n        } else {\n          data.topRule = data.rules[ruleName.index];\n          data.opcodes = data.topRule.opcodes;\n        }\n      }\n    }\n    return ret;\n  }\n  function semAlternation(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      const TRUE = true;\n      while (TRUE) {\n        if (data.definedas === null) {\n          /* rule error - skip opcode generation */\n          ret = id.SEM_SKIP;\n          break;\n        }\n        if (data.topStack === null) {\n          /* top-level ALT */\n          if (data.definedas === '=') {\n            /* \"=\" new rule */\n            data.topStack = {\n              alt: {\n                type: id.ALT,\n                children: [],\n              },\n              cat: null,\n            };\n            data.altStack.push(data.topStack);\n            data.opcodes.push(data.topStack.alt);\n            break;\n          }\n          /* \"=/\" incremental alternate */\n          data.topStack = {\n            alt: data.opcodes[0],\n            cat: null,\n          };\n          data.altStack.push(data.topStack);\n          break;\n        }\n        /* lower-level ALT */\n        data.topStack = {\n          alt: {\n            type: id.ALT,\n            children: [],\n          },\n          cat: null,\n        };\n        data.altStack.push(data.topStack);\n        data.opcodes.push(data.topStack.alt);\n        break;\n      }\n    } else if (state === id.SEM_POST) {\n      data.altStack.pop();\n      if (data.altStack.length > 0) {\n        data.topStack = data.altStack[data.altStack.length - 1];\n      } else {\n        data.topStack = null;\n      }\n    }\n    return ret;\n  }\n  function semConcatenation(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.alt.children.push(data.opcodes.length);\n      data.topStack.cat = {\n        type: id.CAT,\n        children: [],\n      };\n      data.opcodes.push(data.topStack.cat);\n    } else if (state === id.SEM_POST) {\n      data.topStack.cat = null;\n    }\n    return ret;\n  }\n  function semRepetition(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.cat.children.push(data.opcodes.length);\n    }\n    return ret;\n  }\n  function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.REP,\n        min: 0,\n        max: 1,\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDefined(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=';\n    }\n    return ret;\n  }\n  function semIncAlt(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=/';\n    }\n    return ret;\n  }\n  function semRepOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = Infinity;\n      data.topRep = {\n        type: id.REP,\n        min: 0,\n        max: Infinity,\n      };\n      data.opcodes.push(data.topRep);\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.topRep.min = data.min;\n      data.topRep.max = data.max;\n    }\n    return ret;\n  }\n  function semRepMin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n      data.min = data.max;\n    }\n    return ret;\n  }\n  function semAndOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AND,\n      });\n    }\n    return ret;\n  }\n  function semNotOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.NOT,\n      });\n    }\n    return ret;\n  }\n  function semRnmOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.RNM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex,\n          name: apglib.utils.charsToString(chars, phraseIndex, phraseCount),\n        },\n      });\n    }\n    return ret;\n  }\n  function semAbgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.ABG,\n      });\n    }\n    return ret;\n  }\n  function semAenOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AEN,\n      });\n    }\n    return ret;\n  }\n  function semBkaOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKA,\n      });\n    }\n    return ret;\n  }\n  function semBknOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKN,\n      });\n    }\n    return ret;\n  }\n  function semBkrOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ci = true; /* default to case insensitive */\n      data.cs = false;\n      data.um = true;\n      data.pm = false;\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKR,\n        bkrCase: data.cs === true ? id.BKR_MODE_CS : id.BKR_MODE_CI,\n        bkrMode: data.pm === true ? id.BKR_MODE_PM : id.BKR_MODE_UM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex: data.bkrname.phraseIndex,\n          name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength),\n        },\n      });\n    }\n    return ret;\n  }\n  function semBkrCi(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.ci = true;\n    }\n    return ret;\n  }\n  function semBkrCs(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.cs = true;\n    }\n    return ret;\n  }\n  function semBkrUm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.um = true;\n    }\n    return ret;\n  }\n  function semBkrPm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.pm = true;\n    }\n    return ret;\n  }\n  function semBkrName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.bkrname = {\n        phraseIndex,\n        phraseLength: phraseCount,\n      };\n    }\n    return ret;\n  }\n  function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: true,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: true,\n        index: udtName.index,\n      });\n    }\n    return ret;\n  }\n  function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtNonEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: false,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: false,\n        index: udtName.index,\n        syntax: null,\n        semantic: null,\n      });\n    }\n    return ret;\n  }\n  function semTlsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tlscase = true; /* default to case insensitive */\n    }\n    return ret;\n  }\n  function semTlsCase(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {\n        data.tlscase = false; /* set to case sensitive */\n      }\n    }\n    return ret;\n  }\n  function semTlsString(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (data.tlscase) {\n        const str = chars.slice(phraseIndex, phraseIndex + phraseCount);\n        for (let i = 0; i < str.length; i += 1) {\n          if (str[i] >= 65 && str[i] <= 90) {\n            str[i] += 32;\n          }\n        }\n        data.opcodes.push({\n          type: id.TLS,\n          string: str,\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex, phraseIndex + phraseCount),\n        });\n      }\n    }\n    return ret;\n  }\n  function semClsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount <= 2) {\n        /* only TLS is allowed to be empty */\n        data.opcodes.push({\n          type: id.TLS,\n          string: [],\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1),\n        });\n      }\n    }\n    return ret;\n  }\n  function semTbsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tbsstr = [];\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.TBS,\n        string: data.tbsstr,\n      });\n    }\n    return ret;\n  }\n  function semTrgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = 0;\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.opcodes.push({\n        type: id.TRG,\n        min: data.min,\n        max: data.max,\n      });\n    }\n    return ret;\n  }\n  function semDmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semBstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semXstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  // Define the callback functions to the AST object.\n  this.callbacks = [];\n  this.callbacks.abgop = semAbgOp;\n  this.callbacks.aenop = semAenOp;\n  this.callbacks.alternation = semAlternation;\n  this.callbacks.andop = semAndOp;\n  this.callbacks.bmax = semBmax;\n  this.callbacks.bmin = semBmin;\n  this.callbacks.bkaop = semBkaOp;\n  this.callbacks.bknop = semBknOp;\n  this.callbacks.bkrop = semBkrOp;\n  this.callbacks['bkr-name'] = semBkrName;\n  this.callbacks.bstring = semBstring;\n  this.callbacks.clsop = semClsOp;\n  this.callbacks.ci = semBkrCi;\n  this.callbacks.cs = semBkrCs;\n  this.callbacks.um = semBkrUm;\n  this.callbacks.pm = semBkrPm;\n  this.callbacks.concatenation = semConcatenation;\n  this.callbacks.defined = semDefined;\n  this.callbacks.dmax = semDmax;\n  this.callbacks.dmin = semDmin;\n  this.callbacks.dstring = semDstring;\n  this.callbacks.file = semFile;\n  this.callbacks.incalt = semIncAlt;\n  this.callbacks.notop = semNotOp;\n  this.callbacks.optionopen = semOptionOpen;\n  this.callbacks['rep-max'] = semRepMax;\n  this.callbacks['rep-min'] = semRepMin;\n  this.callbacks['rep-min-max'] = semRepMinMax;\n  this.callbacks.repetition = semRepetition;\n  this.callbacks.repop = semRepOp;\n  this.callbacks.rnmop = semRnmOp;\n  this.callbacks.rule = semRule;\n  this.callbacks.rulelookup = semRuleLookup;\n  this.callbacks.rulename = semRuleName;\n  this.callbacks.tbsop = semTbsOp;\n  this.callbacks.tlscase = semTlsCase;\n  this.callbacks.tlsstring = semTlsString;\n  this.callbacks.tlsop = semTlsOp;\n  this.callbacks.trgop = semTrgOp;\n  this.callbacks['udt-empty'] = semUdtEmpty;\n  this.callbacks['udt-non-empty'] = semUdtNonEmpty;\n  this.callbacks.xmax = semXmax;\n  this.callbacks.xmin = semXmin;\n  this.callbacks.xstring = semXstring;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NlbWFudGljLWNhbGxiYWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVMsU0FBUyxTQUFTO0FBQzdGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxTQUFTLFNBQVMsU0FBUztBQUNwRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zZW1hbnRpYy1jYWxsYmFja3MuanM/YjYzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBoYXMgYWxsIG9mIHRoZSBBU1QgdHJhbnNsYXRpb24gY2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgc2VtYW50aWMgYW5hbHlzaXNcbi8vIHBoYXNlIG9mIHRoZSBnZW5lcmF0b3IuXG4vLyBTZWU6PGJyPlxuLy8gYC4vZGlzdC9hYm5mLWZvci1zYWJuZi1ncmFtbWFyLmJuZmA8YnI+XG4vLyBmb3IgdGhlIGdyYW1tYXIgZmlsZSB0aGVzZSBjYWxsYmFjayBmdW5jdGlvbnMgYXJlIGJhc2VkIG9uLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleGZuKCkge1xuICBjb25zdCBhcGdsaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBpZCA9IGFwZ2xpYi5pZHM7XG5cbiAgLyogU29tZSBoZWxwZXIgZnVuY3Rpb25zLiAqL1xuICBjb25zdCBOYW1lTGlzdCA9IGZ1bmN0aW9uIE5hbWVMaXN0KCkge1xuICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICAvKiBBZGRzIGEgbmV3IHJ1bGUgbmFtZSBvYmplY3QgdG8gdGhlIGxpc3QuIFJldHVybnMgLTEgaWYgdGhlIG5hbWUgYWxyZWFkeSBleGlzdHMuICovXG4gICAgLyogUmV0dXJucyB0aGUgYWRkZWQgbmFtZSBvYmplY3QgaWYgdGhlIG5hbWUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gKi9cbiAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lKSB7XG4gICAgICBsZXQgcmV0ID0gLTE7XG4gICAgICBjb25zdCBmaW5kID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICBpZiAoZmluZCA9PT0gLTEpIHtcbiAgICAgICAgcmV0ID0ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgbG93ZXI6IG5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBpbmRleDogdGhpcy5uYW1lcy5sZW5ndGgsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZXMucHVzaChyZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIC8qIEJydXRlLWZvcmNlIGxvb2sgdXAuICovXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgbGV0IHJldCA9IC0xO1xuICAgICAgY29uc3QgbG93ZXIgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZXNbaV0ubG93ZXIgPT09IGxvd2VyKSB7XG4gICAgICAgICAgcmV0ID0gdGhpcy5uYW1lc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9O1xuICAvKiBjb252ZXJ0cyB0ZXh0IGRlY2ltYWwgbnVtYmVycyBmcm9tLCBlLmcuICVkOTksIHRvIGFuIGludGVnZXIgKi9cbiAgY29uc3QgZGVjbnVtID0gZnVuY3Rpb24gZGVjbnVtKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBiZWcgKyBsZW47IGkgKz0gMSkge1xuICAgICAgbnVtID0gMTAgKiBudW0gKyBjaGFyc1tpXSAtIDQ4O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuICAvKiBjb252ZXJ0cyB0ZXh0IGJpbmFyeSBudW1iZXJzIGZyb20sIGUuZy4gJWIxMCwgdG8gYW4gaW50ZWdlciAqL1xuICBjb25zdCBiaW5udW0gPSBmdW5jdGlvbiBiaW5udW0oY2hhcnMsIGJlZywgbGVuKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGJlZyArIGxlbjsgaSArPSAxKSB7XG4gICAgICBudW0gPSAyICogbnVtICsgY2hhcnNbaV0gLSA0ODtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcbiAgLyogY29udmVydHMgdGV4dCBoZXhhZGVjaW1hbCBudW1iZXJzIGZyb20sIGUuZy4gJXhmZiwgdG8gYW4gaW50ZWdlciAqL1xuICBjb25zdCBoZXhudW0gPSBmdW5jdGlvbiBoZXhudW0oY2hhcnMsIGJlZywgbGVuKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGJlZyArIGxlbjsgaSArPSAxKSB7XG4gICAgICBsZXQgZGlnaXQgPSBjaGFyc1tpXTtcbiAgICAgIGlmIChkaWdpdCA+PSA0OCAmJiBkaWdpdCA8PSA1Nykge1xuICAgICAgICBkaWdpdCAtPSA0ODtcbiAgICAgIH0gZWxzZSBpZiAoZGlnaXQgPj0gNjUgJiYgZGlnaXQgPD0gNzApIHtcbiAgICAgICAgZGlnaXQgLT0gNTU7XG4gICAgICB9IGVsc2UgaWYgKGRpZ2l0ID49IDk3ICYmIGRpZ2l0IDw9IDEwMikge1xuICAgICAgICBkaWdpdCAtPSA4NztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4bnVtIG91dCBvZiByYW5nZScpO1xuICAgICAgfVxuICAgICAgbnVtID0gMTYgKiBudW0gKyBkaWdpdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHRoZSBwcm90b3R5cGUgZm9yIGFsbCBzZW1hbnRpYyBhbmFseXNpcyBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIC8vIGBgYGBcbiAgLy8gc3RhdGUgLSB0aGUgdHJhbnNsYXRvciBzdGF0ZVxuICAvLyAgIGlkLlNFTV9QUkUgZm9yIGRvd253YXJkIChwcmUtYnJhbmNoKSB0cmF2ZXJzYWwgb2YgdGhlIEFTVFxuICAvLyAgIGlkLlNFTV9QT1NUIGZvciB1cHdhcmQgKHBvc3QgYnJhbmNoKSB0cmF2ZXJzYWwgb2YgdGhlIEFTVFxuICAvLyBjaGFycyAtIHRoZSBhcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgZm9yIHRoZSBpbnB1dCBzdHJpbmdcbiAgLy8gcGhyYXNlSW5kZXggLSBpbmRleCBpbnRvIHRoZSBjaGFycyBhcnJheSB0byB0aGUgZmlyc3RcbiAgLy8gICAgICAgICAgICAgICBjaGFyYWN0ZXIgb2YgdGhlIHBocmFzZVxuICAvLyBwaHJhc2VDb3VudCAtIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgcGhyYXNlXG4gIC8vIGRhdGEgLSB1c2VyLWRlZmluZWQgZGF0YSBwYXNzZWQgdG8gdGhlIHRyYW5zbGF0b3JcbiAgLy8gICAgICAgIGZvciB1c2UgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gQHJldHVybiBpZC5TRU1fT0ssIG5vcm1hbCByZXR1cm4uXG4gIC8vICAgICAgICAgaWQuU0VNX1NLSVAgaW4gc3RhdGUgaWQuU0VNX1BSRSB3aWxsXG4gIC8vICAgICAgICAgc2tpcCB0aGUgYnJhbmNoIGJlbG93LlxuICAvLyAgICAgICAgIEFueSB0aGluZyBlbHNlIGlzIGFuIGVycm9yIHdoaWNoIHdpbGxcbiAgLy8gICAgICAgICBzdG9wIHRoZSB0cmFuc2xhdGlvbi5cbiAgLy8gYGBgYFxuICAvKlxuICBmdW5jdGlvbiBzZW1DYWxsYmFja1Byb3RvdHlwZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGxldCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAqL1xuICAvLyBUaGUgQVNUIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gc2VtRmlsZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEucnVsZU5hbWVzID0gbmV3IE5hbWVMaXN0KCk7XG4gICAgICBkYXRhLnVkdE5hbWVzID0gbmV3IE5hbWVMaXN0KCk7XG4gICAgICBkYXRhLnJ1bGVzID0gW107XG4gICAgICBkYXRhLnVkdHMgPSBbXTtcbiAgICAgIGRhdGEucnVsZXNMaW5lTWFwID0gW107XG4gICAgICBkYXRhLm9wY29kZXMgPSBbXTtcbiAgICAgIGRhdGEuYWx0U3RhY2sgPSBbXTtcbiAgICAgIGRhdGEudG9wU3RhY2sgPSBudWxsO1xuICAgICAgZGF0YS50b3BSdWxlID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgLyogdmFsaWRhdGUgUk5NIHJ1bGUgbmFtZXMgYW5kIHNldCBvcGNvZGUgcnVsZSBpbmRleCAqL1xuICAgICAgbGV0IG5hbWVPYmo7XG4gICAgICBkYXRhLnJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgICAgcnVsZS5pc0JrciA9IGZhbHNlO1xuICAgICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gaWQuUk5NKSB7XG4gICAgICAgICAgICBuYW1lT2JqID0gZGF0YS5ydWxlTmFtZXMuZ2V0KG9wLmluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWVPYmogPT09IC0xKSB7XG4gICAgICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgb3AuaW5kZXgucGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgICAgIGNoYXI6IG9wLmluZGV4LnBocmFzZUluZGV4LFxuICAgICAgICAgICAgICAgIG1zZzogYFJ1bGUgbmFtZSAnJHtvcC5pbmRleC5uYW1lfScgdXNlZCBidXQgbm90IGRlZmluZWQuYCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG9wLmluZGV4ID0gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcC5pbmRleCA9IG5hbWVPYmouaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLyogdmFsaWRhdGUgQktSIHJ1bGUgbmFtZXMgYW5kIHNldCBvcGNvZGUgcnVsZSBpbmRleCAqL1xuICAgICAgZGF0YS51ZHRzLmZvckVhY2goKHVkdCkgPT4ge1xuICAgICAgICB1ZHQuaXNCa3IgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgZGF0YS5ydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgIHJ1bGUub3Bjb2Rlcy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgIGlmIChvcC50eXBlID09PSBpZC5CS1IpIHtcbiAgICAgICAgICAgIHJ1bGUuaGFzQmtyID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWVPYmogPSBkYXRhLnJ1bGVOYW1lcy5nZXQob3AuaW5kZXgubmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZU9iaiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZGF0YS5ydWxlc1tuYW1lT2JqLmluZGV4XS5pc0JrciA9IHRydWU7XG4gICAgICAgICAgICAgIG9wLmluZGV4ID0gbmFtZU9iai5pbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWVPYmogPSBkYXRhLnVkdE5hbWVzLmdldChvcC5pbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgaWYgKG5hbWVPYmogIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZGF0YS51ZHRzW25hbWVPYmouaW5kZXhdLmlzQmtyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvcC5pbmRleCA9IGRhdGEucnVsZXMubGVuZ3RoICsgbmFtZU9iai5pbmRleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgb3AuaW5kZXgucGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgY2hhcjogb3AuaW5kZXgucGhyYXNlSW5kZXgsXG4gICAgICAgICAgICAgICAgICBtc2c6IGBCYWNrIHJlZmVyZW5jZSBuYW1lICcke29wLmluZGV4Lm5hbWV9JyByZWZlcnMgdG8gdW5kZWZpbmVkIHJ1bGUgb3IgdW5hbWVkIFVEVC5gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wLmluZGV4ID0gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUnVsZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEuYWx0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgIGRhdGEudG9wU3RhY2sgPSBudWxsO1xuICAgICAgZGF0YS5ydWxlc0xpbmVNYXAucHVzaCh7XG4gICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJ1bGVMb29rdXAoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnJ1bGVOYW1lID0gJyc7XG4gICAgICBkYXRhLmRlZmluZWRhcyA9ICcnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBsZXQgcnVsZU5hbWU7XG4gICAgICBpZiAoZGF0YS5kZWZpbmVkYXMgPT09ICc9Jykge1xuICAgICAgICBydWxlTmFtZSA9IGRhdGEucnVsZU5hbWVzLmFkZChkYXRhLnJ1bGVOYW1lKTtcbiAgICAgICAgaWYgKHJ1bGVOYW1lID09PSAtMSkge1xuICAgICAgICAgIGRhdGEuZGVmaW5lZGFzID0gbnVsbDtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6IGBSdWxlIG5hbWUgJyR7ZGF0YS5ydWxlTmFtZX0nIHByZXZpb3VzbHkgZGVmaW5lZC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIHN0YXJ0IGEgbmV3IHJ1bGUgKi9cbiAgICAgICAgICBkYXRhLnRvcFJ1bGUgPSB7XG4gICAgICAgICAgICBuYW1lOiBydWxlTmFtZS5uYW1lLFxuICAgICAgICAgICAgbG93ZXI6IHJ1bGVOYW1lLmxvd2VyLFxuICAgICAgICAgICAgb3Bjb2RlczogW10sXG4gICAgICAgICAgICBpbmRleDogcnVsZU5hbWUuaW5kZXgsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkYXRhLnJ1bGVzLnB1c2goZGF0YS50b3BSdWxlKTtcbiAgICAgICAgICBkYXRhLm9wY29kZXMgPSBkYXRhLnRvcFJ1bGUub3Bjb2RlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnVsZU5hbWUgPSBkYXRhLnJ1bGVOYW1lcy5nZXQoZGF0YS5ydWxlTmFtZSk7XG4gICAgICAgIGlmIChydWxlTmFtZSA9PT0gLTEpIHtcbiAgICAgICAgICBkYXRhLmRlZmluZWRhcyA9IG51bGw7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgUnVsZSBuYW1lICcke2RhdGEucnVsZU5hbWV9JyBmb3IgaW5jcmVtZW50YWwgYWx0ZXJuYXRlIG5vdCBwcmV2aW91c2x5IGRlZmluZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhLnRvcFJ1bGUgPSBkYXRhLnJ1bGVzW3J1bGVOYW1lLmluZGV4XTtcbiAgICAgICAgICBkYXRhLm9wY29kZXMgPSBkYXRhLnRvcFJ1bGUub3Bjb2RlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUFsdGVybmF0aW9uKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgbGV0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgaWYgKGRhdGEuZGVmaW5lZGFzID09PSBudWxsKSB7XG4gICAgICAgICAgLyogcnVsZSBlcnJvciAtIHNraXAgb3Bjb2RlIGdlbmVyYXRpb24gKi9cbiAgICAgICAgICByZXQgPSBpZC5TRU1fU0tJUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50b3BTdGFjayA9PT0gbnVsbCkge1xuICAgICAgICAgIC8qIHRvcC1sZXZlbCBBTFQgKi9cbiAgICAgICAgICBpZiAoZGF0YS5kZWZpbmVkYXMgPT09ICc9Jykge1xuICAgICAgICAgICAgLyogXCI9XCIgbmV3IHJ1bGUgKi9cbiAgICAgICAgICAgIGRhdGEudG9wU3RhY2sgPSB7XG4gICAgICAgICAgICAgIGFsdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IGlkLkFMVCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNhdDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2goZGF0YS50b3BTdGFjayk7XG4gICAgICAgICAgICBkYXRhLm9wY29kZXMucHVzaChkYXRhLnRvcFN0YWNrLmFsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogXCI9L1wiIGluY3JlbWVudGFsIGFsdGVybmF0ZSAqL1xuICAgICAgICAgIGRhdGEudG9wU3RhY2sgPSB7XG4gICAgICAgICAgICBhbHQ6IGRhdGEub3Bjb2Rlc1swXSxcbiAgICAgICAgICAgIGNhdDogbnVsbCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaChkYXRhLnRvcFN0YWNrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBsb3dlci1sZXZlbCBBTFQgKi9cbiAgICAgICAgZGF0YS50b3BTdGFjayA9IHtcbiAgICAgICAgICBhbHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IGlkLkFMVCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhdDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKGRhdGEudG9wU3RhY2spO1xuICAgICAgICBkYXRhLm9wY29kZXMucHVzaChkYXRhLnRvcFN0YWNrLmFsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgaWYgKGRhdGEuYWx0U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBkYXRhLnRvcFN0YWNrID0gZGF0YS5hbHRTdGFja1tkYXRhLmFsdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS50b3BTdGFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQ29uY2F0ZW5hdGlvbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEudG9wU3RhY2suYWx0LmNoaWxkcmVuLnB1c2goZGF0YS5vcGNvZGVzLmxlbmd0aCk7XG4gICAgICBkYXRhLnRvcFN0YWNrLmNhdCA9IHtcbiAgICAgICAgdHlwZTogaWQuQ0FULFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICB9O1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goZGF0YS50b3BTdGFjay5jYXQpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnRvcFN0YWNrLmNhdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUmVwZXRpdGlvbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEudG9wU3RhY2suY2F0LmNoaWxkcmVuLnB1c2goZGF0YS5vcGNvZGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtT3B0aW9uT3BlbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlJFUCxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUnVsZU5hbWUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnJ1bGVOYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtRGVmaW5lZChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmRlZmluZWRhcyA9ICc9JztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1JbmNBbHQoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5kZWZpbmVkYXMgPSAnPS8nO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcE9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5taW4gPSAwO1xuICAgICAgZGF0YS5tYXggPSBJbmZpbml0eTtcbiAgICAgIGRhdGEudG9wUmVwID0ge1xuICAgICAgICB0eXBlOiBpZC5SRVAsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiBJbmZpbml0eSxcbiAgICAgIH07XG4gICAgICBkYXRhLm9wY29kZXMucHVzaChkYXRhLnRvcFJlcCk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGlmIChkYXRhLm1pbiA+IGRhdGEubWF4KSB7XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogYHJlcGV0aXRpb24gbWluIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gbWF4OiBtaW46ICR7ZGF0YS5taW59OiBtYXg6ICR7ZGF0YS5tYXh9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhLnRvcFJlcC5taW4gPSBkYXRhLm1pbjtcbiAgICAgIGRhdGEudG9wUmVwLm1heCA9IGRhdGEubWF4O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcE1pbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1pbiA9IGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SZXBNYXgoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5tYXggPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUmVwTWluTWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgICAgZGF0YS5taW4gPSBkYXRhLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1BbmRPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkFORCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbU5vdE9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuTk9ULFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUm5tT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5STk0sXG4gICAgICAgIC8qIE5PVEU6IHRoaXMgaXMgdGVtcG9yYXJ5IGluZm8sIGluZGV4IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBpbnRlZ2VyIGxhdGVyLiAqL1xuICAgICAgICAvKiBQcm9iYWJseSBub3QgdGhlIGJlc3QgY29kaW5nIHByYWN0aWNlIGJ1dCBoZXJlIHlvdSBnby4gKi9cbiAgICAgICAgaW5kZXg6IHtcbiAgICAgICAgICBwaHJhc2VJbmRleCxcbiAgICAgICAgICBuYW1lOiBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUFiZ09wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQUJHLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQWVuT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5BRU4sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca2FPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkJLQSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrbk9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQktOLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLmNpID0gdHJ1ZTsgLyogZGVmYXVsdCB0byBjYXNlIGluc2Vuc2l0aXZlICovXG4gICAgICBkYXRhLmNzID0gZmFsc2U7XG4gICAgICBkYXRhLnVtID0gdHJ1ZTtcbiAgICAgIGRhdGEucG0gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5CS1IsXG4gICAgICAgIGJrckNhc2U6IGRhdGEuY3MgPT09IHRydWUgPyBpZC5CS1JfTU9ERV9DUyA6IGlkLkJLUl9NT0RFX0NJLFxuICAgICAgICBia3JNb2RlOiBkYXRhLnBtID09PSB0cnVlID8gaWQuQktSX01PREVfUE0gOiBpZC5CS1JfTU9ERV9VTSxcbiAgICAgICAgLyogTk9URTogdGhpcyBpcyB0ZW1wb3JhcnkgaW5mbywgaW5kZXggd2lsbCBiZSByZXBsYWNlZCB3aXRoIGludGVnZXIgbGF0ZXIuICovXG4gICAgICAgIC8qIFByb2JhYmx5IG5vdCB0aGUgYmVzdCBjb2RpbmcgcHJhY3RpY2UgYnV0IGhlcmUgeW91IGdvLiAqL1xuICAgICAgICBpbmRleDoge1xuICAgICAgICAgIHBocmFzZUluZGV4OiBkYXRhLmJrcm5hbWUucGhyYXNlSW5kZXgsXG4gICAgICAgICAgbmFtZTogYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIGRhdGEuYmtybmFtZS5waHJhc2VJbmRleCwgZGF0YS5ia3JuYW1lLnBocmFzZUxlbmd0aCksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JDaShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmNpID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JDcyhzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmNzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JVbShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnVtID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JQbShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnBtID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JOYW1lKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEuYmtybmFtZSA9IHtcbiAgICAgICAgcGhyYXNlSW5kZXgsXG4gICAgICAgIHBocmFzZUxlbmd0aDogcGhyYXNlQ291bnQsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVVkdEVtcHR5KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICAgIGxldCB1ZHROYW1lID0gZGF0YS51ZHROYW1lcy5hZGQobmFtZSk7XG4gICAgICBpZiAodWR0TmFtZSA9PT0gLTEpIHtcbiAgICAgICAgdWR0TmFtZSA9IGRhdGEudWR0TmFtZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodWR0TmFtZSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbVVkdEVtcHR5OiBuYW1lIGxvb2sgdXAgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS51ZHRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHVkdE5hbWUubmFtZSxcbiAgICAgICAgICBsb3dlcjogdWR0TmFtZS5sb3dlcixcbiAgICAgICAgICBpbmRleDogdWR0TmFtZS5pbmRleCxcbiAgICAgICAgICBlbXB0eTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlVEVCxcbiAgICAgICAgZW1wdHk6IHRydWUsXG4gICAgICAgIGluZGV4OiB1ZHROYW1lLmluZGV4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVWR0Tm9uRW1wdHkoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgY29uc3QgbmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgICAgbGV0IHVkdE5hbWUgPSBkYXRhLnVkdE5hbWVzLmFkZChuYW1lKTtcbiAgICAgIGlmICh1ZHROYW1lID09PSAtMSkge1xuICAgICAgICB1ZHROYW1lID0gZGF0YS51ZHROYW1lcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICh1ZHROYW1lID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VtVWR0Tm9uRW1wdHk6IG5hbWUgbG9vayB1cCBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnVkdHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogdWR0TmFtZS5uYW1lLFxuICAgICAgICAgIGxvd2VyOiB1ZHROYW1lLmxvd2VyLFxuICAgICAgICAgIGluZGV4OiB1ZHROYW1lLmluZGV4LFxuICAgICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlVEVCxcbiAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICBpbmRleDogdWR0TmFtZS5pbmRleCxcbiAgICAgICAgc3ludGF4OiBudWxsLFxuICAgICAgICBzZW1hbnRpYzogbnVsbCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVRsc09wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS50bHNjYXNlID0gdHJ1ZTsgLyogZGVmYXVsdCB0byBjYXNlIGluc2Vuc2l0aXZlICovXG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVGxzQ2FzZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBpZiAocGhyYXNlQ291bnQgPiAwICYmIChjaGFyc1twaHJhc2VJbmRleCArIDFdID09PSA4MyB8fCBjaGFyc1twaHJhc2VJbmRleCArIDFdID09PSAxMTUpKSB7XG4gICAgICAgIGRhdGEudGxzY2FzZSA9IGZhbHNlOyAvKiBzZXQgdG8gY2FzZSBzZW5zaXRpdmUgKi9cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UbHNTdHJpbmcoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKGRhdGEudGxzY2FzZSkge1xuICAgICAgICBjb25zdCBzdHIgPSBjaGFycy5zbGljZShwaHJhc2VJbmRleCwgcGhyYXNlSW5kZXggKyBwaHJhc2VDb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHN0cltpXSA+PSA2NSAmJiBzdHJbaV0gPD0gOTApIHtcbiAgICAgICAgICAgIHN0cltpXSArPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGlkLlRMUyxcbiAgICAgICAgICBzdHJpbmc6IHN0cixcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogaWQuVEJTLFxuICAgICAgICAgIHN0cmluZzogY2hhcnMuc2xpY2UocGhyYXNlSW5kZXgsIHBocmFzZUluZGV4ICsgcGhyYXNlQ291bnQpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1DbHNPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBpZiAocGhyYXNlQ291bnQgPD0gMikge1xuICAgICAgICAvKiBvbmx5IFRMUyBpcyBhbGxvd2VkIHRvIGJlIGVtcHR5ICovXG4gICAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBpZC5UTFMsXG4gICAgICAgICAgc3RyaW5nOiBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogaWQuVEJTLFxuICAgICAgICAgIHN0cmluZzogY2hhcnMuc2xpY2UocGhyYXNlSW5kZXggKyAxLCBwaHJhc2VJbmRleCArIHBocmFzZUNvdW50IC0gMSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVRic09wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS50YnNzdHIgPSBbXTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5UQlMsXG4gICAgICAgIHN0cmluZzogZGF0YS50YnNzdHIsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UcmdPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEubWluID0gMDtcbiAgICAgIGRhdGEubWF4ID0gMDtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKGRhdGEubWluID4gZGF0YS5tYXgpIHtcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgbXNnOiBgVFJHLCAoJWRtaW4tbWF4KSwgbWluIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gbWF4OiBtaW46ICR7ZGF0YS5taW59OiBtYXg6ICR7ZGF0YS5tYXh9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlRSRyxcbiAgICAgICAgbWluOiBkYXRhLm1pbixcbiAgICAgICAgbWF4OiBkYXRhLm1heCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbURtaW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5taW4gPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtRG1heChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1heCA9IGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1CbWluKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWluID0gYmlubnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJtYXgoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5tYXggPSBiaW5udW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtWG1pbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1pbiA9IGhleG51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1YbWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gaGV4bnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbURzdHJpbmcoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS50YnNzdHIucHVzaChkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJzdHJpbmcoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS50YnNzdHIucHVzaChiaW5udW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVhzdHJpbmcoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS50YnNzdHIucHVzaChoZXhudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8vIERlZmluZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zIHRvIHRoZSBBU1Qgb2JqZWN0LlxuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICB0aGlzLmNhbGxiYWNrcy5hYmdvcCA9IHNlbUFiZ09wO1xuICB0aGlzLmNhbGxiYWNrcy5hZW5vcCA9IHNlbUFlbk9wO1xuICB0aGlzLmNhbGxiYWNrcy5hbHRlcm5hdGlvbiA9IHNlbUFsdGVybmF0aW9uO1xuICB0aGlzLmNhbGxiYWNrcy5hbmRvcCA9IHNlbUFuZE9wO1xuICB0aGlzLmNhbGxiYWNrcy5ibWF4ID0gc2VtQm1heDtcbiAgdGhpcy5jYWxsYmFja3MuYm1pbiA9IHNlbUJtaW47XG4gIHRoaXMuY2FsbGJhY2tzLmJrYW9wID0gc2VtQmthT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJrbm9wID0gc2VtQmtuT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJrcm9wID0gc2VtQmtyT3A7XG4gIHRoaXMuY2FsbGJhY2tzWydia3ItbmFtZSddID0gc2VtQmtyTmFtZTtcbiAgdGhpcy5jYWxsYmFja3MuYnN0cmluZyA9IHNlbUJzdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLmNsc29wID0gc2VtQ2xzT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmNpID0gc2VtQmtyQ2k7XG4gIHRoaXMuY2FsbGJhY2tzLmNzID0gc2VtQmtyQ3M7XG4gIHRoaXMuY2FsbGJhY2tzLnVtID0gc2VtQmtyVW07XG4gIHRoaXMuY2FsbGJhY2tzLnBtID0gc2VtQmtyUG07XG4gIHRoaXMuY2FsbGJhY2tzLmNvbmNhdGVuYXRpb24gPSBzZW1Db25jYXRlbmF0aW9uO1xuICB0aGlzLmNhbGxiYWNrcy5kZWZpbmVkID0gc2VtRGVmaW5lZDtcbiAgdGhpcy5jYWxsYmFja3MuZG1heCA9IHNlbURtYXg7XG4gIHRoaXMuY2FsbGJhY2tzLmRtaW4gPSBzZW1EbWluO1xuICB0aGlzLmNhbGxiYWNrcy5kc3RyaW5nID0gc2VtRHN0cmluZztcbiAgdGhpcy5jYWxsYmFja3MuZmlsZSA9IHNlbUZpbGU7XG4gIHRoaXMuY2FsbGJhY2tzLmluY2FsdCA9IHNlbUluY0FsdDtcbiAgdGhpcy5jYWxsYmFja3Mubm90b3AgPSBzZW1Ob3RPcDtcbiAgdGhpcy5jYWxsYmFja3Mub3B0aW9ub3BlbiA9IHNlbU9wdGlvbk9wZW47XG4gIHRoaXMuY2FsbGJhY2tzWydyZXAtbWF4J10gPSBzZW1SZXBNYXg7XG4gIHRoaXMuY2FsbGJhY2tzWydyZXAtbWluJ10gPSBzZW1SZXBNaW47XG4gIHRoaXMuY2FsbGJhY2tzWydyZXAtbWluLW1heCddID0gc2VtUmVwTWluTWF4O1xuICB0aGlzLmNhbGxiYWNrcy5yZXBldGl0aW9uID0gc2VtUmVwZXRpdGlvbjtcbiAgdGhpcy5jYWxsYmFja3MucmVwb3AgPSBzZW1SZXBPcDtcbiAgdGhpcy5jYWxsYmFja3Mucm5tb3AgPSBzZW1Sbm1PcDtcbiAgdGhpcy5jYWxsYmFja3MucnVsZSA9IHNlbVJ1bGU7XG4gIHRoaXMuY2FsbGJhY2tzLnJ1bGVsb29rdXAgPSBzZW1SdWxlTG9va3VwO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlbmFtZSA9IHNlbVJ1bGVOYW1lO1xuICB0aGlzLmNhbGxiYWNrcy50YnNvcCA9IHNlbVRic09wO1xuICB0aGlzLmNhbGxiYWNrcy50bHNjYXNlID0gc2VtVGxzQ2FzZTtcbiAgdGhpcy5jYWxsYmFja3MudGxzc3RyaW5nID0gc2VtVGxzU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy50bHNvcCA9IHNlbVRsc09wO1xuICB0aGlzLmNhbGxiYWNrcy50cmdvcCA9IHNlbVRyZ09wO1xuICB0aGlzLmNhbGxiYWNrc1sndWR0LWVtcHR5J10gPSBzZW1VZHRFbXB0eTtcbiAgdGhpcy5jYWxsYmFja3NbJ3VkdC1ub24tZW1wdHknXSA9IHNlbVVkdE5vbkVtcHR5O1xuICB0aGlzLmNhbGxiYWNrcy54bWF4ID0gc2VtWG1heDtcbiAgdGhpcy5jYWxsYmFja3MueG1pbiA9IHNlbVhtaW47XG4gIHRoaXMuY2FsbGJhY2tzLnhzdHJpbmcgPSBzZW1Yc3RyaW5nO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/semantic-callbacks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/show-rules.js":
/*!*******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/show-rules.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\nmodule.exports = (function exfn() {\n  const thisFileName = 'show-rules.js';\n  // Display the rules.\n  // This function may be called before the attributes calculation.\n  // Sorting is done independently from the attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  const showRules = function showRules(rulesIn = [], udtsIn = [], order = 'index') {\n    const thisFuncName = 'showRules';\n    let alphaArray = [];\n    let udtAlphaArray = [];\n    const indexArray = [];\n    const udtIndexArray = [];\n    const rules = rulesIn;\n    const udts = udtsIn;\n    const ruleCount = rulesIn.length;\n    const udtCount = udtsIn.length;\n    let str = 'RULE/UDT NAMES';\n    let i;\n    function compRulesAlpha(left, right) {\n      if (rules[left].lower < rules[right].lower) {\n        return -1;\n      }\n      if (rules[left].lower > rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    function compUdtsAlpha(left, right) {\n      if (udts[left].lower < udts[right].lower) {\n        return -1;\n      }\n      if (udts[left].lower > udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    if (!(Array.isArray(rulesIn) && rulesIn.length)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);\n    }\n    if (!Array.isArray(udtsIn)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);\n    }\n\n    for (i = 0; i < ruleCount; i += 1) {\n      indexArray.push(i);\n    }\n    alphaArray = indexArray.slice(0);\n    alphaArray.sort(compRulesAlpha);\n    if (udtCount) {\n      for (i = 0; i < udtCount; i += 1) {\n        udtIndexArray.push(i);\n      }\n      udtAlphaArray = udtIndexArray.slice(0);\n      udtAlphaArray.sort(compUdtsAlpha);\n    }\n    if (order.charCodeAt(0) === 97) {\n      str += ' - alphabetical by rule/UDT name\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${alphaArray[i]}: ${rules[alphaArray[i]].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udtAlphaArray[i]}: ${udts[udtAlphaArray[i]].name}\\n`;\n        }\n      }\n    } else {\n      str += ' - ordered by rule/UDT index\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${rules[i].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udts[i].name}\\n`;\n        }\n      }\n    }\n    return str;\n  };\n  return showRules;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3Nob3ctcnVsZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLEdBQUcsYUFBYTtBQUN0RDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsR0FBRyxhQUFhO0FBQ3REOztBQUVBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixFQUFFLElBQUksY0FBYyxJQUFJLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsb0JBQW9CLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixFQUFFLElBQUksY0FBYztBQUN0QztBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsb0JBQW9CLEVBQUUsSUFBSSxhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3Nob3ctcnVsZXMuanM/ZWNjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBleGZuKCkge1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnc2hvdy1ydWxlcy5qcyc7XG4gIC8vIERpc3BsYXkgdGhlIHJ1bGVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYmVmb3JlIHRoZSBhdHRyaWJ1dGVzIGNhbGN1bGF0aW9uLlxuICAvLyBTb3J0aW5nIGlzIGRvbmUgaW5kZXBlbmRlbnRseSBmcm9tIHRoZSBhdHRyaWJ1dGVzLlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICBjb25zdCBzaG93UnVsZXMgPSBmdW5jdGlvbiBzaG93UnVsZXMocnVsZXNJbiA9IFtdLCB1ZHRzSW4gPSBbXSwgb3JkZXIgPSAnaW5kZXgnKSB7XG4gICAgY29uc3QgdGhpc0Z1bmNOYW1lID0gJ3Nob3dSdWxlcyc7XG4gICAgbGV0IGFscGhhQXJyYXkgPSBbXTtcbiAgICBsZXQgdWR0QWxwaGFBcnJheSA9IFtdO1xuICAgIGNvbnN0IGluZGV4QXJyYXkgPSBbXTtcbiAgICBjb25zdCB1ZHRJbmRleEFycmF5ID0gW107XG4gICAgY29uc3QgcnVsZXMgPSBydWxlc0luO1xuICAgIGNvbnN0IHVkdHMgPSB1ZHRzSW47XG4gICAgY29uc3QgcnVsZUNvdW50ID0gcnVsZXNJbi5sZW5ndGg7XG4gICAgY29uc3QgdWR0Q291bnQgPSB1ZHRzSW4ubGVuZ3RoO1xuICAgIGxldCBzdHIgPSAnUlVMRS9VRFQgTkFNRVMnO1xuICAgIGxldCBpO1xuICAgIGZ1bmN0aW9uIGNvbXBSdWxlc0FscGhhKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAocnVsZXNbbGVmdF0ubG93ZXIgPCBydWxlc1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHJ1bGVzW2xlZnRdLmxvd2VyID4gcnVsZXNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBVZHRzQWxwaGEobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh1ZHRzW2xlZnRdLmxvd2VyIDwgdWR0c1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHVkdHNbbGVmdF0ubG93ZXIgPiB1ZHRzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoIShBcnJheS5pc0FycmF5KHJ1bGVzSW4pICYmIHJ1bGVzSW4ubGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX06JHt0aGlzRnVuY05hbWV9OiBydWxlcyBhcmcgbXVzdCBiZSBhcnJheSB3aXRoIGxlbmd0aCA+IDBgKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVkdHNJbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9OiR7dGhpc0Z1bmNOYW1lfTogdWR0cyBhcmcgbXVzdCBiZSBhcnJheWApO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgaW5kZXhBcnJheS5wdXNoKGkpO1xuICAgIH1cbiAgICBhbHBoYUFycmF5ID0gaW5kZXhBcnJheS5zbGljZSgwKTtcbiAgICBhbHBoYUFycmF5LnNvcnQoY29tcFJ1bGVzQWxwaGEpO1xuICAgIGlmICh1ZHRDb3VudCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHVkdENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdWR0SW5kZXhBcnJheS5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgdWR0QWxwaGFBcnJheSA9IHVkdEluZGV4QXJyYXkuc2xpY2UoMCk7XG4gICAgICB1ZHRBbHBoYUFycmF5LnNvcnQoY29tcFVkdHNBbHBoYSk7XG4gICAgfVxuICAgIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSA5Nykge1xuICAgICAgc3RyICs9ICcgLSBhbHBoYWJldGljYWwgYnkgcnVsZS9VRFQgbmFtZVxcbic7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGAke2l9OiAke2FscGhhQXJyYXlbaV19OiAke3J1bGVzW2FscGhhQXJyYXlbaV1dLm5hbWV9XFxuYDtcbiAgICAgIH1cbiAgICAgIGlmICh1ZHRDb3VudCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdWR0Q291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgIHN0ciArPSBgJHtpfTogJHt1ZHRBbHBoYUFycmF5W2ldfTogJHt1ZHRzW3VkdEFscGhhQXJyYXlbaV1dLm5hbWV9XFxuYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAtIG9yZGVyZWQgYnkgcnVsZS9VRFQgaW5kZXhcXG4nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBgJHtpfTogJHtydWxlc1tpXS5uYW1lfVxcbmA7XG4gICAgICB9XG4gICAgICBpZiAodWR0Q291bnQpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHVkdENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICBzdHIgKz0gYCR7aX06ICR7dWR0c1tpXS5uYW1lfVxcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgcmV0dXJuIHNob3dSdWxlcztcbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/show-rules.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/syntax-callbacks.js":
/*!*************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/syntax-callbacks.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the callback functions for the syntax phase of the generation.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const thisFileName = 'syntax-callbacks.js: ';\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = apglib.ids;\n  let topAlt;\n  /* syntax, RNM, callback functions */\n  const synFile = function synFile(result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack = [];\n        data.repCount = 0;\n        break;\n      case id.EMPTY:\n        data.errors.push({\n          line: 0,\n          char: 0,\n          msg: 'grammar file is empty',\n        });\n        break;\n      case id.MATCH:\n        if (data.ruleCount === 0) {\n          data.errors.push({\n            line: 0,\n            char: 0,\n            msg: 'no rules defined',\n          });\n        }\n        break;\n      case id.NOMATCH:\n        throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // eslint-disable-next-line func-names\n  const synRule = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack.length = 0;\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      case id.EMPTY:\n        throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.ruleCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized SABNF line. Invalid rule, comment or blank line.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleNameError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Rule names must be alphanum and begin with alphabetic character.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synDefinedAsError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: \"Expected '=' or '=/'. Not found.\",\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAndOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'AND operator(&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synNotOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'NOT operator(!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkaOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBknOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAbgOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAenOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkrOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - strict ABNF specified.`,\n          });\n        } else if (data.lite) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - apg-lite specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synUdtOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `UDT operator found(${name}) - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: \"Tab character (\\\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)\",\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synStringTab = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.stringTabChar = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.tlsOpen),\n          char: topAlt.tlsOpen,\n          msg: 'Case-insensitive literal string(\"...\") opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.tlsOpen = null;\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.clsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in literal string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.clsOpen),\n          char: topAlt.clsOpen,\n          msg: \"Case-sensitive literal string('...') opened but not closed.\",\n        });\n        topAlt.clsOpen = null;\n        topAlt.basicError = true;\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, topAlt.clsOpen),\n            char: topAlt.clsOpen,\n            msg: \"Case-sensitive string operator('...') found - strict ABNF specified.\",\n          });\n        }\n        topAlt.clsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.prosValOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in prose value string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.prosValOpen = null;\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.',\n        });\n        topAlt.prosValOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: phraseIndex,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.groupOpen),\n          char: topAlt.groupOpen,\n          msg: 'Group \"(...)\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.groupError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: phraseIndex,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.optionOpen),\n          char: topAlt.optionOpen,\n          msg: 'Option \"[...]\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.optionError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBasicElementError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (topAlt.basicError === false) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Unrecognized SABNF element.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEnd = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (result.phraseLength === 1 && data.strict) {\n          const end = chars[phraseIndex] === 13 ? 'CR' : 'LF';\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEndError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized grammar element or characters.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRepetition = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.repCount += 1;\n        break;\n      case id.MATCH:\n        data.repCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // Define the list of callback functions.\n  this.callbacks = [];\n  this.callbacks.andop = synAndOp;\n  this.callbacks.basicelementerr = synBasicElementError;\n  this.callbacks.clsclose = synClsClose;\n  this.callbacks.clsopen = synClsOpen;\n  this.callbacks.clsstring = synClsString;\n  this.callbacks.definedaserror = synDefinedAsError;\n  this.callbacks.file = synFile;\n  this.callbacks.groupclose = synGroupClose;\n  this.callbacks.groupopen = synGroupOpen;\n  this.callbacks.lineenderror = synLineEndError;\n  this.callbacks.lineend = synLineEnd;\n  this.callbacks.notop = synNotOp;\n  this.callbacks.optionclose = synOptionClose;\n  this.callbacks.optionopen = synOptionOpen;\n  this.callbacks.prosvalclose = synProsValClose;\n  this.callbacks.prosvalopen = synProsValOpen;\n  this.callbacks.prosvalstring = synProsValString;\n  this.callbacks.repetition = synRepetition;\n  this.callbacks.rule = synRule;\n  this.callbacks.ruleerror = synRuleError;\n  this.callbacks.rulenameerror = synRuleNameError;\n  this.callbacks.stringtab = synStringTab;\n  this.callbacks.tlsclose = synTlsClose;\n  this.callbacks.tlsopen = synTlsOpen;\n  this.callbacks.tlsstring = synTlsString;\n  this.callbacks.udtop = synUdtOp;\n  this.callbacks.bkaop = synBkaOp;\n  this.callbacks.bknop = synBknOp;\n  this.callbacks.bkrop = synBkrOp;\n  this.callbacks.abgop = synAbgOp;\n  this.callbacks.aenop = synAenOp;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3N5bnRheC1jYWxsYmFja3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pELFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3N5bnRheC1jYWxsYmFja3MuanM/YmE0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBoYXMgYWxsIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBzeW50YXggcGhhc2Ugb2YgdGhlIGdlbmVyYXRpb24uXG4vLyBTZWU6PGJyPlxuLy8gYC4vZGlzdC9hYm5mLWZvci1zYWJuZi1ncmFtbWFyLmJuZmA8YnI+XG4vLyBmb3IgdGhlIGdyYW1tYXIgZmlsZSB0aGVzZSBjYWxsYmFjayBmdW5jdGlvbnMgYXJlIGJhc2VkIG9uLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleGZuKCkge1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnc3ludGF4LWNhbGxiYWNrcy5qczogJztcbiAgY29uc3QgYXBnbGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgaWQgPSBhcGdsaWIuaWRzO1xuICBsZXQgdG9wQWx0O1xuICAvKiBzeW50YXgsIFJOTSwgY2FsbGJhY2sgZnVuY3Rpb25zICovXG4gIGNvbnN0IHN5bkZpbGUgPSBmdW5jdGlvbiBzeW5GaWxlKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBkYXRhLmFsdFN0YWNrID0gW107XG4gICAgICAgIGRhdGEucmVwQ291bnQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IDAsXG4gICAgICAgICAgY2hhcjogMCxcbiAgICAgICAgICBtc2c6ICdncmFtbWFyIGZpbGUgaXMgZW1wdHknLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5ydWxlQ291bnQgPT09IDApIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IDAsXG4gICAgICAgICAgICBjaGFyOiAwLFxuICAgICAgICAgICAgbXNnOiAnbm8gcnVsZXMgZGVmaW5lZCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogZ3JhbW1hciBmaWxlIE5PTUFUQ0g6IGRlc2lnbiBlcnJvcjogc2hvdWxkIG5ldmVyIGhhcHBlbi5gKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICBjb25zdCBzeW5SdWxlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBkYXRhLmFsdFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHRvcEFsdCA9IHtcbiAgICAgICAgICBncm91cE9wZW46IG51bGwsXG4gICAgICAgICAgZ3JvdXBFcnJvcjogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uT3BlbjogbnVsbCxcbiAgICAgICAgICBvcHRpb25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgdGxzT3BlbjogbnVsbCxcbiAgICAgICAgICBjbHNPcGVuOiBudWxsLFxuICAgICAgICAgIHByb3NWYWxPcGVuOiBudWxsLFxuICAgICAgICAgIGJhc2ljRXJyb3I6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2godG9wQWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5blJ1bGU6IEVNUFRZOiBydWxlIGNhbm5vdCBiZSBlbXB0eWApO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEucnVsZUNvdW50ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blJ1bGVFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6ICdVbnJlY29nbml6ZWQgU0FCTkYgbGluZS4gSW52YWxpZCBydWxlLCBjb21tZW50IG9yIGJsYW5rIGxpbmUuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blJ1bGVOYW1lRXJyb3IgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgbXNnOiAnUnVsZSBuYW1lcyBtdXN0IGJlIGFscGhhbnVtIGFuZCBiZWdpbiB3aXRoIGFscGhhYmV0aWMgY2hhcmFjdGVyLicsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5EZWZpbmVkQXNFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6IFwiRXhwZWN0ZWQgJz0nIG9yICc9LycuIE5vdCBmb3VuZC5cIixcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkFuZE9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ0FORCBvcGVyYXRvcigmKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bk5vdE9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ05PVCBvcGVyYXRvcighKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkJrYU9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ1Bvc2l0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yKCYmKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGl0ZSkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ1Bvc2l0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yKCYmKSBmb3VuZCAtIGFwZy1saXRlIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkJrbk9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ05lZ2F0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yKCEhKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGl0ZSkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ05lZ2F0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yKCEhKSBmb3VuZCAtIGFwZy1saXRlIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkFiZ09wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ0JlZ2lubmluZyBvZiBzdHJpbmcgYW5jaG9yKCVeKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGl0ZSkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ0JlZ2lubmluZyBvZiBzdHJpbmcgYW5jaG9yKCVeKSBmb3VuZCAtIGFwZy1saXRlIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkFlbk9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ0VuZCBvZiBzdHJpbmcgYW5jaG9yKCUkKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGl0ZSkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ0VuZCBvZiBzdHJpbmcgYW5jaG9yKCUkKSBmb3VuZCAtIGFwZy1saXRlIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkJrck9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYEJhY2sgcmVmZXJlbmNlIG9wZXJhdG9yKCR7bmFtZX0pIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5saXRlKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgQmFjayByZWZlcmVuY2Ugb3BlcmF0b3IoJHtuYW1lfSkgZm91bmQgLSBhcGctbGl0ZSBzcGVjaWZpZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5VZHRPcCA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6IGBVRFQgb3BlcmF0b3IgZm91bmQoJHtuYW1lfSkgLSBzdHJpY3QgQUJORiBzcGVjaWZpZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5UbHNPcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4KSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdC50bHNPcGVuID0gcGhyYXNlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blRsc1N0cmluZyA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgZGF0YS5zdHJpbmdUYWJDaGFyID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaW5nVGFiQ2hhciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgZGF0YS5zdHJpbmdUYWJDaGFyKSxcbiAgICAgICAgICAgIGNoYXI6IGRhdGEuc3RyaW5nVGFiQ2hhcixcbiAgICAgICAgICAgIG1zZzogXCJUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBsaXRlcmFsIHN0cmluZyAoc2VlICdxdW90ZWQtc3RyaW5nJyBkZWZpbml0aW9uLCBSRkMgNzQwNS4pXCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luU3RyaW5nVGFiID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IHBocmFzZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5UbHNDbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQudGxzT3BlbiksXG4gICAgICAgICAgY2hhcjogdG9wQWx0LnRsc09wZW4sXG4gICAgICAgICAgbXNnOiAnQ2FzZS1pbnNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZyhcIi4uLlwiKSBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdC5iYXNpY0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdG9wQWx0LnRsc09wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdC50bHNPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQ2xzT3BlbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQuY2xzT3BlbiA9IHBocmFzZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5DbHNTdHJpbmcgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmluZ1RhYkNoYXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIGRhdGEuc3RyaW5nVGFiQ2hhciksXG4gICAgICAgICAgICBjaGFyOiBkYXRhLnN0cmluZ1RhYkNoYXIsXG4gICAgICAgICAgICBtc2c6ICdUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBsaXRlcmFsIHN0cmluZy4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkNsc0Nsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5jbHNPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQuY2xzT3BlbixcbiAgICAgICAgICBtc2c6IFwiQ2FzZS1zZW5zaXRpdmUgbGl0ZXJhbCBzdHJpbmcoJy4uLicpIG9wZW5lZCBidXQgbm90IGNsb3NlZC5cIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdC5jbHNPcGVuID0gbnVsbDtcbiAgICAgICAgdG9wQWx0LmJhc2ljRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQuY2xzT3BlbiksXG4gICAgICAgICAgICBjaGFyOiB0b3BBbHQuY2xzT3BlbixcbiAgICAgICAgICAgIG1zZzogXCJDYXNlLXNlbnNpdGl2ZSBzdHJpbmcgb3BlcmF0b3IoJy4uLicpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLlwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRvcEFsdC5jbHNPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUHJvc1ZhbE9wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0LnByb3NWYWxPcGVuID0gcGhyYXNlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blByb3NWYWxTdHJpbmcgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmluZ1RhYkNoYXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIGRhdGEuc3RyaW5nVGFiQ2hhciksXG4gICAgICAgICAgICBjaGFyOiBkYXRhLnN0cmluZ1RhYkNoYXIsXG4gICAgICAgICAgICBtc2c6ICdUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBwcm9zZSB2YWx1ZSBzdHJpbmcuJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Qcm9zVmFsQ2xvc2UgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LnByb3NWYWxPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQucHJvc1ZhbE9wZW4sXG4gICAgICAgICAgbXNnOiAnUHJvc2UgdmFsdWUgb3BlcmF0b3IoPC4uLj4pIG9wZW5lZCBidXQgbm90IGNsb3NlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0LmJhc2ljRXJyb3IgPSB0cnVlO1xuICAgICAgICB0b3BBbHQucHJvc1ZhbE9wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LnByb3NWYWxPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQucHJvc1ZhbE9wZW4sXG4gICAgICAgICAgbXNnOiAnUHJvc2UgdmFsdWUgb3BlcmF0b3IoPC4uLj4pIGZvdW5kLiBUaGUgQUJORiBzeW50YXggaXMgdmFsaWQsIGJ1dCBhIHBhcnNlciBjYW5ub3QgYmUgZ2VuZXJhdGVkIGZyb20gdGhpcyBncmFtbWFyLicsXG4gICAgICAgIH0pO1xuICAgICAgICB0b3BBbHQucHJvc1ZhbE9wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Hcm91cE9wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0ID0ge1xuICAgICAgICAgIGdyb3VwT3BlbjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgZ3JvdXBFcnJvcjogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uT3BlbjogbnVsbCxcbiAgICAgICAgICBvcHRpb25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgdGxzT3BlbjogbnVsbCxcbiAgICAgICAgICBjbHNPcGVuOiBudWxsLFxuICAgICAgICAgIHByb3NWYWxPcGVuOiBudWxsLFxuICAgICAgICAgIGJhc2ljRXJyb3I6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2godG9wQWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luR3JvdXBDbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQuZ3JvdXBPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQuZ3JvdXBPcGVuLFxuICAgICAgICAgIG1zZzogJ0dyb3VwIFwiKC4uLilcIiBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdCA9IGRhdGEuYWx0U3RhY2sucG9wKCk7XG4gICAgICAgIHRvcEFsdC5ncm91cEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQgPSBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5PcHRpb25PcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdCA9IHtcbiAgICAgICAgICBncm91cE9wZW46IG51bGwsXG4gICAgICAgICAgZ3JvdXBFcnJvcjogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uT3BlbjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgb3B0aW9uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgIHRsc09wZW46IG51bGwsXG4gICAgICAgICAgY2xzT3BlbjogbnVsbCxcbiAgICAgICAgICBwcm9zVmFsT3BlbjogbnVsbCxcbiAgICAgICAgICBiYXNpY0Vycm9yOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKHRvcEFsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bk9wdGlvbkNsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5vcHRpb25PcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQub3B0aW9uT3BlbixcbiAgICAgICAgICBtc2c6ICdPcHRpb24gXCJbLi4uXVwiIG9wZW5lZCBidXQgbm90IGNsb3NlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0ID0gZGF0YS5hbHRTdGFjay5wb3AoKTtcbiAgICAgICAgdG9wQWx0Lm9wdGlvbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQgPSBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5CYXNpY0VsZW1lbnRFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAodG9wQWx0LmJhc2ljRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnVW5yZWNvZ25pemVkIFNBQk5GIGVsZW1lbnQuJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5MaW5lRW5kID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChyZXN1bHQucGhyYXNlTGVuZ3RoID09PSAxICYmIGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgY29uc3QgZW5kID0gY2hhcnNbcGhyYXNlSW5kZXhdID09PSAxMyA/ICdDUicgOiAnTEYnO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYExpbmUgZW5kICcke2VuZH0nIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLCBvbmx5IENSTEYgYWxsb3dlZC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkxpbmVFbmRFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6ICdVbnJlY29nbml6ZWQgZ3JhbW1hciBlbGVtZW50IG9yIGNoYXJhY3RlcnMuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blJlcGV0aXRpb24gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEucmVwQ291bnQgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLnJlcENvdW50ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIC8vIERlZmluZSB0aGUgbGlzdCBvZiBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIHRoaXMuY2FsbGJhY2tzLmFuZG9wID0gc3luQW5kT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJhc2ljZWxlbWVudGVyciA9IHN5bkJhc2ljRWxlbWVudEVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNjbG9zZSA9IHN5bkNsc0Nsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNvcGVuID0gc3luQ2xzT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MuY2xzc3RyaW5nID0gc3luQ2xzU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy5kZWZpbmVkYXNlcnJvciA9IHN5bkRlZmluZWRBc0Vycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5maWxlID0gc3luRmlsZTtcbiAgdGhpcy5jYWxsYmFja3MuZ3JvdXBjbG9zZSA9IHN5bkdyb3VwQ2xvc2U7XG4gIHRoaXMuY2FsbGJhY2tzLmdyb3Vwb3BlbiA9IHN5bkdyb3VwT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MubGluZWVuZGVycm9yID0gc3luTGluZUVuZEVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5saW5lZW5kID0gc3luTGluZUVuZDtcbiAgdGhpcy5jYWxsYmFja3Mubm90b3AgPSBzeW5Ob3RPcDtcbiAgdGhpcy5jYWxsYmFja3Mub3B0aW9uY2xvc2UgPSBzeW5PcHRpb25DbG9zZTtcbiAgdGhpcy5jYWxsYmFja3Mub3B0aW9ub3BlbiA9IHN5bk9wdGlvbk9wZW47XG4gIHRoaXMuY2FsbGJhY2tzLnByb3N2YWxjbG9zZSA9IHN5blByb3NWYWxDbG9zZTtcbiAgdGhpcy5jYWxsYmFja3MucHJvc3ZhbG9wZW4gPSBzeW5Qcm9zVmFsT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MucHJvc3ZhbHN0cmluZyA9IHN5blByb3NWYWxTdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLnJlcGV0aXRpb24gPSBzeW5SZXBldGl0aW9uO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlID0gc3luUnVsZTtcbiAgdGhpcy5jYWxsYmFja3MucnVsZWVycm9yID0gc3luUnVsZUVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlbmFtZWVycm9yID0gc3luUnVsZU5hbWVFcnJvcjtcbiAgdGhpcy5jYWxsYmFja3Muc3RyaW5ndGFiID0gc3luU3RyaW5nVGFiO1xuICB0aGlzLmNhbGxiYWNrcy50bHNjbG9zZSA9IHN5blRsc0Nsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy50bHNvcGVuID0gc3luVGxzT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MudGxzc3RyaW5nID0gc3luVGxzU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy51ZHRvcCA9IHN5blVkdE9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia2FvcCA9IHN5bkJrYU9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia25vcCA9IHN5bkJrbk9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia3JvcCA9IHN5bkJrck9wO1xuICB0aGlzLmNhbGxiYWNrcy5hYmdvcCA9IHN5bkFiZ09wO1xuICB0aGlzLmNhbGxiYWNrcy5hZW5vcCA9IHN5bkFlbk9wO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/syntax-callbacks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-conv-api/converter.js":
/*!***********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-conv-api/converter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes the public encoding, decoding and conversion functions.\n// Its private functions provide the disassembling and interpetation of the source and destination encoding types.\n// In the case of Unicode encodings, private functions determine the presence of Byte Order Marks (BOMs), if any.\n//\n// Throws \"TypeError\" exceptions on input errors.\n//\n\n'use strict;';\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n\nconst trans = __webpack_require__(/*! ./transformers */ \"(ssr)/./node_modules/apg-js/src/apg-conv-api/transformers.js\");\n\n/* types */\nconst UTF8 = 'UTF8';\nconst UTF16 = 'UTF16';\nconst UTF16BE = 'UTF16BE';\nconst UTF16LE = 'UTF16LE';\nconst UTF32 = 'UTF32';\nconst UTF32BE = 'UTF32BE';\nconst UTF32LE = 'UTF32LE';\nconst UINT7 = 'UINT7';\nconst ASCII = 'ASCII';\nconst BINARY = 'BINARY';\nconst UINT8 = 'UINT8';\nconst UINT16 = 'UINT16';\nconst UINT16LE = 'UINT16LE';\nconst UINT16BE = 'UINT16BE';\nconst UINT32 = 'UINT32';\nconst UINT32LE = 'UINT32LE';\nconst UINT32BE = 'UINT32BE';\nconst ESCAPED = 'ESCAPED';\nconst STRING = 'STRING';\n\n/* private functions */\n// Find the UTF8 BOM, if any.\nconst bom8 = function bom8(src) {\n  src.type = UTF8;\n  const buf = src.data;\n  src.bom = 0;\n  if (buf.length >= 3) {\n    if (buf[0] === 0xef && buf[1] === 0xbb && buf[2] === 0xbf) {\n      src.bom = 3;\n    }\n  }\n};\n// Find the UTF16 BOM, if any, and determine the UTF16 type.\n// Defaults to UTF16BE.\n// Throws TypeError exception if BOM does not match the specified type.\nconst bom16 = function bom16(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF16:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.type = UTF16LE;\n          src.bom = 2;\n        }\n      }\n      break;\n    case UTF16BE:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          throw new TypeError(`src type: \"${UTF16BE}\" specified but BOM is for \"${UTF16LE}\"`);\n        }\n      }\n      break;\n    case UTF16LE:\n      src.type = UTF16LE;\n      if (buf.length >= 0) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          throw new TypeError(`src type: \"${UTF16LE}\" specified but BOM is for \"${UTF16BE}\"`);\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.bom = 2;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF16 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Find the UTF32 BOM, if any, and determine the UTF32 type.\n// Defaults to UTF32BE.\n// Throws exception if BOM does not match the specified type.\nconst bom32 = function bom32(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF32:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.type = UTF32LE;\n          src.bom = 4;\n        }\n      }\n      break;\n    case UTF32BE:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}\"`);\n        }\n      }\n      break;\n    case UTF32LE:\n      src.type = UTF32LE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          throw new TypeError(`src type: \"${UTF32LE}\" specified but BOM is for \"${UTF32BE}\"`);\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.bom = 4;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF32 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Validates the source encoding type and matching data.\n// If the BASE64: prefix is present, the base 64 decoding is done here as the initial step.\n// - For type STRING, data must be a JavaScript string.\n// - For type BASE64:*, data may be a string or Buffer.\n// - For all other types, data must be a Buffer.\n// - The BASE64: prefix is not allowed for type STRING.\nconst validateSrc = function validateSrc(type, data) {\n  function getType(typeArg) {\n    const ret = {\n      type: '',\n      base64: false,\n    };\n    const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;\n    const result = rx.exec(typeArg);\n    if (result) {\n      if (result[2]) {\n        ret.type = result[2].toUpperCase();\n      }\n      if (result[1]) {\n        ret.base64 = true;\n      }\n    }\n    return ret;\n  }\n  const ret = getType(type.toUpperCase());\n  if (ret.base64) {\n    /* handle base 64 */\n    if (ret.type === STRING) {\n      throw new TypeError(`type: \"${type} \"BASE64:\" prefix not allowed with type ${STRING}`);\n    }\n    if (Buffer.isBuffer(data)) {\n      ret.data = trans.base64.decode(data);\n    } else if (typeof data === 'string') {\n      const buf = Buffer.from(data, 'ascii');\n      ret.data = trans.base64.decode(buf);\n    } else {\n      throw new TypeError(`type: \"${type} unrecognized data type: typeof(data): ${typeof data}`);\n    }\n  } else {\n    ret.data = data;\n  }\n  switch (ret.type) {\n    case UTF8:\n      bom8(ret);\n      break;\n    case UTF16:\n    case UTF16BE:\n    case UTF16LE:\n      bom16(ret);\n      break;\n    case UTF32:\n    case UTF32BE:\n    case UTF32LE:\n      bom32(ret);\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case STRING:\n    case ESCAPED:\n      break;\n    default:\n      throw new TypeError(`type: \"${type}\" not recognized`);\n  }\n  if (ret.type === STRING) {\n    if (typeof ret.data !== 'string') {\n      throw new TypeError(`type: \"${type}\" but data is not a string`);\n    }\n  } else if (!Buffer.isBuffer(ret.data)) {\n    throw new TypeError(`type: \"${type}\" but data is not a Buffer`);\n  }\n  return ret;\n};\n// Disassembles and validates the destination type.\n// `chars` must be an Array of integers.\n// The :BASE64 suffix is not allowed for type STRING.\nconst validateDst = function validateDst(type, chars) {\n  function getType(typeArg) {\n    let fix;\n    let rem;\n    const ret = {\n      crlf: false,\n      lf: false,\n      base64: false,\n      type: '',\n    };\n    /* prefix, if any */\n    const TRUE = true;\n    while (TRUE) {\n      rem = typeArg;\n      fix = typeArg.slice(0, 5);\n      if (fix === 'CRLF:') {\n        ret.crlf = true;\n        rem = typeArg.slice(5);\n        break;\n      }\n      fix = typeArg.slice(0, 3);\n      if (fix === 'LF:') {\n        ret.lf = true;\n        rem = typeArg.slice(3);\n        break;\n      }\n      break;\n    }\n    /* suffix, if any */\n    fix = rem.split(':');\n    if (fix.length === 1) {\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    } else if (fix.length === 2 && fix[1] === 'BASE64') {\n      ret.base64 = true;\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    }\n    return ret;\n  }\n  if (!Array.isArray(chars)) {\n    throw new TypeError(`dst chars: not array: \"${typeof chars}`);\n  }\n  if (typeof type !== 'string') {\n    throw new TypeError(`dst type: not string: \"${typeof type}`);\n  }\n  const ret = getType(type.toUpperCase());\n  switch (ret.type) {\n    case UTF8:\n    case UTF16BE:\n    case UTF16LE:\n    case UTF32BE:\n    case UTF32LE:\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case ESCAPED:\n      break;\n    case STRING:\n      if (ret.base64) {\n        throw new TypeError(`\":BASE64\" suffix not allowed with type ${STRING}`);\n      }\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UTF16:\n      ret.type = UTF16BE;\n      break;\n    case UTF32:\n      ret.type = UTF32BE;\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    default:\n      throw new TypeError(`dst type unrecognized: \"${type}\" : must have form [crlf:|lf:]type[:base64]`);\n  }\n  return ret;\n};\n// Select and call the requested encoding function.\nconst encode = function encode(type, chars) {\n  switch (type) {\n    case UTF8:\n      return trans.utf8.encode(chars);\n    case UTF16BE:\n      return trans.utf16be.encode(chars);\n    case UTF16LE:\n      return trans.utf16le.encode(chars);\n    case UTF32BE:\n      return trans.utf32be.encode(chars);\n    case UTF32LE:\n      return trans.utf32le.encode(chars);\n    case UINT7:\n      return trans.uint7.encode(chars);\n    case UINT8:\n      return trans.uint8.encode(chars);\n    case UINT16BE:\n      return trans.uint16be.encode(chars);\n    case UINT16LE:\n      return trans.uint16le.encode(chars);\n    case UINT32BE:\n      return trans.uint32be.encode(chars);\n    case UINT32LE:\n      return trans.uint32le.encode(chars);\n    case STRING:\n      return trans.string.encode(chars);\n    case ESCAPED:\n      return trans.escaped.encode(chars);\n    default:\n      throw new TypeError(`encode type \"${type}\" not recognized`);\n  }\n};\n// Select and call the requested decoding function.\n// `src` contains BOM information as well as the source type and data.\nconst decode = function decode(src) {\n  switch (src.type) {\n    case UTF8:\n      return trans.utf8.decode(src.data, src.bom);\n    case UTF16LE:\n      return trans.utf16le.decode(src.data, src.bom);\n    case UTF16BE:\n      return trans.utf16be.decode(src.data, src.bom);\n    case UTF32BE:\n      return trans.utf32be.decode(src.data, src.bom);\n    case UTF32LE:\n      return trans.utf32le.decode(src.data, src.bom);\n    case UINT7:\n      return trans.uint7.decode(src.data);\n    case UINT8:\n      return trans.uint8.decode(src.data);\n    case UINT16BE:\n      return trans.uint16be.decode(src.data);\n    case UINT16LE:\n      return trans.uint16le.decode(src.data);\n    case UINT32BE:\n      return trans.uint32be.decode(src.data);\n    case UINT32LE:\n      return trans.uint32le.decode(src.data);\n    case STRING:\n      return trans.string.decode(src.data);\n    case ESCAPED:\n      return trans.escaped.decode(src.data);\n    default:\n      throw new TypeError(`decode type \"${src.type}\" not recognized`);\n  }\n};\n\n// The public decoding function. Returns an array of integers.\nexports.decode = function exportsDecode(type, data) {\n  const src = validateSrc(type, data);\n  return decode(src);\n};\n// The public encoding function. Returns a Buffer-typed byte array.\nexports.encode = function exportsEncode(type, chars) {\n  let c;\n  let buf;\n  const dst = validateDst(type, chars);\n  if (dst.crlf) {\n    /* prefix with CRLF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.crlf(chars);\n    buf = encode(dst.type, c);\n  } else if (dst.lf) {\n    /* prefix with LF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.lf(chars);\n    buf = encode(dst.type, c);\n  } else {\n    buf = encode(dst.type, chars);\n  }\n  if (dst.base64) {\n    /* post base 64 encoding */\n    buf = trans.base64.encode(buf);\n  }\n  return buf;\n};\n// Converts data of type `srcType` to data of type `dstType`.\n// `srcData` may be a JavaScript String, or node.js Buffer, depending on the corresponding type.\nconst convert = function convert(srcType, srcData, dstType) {\n  return exports.encode(dstType, exports.decode(srcType, srcData));\n};\nexports.convert = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkMsY0FBYyxtQkFBTyxDQUFDLG9GQUFnQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNENBQTRDLFFBQVEsOEJBQThCLFFBQVE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSw4QkFBOEIsUUFBUTtBQUMxRixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsMkJBQTJCLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSw4QkFBOEIsUUFBUTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLHlDQUF5QyxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9DQUFvQyxNQUFNLHdDQUF3QyxZQUFZO0FBQzlGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBLElBQUk7QUFDSixrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWNvbnYtYXBpL2NvbnZlcnRlci5qcz80ZGM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGV4cG9zZXMgdGhlIHB1YmxpYyBlbmNvZGluZywgZGVjb2RpbmcgYW5kIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuLy8gSXRzIHByaXZhdGUgZnVuY3Rpb25zIHByb3ZpZGUgdGhlIGRpc2Fzc2VtYmxpbmcgYW5kIGludGVycGV0YXRpb24gb2YgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZW5jb2RpbmcgdHlwZXMuXG4vLyBJbiB0aGUgY2FzZSBvZiBVbmljb2RlIGVuY29kaW5ncywgcHJpdmF0ZSBmdW5jdGlvbnMgZGV0ZXJtaW5lIHRoZSBwcmVzZW5jZSBvZiBCeXRlIE9yZGVyIE1hcmtzIChCT01zKSwgaWYgYW55LlxuLy9cbi8vIFRocm93cyBcIlR5cGVFcnJvclwiIGV4Y2VwdGlvbnMgb24gaW5wdXQgZXJyb3JzLlxuLy9cblxuJ3VzZSBzdHJpY3Q7JztcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuXG5jb25zdCB0cmFucyA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtZXJzJyk7XG5cbi8qIHR5cGVzICovXG5jb25zdCBVVEY4ID0gJ1VURjgnO1xuY29uc3QgVVRGMTYgPSAnVVRGMTYnO1xuY29uc3QgVVRGMTZCRSA9ICdVVEYxNkJFJztcbmNvbnN0IFVURjE2TEUgPSAnVVRGMTZMRSc7XG5jb25zdCBVVEYzMiA9ICdVVEYzMic7XG5jb25zdCBVVEYzMkJFID0gJ1VURjMyQkUnO1xuY29uc3QgVVRGMzJMRSA9ICdVVEYzMkxFJztcbmNvbnN0IFVJTlQ3ID0gJ1VJTlQ3JztcbmNvbnN0IEFTQ0lJID0gJ0FTQ0lJJztcbmNvbnN0IEJJTkFSWSA9ICdCSU5BUlknO1xuY29uc3QgVUlOVDggPSAnVUlOVDgnO1xuY29uc3QgVUlOVDE2ID0gJ1VJTlQxNic7XG5jb25zdCBVSU5UMTZMRSA9ICdVSU5UMTZMRSc7XG5jb25zdCBVSU5UMTZCRSA9ICdVSU5UMTZCRSc7XG5jb25zdCBVSU5UMzIgPSAnVUlOVDMyJztcbmNvbnN0IFVJTlQzMkxFID0gJ1VJTlQzMkxFJztcbmNvbnN0IFVJTlQzMkJFID0gJ1VJTlQzMkJFJztcbmNvbnN0IEVTQ0FQRUQgPSAnRVNDQVBFRCc7XG5jb25zdCBTVFJJTkcgPSAnU1RSSU5HJztcblxuLyogcHJpdmF0ZSBmdW5jdGlvbnMgKi9cbi8vIEZpbmQgdGhlIFVURjggQk9NLCBpZiBhbnkuXG5jb25zdCBib204ID0gZnVuY3Rpb24gYm9tOChzcmMpIHtcbiAgc3JjLnR5cGUgPSBVVEY4O1xuICBjb25zdCBidWYgPSBzcmMuZGF0YTtcbiAgc3JjLmJvbSA9IDA7XG4gIGlmIChidWYubGVuZ3RoID49IDMpIHtcbiAgICBpZiAoYnVmWzBdID09PSAweGVmICYmIGJ1ZlsxXSA9PT0gMHhiYiAmJiBidWZbMl0gPT09IDB4YmYpIHtcbiAgICAgIHNyYy5ib20gPSAzO1xuICAgIH1cbiAgfVxufTtcbi8vIEZpbmQgdGhlIFVURjE2IEJPTSwgaWYgYW55LCBhbmQgZGV0ZXJtaW5lIHRoZSBVVEYxNiB0eXBlLlxuLy8gRGVmYXVsdHMgdG8gVVRGMTZCRS5cbi8vIFRocm93cyBUeXBlRXJyb3IgZXhjZXB0aW9uIGlmIEJPTSBkb2VzIG5vdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHR5cGUuXG5jb25zdCBib20xNiA9IGZ1bmN0aW9uIGJvbTE2KHNyYykge1xuICBjb25zdCBidWYgPSBzcmMuZGF0YTtcbiAgc3JjLmJvbSA9IDA7XG4gIHN3aXRjaCAoc3JjLnR5cGUpIHtcbiAgICBjYXNlIFVURjE2OlxuICAgICAgc3JjLnR5cGUgPSBVVEYxNkJFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gMikge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZlICYmIGJ1ZlsxXSA9PT0gMHhmZikge1xuICAgICAgICAgIHNyYy5ib20gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUpIHtcbiAgICAgICAgICBzcmMudHlwZSA9IFVURjE2TEU7XG4gICAgICAgICAgc3JjLmJvbSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMTZCRTpcbiAgICAgIHNyYy50eXBlID0gVVRGMTZCRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDIpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZSAmJiBidWZbMV0gPT09IDB4ZmYpIHtcbiAgICAgICAgICBzcmMuYm9tID0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3JjIHR5cGU6IFwiJHtVVEYxNkJFfVwiIHNwZWNpZmllZCBidXQgQk9NIGlzIGZvciBcIiR7VVRGMTZMRX1cImApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgICBzcmMudHlwZSA9IFVURjE2TEU7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmUgJiYgYnVmWzFdID09PSAweGZmKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3JjIHR5cGU6IFwiJHtVVEYxNkxFfVwiIHNwZWNpZmllZCBidXQgQk9NIGlzIGZvciBcIiR7VVRGMTZCRX1cImApO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUpIHtcbiAgICAgICAgICBzcmMuYm9tID0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVURjE2IEJPTTogc3JjIHR5cGUgXCIke3NyYy50eXBlfVwiIHVucmVjb2duaXplZGApO1xuICB9XG59O1xuLy8gRmluZCB0aGUgVVRGMzIgQk9NLCBpZiBhbnksIGFuZCBkZXRlcm1pbmUgdGhlIFVURjMyIHR5cGUuXG4vLyBEZWZhdWx0cyB0byBVVEYzMkJFLlxuLy8gVGhyb3dzIGV4Y2VwdGlvbiBpZiBCT00gZG9lcyBub3QgbWF0Y2ggdGhlIHNwZWNpZmllZCB0eXBlLlxuY29uc3QgYm9tMzIgPSBmdW5jdGlvbiBib20zMihzcmMpIHtcbiAgY29uc3QgYnVmID0gc3JjLmRhdGE7XG4gIHNyYy5ib20gPSAwO1xuICBzd2l0Y2ggKHNyYy50eXBlKSB7XG4gICAgY2FzZSBVVEYzMjpcbiAgICAgIHNyYy50eXBlID0gVVRGMzJCRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDQpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMCAmJiBidWZbMV0gPT09IDAgJiYgYnVmWzJdID09PSAweGZlICYmIGJ1ZlszXSA9PT0gMHhmZikge1xuICAgICAgICAgIHNyYy5ib20gPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlICYmIGJ1ZlsyXSA9PT0gMCAmJiBidWZbM10gPT09IDApIHtcbiAgICAgICAgICBzcmMudHlwZSA9IFVURjMyTEU7XG4gICAgICAgICAgc3JjLmJvbSA9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMzJCRTpcbiAgICAgIHNyYy50eXBlID0gVVRGMzJCRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDQpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMCAmJiBidWZbMV0gPT09IDAgJiYgYnVmWzJdID09PSAweGZlICYmIGJ1ZlszXSA9PT0gMHhmZikge1xuICAgICAgICAgIHNyYy5ib20gPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlICYmIGJ1ZlsyXSA9PT0gMCAmJiBidWZbM10gPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzcmMgdHlwZTogJHtVVEYzMkJFfSBzcGVjaWZpZWQgYnV0IEJPTSBpcyBmb3IgJHtVVEYzMkxFfVwiYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMzJMRTpcbiAgICAgIHNyYy50eXBlID0gVVRGMzJMRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDQpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMCAmJiBidWZbMV0gPT09IDAgJiYgYnVmWzJdID09PSAweGZlICYmIGJ1ZlszXSA9PT0gMHhmZikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHNyYyB0eXBlOiBcIiR7VVRGMzJMRX1cIiBzcGVjaWZpZWQgYnV0IEJPTSBpcyBmb3IgXCIke1VURjMyQkV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSAmJiBidWZbMl0gPT09IDAgJiYgYnVmWzNdID09PSAwKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVVEYzMiBCT006IHNyYyB0eXBlIFwiJHtzcmMudHlwZX1cIiB1bnJlY29nbml6ZWRgKTtcbiAgfVxufTtcbi8vIFZhbGlkYXRlcyB0aGUgc291cmNlIGVuY29kaW5nIHR5cGUgYW5kIG1hdGNoaW5nIGRhdGEuXG4vLyBJZiB0aGUgQkFTRTY0OiBwcmVmaXggaXMgcHJlc2VudCwgdGhlIGJhc2UgNjQgZGVjb2RpbmcgaXMgZG9uZSBoZXJlIGFzIHRoZSBpbml0aWFsIHN0ZXAuXG4vLyAtIEZvciB0eXBlIFNUUklORywgZGF0YSBtdXN0IGJlIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4vLyAtIEZvciB0eXBlIEJBU0U2NDoqLCBkYXRhIG1heSBiZSBhIHN0cmluZyBvciBCdWZmZXIuXG4vLyAtIEZvciBhbGwgb3RoZXIgdHlwZXMsIGRhdGEgbXVzdCBiZSBhIEJ1ZmZlci5cbi8vIC0gVGhlIEJBU0U2NDogcHJlZml4IGlzIG5vdCBhbGxvd2VkIGZvciB0eXBlIFNUUklORy5cbmNvbnN0IHZhbGlkYXRlU3JjID0gZnVuY3Rpb24gdmFsaWRhdGVTcmModHlwZSwgZGF0YSkge1xuICBmdW5jdGlvbiBnZXRUeXBlKHR5cGVBcmcpIHtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICB0eXBlOiAnJyxcbiAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgfTtcbiAgICBjb25zdCByeCA9IC9eKGJhc2U2NDopPyhbYS16QS1aMC05XSspJC9pO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ4LmV4ZWModHlwZUFyZyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdFsyXSkge1xuICAgICAgICByZXQudHlwZSA9IHJlc3VsdFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgICByZXQuYmFzZTY0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBjb25zdCByZXQgPSBnZXRUeXBlKHR5cGUudG9VcHBlckNhc2UoKSk7XG4gIGlmIChyZXQuYmFzZTY0KSB7XG4gICAgLyogaGFuZGxlIGJhc2UgNjQgKi9cbiAgICBpZiAocmV0LnR5cGUgPT09IFNUUklORykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9IFwiQkFTRTY0OlwiIHByZWZpeCBub3QgYWxsb3dlZCB3aXRoIHR5cGUgJHtTVFJJTkd9YCk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIHJldC5kYXRhID0gdHJhbnMuYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oZGF0YSwgJ2FzY2lpJyk7XG4gICAgICByZXQuZGF0YSA9IHRyYW5zLmJhc2U2NC5kZWNvZGUoYnVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9IHVucmVjb2duaXplZCBkYXRhIHR5cGU6IHR5cGVvZihkYXRhKTogJHt0eXBlb2YgZGF0YX1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0LmRhdGEgPSBkYXRhO1xuICB9XG4gIHN3aXRjaCAocmV0LnR5cGUpIHtcbiAgICBjYXNlIFVURjg6XG4gICAgICBib204KHJldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjE2OlxuICAgIGNhc2UgVVRGMTZCRTpcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgICBib20xNihyZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYzMjpcbiAgICBjYXNlIFVURjMyQkU6XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgICAgYm9tMzIocmV0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVUlOVDE2OlxuICAgICAgcmV0LnR5cGUgPSBVSU5UMTZCRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVUlOVDMyOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UMzJCRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQVNDSUk6XG4gICAgICByZXQudHlwZSA9IFVJTlQ3O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCSU5BUlk6XG4gICAgICByZXQudHlwZSA9IFVJTlQ4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UNzpcbiAgICBjYXNlIFVJTlQ4OlxuICAgIGNhc2UgVUlOVDE2TEU6XG4gICAgY2FzZSBVSU5UMTZCRTpcbiAgICBjYXNlIFVJTlQzMkxFOlxuICAgIGNhc2UgVUlOVDMyQkU6XG4gICAgY2FzZSBTVFJJTkc6XG4gICAgY2FzZSBFU0NBUEVEOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGU6IFwiJHt0eXBlfVwiIG5vdCByZWNvZ25pemVkYCk7XG4gIH1cbiAgaWYgKHJldC50eXBlID09PSBTVFJJTkcpIHtcbiAgICBpZiAodHlwZW9mIHJldC5kYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9XCIgYnV0IGRhdGEgaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIocmV0LmRhdGEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9XCIgYnV0IGRhdGEgaXMgbm90IGEgQnVmZmVyYCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBEaXNhc3NlbWJsZXMgYW5kIHZhbGlkYXRlcyB0aGUgZGVzdGluYXRpb24gdHlwZS5cbi8vIGBjaGFyc2AgbXVzdCBiZSBhbiBBcnJheSBvZiBpbnRlZ2Vycy5cbi8vIFRoZSA6QkFTRTY0IHN1ZmZpeCBpcyBub3QgYWxsb3dlZCBmb3IgdHlwZSBTVFJJTkcuXG5jb25zdCB2YWxpZGF0ZURzdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRHN0KHR5cGUsIGNoYXJzKSB7XG4gIGZ1bmN0aW9uIGdldFR5cGUodHlwZUFyZykge1xuICAgIGxldCBmaXg7XG4gICAgbGV0IHJlbTtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICBjcmxmOiBmYWxzZSxcbiAgICAgIGxmOiBmYWxzZSxcbiAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICB0eXBlOiAnJyxcbiAgICB9O1xuICAgIC8qIHByZWZpeCwgaWYgYW55ICovXG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIHJlbSA9IHR5cGVBcmc7XG4gICAgICBmaXggPSB0eXBlQXJnLnNsaWNlKDAsIDUpO1xuICAgICAgaWYgKGZpeCA9PT0gJ0NSTEY6Jykge1xuICAgICAgICByZXQuY3JsZiA9IHRydWU7XG4gICAgICAgIHJlbSA9IHR5cGVBcmcuc2xpY2UoNSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZml4ID0gdHlwZUFyZy5zbGljZSgwLCAzKTtcbiAgICAgIGlmIChmaXggPT09ICdMRjonKSB7XG4gICAgICAgIHJldC5sZiA9IHRydWU7XG4gICAgICAgIHJlbSA9IHR5cGVBcmcuc2xpY2UoMyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8qIHN1ZmZpeCwgaWYgYW55ICovXG4gICAgZml4ID0gcmVtLnNwbGl0KCc6Jyk7XG4gICAgaWYgKGZpeC5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgcmV0LnR5cGUgPSBmaXhbMF07XG4gICAgfSBlbHNlIGlmIChmaXgubGVuZ3RoID09PSAyICYmIGZpeFsxXSA9PT0gJ0JBU0U2NCcpIHtcbiAgICAgIHJldC5iYXNlNjQgPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICByZXQudHlwZSA9IGZpeFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZHN0IGNoYXJzOiBub3QgYXJyYXk6IFwiJHt0eXBlb2YgY2hhcnN9YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRzdCB0eXBlOiBub3Qgc3RyaW5nOiBcIiR7dHlwZW9mIHR5cGV9YCk7XG4gIH1cbiAgY29uc3QgcmV0ID0gZ2V0VHlwZSh0eXBlLnRvVXBwZXJDYXNlKCkpO1xuICBzd2l0Y2ggKHJldC50eXBlKSB7XG4gICAgY2FzZSBVVEY4OlxuICAgIGNhc2UgVVRGMTZCRTpcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgY2FzZSBVVEYzMkJFOlxuICAgIGNhc2UgVVRGMzJMRTpcbiAgICBjYXNlIFVJTlQ3OlxuICAgIGNhc2UgVUlOVDg6XG4gICAgY2FzZSBVSU5UMTZMRTpcbiAgICBjYXNlIFVJTlQxNkJFOlxuICAgIGNhc2UgVUlOVDMyTEU6XG4gICAgY2FzZSBVSU5UMzJCRTpcbiAgICBjYXNlIEVTQ0FQRUQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNUUklORzpcbiAgICAgIGlmIChyZXQuYmFzZTY0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiOkJBU0U2NFwiIHN1ZmZpeCBub3QgYWxsb3dlZCB3aXRoIHR5cGUgJHtTVFJJTkd9YCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFTQ0lJOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UNztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQklOQVJZOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMTY6XG4gICAgICByZXQudHlwZSA9IFVURjE2QkU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjMyOlxuICAgICAgcmV0LnR5cGUgPSBVVEYzMkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UMTY6XG4gICAgICByZXQudHlwZSA9IFVJTlQxNkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UMzI6XG4gICAgICByZXQudHlwZSA9IFVJTlQzMkJFO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRzdCB0eXBlIHVucmVjb2duaXplZDogXCIke3R5cGV9XCIgOiBtdXN0IGhhdmUgZm9ybSBbY3JsZjp8bGY6XXR5cGVbOmJhc2U2NF1gKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFNlbGVjdCBhbmQgY2FsbCB0aGUgcmVxdWVzdGVkIGVuY29kaW5nIGZ1bmN0aW9uLlxuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHR5cGUsIGNoYXJzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgVVRGODpcbiAgICAgIHJldHVybiB0cmFucy51dGY4LmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjE2YmUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMTZsZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVVRGMzJCRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYzMmJlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjMybGUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQ3OlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQ3LmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UODpcbiAgICAgIHJldHVybiB0cmFucy51aW50OC5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDE2QkU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDE2YmUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQxNkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQxNmxlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UMzJCRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MzJiZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDMyTEU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDMybGUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFNUUklORzpcbiAgICAgIHJldHVybiB0cmFucy5zdHJpbmcuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIEVTQ0FQRUQ6XG4gICAgICByZXR1cm4gdHJhbnMuZXNjYXBlZC5lbmNvZGUoY2hhcnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBlbmNvZGUgdHlwZSBcIiR7dHlwZX1cIiBub3QgcmVjb2duaXplZGApO1xuICB9XG59O1xuLy8gU2VsZWN0IGFuZCBjYWxsIHRoZSByZXF1ZXN0ZWQgZGVjb2RpbmcgZnVuY3Rpb24uXG4vLyBgc3JjYCBjb250YWlucyBCT00gaW5mb3JtYXRpb24gYXMgd2VsbCBhcyB0aGUgc291cmNlIHR5cGUgYW5kIGRhdGEuXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3JjKSB7XG4gIHN3aXRjaCAoc3JjLnR5cGUpIHtcbiAgICBjYXNlIFVURjg6XG4gICAgICByZXR1cm4gdHJhbnMudXRmOC5kZWNvZGUoc3JjLmRhdGEsIHNyYy5ib20pO1xuICAgIGNhc2UgVVRGMTZMRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYxNmxlLmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjE2YmUuZGVjb2RlKHNyYy5kYXRhLCBzcmMuYm9tKTtcbiAgICBjYXNlIFVURjMyQkU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMzJiZS5kZWNvZGUoc3JjLmRhdGEsIHNyYy5ib20pO1xuICAgIGNhc2UgVVRGMzJMRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYzMmxlLmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVSU5UNzpcbiAgICAgIHJldHVybiB0cmFucy51aW50Ny5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDg6XG4gICAgICByZXR1cm4gdHJhbnMudWludDguZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFVJTlQxNkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQxNmJlLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBVSU5UMTZMRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MTZsZS5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDMyQkU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDMyYmUuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFVJTlQzMkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQzMmxlLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBTVFJJTkc6XG4gICAgICByZXR1cm4gdHJhbnMuc3RyaW5nLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBFU0NBUEVEOlxuICAgICAgcmV0dXJuIHRyYW5zLmVzY2FwZWQuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGVjb2RlIHR5cGUgXCIke3NyYy50eXBlfVwiIG5vdCByZWNvZ25pemVkYCk7XG4gIH1cbn07XG5cbi8vIFRoZSBwdWJsaWMgZGVjb2RpbmcgZnVuY3Rpb24uIFJldHVybnMgYW4gYXJyYXkgb2YgaW50ZWdlcnMuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGV4cG9ydHNEZWNvZGUodHlwZSwgZGF0YSkge1xuICBjb25zdCBzcmMgPSB2YWxpZGF0ZVNyYyh0eXBlLCBkYXRhKTtcbiAgcmV0dXJuIGRlY29kZShzcmMpO1xufTtcbi8vIFRoZSBwdWJsaWMgZW5jb2RpbmcgZnVuY3Rpb24uIFJldHVybnMgYSBCdWZmZXItdHlwZWQgYnl0ZSBhcnJheS5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gZXhwb3J0c0VuY29kZSh0eXBlLCBjaGFycykge1xuICBsZXQgYztcbiAgbGV0IGJ1ZjtcbiAgY29uc3QgZHN0ID0gdmFsaWRhdGVEc3QodHlwZSwgY2hhcnMpO1xuICBpZiAoZHN0LmNybGYpIHtcbiAgICAvKiBwcmVmaXggd2l0aCBDUkxGIGxpbmUgZW5kIGNvbnZlcnNpb24sIGRvbid0IGNvbnRhbWluYXRlIGNhbGxlcidzIGNoYXJzIGFycmF5ICovXG4gICAgYyA9IHRyYW5zLmxpbmVFbmRzLmNybGYoY2hhcnMpO1xuICAgIGJ1ZiA9IGVuY29kZShkc3QudHlwZSwgYyk7XG4gIH0gZWxzZSBpZiAoZHN0LmxmKSB7XG4gICAgLyogcHJlZml4IHdpdGggTEYgbGluZSBlbmQgY29udmVyc2lvbiwgZG9uJ3QgY29udGFtaW5hdGUgY2FsbGVyJ3MgY2hhcnMgYXJyYXkgKi9cbiAgICBjID0gdHJhbnMubGluZUVuZHMubGYoY2hhcnMpO1xuICAgIGJ1ZiA9IGVuY29kZShkc3QudHlwZSwgYyk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gZW5jb2RlKGRzdC50eXBlLCBjaGFycyk7XG4gIH1cbiAgaWYgKGRzdC5iYXNlNjQpIHtcbiAgICAvKiBwb3N0IGJhc2UgNjQgZW5jb2RpbmcgKi9cbiAgICBidWYgPSB0cmFucy5iYXNlNjQuZW5jb2RlKGJ1Zik7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG4vLyBDb252ZXJ0cyBkYXRhIG9mIHR5cGUgYHNyY1R5cGVgIHRvIGRhdGEgb2YgdHlwZSBgZHN0VHlwZWAuXG4vLyBgc3JjRGF0YWAgbWF5IGJlIGEgSmF2YVNjcmlwdCBTdHJpbmcsIG9yIG5vZGUuanMgQnVmZmVyLCBkZXBlbmRpbmcgb24gdGhlIGNvcnJlc3BvbmRpbmcgdHlwZS5cbmNvbnN0IGNvbnZlcnQgPSBmdW5jdGlvbiBjb252ZXJ0KHNyY1R5cGUsIHNyY0RhdGEsIGRzdFR5cGUpIHtcbiAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlKGRzdFR5cGUsIGV4cG9ydHMuZGVjb2RlKHNyY1R5cGUsIHNyY0RhdGEpKTtcbn07XG5leHBvcnRzLmNvbnZlcnQgPSBjb252ZXJ0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-conv-api/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-conv-api/transformers.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-conv-api/transformers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable prefer-destructuring */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-bitwise */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module contains the actual encoding and decoding algorithms.\n// Throws \"RangeError\" exceptions on characters or bytes out of range for the given encoding.\n\n'use strict;';\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n\n/* decoding error codes */\nconst NON_SHORTEST = 0xfffffffc;\nconst TRAILING = 0xfffffffd;\nconst RANGE = 0xfffffffe;\nconst ILL_FORMED = 0xffffffff;\n\n/* mask[n] = 2**n - 1, ie. mask[n] = n bits on. e.g. mask[6] = %b111111 */\nconst mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];\n\n/* ascii[n] = 'HH', where 0xHH = n, eg. ascii[254] = 'FE' */\nconst ascii = [\n  '00',\n  '01',\n  '02',\n  '03',\n  '04',\n  '05',\n  '06',\n  '07',\n  '08',\n  '09',\n  '0A',\n  '0B',\n  '0C',\n  '0D',\n  '0E',\n  '0F',\n  '10',\n  '11',\n  '12',\n  '13',\n  '14',\n  '15',\n  '16',\n  '17',\n  '18',\n  '19',\n  '1A',\n  '1B',\n  '1C',\n  '1D',\n  '1E',\n  '1F',\n  '20',\n  '21',\n  '22',\n  '23',\n  '24',\n  '25',\n  '26',\n  '27',\n  '28',\n  '29',\n  '2A',\n  '2B',\n  '2C',\n  '2D',\n  '2E',\n  '2F',\n  '30',\n  '31',\n  '32',\n  '33',\n  '34',\n  '35',\n  '36',\n  '37',\n  '38',\n  '39',\n  '3A',\n  '3B',\n  '3C',\n  '3D',\n  '3E',\n  '3F',\n  '40',\n  '41',\n  '42',\n  '43',\n  '44',\n  '45',\n  '46',\n  '47',\n  '48',\n  '49',\n  '4A',\n  '4B',\n  '4C',\n  '4D',\n  '4E',\n  '4F',\n  '50',\n  '51',\n  '52',\n  '53',\n  '54',\n  '55',\n  '56',\n  '57',\n  '58',\n  '59',\n  '5A',\n  '5B',\n  '5C',\n  '5D',\n  '5E',\n  '5F',\n  '60',\n  '61',\n  '62',\n  '63',\n  '64',\n  '65',\n  '66',\n  '67',\n  '68',\n  '69',\n  '6A',\n  '6B',\n  '6C',\n  '6D',\n  '6E',\n  '6F',\n  '70',\n  '71',\n  '72',\n  '73',\n  '74',\n  '75',\n  '76',\n  '77',\n  '78',\n  '79',\n  '7A',\n  '7B',\n  '7C',\n  '7D',\n  '7E',\n  '7F',\n  '80',\n  '81',\n  '82',\n  '83',\n  '84',\n  '85',\n  '86',\n  '87',\n  '88',\n  '89',\n  '8A',\n  '8B',\n  '8C',\n  '8D',\n  '8E',\n  '8F',\n  '90',\n  '91',\n  '92',\n  '93',\n  '94',\n  '95',\n  '96',\n  '97',\n  '98',\n  '99',\n  '9A',\n  '9B',\n  '9C',\n  '9D',\n  '9E',\n  '9F',\n  'A0',\n  'A1',\n  'A2',\n  'A3',\n  'A4',\n  'A5',\n  'A6',\n  'A7',\n  'A8',\n  'A9',\n  'AA',\n  'AB',\n  'AC',\n  'AD',\n  'AE',\n  'AF',\n  'B0',\n  'B1',\n  'B2',\n  'B3',\n  'B4',\n  'B5',\n  'B6',\n  'B7',\n  'B8',\n  'B9',\n  'BA',\n  'BB',\n  'BC',\n  'BD',\n  'BE',\n  'BF',\n  'C0',\n  'C1',\n  'C2',\n  'C3',\n  'C4',\n  'C5',\n  'C6',\n  'C7',\n  'C8',\n  'C9',\n  'CA',\n  'CB',\n  'CC',\n  'CD',\n  'CE',\n  'CF',\n  'D0',\n  'D1',\n  'D2',\n  'D3',\n  'D4',\n  'D5',\n  'D6',\n  'D7',\n  'D8',\n  'D9',\n  'DA',\n  'DB',\n  'DC',\n  'DD',\n  'DE',\n  'DF',\n  'E0',\n  'E1',\n  'E2',\n  'E3',\n  'E4',\n  'E5',\n  'E6',\n  'E7',\n  'E8',\n  'E9',\n  'EA',\n  'EB',\n  'EC',\n  'ED',\n  'EE',\n  'EF',\n  'F0',\n  'F1',\n  'F2',\n  'F3',\n  'F4',\n  'F5',\n  'F6',\n  'F7',\n  'F8',\n  'F9',\n  'FA',\n  'FB',\n  'FC',\n  'FD',\n  'FE',\n  'FF',\n];\n\n/* vector of base 64 characters */\nconst base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');\n\n/* vector of base 64 character codes */\nconst base64codes = [];\nbase64chars.forEach((char) => {\n  base64codes.push(char.charCodeAt(0));\n});\n\n// The UTF8 algorithms.\nexports.utf8 = {\n  encode(chars) {\n    const bytes = [];\n    chars.forEach((char) => {\n      if (char >= 0 && char <= 0x7f) {\n        bytes.push(char);\n      } else if (char <= 0x7ff) {\n        bytes.push(0xc0 + ((char >> 6) & mask[5]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char < 0xd800 || (char > 0xdfff && char <= 0xffff)) {\n        bytes.push(0xe0 + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        const u = (char >> 16) & mask[5];\n        bytes.push(0xf0 + (u >> 2));\n        bytes.push(0x80 + ((u & mask[2]) << 4) + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else {\n        throw new RangeError(`utf8.encode: character out of range: char: ${char}`);\n      }\n    });\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* bytes functions return error for non-shortest forms & values out of range */\n    function bytes2(b1, b2) {\n      /* U+0080..U+07FF */\n      /* 00000000 00000yyy yyxxxxxx | 110yyyyy 10xxxxxx */\n      if ((b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[5]) << 6) + (b2 & mask[6]);\n      if (x < 0x80) {\n        return NON_SHORTEST;\n      }\n      return x;\n    }\n    function bytes3(b1, b2, b3) {\n      /* U+0800..U+FFFF */\n      /* 00000000 zzzzyyyy yyxxxxxx | 1110zzzz 10yyyyyy 10xxxxxx */\n      if ((b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);\n      if (x < 0x800) {\n        return NON_SHORTEST;\n      }\n      if (x >= 0xd800 && x <= 0xdfff) {\n        return RANGE;\n      }\n      return x;\n    }\n    function bytes4(b1, b2, b3, b4) {\n      /* U+10000..U+10FFFF */\n      /* 000uuuuu zzzzyyyy yyxxxxxx | 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx */\n      if ((b4 & 0xc0) !== 0x80 || (b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x =\n        ((((b1 & mask[3]) << 2) + ((b2 >> 4) & mask[2])) << 16) +\n        ((b2 & mask[4]) << 12) +\n        ((b3 & mask[6]) << 6) +\n        (b4 & mask[6]);\n      if (x < 0x10000) {\n        return NON_SHORTEST;\n      }\n      if (x > 0x10ffff) {\n        return RANGE;\n      }\n      return x;\n    }\n    let c;\n    let b1;\n    let i1;\n    let i2;\n    let i3;\n    let inc;\n    const len = buf.length;\n    let i = bom ? 3 : 0;\n    const chars = [];\n    while (i < len) {\n      b1 = buf[i];\n      c = ILL_FORMED;\n      const TRUE = true;\n      while (TRUE) {\n        if (b1 >= 0 && b1 <= 0x7f) {\n          /* U+0000..U+007F 00..7F */\n          c = b1;\n          inc = 1;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 < len && b1 >= 0xc2 && b1 <= 0xdf) {\n          /* U+0080..U+07FF C2..DF 80..BF */\n          c = bytes2(b1, buf[i1]);\n          inc = 2;\n          break;\n        }\n        i2 = i + 2;\n        if (i2 < len && b1 >= 0xe0 && b1 <= 0xef) {\n          /* U+0800..U+FFFF */\n          c = bytes3(b1, buf[i1], buf[i2]);\n          inc = 3;\n          break;\n        }\n        i3 = i + 3;\n        if (i3 < len && b1 >= 0xf0 && b1 <= 0xf4) {\n          /* U+10000..U+10FFFF */\n          c = bytes4(b1, buf[i1], buf[i2], buf[i3]);\n          inc = 4;\n          break;\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        break;\n      }\n      if (c > 0x10ffff) {\n        const at = `byte[${i}]`;\n        if (c === ILL_FORMED) {\n          throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);\n        }\n        if (c === TRAILING) {\n          throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);\n        }\n        if (c === RANGE) {\n          throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);\n        }\n        if (c === NON_SHORTEST) {\n          throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);\n        }\n        throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);\n      }\n      chars.push(c);\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16BE algorithms.\nexports.utf16be = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push((char >> 8) & mask[8]);\n        bytes.push(char & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(h & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n      } else {\n        throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i] << 8) + buf[i1];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i + 2] << 8) + buf[i3];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16LE algorithms.\nexports.utf16le = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push(char & mask[8]);\n        bytes.push((char >> 8) & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push(h & mask[8]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n      } else {\n        throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i1] << 8) + buf[i];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i3] << 8) + buf[i + 2];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF32BE algorithms.\nexports.utf32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UTF32LE algorithms.\nexports.utf32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UINT7 algorithms. ASCII or 7-bit unsigned integers.\nexports.uint7 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0x7f) {\n        throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      if (buf[i] > 0x7f) {\n        throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf[i]}`);\n      }\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT8 algorithms. BINARY, Latin 1 or 8-bit unsigned integers.\nexports.uint8 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0xff) {\n        throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT16BE algorithms. Big-endian 16-bit unsigned integers.\nexports.uint16be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i] << 8) + buf[i + 1]);\n    }\n    return chars;\n  },\n};\n\n// The UINT16LE algorithms. Little-endian 16-bit unsigned integers.\nexports.uint16le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32BE algorithms. Big-endian 32-bit unsigned integers.\nexports.uint32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32LE algorithms. Little-endian 32-bit unsigned integers.\nexports.uint32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The STRING algorithms. Converts JavaScript strings to Array of 32-bit integers and vice versa.\n// Uses the node.js Buffer's native \"utf16le\" capabilites.\nexports.string = {\n  encode(chars) {\n    return exports.utf16le.encode(chars).toString('utf16le');\n  },\n  decode(str) {\n    return exports.utf16le.decode(Buffer.from(str, 'utf16le'), 0);\n  },\n};\n\n// The ESCAPED algorithms.\n// Note that ESCAPED format contains only ASCII characters.\n// The characters are always in the form of a Buffer of bytes.\nexports.escaped = {\n  // Encodes an Array of 32-bit integers into ESCAPED format.\n  encode(chars) {\n    const bytes = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      const char = chars[i];\n      if (char === 96) {\n        bytes.push(char);\n        bytes.push(char);\n      } else if (char === 10) {\n        bytes.push(char);\n      } else if (char >= 32 && char <= 126) {\n        bytes.push(char);\n      } else {\n        let str = '';\n        if (char >= 0 && char <= 31) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 127 && char <= 255) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 0x100 && char <= 0xffff) {\n          str += `\\`u${ascii[(char >> 8) & mask[8]]}${ascii[char & mask[8]]}`;\n        } else if (char >= 0x10000 && char <= 0xffffffff) {\n          str += '`u{';\n          const digit = (char >> 24) & mask[8];\n          if (digit > 0) {\n            str += ascii[digit];\n          }\n          str += `${ascii[(char >> 16) & mask[8]] + ascii[(char >> 8) & mask[8]] + ascii[char & mask[8]]}}`;\n        } else {\n          throw new Error('escape.encode(char): char > 0xffffffff not allowed');\n        }\n        const buf = Buffer.from(str);\n        buf.forEach((b) => {\n          bytes.push(b);\n        });\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.\n  decode(buf) {\n    function isHex(hex) {\n      if ((hex >= 48 && hex <= 57) || (hex >= 65 && hex <= 70) || (hex >= 97 && hex <= 102)) {\n        return true;\n      }\n      return false;\n    }\n    function getx(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 2, error: true };\n      if (i + 1 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getu(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      if (i + 3 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1]) && isHex(bufArg[i + 2]) && isHex(bufArg[i + 3])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1], bufArg[i + 2], bufArg[i + 3]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getU(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      let str = '';\n      while (i < len && isHex(bufArg[i])) {\n        str += String.fromCodePoint(bufArg[i]);\n        // eslint-disable-next-line no-param-reassign\n        i += 1;\n      }\n      ret.char = parseInt(str, 16);\n      if (bufArg[i] === 125 && !Number.isNaN(ret.char)) {\n        ret.error = false;\n      }\n      ret.nexti = i + 1;\n      return ret;\n    }\n    const chars = [];\n    const len = buf.length;\n    let i1;\n    let ret;\n    let error;\n    let i = 0;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        error = true;\n        if (buf[i] !== 96) {\n          /* unescaped character */\n          chars.push(buf[i]);\n          i += 1;\n          error = false;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 >= len) {\n          break;\n        }\n        if (buf[i1] === 96) {\n          /* escaped grave accent */\n          chars.push(96);\n          i += 2;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 120) {\n          ret = getx(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped hex */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 117) {\n          if (buf[i1 + 1] === 123) {\n            ret = getU(i1 + 2, len, buf);\n            if (ret.error) {\n              break;\n            }\n            /* escaped utf-32 */\n            chars.push(ret.char);\n            i = ret.nexti;\n            error = false;\n            break;\n          }\n          ret = getu(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped utf-16 */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        break;\n      }\n      if (error) {\n        throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);\n      }\n    }\n    return chars;\n  },\n};\n\n// The line end conversion algorigthms.\nconst CR = 13;\nconst LF = 10;\nexports.lineEnds = {\n  crlf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(CR);\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(CR);\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(CR);\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n  lf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n};\n\n// The base 64 algorithms.\nexports.base64 = {\n  encode(buf) {\n    if (buf.length === 0) {\n      return Buffer.alloc(0);\n    }\n    let i;\n    let j;\n    let n;\n    let tail = buf.length % 3;\n    tail = tail > 0 ? 3 - tail : 0;\n    let units = (buf.length + tail) / 3;\n    const base64 = Buffer.alloc(units * 4);\n    if (tail > 0) {\n      units -= 1;\n    }\n    i = 0;\n    j = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = buf[i++] << 16;\n      n += buf[i++] << 8;\n      n += buf[i++];\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j++] = base64codes[n & mask[6]];\n    }\n    if (tail === 0) {\n      return base64;\n    }\n    if (tail === 1) {\n      n = buf[i++] << 16;\n      n += buf[i] << 8;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    if (tail === 2) {\n      n = buf[i] << 16;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[64];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    return undefined;\n  },\n  decode(codes) {\n    /* remove white space and ctrl characters, validate & translate characters */\n    function validate(buf) {\n      const chars = [];\n      let tail = 0;\n      for (let i = 0; i < buf.length; i += 1) {\n        const char = buf[i];\n        const TRUE = true;\n        while (TRUE) {\n          if (char === 32 || char === 9 || char === 10 || char === 13) {\n            break;\n          }\n          if (char >= 65 && char <= 90) {\n            chars.push(char - 65);\n            break;\n          }\n          if (char >= 97 && char <= 122) {\n            chars.push(char - 71);\n            break;\n          }\n          if (char >= 48 && char <= 57) {\n            chars.push(char + 4);\n            break;\n          }\n          if (char === 43) {\n            chars.push(62);\n            break;\n          }\n          if (char === 47) {\n            chars.push(63);\n            break;\n          }\n          if (char === 61) {\n            chars.push(64);\n            tail += 1;\n            break;\n          }\n          /* invalid character */\n          throw new RangeError(`base64.decode: invalid character buf[${i}]: ${char}`);\n        }\n      }\n      /* validate length */\n      if (chars.length % 4 > 0) {\n        throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);\n      }\n      /* validate tail */\n      switch (tail) {\n        case 0:\n          break;\n        case 1:\n          if (chars[chars.length - 1] !== 64) {\n            throw new RangeError('base64.decode: one tail character found: not last character');\n          }\n          break;\n        case 2:\n          if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {\n            throw new RangeError('base64.decode: two tail characters found: not last characters');\n          }\n          break;\n        default:\n          throw new RangeError(`base64.decode: more than two tail characters found: ${tail}`);\n      }\n      return { tail, buf: Buffer.from(chars) };\n    }\n\n    if (codes.length === 0) {\n      return Buffer.alloc(0);\n    }\n    const val = validate(codes);\n    const { tail } = val;\n    const base64 = val.buf;\n    let i;\n    let j;\n    let n;\n    let units = base64.length / 4;\n    const buf = Buffer.alloc(units * 3 - tail);\n    if (tail > 0) {\n      units -= 1;\n    }\n    j = 0;\n    i = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i++] << 6;\n      n += base64[i++];\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j++] = (n >> 8) & mask[8];\n      buf[j++] = n & mask[8];\n    }\n    if (tail === 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i] << 6;\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j] = (n >> 8) & mask[8];\n    }\n    if (tail === 2) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      buf[j] = (n >> 16) & mask[8];\n    }\n    return buf;\n  },\n  // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.\n  toString(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);\n    }\n    let str = '';\n    let lineLen = 0;\n    function buildLine(c1, c2, c3, c4) {\n      switch (lineLen) {\n        case 76:\n          str += `\\r\\n${c1}${c2}${c3}${c4}`;\n          lineLen = 4;\n          break;\n        case 75:\n          str += `${c1}\\r\\n${c2}${c3}${c4}`;\n          lineLen = 3;\n          break;\n        case 74:\n          str += `${c1 + c2}\\r\\n${c3}${c4}`;\n          lineLen = 2;\n          break;\n        case 73:\n          str += `${c1 + c2 + c3}\\r\\n${c4}`;\n          lineLen = 1;\n          break;\n        default:\n          str += c1 + c2 + c3 + c4;\n          lineLen += 4;\n          break;\n      }\n    }\n    function validate(c) {\n      if (c >= 65 && c <= 90) {\n        return true;\n      }\n      if (c >= 97 && c <= 122) {\n        return true;\n      }\n      if (c >= 48 && c <= 57) {\n        return true;\n      }\n      if (c === 43) {\n        return true;\n      }\n      if (c === 47) {\n        return true;\n      }\n      if (c === 61) {\n        return true;\n      }\n      return false;\n    }\n    for (let i = 0; i < buf.length; i += 4) {\n      for (let j = i; j < i + 4; j += 1) {\n        if (!validate(buf[j])) {\n          throw new RangeError(`base64.toString: buf[${j}]: ${buf[j]} : not valid base64 character code`);\n        }\n      }\n      buildLine(\n        String.fromCharCode(buf[i]),\n        String.fromCharCode(buf[i + 1]),\n        String.fromCharCode(buf[i + 2]),\n        String.fromCharCode(buf[i + 3])\n      );\n    }\n    return str;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvdHJhbnNmb3JtZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkVBQTJFLEtBQUs7QUFDaEY7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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b0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFLEtBQUssS0FBSztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixhQUFhO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLEtBQUs7QUFDM0Y7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRyxNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxNQUFNLEdBQUcsRUFBRSxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLE1BQU0sR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxzQkFBc0IsV0FBVztBQUNqQztBQUNBLHVEQUF1RCxFQUFFLEtBQUssUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1jb252LWFwaS90cmFuc2Zvcm1lcnMuanM/Y2EzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGx1c3BsdXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHRoZSBhY3R1YWwgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGFsZ29yaXRobXMuXG4vLyBUaHJvd3MgXCJSYW5nZUVycm9yXCIgZXhjZXB0aW9ucyBvbiBjaGFyYWN0ZXJzIG9yIGJ5dGVzIG91dCBvZiByYW5nZSBmb3IgdGhlIGdpdmVuIGVuY29kaW5nLlxuXG4ndXNlIHN0cmljdDsnO1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5cbi8qIGRlY29kaW5nIGVycm9yIGNvZGVzICovXG5jb25zdCBOT05fU0hPUlRFU1QgPSAweGZmZmZmZmZjO1xuY29uc3QgVFJBSUxJTkcgPSAweGZmZmZmZmZkO1xuY29uc3QgUkFOR0UgPSAweGZmZmZmZmZlO1xuY29uc3QgSUxMX0ZPUk1FRCA9IDB4ZmZmZmZmZmY7XG5cbi8qIG1hc2tbbl0gPSAyKipuIC0gMSwgaWUuIG1hc2tbbl0gPSBuIGJpdHMgb24uIGUuZy4gbWFza1s2XSA9ICViMTExMTExICovXG5jb25zdCBtYXNrID0gWzAsIDEsIDMsIDcsIDE1LCAzMSwgNjMsIDEyNywgMjU1LCA1MTEsIDEwMjNdO1xuXG4vKiBhc2NpaVtuXSA9ICdISCcsIHdoZXJlIDB4SEggPSBuLCBlZy4gYXNjaWlbMjU0XSA9ICdGRScgKi9cbmNvbnN0IGFzY2lpID0gW1xuICAnMDAnLFxuICAnMDEnLFxuICAnMDInLFxuICAnMDMnLFxuICAnMDQnLFxuICAnMDUnLFxuICAnMDYnLFxuICAnMDcnLFxuICAnMDgnLFxuICAnMDknLFxuICAnMEEnLFxuICAnMEInLFxuICAnMEMnLFxuICAnMEQnLFxuICAnMEUnLFxuICAnMEYnLFxuICAnMTAnLFxuICAnMTEnLFxuICAnMTInLFxuICAnMTMnLFxuICAnMTQnLFxuICAnMTUnLFxuICAnMTYnLFxuICAnMTcnLFxuICAnMTgnLFxuICAnMTknLFxuICAnMUEnLFxuICAnMUInLFxuICAnMUMnLFxuICAnMUQnLFxuICAnMUUnLFxuICAnMUYnLFxuICAnMjAnLFxuICAnMjEnLFxuICAnMjInLFxuICAnMjMnLFxuICAnMjQnLFxuICAnMjUnLFxuICAnMjYnLFxuICAnMjcnLFxuICAnMjgnLFxuICAnMjknLFxuICAnMkEnLFxuICAnMkInLFxuICAnMkMnLFxuICAnMkQnLFxuICAnMkUnLFxuICAnMkYnLFxuICAnMzAnLFxuICAnMzEnLFxuICAnMzInLFxuICAnMzMnLFxuICAnMzQnLFxuICAnMzUnLFxuICAnMzYnLFxuICAnMzcnLFxuICAnMzgnLFxuICAnMzknLFxuICAnM0EnLFxuICAnM0InLFxuICAnM0MnLFxuICAnM0QnLFxuICAnM0UnLFxuICAnM0YnLFxuICAnNDAnLFxuICAnNDEnLFxuICAnNDInLFxuICAnNDMnLFxuICAnNDQnLFxuICAnNDUnLFxuICAnNDYnLFxuICAnNDcnLFxuICAnNDgnLFxuICAnNDknLFxuICAnNEEnLFxuICAnNEInLFxuICAnNEMnLFxuICAnNEQnLFxuICAnNEUnLFxuICAnNEYnLFxuICAnNTAnLFxuICAnNTEnLFxuICAnNTInLFxuICAnNTMnLFxuICAnNTQnLFxuICAnNTUnLFxuICAnNTYnLFxuICAnNTcnLFxuICAnNTgnLFxuICAnNTknLFxuICAnNUEnLFxuICAnNUInLFxuICAnNUMnLFxuICAnNUQnLFxuICAnNUUnLFxuICAnNUYnLFxuICAnNjAnLFxuICAnNjEnLFxuICAnNjInLFxuICAnNjMnLFxuICAnNjQnLFxuICAnNjUnLFxuICAnNjYnLFxuICAnNjcnLFxuICAnNjgnLFxuICAnNjknLFxuICAnNkEnLFxuICAnNkInLFxuICAnNkMnLFxuICAnNkQnLFxuICAnNkUnLFxuICAnNkYnLFxuICAnNzAnLFxuICAnNzEnLFxuICAnNzInLFxuICAnNzMnLFxuICAnNzQnLFxuICAnNzUnLFxuICAnNzYnLFxuICAnNzcnLFxuICAnNzgnLFxuICAnNzknLFxuICAnN0EnLFxuICAnN0InLFxuICAnN0MnLFxuICAnN0QnLFxuICAnN0UnLFxuICAnN0YnLFxuICAnODAnLFxuICAnODEnLFxuICAnODInLFxuICAnODMnLFxuICAnODQnLFxuICAnODUnLFxuICAnODYnLFxuICAnODcnLFxuICAnODgnLFxuICAnODknLFxuICAnOEEnLFxuICAnOEInLFxuICAnOEMnLFxuICAnOEQnLFxuICAnOEUnLFxuICAnOEYnLFxuICAnOTAnLFxuICAnOTEnLFxuICAnOTInLFxuICAnOTMnLFxuICAnOTQnLFxuICAnOTUnLFxuICAnOTYnLFxuICAnOTcnLFxuICAnOTgnLFxuICAnOTknLFxuICAnOUEnLFxuICAnOUInLFxuICAnOUMnLFxuICAnOUQnLFxuICAnOUUnLFxuICAnOUYnLFxuICAnQTAnLFxuICAnQTEnLFxuICAnQTInLFxuICAnQTMnLFxuICAnQTQnLFxuICAnQTUnLFxuICAnQTYnLFxuICAnQTcnLFxuICAnQTgnLFxuICAnQTknLFxuICAnQUEnLFxuICAnQUInLFxuICAnQUMnLFxuICAnQUQnLFxuICAnQUUnLFxuICAnQUYnLFxuICAnQjAnLFxuICAnQjEnLFxuICAnQjInLFxuICAnQjMnLFxuICAnQjQnLFxuICAnQjUnLFxuICAnQjYnLFxuICAnQjcnLFxuICAnQjgnLFxuICAnQjknLFxuICAnQkEnLFxuICAnQkInLFxuICAnQkMnLFxuICAnQkQnLFxuICAnQkUnLFxuICAnQkYnLFxuICAnQzAnLFxuICAnQzEnLFxuICAnQzInLFxuICAnQzMnLFxuICAnQzQnLFxuICAnQzUnLFxuICAnQzYnLFxuICAnQzcnLFxuICAnQzgnLFxuICAnQzknLFxuICAnQ0EnLFxuICAnQ0InLFxuICAnQ0MnLFxuICAnQ0QnLFxuICAnQ0UnLFxuICAnQ0YnLFxuICAnRDAnLFxuICAnRDEnLFxuICAnRDInLFxuICAnRDMnLFxuICAnRDQnLFxuICAnRDUnLFxuICAnRDYnLFxuICAnRDcnLFxuICAnRDgnLFxuICAnRDknLFxuICAnREEnLFxuICAnREInLFxuICAnREMnLFxuICAnREQnLFxuICAnREUnLFxuICAnREYnLFxuICAnRTAnLFxuICAnRTEnLFxuICAnRTInLFxuICAnRTMnLFxuICAnRTQnLFxuICAnRTUnLFxuICAnRTYnLFxuICAnRTcnLFxuICAnRTgnLFxuICAnRTknLFxuICAnRUEnLFxuICAnRUInLFxuICAnRUMnLFxuICAnRUQnLFxuICAnRUUnLFxuICAnRUYnLFxuICAnRjAnLFxuICAnRjEnLFxuICAnRjInLFxuICAnRjMnLFxuICAnRjQnLFxuICAnRjUnLFxuICAnRjYnLFxuICAnRjcnLFxuICAnRjgnLFxuICAnRjknLFxuICAnRkEnLFxuICAnRkInLFxuICAnRkMnLFxuICAnRkQnLFxuICAnRkUnLFxuICAnRkYnLFxuXTtcblxuLyogdmVjdG9yIG9mIGJhc2UgNjQgY2hhcmFjdGVycyAqL1xuY29uc3QgYmFzZTY0Y2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLnNwbGl0KCcnKTtcblxuLyogdmVjdG9yIG9mIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGVzICovXG5jb25zdCBiYXNlNjRjb2RlcyA9IFtdO1xuYmFzZTY0Y2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICBiYXNlNjRjb2Rlcy5wdXNoKGNoYXIuY2hhckNvZGVBdCgwKSk7XG59KTtcblxuLy8gVGhlIFVURjggYWxnb3JpdGhtcy5cbmV4cG9ydHMudXRmOCA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoY2hhciA+PSAwICYmIGNoYXIgPD0gMHg3Zikge1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyIDw9IDB4N2ZmKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhjMCArICgoY2hhciA+PiA2KSAmIG1hc2tbNV0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKGNoYXIgJiBtYXNrWzZdKSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPCAweGQ4MDAgfHwgKGNoYXIgPiAweGRmZmYgJiYgY2hhciA8PSAweGZmZmYpKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhlMCArICgoY2hhciA+PiAxMikgJiBtYXNrWzRdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArICgoY2hhciA+PiA2KSAmIG1hc2tbNl0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKGNoYXIgJiBtYXNrWzZdKSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAwMCAmJiBjaGFyIDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGNvbnN0IHUgPSAoY2hhciA+PiAxNikgJiBtYXNrWzVdO1xuICAgICAgICBieXRlcy5wdXNoKDB4ZjAgKyAodSA+PiAyKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArICgodSAmIG1hc2tbMl0pIDw8IDQpICsgKChjaGFyID4+IDEyKSAmIG1hc2tbNF0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKChjaGFyID4+IDYpICYgbWFza1s2XSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoY2hhciAmIG1hc2tbNl0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmVuY29kZTogY2hhcmFjdGVyIG91dCBvZiByYW5nZTogY2hhcjogJHtjaGFyfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGJ5dGVzIGZ1bmN0aW9ucyByZXR1cm4gZXJyb3IgZm9yIG5vbi1zaG9ydGVzdCBmb3JtcyAmIHZhbHVlcyBvdXQgb2YgcmFuZ2UgKi9cbiAgICBmdW5jdGlvbiBieXRlczIoYjEsIGIyKSB7XG4gICAgICAvKiBVKzAwODAuLlUrMDdGRiAqL1xuICAgICAgLyogMDAwMDAwMDAgMDAwMDB5eXkgeXl4eHh4eHggfCAxMTB5eXl5eSAxMHh4eHh4eCAqL1xuICAgICAgaWYgKChiMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBUUkFJTElORztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSAoKGIxICYgbWFza1s1XSkgPDwgNikgKyAoYjIgJiBtYXNrWzZdKTtcbiAgICAgIGlmICh4IDwgMHg4MCkge1xuICAgICAgICByZXR1cm4gTk9OX1NIT1JURVNUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ5dGVzMyhiMSwgYjIsIGIzKSB7XG4gICAgICAvKiBVKzA4MDAuLlUrRkZGRiAqL1xuICAgICAgLyogMDAwMDAwMDAgenp6enl5eXkgeXl4eHh4eHggfCAxMTEwenp6eiAxMHl5eXl5eSAxMHh4eHh4eCAqL1xuICAgICAgaWYgKChiMyAmIDB4YzApICE9PSAweDgwIHx8IChiMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBUUkFJTElORztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSAoKGIxICYgbWFza1s0XSkgPDwgMTIpICsgKChiMiAmIG1hc2tbNl0pIDw8IDYpICsgKGIzICYgbWFza1s2XSk7XG4gICAgICBpZiAoeCA8IDB4ODAwKSB7XG4gICAgICAgIHJldHVybiBOT05fU0hPUlRFU1Q7XG4gICAgICB9XG4gICAgICBpZiAoeCA+PSAweGQ4MDAgJiYgeCA8PSAweGRmZmYpIHtcbiAgICAgICAgcmV0dXJuIFJBTkdFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ5dGVzNChiMSwgYjIsIGIzLCBiNCkge1xuICAgICAgLyogVSsxMDAwMC4uVSsxMEZGRkYgKi9cbiAgICAgIC8qIDAwMHV1dXV1IHp6enp5eXl5IHl5eHh4eHh4IHwgMTExMTB1dXUgMTB1dXp6enogMTB5eXl5eXkgMTB4eHh4eHggKi9cbiAgICAgIGlmICgoYjQgJiAweGMwKSAhPT0gMHg4MCB8fCAoYjMgJiAweGMwKSAhPT0gMHg4MCB8fCAoYjIgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICByZXR1cm4gVFJBSUxJTkc7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID1cbiAgICAgICAgKCgoKGIxICYgbWFza1szXSkgPDwgMikgKyAoKGIyID4+IDQpICYgbWFza1syXSkpIDw8IDE2KSArXG4gICAgICAgICgoYjIgJiBtYXNrWzRdKSA8PCAxMikgK1xuICAgICAgICAoKGIzICYgbWFza1s2XSkgPDwgNikgK1xuICAgICAgICAoYjQgJiBtYXNrWzZdKTtcbiAgICAgIGlmICh4IDwgMHgxMDAwMCkge1xuICAgICAgICByZXR1cm4gTk9OX1NIT1JURVNUO1xuICAgICAgfVxuICAgICAgaWYgKHggPiAweDEwZmZmZikge1xuICAgICAgICByZXR1cm4gUkFOR0U7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgbGV0IGM7XG4gICAgbGV0IGIxO1xuICAgIGxldCBpMTtcbiAgICBsZXQgaTI7XG4gICAgbGV0IGkzO1xuICAgIGxldCBpbmM7XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaSA9IGJvbSA/IDMgOiAwO1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGIxID0gYnVmW2ldO1xuICAgICAgYyA9IElMTF9GT1JNRUQ7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGlmIChiMSA+PSAwICYmIGIxIDw9IDB4N2YpIHtcbiAgICAgICAgICAvKiBVKzAwMDAuLlUrMDA3RiAwMC4uN0YgKi9cbiAgICAgICAgICBjID0gYjE7XG4gICAgICAgICAgaW5jID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpMSA9IGkgKyAxO1xuICAgICAgICBpZiAoaTEgPCBsZW4gJiYgYjEgPj0gMHhjMiAmJiBiMSA8PSAweGRmKSB7XG4gICAgICAgICAgLyogVSswMDgwLi5VKzA3RkYgQzIuLkRGIDgwLi5CRiAqL1xuICAgICAgICAgIGMgPSBieXRlczIoYjEsIGJ1ZltpMV0pO1xuICAgICAgICAgIGluYyA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaTIgPSBpICsgMjtcbiAgICAgICAgaWYgKGkyIDwgbGVuICYmIGIxID49IDB4ZTAgJiYgYjEgPD0gMHhlZikge1xuICAgICAgICAgIC8qIFUrMDgwMC4uVStGRkZGICovXG4gICAgICAgICAgYyA9IGJ5dGVzMyhiMSwgYnVmW2kxXSwgYnVmW2kyXSk7XG4gICAgICAgICAgaW5jID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpMyA9IGkgKyAzO1xuICAgICAgICBpZiAoaTMgPCBsZW4gJiYgYjEgPj0gMHhmMCAmJiBiMSA8PSAweGY0KSB7XG4gICAgICAgICAgLyogVSsxMDAwMC4uVSsxMEZGRkYgKi9cbiAgICAgICAgICBjID0gYnl0ZXM0KGIxLCBidWZbaTFdLCBidWZbaTJdLCBidWZbaTNdKTtcbiAgICAgICAgICBpbmMgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHdlIGZhbGwgdGhyb3VnaCB0byBoZXJlLCBpdCBpcyBhbiBpbGwtZm9ybWVkIHNlcXVlbmNlICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGMgPiAweDEwZmZmZikge1xuICAgICAgICBjb25zdCBhdCA9IGBieXRlWyR7aX1dYDtcbiAgICAgICAgaWYgKGMgPT09IElMTF9GT1JNRUQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IGlsbC1mb3JtZWQgVVRGOCBieXRlIHNlcXVlbmNlIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBUUkFJTElORykge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogaWxsZWdhbCB0cmFpbGluZyBieXRlIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBSQU5HRSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogY29kZSBwb2ludCBvdXQgb2YgcmFuZ2UgZm91bmQgYXQ6ICR7YXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IE5PTl9TSE9SVEVTVCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogbm9uLXNob3J0ZXN0IGZvcm0gZm91bmQgYXQ6ICR7YXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjguZGVjb2RlOiB1bnJlY29nbml6ZWQgZXJyb3IgZm91bmQgYXQ6ICR7YXR9YCk7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKGMpO1xuICAgICAgaSArPSBpbmM7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVVEYxNkJFIGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjE2YmUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgbGV0IGNoYXI7XG4gICAgbGV0IGg7XG4gICAgbGV0IGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgaWYgKChjaGFyID49IDAgJiYgY2hhciA8PSAweGQ3ZmYpIHx8IChjaGFyID49IDB4ZTAwMCAmJiBjaGFyIDw9IDB4ZmZmZikpIHtcbiAgICAgICAgYnl0ZXMucHVzaCgoY2hhciA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIgJiBtYXNrWzhdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAweDEwMDAwICYmIGNoYXIgPD0gMHgxMGZmZmYpIHtcbiAgICAgICAgbCA9IGNoYXIgLSAweDEwMDAwO1xuICAgICAgICBoID0gMHhkODAwICsgKGwgPj4gMTApO1xuICAgICAgICBsID0gMHhkYzAwICsgKGwgJiBtYXNrWzEwXSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGggPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaChoICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGwgPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaChsICYgbWFza1s4XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZiZS5lbmNvZGU6IFVURjE2QkUgdmFsdWUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aX1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGFzc3VtZXMgY2FsbGVyIGhhcyBpbnN1cmVkIHRoYXQgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSAyID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2YmUuZGVjb2RlOiBkYXRhIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgMjogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaSA9IGJvbSA/IDIgOiAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgYztcbiAgICBsZXQgaW5jO1xuICAgIGxldCBpMTtcbiAgICBsZXQgaTM7XG4gICAgbGV0IGhpZ2g7XG4gICAgbGV0IGxvdztcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICBpMSA9IGkgKyAxO1xuICAgICAgICBpZiAoaTEgPCBsZW4pIHtcbiAgICAgICAgICBoaWdoID0gKGJ1ZltpXSA8PCA4KSArIGJ1ZltpMV07XG4gICAgICAgICAgaWYgKGhpZ2ggPCAweGQ4MDAgfHwgaGlnaCA+IDB4ZGZmZikge1xuICAgICAgICAgICAgYyA9IGhpZ2g7XG4gICAgICAgICAgICBpbmMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkzID0gaSArIDM7XG4gICAgICAgICAgaWYgKGkzIDwgbGVuKSB7XG4gICAgICAgICAgICBsb3cgPSAoYnVmW2kgKyAyXSA8PCA4KSArIGJ1ZltpM107XG4gICAgICAgICAgICBpZiAoaGlnaCA8PSAweGRiZmYgJiYgbG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChoaWdoIC0gMHhkODAwKSA8PCAxMCkgKyAobG93IC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgaW5jID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHdlIGZhbGwgdGhyb3VnaCB0byBoZXJlLCBpdCBpcyBhbiBpbGwtZm9ybWVkIHNlcXVlbmNlICovXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmJlLmRlY29kZTogaWxsLWZvcm1lZCBVVEYxNkJFIGJ5dGUgc2VxdWVuY2UgZm91bmQ6IGJ5dGVbJHtpfV1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzW2orK10gPSBjO1xuICAgICAgaSArPSBpbmM7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVVEYxNkxFIGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjE2bGUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgbGV0IGNoYXI7XG4gICAgbGV0IGg7XG4gICAgbGV0IGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgaWYgKChjaGFyID49IDAgJiYgY2hhciA8PSAweGQ3ZmYpIHx8IChjaGFyID49IDB4ZTAwMCAmJiBjaGFyIDw9IDB4ZmZmZikpIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGNoYXIgPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAweDEwMDAwICYmIGNoYXIgPD0gMHgxMGZmZmYpIHtcbiAgICAgICAgbCA9IGNoYXIgLSAweDEwMDAwO1xuICAgICAgICBoID0gMHhkODAwICsgKGwgPj4gMTApO1xuICAgICAgICBsID0gMHhkYzAwICsgKGwgJiBtYXNrWzEwXSk7XG4gICAgICAgIGJ5dGVzLnB1c2goaCAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKChoID4+IDgpICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2gobCAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKChsID4+IDgpICYgbWFza1s4XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZsZS5lbmNvZGU6IFVURjE2TEUgdmFsdWUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aX1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGFzc3VtZXMgY2FsbGVyIGhhcyBpbnN1cmVkIHRoYXQgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSAyID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2bGUuZGVjb2RlOiBkYXRhIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgMjogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaSA9IGJvbSA/IDIgOiAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgYztcbiAgICBsZXQgaW5jO1xuICAgIGxldCBpMTtcbiAgICBsZXQgaTM7XG4gICAgbGV0IGhpZ2g7XG4gICAgbGV0IGxvdztcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICBpMSA9IGkgKyAxO1xuICAgICAgICBpZiAoaTEgPCBsZW4pIHtcbiAgICAgICAgICBoaWdoID0gKGJ1ZltpMV0gPDwgOCkgKyBidWZbaV07XG4gICAgICAgICAgaWYgKGhpZ2ggPCAweGQ4MDAgfHwgaGlnaCA+IDB4ZGZmZikge1xuICAgICAgICAgICAgYyA9IGhpZ2g7XG4gICAgICAgICAgICBpbmMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkzID0gaSArIDM7XG4gICAgICAgICAgaWYgKGkzIDwgbGVuKSB7XG4gICAgICAgICAgICBsb3cgPSAoYnVmW2kzXSA8PCA4KSArIGJ1ZltpICsgMl07XG4gICAgICAgICAgICBpZiAoaGlnaCA8PSAweGRiZmYgJiYgbG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChoaWdoIC0gMHhkODAwKSA8PCAxMCkgKyAobG93IC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgaW5jID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHdlIGZhbGwgdGhyb3VnaCB0byBoZXJlLCBpdCBpcyBhbiBpbGwtZm9ybWVkIHNlcXVlbmNlICovXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmxlLmRlY29kZTogaWxsLWZvcm1lZCBVVEYxNkxFIGJ5dGUgc2VxdWVuY2UgZm91bmQ6IGJ5dGVbJHtpfV1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzW2orK10gPSBjO1xuICAgICAgaSArPSBpbmM7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVVEYzMkJFIGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjMyYmUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiA0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKChjaGFyID49IDB4ZDgwMCAmJiBjaGFyIDw9IDB4ZGZmZikgfHwgY2hhciA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmJlLmVuY29kZTogVVRGMzJCRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gNH1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDI0KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1ZiwgYm9tKSB7XG4gICAgLyogY2FsbGVyIHRvIGluc3VyZSBidWYgaXMgYSBCdWZmZXIgb2YgYnl0ZXMgKi9cbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJiZS5kZWNvZGU6IFVURjMyQkUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDQ6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGxldCBpID0gYm9tID8gNCA6IDA7XG4gICAgZm9yICg7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSAoYnVmW2ldIDw8IDI0KSArIChidWZbaSArIDFdIDw8IDE2KSArIChidWZbaSArIDJdIDw8IDgpICsgYnVmW2kgKyAzXTtcbiAgICAgIGlmICgoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHx8IGNoYXIgPiAweDEwZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJiZS5kZWNvZGU6IFVURjMyQkUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDR9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVURjMyTEUgYWxnb3JpdGhtcy5cbmV4cG9ydHMudXRmMzJsZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDQpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoKGNoYXIgPj0gMHhkODAwICYmIGNoYXIgPD0gMHhkZmZmKSB8fCBjaGFyID4gMHgxMGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMybGUuZW5jb2RlOiBVVEYzMkxFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyA0fV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBjYWxsZXIgdG8gaW5zdXJlIGJ1ZiBpcyBhIEJ1ZmZlciBvZiBieXRlcyAqL1xuICAgIGlmIChidWYubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmJlLmRlY29kZTogVVRGMzJMRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgNDogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgbGV0IGkgPSBib20gPyA0IDogMDtcbiAgICBmb3IgKDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgY29uc3QgY2hhciA9IChidWZbaSArIDNdIDw8IDI0KSArIChidWZbaSArIDJdIDw8IDE2KSArIChidWZbaSArIDFdIDw8IDgpICsgYnVmW2ldO1xuICAgICAgaWYgKChjaGFyID49IDB4ZDgwMCAmJiBjaGFyIDw9IDB4ZGZmZikgfHwgY2hhciA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmxlLmVuY29kZTogVVRGMzJMRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gNH1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDcgYWxnb3JpdGhtcy4gQVNDSUkgb3IgNy1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQ3ID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY2hhcnNbaV0gPiAweDdmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50Ny5lbmNvZGU6IFVJTlQ3IGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2l9XTogJHtjaGFyc1tpXX1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpXSA9IGNoYXJzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGJ1ZltpXSA+IDB4N2YpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQ3LmRlY29kZTogVUlOVDcgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBieXRlWyR7aX1dOiAke2J1ZltpXX1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzW2ldID0gYnVmW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDggYWxnb3JpdGhtcy4gQklOQVJZLCBMYXRpbiAxIG9yIDgtYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50OCA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGNoYXJzW2ldID4gMHhmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDguZW5jb2RlOiBVSU5UOCBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpfV06ICR7Y2hhcnNbaV19YCk7XG4gICAgICB9XG4gICAgICBidWZbaV0gPSBjaGFyc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNoYXJzW2ldID0gYnVmW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDE2QkUgYWxnb3JpdGhtcy4gQmlnLWVuZGlhbiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQxNmJlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogMik7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGlmIChjaGFyID4gMHhmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MTZiZS5lbmNvZGU6IFVJTlQxNkJFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyAyfV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggJSAyID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQxNmJlLmRlY29kZTogVUlOVDE2QkUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDI6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjaGFycy5wdXNoKChidWZbaV0gPDwgOCkgKyBidWZbaSArIDFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQxNkxFIGFsZ29yaXRobXMuIExpdHRsZS1lbmRpYW4gMTYtYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50MTZsZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDIpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoY2hhciA+IDB4ZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDE2bGUuZW5jb2RlOiBVSU5UMTZMRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gMn1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGlmIChidWYubGVuZ3RoICUgMiA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MTZsZS5kZWNvZGU6IFVJTlQxNkxFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiAyOiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY2hhcnMucHVzaCgoYnVmW2kgKyAxXSA8PCA4KSArIGJ1ZltpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVSU5UMzJCRSBhbGdvcml0aG1zLiBCaWctZW5kaWFuIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDMyYmUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiA0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAyNCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDMyYmUuZGVjb2RlOiBVSU5UMzJCRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgNDogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNoYXJzLnB1c2goKGJ1ZltpXSA8PCAyNCkgKyAoYnVmW2kgKyAxXSA8PCAxNikgKyAoYnVmW2kgKyAyXSA8PCA4KSArIGJ1ZltpICsgM10pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDMyTEUgYWxnb3JpdGhtcy4gTGl0dGxlLWVuZGlhbiAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQzMmxlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogNCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgLyogY2FsbGVyIHRvIGluc3VyZSBidWYgaXMgYSBCdWZmZXIgb2YgYnl0ZXMgKi9cbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDMybGUuZGVjb2RlOiBVSU5UMzJMRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgNDogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNoYXJzLnB1c2goKGJ1ZltpICsgM10gPDwgMjQpICsgKGJ1ZltpICsgMl0gPDwgMTYpICsgKGJ1ZltpICsgMV0gPDwgOCkgKyBidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgU1RSSU5HIGFsZ29yaXRobXMuIENvbnZlcnRzIEphdmFTY3JpcHQgc3RyaW5ncyB0byBBcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMgYW5kIHZpY2UgdmVyc2EuXG4vLyBVc2VzIHRoZSBub2RlLmpzIEJ1ZmZlcidzIG5hdGl2ZSBcInV0ZjE2bGVcIiBjYXBhYmlsaXRlcy5cbmV4cG9ydHMuc3RyaW5nID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICByZXR1cm4gZXhwb3J0cy51dGYxNmxlLmVuY29kZShjaGFycykudG9TdHJpbmcoJ3V0ZjE2bGUnKTtcbiAgfSxcbiAgZGVjb2RlKHN0cikge1xuICAgIHJldHVybiBleHBvcnRzLnV0ZjE2bGUuZGVjb2RlKEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjE2bGUnKSwgMCk7XG4gIH0sXG59O1xuXG4vLyBUaGUgRVNDQVBFRCBhbGdvcml0aG1zLlxuLy8gTm90ZSB0aGF0IEVTQ0FQRUQgZm9ybWF0IGNvbnRhaW5zIG9ubHkgQVNDSUkgY2hhcmFjdGVycy5cbi8vIFRoZSBjaGFyYWN0ZXJzIGFyZSBhbHdheXMgaW4gdGhlIGZvcm0gb2YgYSBCdWZmZXIgb2YgYnl0ZXMuXG5leHBvcnRzLmVzY2FwZWQgPSB7XG4gIC8vIEVuY29kZXMgYW4gQXJyYXkgb2YgMzItYml0IGludGVnZXJzIGludG8gRVNDQVBFRCBmb3JtYXQuXG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgaWYgKGNoYXIgPT09IDk2KSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IDEwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMzIgJiYgY2hhciA8PSAxMjYpIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgaWYgKGNoYXIgPj0gMCAmJiBjaGFyIDw9IDMxKSB7XG4gICAgICAgICAgc3RyICs9IGBcXGB4JHthc2NpaVtjaGFyXX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMTI3ICYmIGNoYXIgPD0gMjU1KSB7XG4gICAgICAgICAgc3RyICs9IGBcXGB4JHthc2NpaVtjaGFyXX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAgJiYgY2hhciA8PSAweGZmZmYpIHtcbiAgICAgICAgICBzdHIgKz0gYFxcYHUke2FzY2lpWyhjaGFyID4+IDgpICYgbWFza1s4XV19JHthc2NpaVtjaGFyICYgbWFza1s4XV19YDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID49IDB4MTAwMDAgJiYgY2hhciA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgc3RyICs9ICdgdXsnO1xuICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICAgICAgICBpZiAoZGlnaXQgPiAwKSB7XG4gICAgICAgICAgICBzdHIgKz0gYXNjaWlbZGlnaXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gYCR7YXNjaWlbKGNoYXIgPj4gMTYpICYgbWFza1s4XV0gKyBhc2NpaVsoY2hhciA+PiA4KSAmIG1hc2tbOF1dICsgYXNjaWlbY2hhciAmIG1hc2tbOF1dfX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlLmVuY29kZShjaGFyKTogY2hhciA+IDB4ZmZmZmZmZmYgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzdHIpO1xuICAgICAgICBidWYuZm9yRWFjaCgoYikgPT4ge1xuICAgICAgICAgIGJ5dGVzLnB1c2goYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICAvLyBEZWNvZGVzIEVTQ0FQRUQgZm9ybWF0IGZyb20gYSBCdWZmZXIgb2YgYnl0ZXMgdG8gYW4gQXJyYXkgb2YgMzItYml0IGludGVnZXJzLlxuICBkZWNvZGUoYnVmKSB7XG4gICAgZnVuY3Rpb24gaXNIZXgoaGV4KSB7XG4gICAgICBpZiAoKGhleCA+PSA0OCAmJiBoZXggPD0gNTcpIHx8IChoZXggPj0gNjUgJiYgaGV4IDw9IDcwKSB8fCAoaGV4ID49IDk3ICYmIGhleCA8PSAxMDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXR4KGksIGxlbiwgYnVmQXJnKSB7XG4gICAgICBjb25zdCByZXQgPSB7IGNoYXI6IG51bGwsIG5leHRpOiBpICsgMiwgZXJyb3I6IHRydWUgfTtcbiAgICAgIGlmIChpICsgMSA8IGxlbikge1xuICAgICAgICBpZiAoaXNIZXgoYnVmQXJnW2ldKSAmJiBpc0hleChidWZBcmdbaSArIDFdKSkge1xuICAgICAgICAgIGNvbnN0IHN0ciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGJ1ZkFyZ1tpXSwgYnVmQXJnW2kgKyAxXSk7XG4gICAgICAgICAgcmV0LmNoYXIgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXQuY2hhcikpIHtcbiAgICAgICAgICAgIHJldC5lcnJvciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0dShpLCBsZW4sIGJ1ZkFyZykge1xuICAgICAgY29uc3QgcmV0ID0geyBjaGFyOiBudWxsLCBuZXh0aTogaSArIDQsIGVycm9yOiB0cnVlIH07XG4gICAgICBpZiAoaSArIDMgPCBsZW4pIHtcbiAgICAgICAgaWYgKGlzSGV4KGJ1ZkFyZ1tpXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAxXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAyXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAzXSkpIHtcbiAgICAgICAgICBjb25zdCBzdHIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChidWZBcmdbaV0sIGJ1ZkFyZ1tpICsgMV0sIGJ1ZkFyZ1tpICsgMl0sIGJ1ZkFyZ1tpICsgM10pO1xuICAgICAgICAgIHJldC5jaGFyID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocmV0LmNoYXIpKSB7XG4gICAgICAgICAgICByZXQuZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFUoaSwgbGVuLCBidWZBcmcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgY2hhcjogbnVsbCwgbmV4dGk6IGkgKyA0LCBlcnJvcjogdHJ1ZSB9O1xuICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgaXNIZXgoYnVmQXJnW2ldKSkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYnVmQXJnW2ldKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICAgIHJldC5jaGFyID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICBpZiAoYnVmQXJnW2ldID09PSAxMjUgJiYgIU51bWJlci5pc05hTihyZXQuY2hhcikpIHtcbiAgICAgICAgcmV0LmVycm9yID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXQubmV4dGkgPSBpICsgMTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaTE7XG4gICAgbGV0IHJldDtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGJ1ZltpXSAhPT0gOTYpIHtcbiAgICAgICAgICAvKiB1bmVzY2FwZWQgY2hhcmFjdGVyICovXG4gICAgICAgICAgY2hhcnMucHVzaChidWZbaV0pO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkxID0gaSArIDE7XG4gICAgICAgIGlmIChpMSA+PSBsZW4pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmW2kxXSA9PT0gOTYpIHtcbiAgICAgICAgICAvKiBlc2NhcGVkIGdyYXZlIGFjY2VudCAqL1xuICAgICAgICAgIGNoYXJzLnB1c2goOTYpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbaTFdID09PSAxMjApIHtcbiAgICAgICAgICByZXQgPSBnZXR4KGkxICsgMSwgbGVuLCBidWYpO1xuICAgICAgICAgIGlmIChyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBlc2NhcGVkIGhleCAqL1xuICAgICAgICAgIGNoYXJzLnB1c2gocmV0LmNoYXIpO1xuICAgICAgICAgIGkgPSByZXQubmV4dGk7XG4gICAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmW2kxXSA9PT0gMTE3KSB7XG4gICAgICAgICAgaWYgKGJ1ZltpMSArIDFdID09PSAxMjMpIHtcbiAgICAgICAgICAgIHJldCA9IGdldFUoaTEgKyAyLCBsZW4sIGJ1Zik7XG4gICAgICAgICAgICBpZiAocmV0LmVycm9yKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNjYXBlZCB1dGYtMzIgKi9cbiAgICAgICAgICAgIGNoYXJzLnB1c2gocmV0LmNoYXIpO1xuICAgICAgICAgICAgaSA9IHJldC5uZXh0aTtcbiAgICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0ID0gZ2V0dShpMSArIDEsIGxlbiwgYnVmKTtcbiAgICAgICAgICBpZiAocmV0LmVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogZXNjYXBlZCB1dGYtMTYgKi9cbiAgICAgICAgICBjaGFycy5wdXNoKHJldC5jaGFyKTtcbiAgICAgICAgICBpID0gcmV0Lm5leHRpO1xuICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlc2NhcGVkLmRlY29kZTogaWxsLWZvcm1lZCBlc2NhcGUgc2VxdWVuY2UgYXQgYnVmWyR7aX1dYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBsaW5lIGVuZCBjb252ZXJzaW9uIGFsZ29yaWd0aG1zLlxuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5leHBvcnRzLmxpbmVFbmRzID0ge1xuICBjcmxmKGNoYXJzKSB7XG4gICAgY29uc3QgbGZjaGFycyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYXJzLmxlbmd0aCkge1xuICAgICAgc3dpdGNoIChjaGFyc1tpXSkge1xuICAgICAgICBjYXNlIENSOlxuICAgICAgICAgIGlmIChpICsgMSA8IGNoYXJzLmxlbmd0aCAmJiBjaGFyc1tpICsgMV0gPT09IExGKSB7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGZjaGFycy5wdXNoKENSKTtcbiAgICAgICAgICBsZmNoYXJzLnB1c2goTEYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExGOlxuICAgICAgICAgIGxmY2hhcnMucHVzaChDUik7XG4gICAgICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZmNoYXJzLmxlbmd0aCA+IDAgJiYgbGZjaGFyc1tsZmNoYXJzLmxlbmd0aCAtIDFdICE9PSBMRikge1xuICAgICAgbGZjaGFycy5wdXNoKENSKTtcbiAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgfVxuICAgIHJldHVybiBsZmNoYXJzO1xuICB9LFxuICBsZihjaGFycykge1xuICAgIGNvbnN0IGxmY2hhcnMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFycy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoY2hhcnNbaV0pIHtcbiAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICBpZiAoaSArIDEgPCBjaGFycy5sZW5ndGggJiYgY2hhcnNbaSArIDFdID09PSBMRikge1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZmNoYXJzLmxlbmd0aCA+IDAgJiYgbGZjaGFyc1tsZmNoYXJzLmxlbmd0aCAtIDFdICE9PSBMRikge1xuICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICB9XG4gICAgcmV0dXJuIGxmY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgYmFzZSA2NCBhbGdvcml0aG1zLlxuZXhwb3J0cy5iYXNlNjQgPSB7XG4gIGVuY29kZShidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IG47XG4gICAgbGV0IHRhaWwgPSBidWYubGVuZ3RoICUgMztcbiAgICB0YWlsID0gdGFpbCA+IDAgPyAzIC0gdGFpbCA6IDA7XG4gICAgbGV0IHVuaXRzID0gKGJ1Zi5sZW5ndGggKyB0YWlsKSAvIDM7XG4gICAgY29uc3QgYmFzZTY0ID0gQnVmZmVyLmFsbG9jKHVuaXRzICogNCk7XG4gICAgaWYgKHRhaWwgPiAwKSB7XG4gICAgICB1bml0cyAtPSAxO1xuICAgIH1cbiAgICBpID0gMDtcbiAgICBqID0gMDtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVuaXRzOyB1ICs9IDEpIHtcbiAgICAgIG4gPSBidWZbaSsrXSA8PCAxNjtcbiAgICAgIG4gKz0gYnVmW2krK10gPDwgODtcbiAgICAgIG4gKz0gYnVmW2krK107XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDE4KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxMikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gNikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbbiAmIG1hc2tbNl1dO1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDEpIHtcbiAgICAgIG4gPSBidWZbaSsrXSA8PCAxNjtcbiAgICAgIG4gKz0gYnVmW2ldIDw8IDg7XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDE4KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxMikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gNikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGlmICh0YWlsID09PSAyKSB7XG4gICAgICBuID0gYnVmW2ldIDw8IDE2O1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxOCkgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gMTIpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIGJhc2U2NFtqXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG4gIGRlY29kZShjb2Rlcykge1xuICAgIC8qIHJlbW92ZSB3aGl0ZSBzcGFjZSBhbmQgY3RybCBjaGFyYWN0ZXJzLCB2YWxpZGF0ZSAmIHRyYW5zbGF0ZSBjaGFyYWN0ZXJzICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoYnVmKSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHRhaWwgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGJ1ZltpXTtcbiAgICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT09IDMyIHx8IGNoYXIgPT09IDkgfHwgY2hhciA9PT0gMTAgfHwgY2hhciA9PT0gMTMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA+PSA2NSAmJiBjaGFyIDw9IDkwKSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIgLSA2NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPj0gOTcgJiYgY2hhciA8PSAxMjIpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhciAtIDcxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA+PSA0OCAmJiBjaGFyIDw9IDU3KSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIgKyA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA9PT0gNDMpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goNjIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID09PSA0Nykge1xuICAgICAgICAgICAgY2hhcnMucHVzaCg2Myk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPT09IDYxKSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKDY0KTtcbiAgICAgICAgICAgIHRhaWwgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBpbnZhbGlkIGNoYXJhY3RlciAqL1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQuZGVjb2RlOiBpbnZhbGlkIGNoYXJhY3RlciBidWZbJHtpfV06ICR7Y2hhcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogdmFsaWRhdGUgbGVuZ3RoICovXG4gICAgICBpZiAoY2hhcnMubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGJhc2U2NC5kZWNvZGU6IHN0cmluZyBsZW5ndGggbm90IGludGVncmFsIG11bHRpcGxlIG9mIDQ6ICR7Y2hhcnMubGVuZ3RofWApO1xuICAgICAgfVxuICAgICAgLyogdmFsaWRhdGUgdGFpbCAqL1xuICAgICAgc3dpdGNoICh0YWlsKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChjaGFyc1tjaGFycy5sZW5ndGggLSAxXSAhPT0gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdiYXNlNjQuZGVjb2RlOiBvbmUgdGFpbCBjaGFyYWN0ZXIgZm91bmQ6IG5vdCBsYXN0IGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmIChjaGFyc1tjaGFycy5sZW5ndGggLSAxXSAhPT0gNjQgfHwgY2hhcnNbY2hhcnMubGVuZ3RoIC0gMl0gIT09IDY0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYmFzZTY0LmRlY29kZTogdHdvIHRhaWwgY2hhcmFjdGVycyBmb3VuZDogbm90IGxhc3QgY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LmRlY29kZTogbW9yZSB0aGFuIHR3byB0YWlsIGNoYXJhY3RlcnMgZm91bmQ6ICR7dGFpbH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHRhaWwsIGJ1ZjogQnVmZmVyLmZyb20oY2hhcnMpIH07XG4gICAgfVxuXG4gICAgaWYgKGNvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gdmFsaWRhdGUoY29kZXMpO1xuICAgIGNvbnN0IHsgdGFpbCB9ID0gdmFsO1xuICAgIGNvbnN0IGJhc2U2NCA9IHZhbC5idWY7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IG47XG4gICAgbGV0IHVuaXRzID0gYmFzZTY0Lmxlbmd0aCAvIDQ7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKHVuaXRzICogMyAtIHRhaWwpO1xuICAgIGlmICh0YWlsID4gMCkge1xuICAgICAgdW5pdHMgLT0gMTtcbiAgICB9XG4gICAgaiA9IDA7XG4gICAgaSA9IDA7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1bml0czsgdSArPSAxKSB7XG4gICAgICBuID0gYmFzZTY0W2krK10gPDwgMTg7XG4gICAgICBuICs9IGJhc2U2NFtpKytdIDw8IDEyO1xuICAgICAgbiArPSBiYXNlNjRbaSsrXSA8PCA2O1xuICAgICAgbiArPSBiYXNlNjRbaSsrXTtcbiAgICAgIGJ1ZltqKytdID0gKG4gPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltqKytdID0gKG4gPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2orK10gPSBuICYgbWFza1s4XTtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDEpIHtcbiAgICAgIG4gPSBiYXNlNjRbaSsrXSA8PCAxODtcbiAgICAgIG4gKz0gYmFzZTY0W2krK10gPDwgMTI7XG4gICAgICBuICs9IGJhc2U2NFtpXSA8PCA2O1xuICAgICAgYnVmW2orK10gPSAobiA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2pdID0gKG4gPj4gOCkgJiBtYXNrWzhdO1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMikge1xuICAgICAgbiA9IGJhc2U2NFtpKytdIDw8IDE4O1xuICAgICAgbiArPSBiYXNlNjRbaSsrXSA8PCAxMjtcbiAgICAgIGJ1ZltqXSA9IChuID4+IDE2KSAmIG1hc2tbOF07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIC8vIENvbnZlcnRzIGEgYmFzZSA2NCBCdWZmZXIgb2YgYnl0ZXMgdG8gYSBKYXZhU2NyaXB0IHN0cmluZyB3aXRoIGxpbmUgYnJlYWtzLlxuICB0b1N0cmluZyhidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LnRvU3RyaW5nOiBpbnB1dCBidWZmZXIgbGVuZ3RoIG5vdCBtdWx0aXBsZSBvZiA0OiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgbGluZUxlbiA9IDA7XG4gICAgZnVuY3Rpb24gYnVpbGRMaW5lKGMxLCBjMiwgYzMsIGM0KSB7XG4gICAgICBzd2l0Y2ggKGxpbmVMZW4pIHtcbiAgICAgICAgY2FzZSA3NjpcbiAgICAgICAgICBzdHIgKz0gYFxcclxcbiR7YzF9JHtjMn0ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3NTpcbiAgICAgICAgICBzdHIgKz0gYCR7YzF9XFxyXFxuJHtjMn0ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3NDpcbiAgICAgICAgICBzdHIgKz0gYCR7YzEgKyBjMn1cXHJcXG4ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3MzpcbiAgICAgICAgICBzdHIgKz0gYCR7YzEgKyBjMiArIGMzfVxcclxcbiR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdHIgKz0gYzEgKyBjMiArIGMzICsgYzQ7XG4gICAgICAgICAgbGluZUxlbiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShjKSB7XG4gICAgICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDQzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDQ3KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDYxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBpICsgNDsgaiArPSAxKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGUoYnVmW2pdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQudG9TdHJpbmc6IGJ1Zlske2p9XTogJHtidWZbal19IDogbm90IHZhbGlkIGJhc2U2NCBjaGFyYWN0ZXIgY29kZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWlsZExpbmUoXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDFdKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDJdKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDNdKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-conv-api/transformers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/ast.js":
/*!************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/ast.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable guard-for-in */\n/* eslint-disable no-restricted-syntax */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is used by the parser to build an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).\n// The AST can be thought of as a subset of the full parse tree.\n// Each node of the AST holds the phrase that was matched at the corresponding, named parse tree node.\n// It is built as the parser successfully matches phrases to the rule names\n// (`RNM` operators) and `UDT`s as it parses an input string.\n// The user controls which `RNM` or `UDT` names to keep on the AST.\n// The user can also associate callback functions with some or all of the retained\n// AST nodes to be used to translate the node phrases. That is, associate semantic\n// actions to the matched phrases.\n// Translating the AST rather that attempting to apply semantic actions during\n// the parsing process, has the advantage that there is no backtracking and that the phrases\n// are known while traversing down tree as will as up.\n//\n// Let `ast` be an `ast.js` object. To identify a node to be kept on the AST:\n// ```\n// ast.callbacks[\"rulename\"] = true; (all nodes default to false)\n// ```\n// To associate a callback function with a node:\n// ```\n// ast.callbacks[\"rulename\"] = fn\n// ```\n// `rulename` is any `RNM` or `UDT` name defined by the associated grammar\n// and `fn` is a user-written callback function.\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js2-examples/tree/master/ast) for examples of how to create an AST,\n// define the nodes and callback functions and attach it to a parser.)\nmodule.exports = function exportsAst() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n\n  const thisFileName = 'ast.js: ';\n  const that = this;\n  let rules = null;\n  let udts = null;\n  let chars = null;\n  let nodeCount = 0;\n  const nodesDefined = [];\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  this.callbacks = [];\n  this.astObject = 'astObject';\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  this.init = function init(rulesIn, udtsIn, charsIn) {\n    stack.length = 0;\n    records.length = 0;\n    nodesDefined.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodesDefined[i] = false;\n      nodeCallbacks[i] = null;\n    }\n    for (const index in that.callbacks) {\n      const lower = index.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n      }\n      if (typeof that.callbacks[index] === 'function') {\n        nodesDefined[i] = true;\n        nodeCallbacks[i] = that.callbacks[index];\n      }\n      if (that.callbacks[index] === true) {\n        nodesDefined[i] = true;\n      }\n    }\n  };\n  /* AST node definitions - called by the parser's `RNM` operator */\n  this.ruleDefined = function ruleDefined(index) {\n    return nodesDefined[index] !== false;\n  };\n  /* AST node definitions - called by the parser's `UDT` operator */\n  this.udtDefined = function udtDefined(index) {\n    return nodesDefined[rules.length + index] !== false;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the downward traversal of the node */\n  this.down = function down(callbackIndex, name) {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: null,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: null,\n      phraseLength: null,\n      stack: stack.length,\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length,\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  this.translate = function translate(data) {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (record.state === id.SEM_PRE) {\n        if (callback !== null) {\n          ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n          if (ret === id.SEM_SKIP) {\n            i = record.thatIndex;\n          }\n        }\n      } else if (callback !== null) {\n        callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  this.setLength = function setLength(length) {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  this.getLength = function getLength() {\n    return records.length;\n  };\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    for (let i = 0; i < n; i += 1) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST.\n  // ```\n  // mode - the display mode of the captured phrases\n  //      - default mode is \"ascii\"\n  //      - can be: \"ascii\"\n  //                \"decimal\"\n  //                \"hexadecimal\"\n  //                \"unicode\"\n  // ```\n  this.toXml = function toSml(modeArg) {\n    let display = utils.charsToDec;\n    let caption = 'decimal integer character codes';\n    if (typeof modeArg === 'string' && modeArg.length >= 3) {\n      const mode = modeArg.slice(0, 3).toLowerCase();\n      if (mode === 'asc') {\n        display = utils.charsToAscii;\n        caption = 'ASCII for printing characters, hex for non-printing';\n      } else if (mode === 'hex') {\n        display = utils.charsToHex;\n        caption = 'hexadecimal integer character codes';\n      } else if (mode === 'uni') {\n        display = utils.charsToUnicode;\n        caption = 'Unicode UTF-32 integer character codes';\n      }\n    }\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n    xml += `<!-- input string, ${caption} -->\\n`;\n    xml += indent(depth + 2);\n    xml += display(chars);\n    xml += '\\n';\n    records.forEach((rec) => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n        xml += indent(depth + 2);\n        xml += display(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n        depth -= 1;\n      }\n    });\n\n    xml += '</root>\\n';\n    return xml;\n  };\n  /* generate a JavaScript object version of the AST */\n  /* for the phrase-matching engine apg-exp */\n  this.phrases = function phrases() {\n    const obj = {};\n    let i;\n    let record;\n    for (i = 0; i < records.length; i += 1) {\n      record = records[i];\n      if (record.state === id.SEM_PRE) {\n        if (!Array.isArray(obj[record.name])) {\n          obj[record.name] = [];\n        }\n        obj[record.name].push({\n          index: record.phraseIndex,\n          length: record.phraseLength,\n        });\n      }\n    }\n    return obj;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNkVBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsY0FBYyxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQixnQkFBZ0IsYUFBYTtBQUMzRSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTLFdBQVcsZ0JBQWdCLFlBQVksaUJBQWlCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9hc3QuanM/YjU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBpcyB1c2VkIGJ5IHRoZSBwYXJzZXIgdG8gYnVpbGQgYW4gW0Fic3RyYWN0IFN5bnRheCBUcmVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BYnN0cmFjdF9zeW50YXhfdHJlZSkgKEFTVCkuXG4vLyBUaGUgQVNUIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGEgc3Vic2V0IG9mIHRoZSBmdWxsIHBhcnNlIHRyZWUuXG4vLyBFYWNoIG5vZGUgb2YgdGhlIEFTVCBob2xkcyB0aGUgcGhyYXNlIHRoYXQgd2FzIG1hdGNoZWQgYXQgdGhlIGNvcnJlc3BvbmRpbmcsIG5hbWVkIHBhcnNlIHRyZWUgbm9kZS5cbi8vIEl0IGlzIGJ1aWx0IGFzIHRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IG1hdGNoZXMgcGhyYXNlcyB0byB0aGUgcnVsZSBuYW1lc1xuLy8gKGBSTk1gIG9wZXJhdG9ycykgYW5kIGBVRFRgcyBhcyBpdCBwYXJzZXMgYW4gaW5wdXQgc3RyaW5nLlxuLy8gVGhlIHVzZXIgY29udHJvbHMgd2hpY2ggYFJOTWAgb3IgYFVEVGAgbmFtZXMgdG8ga2VlcCBvbiB0aGUgQVNULlxuLy8gVGhlIHVzZXIgY2FuIGFsc28gYXNzb2NpYXRlIGNhbGxiYWNrIGZ1bmN0aW9ucyB3aXRoIHNvbWUgb3IgYWxsIG9mIHRoZSByZXRhaW5lZFxuLy8gQVNUIG5vZGVzIHRvIGJlIHVzZWQgdG8gdHJhbnNsYXRlIHRoZSBub2RlIHBocmFzZXMuIFRoYXQgaXMsIGFzc29jaWF0ZSBzZW1hbnRpY1xuLy8gYWN0aW9ucyB0byB0aGUgbWF0Y2hlZCBwaHJhc2VzLlxuLy8gVHJhbnNsYXRpbmcgdGhlIEFTVCByYXRoZXIgdGhhdCBhdHRlbXB0aW5nIHRvIGFwcGx5IHNlbWFudGljIGFjdGlvbnMgZHVyaW5nXG4vLyB0aGUgcGFyc2luZyBwcm9jZXNzLCBoYXMgdGhlIGFkdmFudGFnZSB0aGF0IHRoZXJlIGlzIG5vIGJhY2t0cmFja2luZyBhbmQgdGhhdCB0aGUgcGhyYXNlc1xuLy8gYXJlIGtub3duIHdoaWxlIHRyYXZlcnNpbmcgZG93biB0cmVlIGFzIHdpbGwgYXMgdXAuXG4vL1xuLy8gTGV0IGBhc3RgIGJlIGFuIGBhc3QuanNgIG9iamVjdC4gVG8gaWRlbnRpZnkgYSBub2RlIHRvIGJlIGtlcHQgb24gdGhlIEFTVDpcbi8vIGBgYFxuLy8gYXN0LmNhbGxiYWNrc1tcInJ1bGVuYW1lXCJdID0gdHJ1ZTsgKGFsbCBub2RlcyBkZWZhdWx0IHRvIGZhbHNlKVxuLy8gYGBgXG4vLyBUbyBhc3NvY2lhdGUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbm9kZTpcbi8vIGBgYFxuLy8gYXN0LmNhbGxiYWNrc1tcInJ1bGVuYW1lXCJdID0gZm5cbi8vIGBgYFxuLy8gYHJ1bGVuYW1lYCBpcyBhbnkgYFJOTWAgb3IgYFVEVGAgbmFtZSBkZWZpbmVkIGJ5IHRoZSBhc3NvY2lhdGVkIGdyYW1tYXJcbi8vIGFuZCBgZm5gIGlzIGEgdXNlci13cml0dGVuIGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gKFNlZSBbYGFwZy1leGFtcGxlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMyLWV4YW1wbGVzL3RyZWUvbWFzdGVyL2FzdCkgZm9yIGV4YW1wbGVzIG9mIGhvdyB0byBjcmVhdGUgYW4gQVNULFxuLy8gZGVmaW5lIHRoZSBub2RlcyBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zIGFuZCBhdHRhY2ggaXQgdG8gYSBwYXJzZXIuKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHBvcnRzQXN0KCkge1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKTtcbiAgY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxpdGllcycpO1xuXG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdhc3QuanM6ICc7XG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICBsZXQgcnVsZXMgPSBudWxsO1xuICBsZXQgdWR0cyA9IG51bGw7XG4gIGxldCBjaGFycyA9IG51bGw7XG4gIGxldCBub2RlQ291bnQgPSAwO1xuICBjb25zdCBub2Rlc0RlZmluZWQgPSBbXTtcbiAgY29uc3Qgbm9kZUNhbGxiYWNrcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBjb25zdCByZWNvcmRzID0gW107XG4gIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIHRoaXMuYXN0T2JqZWN0ID0gJ2FzdE9iamVjdCc7XG4gIC8qIGNhbGxlZCBieSB0aGUgcGFyc2VyIHRvIGluaXRpYWxpemUgdGhlIEFTVCB3aXRoIHRoZSBydWxlcywgVURUcyBhbmQgdGhlIGlucHV0IGNoYXJhY3RlcnMgKi9cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gaW5pdChydWxlc0luLCB1ZHRzSW4sIGNoYXJzSW4pIHtcbiAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgIHJlY29yZHMubGVuZ3RoID0gMDtcbiAgICBub2Rlc0RlZmluZWQubGVuZ3RoID0gMDtcbiAgICBub2RlQ291bnQgPSAwO1xuICAgIHJ1bGVzID0gcnVsZXNJbjtcbiAgICB1ZHRzID0gdWR0c0luO1xuICAgIGNoYXJzID0gY2hhcnNJbjtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsaXN0LnB1c2gocnVsZXNbaV0ubG93ZXIpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHVkdHNbaV0ubG93ZXIpO1xuICAgIH1cbiAgICBub2RlQ291bnQgPSBydWxlcy5sZW5ndGggKyB1ZHRzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIG5vZGVzRGVmaW5lZFtpXSA9IGZhbHNlO1xuICAgICAgbm9kZUNhbGxiYWNrc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gdGhhdC5jYWxsYmFja3MpIHtcbiAgICAgIGNvbnN0IGxvd2VyID0gaW5kZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgIGkgPSBsaXN0LmluZGV4T2YobG93ZXIpO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aW5pdDogbm9kZSAnJHtpbmRleH0nIG5vdCBhIHJ1bGUgb3IgdWR0IG5hbWVgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhhdC5jYWxsYmFja3NbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5vZGVzRGVmaW5lZFtpXSA9IHRydWU7XG4gICAgICAgIG5vZGVDYWxsYmFja3NbaV0gPSB0aGF0LmNhbGxiYWNrc1tpbmRleF07XG4gICAgICB9XG4gICAgICBpZiAodGhhdC5jYWxsYmFja3NbaW5kZXhdID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGVzRGVmaW5lZFtpXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBBU1Qgbm9kZSBkZWZpbml0aW9ucyAtIGNhbGxlZCBieSB0aGUgcGFyc2VyJ3MgYFJOTWAgb3BlcmF0b3IgKi9cbiAgdGhpcy5ydWxlRGVmaW5lZCA9IGZ1bmN0aW9uIHJ1bGVEZWZpbmVkKGluZGV4KSB7XG4gICAgcmV0dXJuIG5vZGVzRGVmaW5lZFtpbmRleF0gIT09IGZhbHNlO1xuICB9O1xuICAvKiBBU1Qgbm9kZSBkZWZpbml0aW9ucyAtIGNhbGxlZCBieSB0aGUgcGFyc2VyJ3MgYFVEVGAgb3BlcmF0b3IgKi9cbiAgdGhpcy51ZHREZWZpbmVkID0gZnVuY3Rpb24gdWR0RGVmaW5lZChpbmRleCkge1xuICAgIHJldHVybiBub2Rlc0RlZmluZWRbcnVsZXMubGVuZ3RoICsgaW5kZXhdICE9PSBmYWxzZTtcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHRoZSBwYXJzZXIncyBgUk5NYCAmIGBVRFRgIG9wZXJhdG9ycyAqL1xuICAvKiBidWlsZHMgYSByZWNvcmQgZm9yIHRoZSBkb3dud2FyZCB0cmF2ZXJzYWwgb2YgdGhlIG5vZGUgKi9cbiAgdGhpcy5kb3duID0gZnVuY3Rpb24gZG93bihjYWxsYmFja0luZGV4LCBuYW1lKSB7XG4gICAgY29uc3QgdGhpc0luZGV4ID0gcmVjb3Jkcy5sZW5ndGg7XG4gICAgc3RhY2sucHVzaCh0aGlzSW5kZXgpO1xuICAgIHJlY29yZHMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgdGhpc0luZGV4LFxuICAgICAgdGhhdEluZGV4OiBudWxsLFxuICAgICAgc3RhdGU6IGlkLlNFTV9QUkUsXG4gICAgICBjYWxsYmFja0luZGV4LFxuICAgICAgcGhyYXNlSW5kZXg6IG51bGwsXG4gICAgICBwaHJhc2VMZW5ndGg6IG51bGwsXG4gICAgICBzdGFjazogc3RhY2subGVuZ3RoLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzSW5kZXg7XG4gIH07XG4gIC8qIGNhbGxlZCBieSB0aGUgcGFyc2VyJ3MgYFJOTWAgJiBgVURUYCBvcGVyYXRvcnMgKi9cbiAgLyogYnVpbGRzIGEgcmVjb3JkIGZvciB0aGUgdXB3YXJkIHRyYXZlcnNhbCBvZiB0aGUgbm9kZSAqL1xuICB0aGlzLnVwID0gZnVuY3Rpb24gdXAoY2FsbGJhY2tJbmRleCwgbmFtZSwgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aCkge1xuICAgIGNvbnN0IHRoaXNJbmRleCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIGNvbnN0IHRoYXRJbmRleCA9IHN0YWNrLnBvcCgpO1xuICAgIHJlY29yZHMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgdGhpc0luZGV4LFxuICAgICAgdGhhdEluZGV4LFxuICAgICAgc3RhdGU6IGlkLlNFTV9QT1NULFxuICAgICAgY2FsbGJhY2tJbmRleCxcbiAgICAgIHBocmFzZUluZGV4LFxuICAgICAgcGhyYXNlTGVuZ3RoLFxuICAgICAgc3RhY2s6IHN0YWNrLmxlbmd0aCxcbiAgICB9KTtcbiAgICByZWNvcmRzW3RoYXRJbmRleF0udGhhdEluZGV4ID0gdGhpc0luZGV4O1xuICAgIHJlY29yZHNbdGhhdEluZGV4XS5waHJhc2VJbmRleCA9IHBocmFzZUluZGV4O1xuICAgIHJlY29yZHNbdGhhdEluZGV4XS5waHJhc2VMZW5ndGggPSBwaHJhc2VMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXNJbmRleDtcbiAgfTtcbiAgLy8gQ2FsbGVkIGJ5IHRoZSB1c2VyIHRvIHRyYW5zbGF0ZSB0aGUgQVNULlxuICAvLyBUcmFuc2xhdGUgbWVhbnMgdG8gYXNzb2NpYXRlIG9yIGFwcGx5IHNvbWUgc2VtYW50aWMgYWN0aW9uIHRvIHRoZVxuICAvLyBwaHJhc2VzIHRoYXQgd2VyZSBzeW50YWN0aWNhbGx5IG1hdGNoZWQgdG8gdGhlIEFTVCBub2RlcyBhY2NvcmRpbmdcbiAgLy8gdG8gdGhlIGRlZmluaW5nIGdyYW1tYXIuXG4gIC8vIGBgYFxuICAvLyBkYXRhIC0gb3B0aW9uYWwgdXNlci1kZWZpbmVkIGRhdGFcbiAgLy8gICAgICAgIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zIGJ5IHRoZSB0cmFuc2xhdG9yXG4gIC8vIGBgYFxuICB0aGlzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZShkYXRhKSB7XG4gICAgbGV0IHJldDtcbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgbGV0IHJlY29yZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICBjYWxsYmFjayA9IG5vZGVDYWxsYmFja3NbcmVjb3JkLmNhbGxiYWNrSW5kZXhdO1xuICAgICAgaWYgKHJlY29yZC5zdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICByZXQgPSBjYWxsYmFjayhpZC5TRU1fUFJFLCBjaGFycywgcmVjb3JkLnBocmFzZUluZGV4LCByZWNvcmQucGhyYXNlTGVuZ3RoLCBkYXRhKTtcbiAgICAgICAgICBpZiAocmV0ID09PSBpZC5TRU1fU0tJUCkge1xuICAgICAgICAgICAgaSA9IHJlY29yZC50aGF0SW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrKGlkLlNFTV9QT1NULCBjaGFycywgcmVjb3JkLnBocmFzZUluZGV4LCByZWNvcmQucGhyYXNlTGVuZ3RoLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSB0aGUgcGFyc2VyIHRvIHJlc2V0IHRoZSBsZW5ndGggb2YgdGhlIHJlY29yZHMgYXJyYXkgKi9cbiAgLyogbmVjZXNzYXJ5IG9uIGJhY2t0cmFja2luZyAqL1xuICB0aGlzLnNldExlbmd0aCA9IGZ1bmN0aW9uIHNldExlbmd0aChsZW5ndGgpIHtcbiAgICByZWNvcmRzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgc3RhY2subGVuZ3RoID0gcmVjb3Jkc1tsZW5ndGggLSAxXS5zdGFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSB0aGUgcGFyc2VyIHRvIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSByZWNvcmRzIGFycmF5ICovXG4gIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiByZWNvcmRzLmxlbmd0aDtcbiAgfTtcbiAgLyogaGVscGVyIGZvciBYTUwgZGlzcGxheSAqL1xuICBmdW5jdGlvbiBpbmRlbnQobikge1xuICAgIGxldCByZXQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkgKz0gMSkge1xuICAgICAgcmV0ICs9ICcgJztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvLyBHZW5lcmF0ZSBhbiBgWE1MYCB2ZXJzaW9uIG9mIHRoZSBBU1QuXG4gIC8vIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byB1c2UgYSBzcGVjaWFsIG9yIGZhdm9yaXRlIFhNTCBwYXJzZXIgdG8gdHJhbnNsYXRlIHRoZVxuICAvLyBBU1QuXG4gIC8vIGBgYFxuICAvLyBtb2RlIC0gdGhlIGRpc3BsYXkgbW9kZSBvZiB0aGUgY2FwdHVyZWQgcGhyYXNlc1xuICAvLyAgICAgIC0gZGVmYXVsdCBtb2RlIGlzIFwiYXNjaWlcIlxuICAvLyAgICAgIC0gY2FuIGJlOiBcImFzY2lpXCJcbiAgLy8gICAgICAgICAgICAgICAgXCJkZWNpbWFsXCJcbiAgLy8gICAgICAgICAgICAgICAgXCJoZXhhZGVjaW1hbFwiXG4gIC8vICAgICAgICAgICAgICAgIFwidW5pY29kZVwiXG4gIC8vIGBgYFxuICB0aGlzLnRvWG1sID0gZnVuY3Rpb24gdG9TbWwobW9kZUFyZykge1xuICAgIGxldCBkaXNwbGF5ID0gdXRpbHMuY2hhcnNUb0RlYztcbiAgICBsZXQgY2FwdGlvbiA9ICdkZWNpbWFsIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzJztcbiAgICBpZiAodHlwZW9mIG1vZGVBcmcgPT09ICdzdHJpbmcnICYmIG1vZGVBcmcubGVuZ3RoID49IDMpIHtcbiAgICAgIGNvbnN0IG1vZGUgPSBtb2RlQXJnLnNsaWNlKDAsIDMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobW9kZSA9PT0gJ2FzYycpIHtcbiAgICAgICAgZGlzcGxheSA9IHV0aWxzLmNoYXJzVG9Bc2NpaTtcbiAgICAgICAgY2FwdGlvbiA9ICdBU0NJSSBmb3IgcHJpbnRpbmcgY2hhcmFjdGVycywgaGV4IGZvciBub24tcHJpbnRpbmcnO1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaGV4Jykge1xuICAgICAgICBkaXNwbGF5ID0gdXRpbHMuY2hhcnNUb0hleDtcbiAgICAgICAgY2FwdGlvbiA9ICdoZXhhZGVjaW1hbCBpbnRlZ2VyIGNoYXJhY3RlciBjb2Rlcyc7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICd1bmknKSB7XG4gICAgICAgIGRpc3BsYXkgPSB1dGlscy5jaGFyc1RvVW5pY29kZTtcbiAgICAgICAgY2FwdGlvbiA9ICdVbmljb2RlIFVURi0zMiBpbnRlZ2VyIGNoYXJhY3RlciBjb2Rlcyc7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB4bWwgPSAnJztcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIHhtbCArPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwidXRmLThcIj8+XFxuJztcbiAgICB4bWwgKz0gYDxyb290IG5vZGVzPVwiJHtyZWNvcmRzLmxlbmd0aCAvIDJ9XCIgY2hhcmFjdGVycz1cIiR7Y2hhcnMubGVuZ3RofVwiPlxcbmA7XG4gICAgeG1sICs9IGA8IS0tIGlucHV0IHN0cmluZywgJHtjYXB0aW9ufSAtLT5cXG5gO1xuICAgIHhtbCArPSBpbmRlbnQoZGVwdGggKyAyKTtcbiAgICB4bWwgKz0gZGlzcGxheShjaGFycyk7XG4gICAgeG1sICs9ICdcXG4nO1xuICAgIHJlY29yZHMuZm9yRWFjaCgocmVjKSA9PiB7XG4gICAgICBpZiAocmVjLnN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIHhtbCArPSBpbmRlbnQoZGVwdGgpO1xuICAgICAgICB4bWwgKz0gYDxub2RlIG5hbWU9XCIke3JlYy5uYW1lfVwiIGluZGV4PVwiJHtyZWMucGhyYXNlSW5kZXh9XCIgbGVuZ3RoPVwiJHtyZWMucGhyYXNlTGVuZ3RofVwiPlxcbmA7XG4gICAgICAgIHhtbCArPSBpbmRlbnQoZGVwdGggKyAyKTtcbiAgICAgICAgeG1sICs9IGRpc3BsYXkoY2hhcnMsIHJlYy5waHJhc2VJbmRleCwgcmVjLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIHhtbCArPSAnXFxuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhtbCArPSBpbmRlbnQoZGVwdGgpO1xuICAgICAgICB4bWwgKz0gYDwvbm9kZT48IS0tIG5hbWU9XCIke3JlYy5uYW1lfVwiIC0tPlxcbmA7XG4gICAgICAgIGRlcHRoIC09IDE7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB4bWwgKz0gJzwvcm9vdD5cXG4nO1xuICAgIHJldHVybiB4bWw7XG4gIH07XG4gIC8qIGdlbmVyYXRlIGEgSmF2YVNjcmlwdCBvYmplY3QgdmVyc2lvbiBvZiB0aGUgQVNUICovXG4gIC8qIGZvciB0aGUgcGhyYXNlLW1hdGNoaW5nIGVuZ2luZSBhcGctZXhwICovXG4gIHRoaXMucGhyYXNlcyA9IGZ1bmN0aW9uIHBocmFzZXMoKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgbGV0IGk7XG4gICAgbGV0IHJlY29yZDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgcmVjb3JkID0gcmVjb3Jkc1tpXTtcbiAgICAgIGlmIChyZWNvcmQuc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialtyZWNvcmQubmFtZV0pKSB7XG4gICAgICAgICAgb2JqW3JlY29yZC5uYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG9ialtyZWNvcmQubmFtZV0ucHVzaCh7XG4gICAgICAgICAgaW5kZXg6IHJlY29yZC5waHJhc2VJbmRleCxcbiAgICAgICAgICBsZW5ndGg6IHJlY29yZC5waHJhc2VMZW5ndGgsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/ast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/circular-buffer.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/circular-buffer.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module acts as a \"circular buffer\". It is used to keep track\n// only the last N records in an array of records. If more than N records\n// are saved, each additional record overwrites the previously oldest record.\n// This module deals only with the record indexes and does not save\n// any actual records. It is used by [`trace.js`](./trace.html) for limiting the number of\n// trace records saved.\nmodule.exports = function exportsCircularBuffer() {\n  'use strict;';\n\n  const thisFileName = 'circular-buffer.js: ';\n  let itemIndex = -1;\n  let maxListSize = 0;\n  // Initialize buffer.<br>\n  // *size* is `maxListSize`, the maximum number of records saved before overwriting begins.\n  this.init = function init(size) {\n    if (typeof size !== 'number' || size <= 0) {\n      throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);\n    }\n    maxListSize = Math.ceil(size);\n    itemIndex = -1;\n  };\n  // Call this to increment the number of records collected.<br>\n  // Returns the array index number to store the next record in.\n  this.increment = function increment() {\n    itemIndex += 1;\n    return (itemIndex + maxListSize) % maxListSize;\n  };\n  // Returns `maxListSize` - the maximum number of records to keep in the buffer.\n  this.maxSize = function maxSize() {\n    return maxListSize;\n  };\n  // Returns the highest number of items saved.<br>\n  // (The number of items is the actual number of records processed\n  // even though only `maxListSize` records are actually retained.)\n  this.items = function items() {\n    return itemIndex + 1;\n  };\n  // Returns the record number associated with this item index.\n  this.getListIndex = function getListIndex(item) {\n    if (itemIndex === -1) {\n      return -1;\n    }\n    if (item < 0 || item > itemIndex) {\n      return -1;\n    }\n    if (itemIndex - item >= maxListSize) {\n      return -1;\n    }\n    return (item + maxListSize) % maxListSize;\n  };\n  // The iterator over the circular buffer.\n  // The user's function, `fn`, will be called with arguments `fn(listIndex, itemIndex)`\n  // where `listIndex` is the saved record index and `itemIndex` is the actual item index.\n  this.forEach = function forEach(fn) {\n    if (itemIndex === -1) {\n      /* no records have been collected */\n      return;\n    }\n    if (itemIndex < maxListSize) {\n      /* fewer than maxListSize records have been collected - number of items = number of records */\n      for (let i = 0; i <= itemIndex; i += 1) {\n        fn(i, i);\n      }\n      return;\n    }\n    /* start with the oldest record saved and finish with the most recent record saved */\n    for (let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1) {\n      const listIndex = (i + maxListSize) % maxListSize;\n      fn(listIndex, i);\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2NpcmN1bGFyLWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9jaXJjdWxhci1idWZmZXIuanM/YWJmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBhY3RzIGFzIGEgXCJjaXJjdWxhciBidWZmZXJcIi4gSXQgaXMgdXNlZCB0byBrZWVwIHRyYWNrXG4vLyBvbmx5IHRoZSBsYXN0IE4gcmVjb3JkcyBpbiBhbiBhcnJheSBvZiByZWNvcmRzLiBJZiBtb3JlIHRoYW4gTiByZWNvcmRzXG4vLyBhcmUgc2F2ZWQsIGVhY2ggYWRkaXRpb25hbCByZWNvcmQgb3ZlcndyaXRlcyB0aGUgcHJldmlvdXNseSBvbGRlc3QgcmVjb3JkLlxuLy8gVGhpcyBtb2R1bGUgZGVhbHMgb25seSB3aXRoIHRoZSByZWNvcmQgaW5kZXhlcyBhbmQgZG9lcyBub3Qgc2F2ZVxuLy8gYW55IGFjdHVhbCByZWNvcmRzLiBJdCBpcyB1c2VkIGJ5IFtgdHJhY2UuanNgXSguL3RyYWNlLmh0bWwpIGZvciBsaW1pdGluZyB0aGUgbnVtYmVyIG9mXG4vLyB0cmFjZSByZWNvcmRzIHNhdmVkLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHBvcnRzQ2lyY3VsYXJCdWZmZXIoKSB7XG4gICd1c2Ugc3RyaWN0Oyc7XG5cbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ2NpcmN1bGFyLWJ1ZmZlci5qczogJztcbiAgbGV0IGl0ZW1JbmRleCA9IC0xO1xuICBsZXQgbWF4TGlzdFNpemUgPSAwO1xuICAvLyBJbml0aWFsaXplIGJ1ZmZlci48YnI+XG4gIC8vICpzaXplKiBpcyBgbWF4TGlzdFNpemVgLCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyBzYXZlZCBiZWZvcmUgb3ZlcndyaXRpbmcgYmVnaW5zLlxuICB0aGlzLmluaXQgPSBmdW5jdGlvbiBpbml0KHNpemUpIHtcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInIHx8IHNpemUgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1pbml0OiBjaXJjdWxhciBidWZmZXIgc2l6ZSBtdXN0IGFuIGludGVnZXIgPiAwYCk7XG4gICAgfVxuICAgIG1heExpc3RTaXplID0gTWF0aC5jZWlsKHNpemUpO1xuICAgIGl0ZW1JbmRleCA9IC0xO1xuICB9O1xuICAvLyBDYWxsIHRoaXMgdG8gaW5jcmVtZW50IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBjb2xsZWN0ZWQuPGJyPlxuICAvLyBSZXR1cm5zIHRoZSBhcnJheSBpbmRleCBudW1iZXIgdG8gc3RvcmUgdGhlIG5leHQgcmVjb3JkIGluLlxuICB0aGlzLmluY3JlbWVudCA9IGZ1bmN0aW9uIGluY3JlbWVudCgpIHtcbiAgICBpdGVtSW5kZXggKz0gMTtcbiAgICByZXR1cm4gKGl0ZW1JbmRleCArIG1heExpc3RTaXplKSAlIG1heExpc3RTaXplO1xuICB9O1xuICAvLyBSZXR1cm5zIGBtYXhMaXN0U2l6ZWAgLSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0byBrZWVwIGluIHRoZSBidWZmZXIuXG4gIHRoaXMubWF4U2l6ZSA9IGZ1bmN0aW9uIG1heFNpemUoKSB7XG4gICAgcmV0dXJuIG1heExpc3RTaXplO1xuICB9O1xuICAvLyBSZXR1cm5zIHRoZSBoaWdoZXN0IG51bWJlciBvZiBpdGVtcyBzYXZlZC48YnI+XG4gIC8vIChUaGUgbnVtYmVyIG9mIGl0ZW1zIGlzIHRoZSBhY3R1YWwgbnVtYmVyIG9mIHJlY29yZHMgcHJvY2Vzc2VkXG4gIC8vIGV2ZW4gdGhvdWdoIG9ubHkgYG1heExpc3RTaXplYCByZWNvcmRzIGFyZSBhY3R1YWxseSByZXRhaW5lZC4pXG4gIHRoaXMuaXRlbXMgPSBmdW5jdGlvbiBpdGVtcygpIHtcbiAgICByZXR1cm4gaXRlbUluZGV4ICsgMTtcbiAgfTtcbiAgLy8gUmV0dXJucyB0aGUgcmVjb3JkIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBpdGVtIGluZGV4LlxuICB0aGlzLmdldExpc3RJbmRleCA9IGZ1bmN0aW9uIGdldExpc3RJbmRleChpdGVtKSB7XG4gICAgaWYgKGl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gPCAwIHx8IGl0ZW0gPiBpdGVtSW5kZXgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGl0ZW1JbmRleCAtIGl0ZW0gPj0gbWF4TGlzdFNpemUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIChpdGVtICsgbWF4TGlzdFNpemUpICUgbWF4TGlzdFNpemU7XG4gIH07XG4gIC8vIFRoZSBpdGVyYXRvciBvdmVyIHRoZSBjaXJjdWxhciBidWZmZXIuXG4gIC8vIFRoZSB1c2VyJ3MgZnVuY3Rpb24sIGBmbmAsIHdpbGwgYmUgY2FsbGVkIHdpdGggYXJndW1lbnRzIGBmbihsaXN0SW5kZXgsIGl0ZW1JbmRleClgXG4gIC8vIHdoZXJlIGBsaXN0SW5kZXhgIGlzIHRoZSBzYXZlZCByZWNvcmQgaW5kZXggYW5kIGBpdGVtSW5kZXhgIGlzIHRoZSBhY3R1YWwgaXRlbSBpbmRleC5cbiAgdGhpcy5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAvKiBubyByZWNvcmRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGl0ZW1JbmRleCA8IG1heExpc3RTaXplKSB7XG4gICAgICAvKiBmZXdlciB0aGFuIG1heExpc3RTaXplIHJlY29yZHMgaGF2ZSBiZWVuIGNvbGxlY3RlZCAtIG51bWJlciBvZiBpdGVtcyA9IG51bWJlciBvZiByZWNvcmRzICovXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpdGVtSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICBmbihpLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogc3RhcnQgd2l0aCB0aGUgb2xkZXN0IHJlY29yZCBzYXZlZCBhbmQgZmluaXNoIHdpdGggdGhlIG1vc3QgcmVjZW50IHJlY29yZCBzYXZlZCAqL1xuICAgIGZvciAobGV0IGkgPSBpdGVtSW5kZXggLSBtYXhMaXN0U2l6ZSArIDE7IGkgPD0gaXRlbUluZGV4OyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGxpc3RJbmRleCA9IChpICsgbWF4TGlzdFNpemUpICUgbWF4TGlzdFNpemU7XG4gICAgICBmbihsaXN0SW5kZXgsIGkpO1xuICAgIH1cbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/circular-buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/emitcss.js":
/*!****************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/emitcss.js ***!
  \****************************************************/
/***/ ((module) => {

eval("// This module has been developed programmatically in the `apg-lib` build process.\n// It is used to build web pages programatically on the fly without the need for <script> or <style> tags.\n\nmodule.exports = function emittcss(){\nreturn '/* This file automatically generated by jsonToless() and LESS. */\\n.apg-mono {\\n  font-family: monospace;\\n}\\n.apg-active {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-match {\\n  font-weight: bold;\\n  color: #264BFF;\\n}\\n.apg-empty {\\n  font-weight: bold;\\n  color: #0fbd0f;\\n}\\n.apg-nomatch {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-lh-match {\\n  font-weight: bold;\\n  color: #1A97BA;\\n}\\n.apg-lb-match {\\n  font-weight: bold;\\n  color: #5F1687;\\n}\\n.apg-remainder {\\n  font-weight: bold;\\n  color: #999999;\\n}\\n.apg-ctrl-char {\\n  font-weight: bolder;\\n  font-style: italic;\\n  font-size: 0.6em;\\n}\\n.apg-line-end {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-error {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-phrase {\\n  color: #000000;\\n  background-color: #8caae6;\\n}\\n.apg-empty-phrase {\\n  color: #0fbd0f;\\n}\\ntable.apg-state {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th,\\ntable.apg-state td {\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th:nth-last-child(2),\\ntable.apg-state td:nth-last-child(2) {\\n  text-align: right;\\n}\\ntable.apg-state caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-stats {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats th,\\ntable.apg-stats td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace th,\\ntable.apg-trace td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace th:last-child,\\ntable.apg-trace th:nth-last-child(2),\\ntable.apg-trace td:last-child,\\ntable.apg-trace td:nth-last-child(2) {\\n  text-align: left;\\n}\\ntable.apg-grammar {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-grammar th,\\ntable.apg-grammar td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar th:last-child,\\ntable.apg-grammar td:last-child {\\n  text-align: left;\\n}\\ntable.apg-rules {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-rules th,\\ntable.apg-rules td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules a {\\n  color: #003399 !important;\\n}\\ntable.apg-rules a:hover {\\n  color: #8caae6 !important;\\n}\\ntable.apg-attrs {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-attrs th,\\ntable.apg-attrs td {\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs th:nth-child(1),\\ntable.apg-attrs th:nth-child(2),\\ntable.apg-attrs th:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs td:nth-child(1),\\ntable.apg-attrs td:nth-child(2),\\ntable.apg-attrs td:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs a {\\n  color: #003399 !important;\\n}\\ntable.apg-attrs a:hover {\\n  color: #8caae6 !important;\\n}\\n';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2VtaXRjc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRiwyQkFBMkIsR0FBRyxlQUFlLHNCQUFzQixtQkFBbUIsR0FBRyxjQUFjLHNCQUFzQixtQkFBbUIsR0FBRyxjQUFjLHNCQUFzQixtQkFBbUIsR0FBRyxnQkFBZ0Isc0JBQXNCLG1CQUFtQixHQUFHLGlCQUFpQixzQkFBc0IsbUJBQW1CLEdBQUcsaUJBQWlCLHNCQUFzQixtQkFBbUIsR0FBRyxrQkFBa0Isc0JBQXNCLG1CQUFtQixHQUFHLGtCQUFrQix3QkFBd0IsdUJBQXVCLHFCQUFxQixHQUFHLGlCQUFpQixzQkFBc0IsbUJBQW1CLEdBQUcsY0FBYyxzQkFBc0IsbUJBQW1CLEdBQUcsZUFBZSxtQkFBbUIsOEJBQThCLEdBQUcscUJBQXFCLG1CQUFtQixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0IscUJBQXFCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQ0FBMkMscUJBQXFCLDRCQUE0Qiw4QkFBOEIsR0FBRywrRUFBK0Usc0JBQXNCLEdBQUcsMkJBQTJCLG9CQUFvQixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0Isc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQkFBMkIsb0JBQW9CLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUcsbUJBQW1CLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDJCQUEyQixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywrSUFBK0kscUJBQXFCLEdBQUcscUJBQXFCLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDZCQUE2QixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywrQ0FBK0Msc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRyxxRUFBcUUscUJBQXFCLEdBQUcsbUJBQW1CLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDJCQUEyQixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsMkJBQTJCLDhCQUE4QixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0IsdUJBQXVCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQkFBMkIsb0JBQW9CLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUcsMkNBQTJDLHVCQUF1Qiw0QkFBNEIsOEJBQThCLEdBQUcsdUdBQXVHLHNCQUFzQixHQUFHLHVHQUF1RyxzQkFBc0IsR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsMkJBQTJCLDhCQUE4QixHQUFHO0FBQzdzSSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvZW1pdGNzcy5qcz9jYzkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgbW9kdWxlIGhhcyBiZWVuIGRldmVsb3BlZCBwcm9ncmFtbWF0aWNhbGx5IGluIHRoZSBgYXBnLWxpYmAgYnVpbGQgcHJvY2Vzcy5cbi8vIEl0IGlzIHVzZWQgdG8gYnVpbGQgd2ViIHBhZ2VzIHByb2dyYW1hdGljYWxseSBvbiB0aGUgZmx5IHdpdGhvdXQgdGhlIG5lZWQgZm9yIDxzY3JpcHQ+IG9yIDxzdHlsZT4gdGFncy5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbWl0dGNzcygpe1xucmV0dXJuICcvKiBUaGlzIGZpbGUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkganNvblRvbGVzcygpIGFuZCBMRVNTLiAqL1xcbi5hcGctbW9ubyB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbn1cXG4uYXBnLWFjdGl2ZSB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjMDAwMDAwO1xcbn1cXG4uYXBnLW1hdGNoIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMyNjRCRkY7XFxufVxcbi5hcGctZW1wdHkge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzBmYmQwZjtcXG59XFxuLmFwZy1ub21hdGNoIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICNGRjQwMDA7XFxufVxcbi5hcGctbGgtbWF0Y2gge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzFBOTdCQTtcXG59XFxuLmFwZy1sYi1tYXRjaCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjNUYxNjg3O1xcbn1cXG4uYXBnLXJlbWFpbmRlciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjOTk5OTk5O1xcbn1cXG4uYXBnLWN0cmwtY2hhciB7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgZm9udC1zaXplOiAwLjZlbTtcXG59XFxuLmFwZy1saW5lLWVuZCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjMDAwMDAwO1xcbn1cXG4uYXBnLWVycm9yIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICNGRjQwMDA7XFxufVxcbi5hcGctcGhyYXNlIHtcXG4gIGNvbG9yOiAjMDAwMDAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzhjYWFlNjtcXG59XFxuLmFwZy1lbXB0eS1waHJhc2Uge1xcbiAgY29sb3I6ICMwZmJkMGY7XFxufVxcbnRhYmxlLmFwZy1zdGF0ZSB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctc3RhdGUgdGgsXFxudGFibGUuYXBnLXN0YXRlIHRkIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1zdGF0ZSB0aDpudGgtbGFzdC1jaGlsZCgyKSxcXG50YWJsZS5hcGctc3RhdGUgdGQ6bnRoLWxhc3QtY2hpbGQoMikge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcbnRhYmxlLmFwZy1zdGF0ZSBjYXB0aW9uIHtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctc3RhdHMge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1zdGF0cyB0aCxcXG50YWJsZS5hcGctc3RhdHMgdGQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1zdGF0cyBjYXB0aW9uIHtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctdHJhY2Uge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy10cmFjZSBjYXB0aW9uIHtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctdHJhY2UgdGgsXFxudGFibGUuYXBnLXRyYWNlIHRkIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctdHJhY2UgdGg6bGFzdC1jaGlsZCxcXG50YWJsZS5hcGctdHJhY2UgdGg6bnRoLWxhc3QtY2hpbGQoMiksXFxudGFibGUuYXBnLXRyYWNlIHRkOmxhc3QtY2hpbGQsXFxudGFibGUuYXBnLXRyYWNlIHRkOm50aC1sYXN0LWNoaWxkKDIpIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1ncmFtbWFyIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctZ3JhbW1hciBjYXB0aW9uIHtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctZ3JhbW1hciB0aCxcXG50YWJsZS5hcGctZ3JhbW1hciB0ZCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLWdyYW1tYXIgdGg6bGFzdC1jaGlsZCxcXG50YWJsZS5hcGctZ3JhbW1hciB0ZDpsYXN0LWNoaWxkIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1ydWxlcyB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXJ1bGVzIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1ydWxlcyB0aCxcXG50YWJsZS5hcGctcnVsZXMgdGQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1ydWxlcyBhIHtcXG4gIGNvbG9yOiAjMDAzMzk5ICFpbXBvcnRhbnQ7XFxufVxcbnRhYmxlLmFwZy1ydWxlcyBhOmhvdmVyIHtcXG4gIGNvbG9yOiAjOGNhYWU2ICFpbXBvcnRhbnQ7XFxufVxcbnRhYmxlLmFwZy1hdHRycyB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1hdHRycyBjYXB0aW9uIHtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctYXR0cnMgdGgsXFxudGFibGUuYXBnLWF0dHJzIHRkIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLWF0dHJzIHRoOm50aC1jaGlsZCgxKSxcXG50YWJsZS5hcGctYXR0cnMgdGg6bnRoLWNoaWxkKDIpLFxcbnRhYmxlLmFwZy1hdHRycyB0aDpudGgtY2hpbGQoMykge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcbnRhYmxlLmFwZy1hdHRycyB0ZDpudGgtY2hpbGQoMSksXFxudGFibGUuYXBnLWF0dHJzIHRkOm50aC1jaGlsZCgyKSxcXG50YWJsZS5hcGctYXR0cnMgdGQ6bnRoLWNoaWxkKDMpIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG50YWJsZS5hcGctYXR0cnMgYSB7XFxuICBjb2xvcjogIzAwMzM5OSAhaW1wb3J0YW50O1xcbn1cXG50YWJsZS5hcGctYXR0cnMgYTpob3ZlciB7XFxuICBjb2xvcjogIzhjYWFlNiAhaW1wb3J0YW50O1xcbn1cXG4nO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/emitcss.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js":
/*!********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/identifiers.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes a list of named identifiers, shared across the parser generator\n// and the parsers that are generated.\n\nmodule.exports = {\n  // Identifies the operator type. Used by the generator\n  // to indicate operator types in the grammar object.\n  // Used by the [parser](./parser.html) when interpreting the grammar object.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n  BKR: 14 /* back reference to a previously matched rule name */,\n  BKA: 15 /* positive look behind */,\n  BKN: 16 /* negative look behind */,\n  ABG: 17 /* anchor - begin of string */,\n  AEN: 18 /* anchor - end of string */,\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.\n  // - *SEM_OK* - normal return value\n  // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,\n  // the translator will skip processing all `AST` nodes in the branch below the current node.\n  // Ignored if returned from the SEM_POST state.\n  SEM_OK: 300,\n  SEM_SKIP: 301,\n  // Used in attribute generation to distinguish the necessary attribute categories.\n  // - *ATTR_N* - non-recursive\n  // - *ATTR_R* - recursive\n  // - *ATTR_MR* - belongs to a mutually-recursive set\n  ATTR_N: 400,\n  ATTR_R: 401,\n  ATTR_MR: 402,\n  // Look around values indicate whether the parser is in look ahead or look behind mode.\n  // Used by the tracing facility to indicate the look around mode in the trace records display.\n  // - *LOOKAROUND_NONE* - the parser is in normal parsing mode\n  // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`\n  // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`\n  LOOKAROUND_NONE: 500,\n  LOOKAROUND_AHEAD: 501,\n  LOOKAROUND_BEHIND: 502,\n  // Back reference rule mode indicators\n  // - *BKR_MODE_UM* - the back reference is using universal mode\n  // - *BKR_MODE_PM* - the back reference is using parent frame mode\n  // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching\n  // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching\n  BKR_MODE_UM: 601,\n  BKR_MODE_PM: 602,\n  BKR_MODE_CS: 603,\n  BKR_MODE_CI: 604,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2lkZW50aWZpZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2lkZW50aWZpZXJzLmpzP2UxMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgZXhwb3NlcyBhIGxpc3Qgb2YgbmFtZWQgaWRlbnRpZmllcnMsIHNoYXJlZCBhY3Jvc3MgdGhlIHBhcnNlciBnZW5lcmF0b3Jcbi8vIGFuZCB0aGUgcGFyc2VycyB0aGF0IGFyZSBnZW5lcmF0ZWQuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBJZGVudGlmaWVzIHRoZSBvcGVyYXRvciB0eXBlLiBVc2VkIGJ5IHRoZSBnZW5lcmF0b3JcbiAgLy8gdG8gaW5kaWNhdGUgb3BlcmF0b3IgdHlwZXMgaW4gdGhlIGdyYW1tYXIgb2JqZWN0LlxuICAvLyBVc2VkIGJ5IHRoZSBbcGFyc2VyXSguL3BhcnNlci5odG1sKSB3aGVuIGludGVycHJldGluZyB0aGUgZ3JhbW1hciBvYmplY3QuXG4gIC8qIHRoZSBvcmlnaW5hbCBBQk5GIG9wZXJhdG9ycyAqL1xuICBBTFQ6IDEgLyogYWx0ZXJuYXRpb24gKi8sXG4gIENBVDogMiAvKiBjb25jYXRlbmF0aW9uICovLFxuICBSRVA6IDMgLyogcmVwZXRpdGlvbiAqLyxcbiAgUk5NOiA0IC8qIHJ1bGUgbmFtZSAqLyxcbiAgVFJHOiA1IC8qIHRlcm1pbmFsIHJhbmdlICovLFxuICBUQlM6IDYgLyogdGVybWluYWwgYmluYXJ5IHN0cmluZywgY2FzZSBzZW5zaXRpdmUgKi8sXG4gIFRMUzogNyAvKiB0ZXJtaW5hbCBsaXRlcmFsIHN0cmluZywgY2FzZSBpbnNlbnNpdGl2ZSAqLyxcbiAgLyogdGhlIHN1cGVyIHNldCwgU0FCTkYgb3BlcmF0b3JzICovXG4gIFVEVDogMTEgLyogdXNlci1kZWZpbmVkIHRlcm1pbmFsICovLFxuICBBTkQ6IDEyIC8qIHBvc2l0aXZlIGxvb2sgYWhlYWQgKi8sXG4gIE5PVDogMTMgLyogbmVnYXRpdmUgbG9vayBhaGVhZCAqLyxcbiAgQktSOiAxNCAvKiBiYWNrIHJlZmVyZW5jZSB0byBhIHByZXZpb3VzbHkgbWF0Y2hlZCBydWxlIG5hbWUgKi8sXG4gIEJLQTogMTUgLyogcG9zaXRpdmUgbG9vayBiZWhpbmQgKi8sXG4gIEJLTjogMTYgLyogbmVnYXRpdmUgbG9vayBiZWhpbmQgKi8sXG4gIEFCRzogMTcgLyogYW5jaG9yIC0gYmVnaW4gb2Ygc3RyaW5nICovLFxuICBBRU46IDE4IC8qIGFuY2hvciAtIGVuZCBvZiBzdHJpbmcgKi8sXG4gIC8vIFVzZWQgYnkgdGhlIHBhcnNlciBhbmQgdGhlIHVzZXIncyBgUk5NYCBhbmQgYFVEVGAgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAvLyBJZGVudGlmaWVzIHRoZSBwYXJzZXIgc3RhdGUgYXMgaXQgdHJhdmVyc2VzIHRoZSBwYXJzZSB0cmVlIG5vZGVzLlxuICAvLyAtICpBQ1RJVkUqIC0gaW5kaWNhdGVzIHRoZSBkb3dud2FyZCBkaXJlY3Rpb24gdGhyb3VnaCB0aGUgcGFyc2UgdHJlZSBub2RlLlxuICAvLyAtICpNQVRDSCogLSBpbmRpY2F0ZXMgdGhlIHVwd2FyZCBkaXJlY3Rpb24gYW5kIGEgcGhyYXNlLCBvZiBsZW5ndGggXFw+IDAsIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBtYXRjaGVkXG4gIC8vIC0gKkVNUFRZKiAtIGluZGljYXRlcyB0aGUgdXB3YXJkIGRpcmVjdGlvbiBhbmQgYSBwaHJhc2UsIG9mIGxlbmd0aCA9IDAsIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBtYXRjaGVkXG4gIC8vIC0gKk5PTUFUQ0gqIC0gaW5kaWNhdGVzIHRoZSB1cHdhcmQgZGlyZWN0aW9uIGFuZCB0aGUgcGFyc2VyIGZhaWxlZCB0byBtYXRjaCBhbnkgcGhyYXNlIGF0IGFsbFxuICBBQ1RJVkU6IDEwMCxcbiAgTUFUQ0g6IDEwMSxcbiAgRU1QVFk6IDEwMixcbiAgTk9NQVRDSDogMTAzLFxuICAvLyBVc2VkIGJ5IFtgQVNUYCB0cmFuc2xhdG9yXSguL2FzdC5odG1sKSAoc2VtYW50aWMgYW5hbHlzaXMpIGFuZCB0aGUgdXNlcidzIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAvLyB0byBpbmRpY2F0ZSB0aGUgZGlyZWN0aW9uIG9mIGZsb3cgdGhyb3VnaCB0aGUgYEFTVGAgbm9kZXMuXG4gIC8vIC0gKlNFTV9QUkUqIC0gaW5kaWNhdGVzIHRoZSBkb3dud2FyZCAocHJlLWJyYW5jaCkgZGlyZWN0aW9uIHRocm91Z2ggdGhlIGBBU1RgIG5vZGUuXG4gIC8vIC0gKlNFTV9QT1NUKiAtIGluZGljYXRlcyB0aGUgdXB3YXJkIChwb3N0LWJyYW5jaCkgZGlyZWN0aW9uIHRocm91Z2ggdGhlIGBBU1RgIG5vZGUuXG4gIFNFTV9QUkU6IDIwMCxcbiAgU0VNX1BPU1Q6IDIwMSxcbiAgLy8gVXNlZCBieSB0aGUgdXNlcidzIGNhbGxiYWNrIGZ1bmN0aW9ucyB0byBpbmRpY2F0ZSB0byB0aGUgYEFTVGAgdHJhbnNsYXRvciAoc2VtYW50aWMgYW5hbHlzaXMpIGhvdyB0byBwcm9jZWVkLlxuICAvLyAtICpTRU1fT0sqIC0gbm9ybWFsIHJldHVybiB2YWx1ZVxuICAvLyAtICpTRU1fU0tJUCogLSBpZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgdGhpcyB2YWx1ZSBmcm9tIHRoZSBTRU1fUFJFIHN0YXRlLFxuICAvLyB0aGUgdHJhbnNsYXRvciB3aWxsIHNraXAgcHJvY2Vzc2luZyBhbGwgYEFTVGAgbm9kZXMgaW4gdGhlIGJyYW5jaCBiZWxvdyB0aGUgY3VycmVudCBub2RlLlxuICAvLyBJZ25vcmVkIGlmIHJldHVybmVkIGZyb20gdGhlIFNFTV9QT1NUIHN0YXRlLlxuICBTRU1fT0s6IDMwMCxcbiAgU0VNX1NLSVA6IDMwMSxcbiAgLy8gVXNlZCBpbiBhdHRyaWJ1dGUgZ2VuZXJhdGlvbiB0byBkaXN0aW5ndWlzaCB0aGUgbmVjZXNzYXJ5IGF0dHJpYnV0ZSBjYXRlZ29yaWVzLlxuICAvLyAtICpBVFRSX04qIC0gbm9uLXJlY3Vyc2l2ZVxuICAvLyAtICpBVFRSX1IqIC0gcmVjdXJzaXZlXG4gIC8vIC0gKkFUVFJfTVIqIC0gYmVsb25ncyB0byBhIG11dHVhbGx5LXJlY3Vyc2l2ZSBzZXRcbiAgQVRUUl9OOiA0MDAsXG4gIEFUVFJfUjogNDAxLFxuICBBVFRSX01SOiA0MDIsXG4gIC8vIExvb2sgYXJvdW5kIHZhbHVlcyBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBwYXJzZXIgaXMgaW4gbG9vayBhaGVhZCBvciBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBVc2VkIGJ5IHRoZSB0cmFjaW5nIGZhY2lsaXR5IHRvIGluZGljYXRlIHRoZSBsb29rIGFyb3VuZCBtb2RlIGluIHRoZSB0cmFjZSByZWNvcmRzIGRpc3BsYXkuXG4gIC8vIC0gKkxPT0tBUk9VTkRfTk9ORSogLSB0aGUgcGFyc2VyIGlzIGluIG5vcm1hbCBwYXJzaW5nIG1vZGVcbiAgLy8gLSAqTE9PS0FST1VORF9BSEVBRCogLSB0aGUgcGFyc2UgaXMgaW4gbG9vay1haGVhZCBtb2RlLCBwaHJhc2UgbWF0Y2hpbmcgZm9yIG9wZXJhdG9yIGBBTkQoJilgIG9yIGBOT1QoISlgXG4gIC8vIC0gKkxPT0tBUk9VTkRfQkVISU5EKiAtIHRoZSBwYXJzZSBpcyBpbiBsb29rLWJlaGluZCBtb2RlLCBwaHJhc2UgbWF0Y2hpbmcgZm9yIG9wZXJhdG9yIGBCS0EoJiYpYCBvciBgQktOKCEhKWBcbiAgTE9PS0FST1VORF9OT05FOiA1MDAsXG4gIExPT0tBUk9VTkRfQUhFQUQ6IDUwMSxcbiAgTE9PS0FST1VORF9CRUhJTkQ6IDUwMixcbiAgLy8gQmFjayByZWZlcmVuY2UgcnVsZSBtb2RlIGluZGljYXRvcnNcbiAgLy8gLSAqQktSX01PREVfVU0qIC0gdGhlIGJhY2sgcmVmZXJlbmNlIGlzIHVzaW5nIHVuaXZlcnNhbCBtb2RlXG4gIC8vIC0gKkJLUl9NT0RFX1BNKiAtIHRoZSBiYWNrIHJlZmVyZW5jZSBpcyB1c2luZyBwYXJlbnQgZnJhbWUgbW9kZVxuICAvLyAtICpCS1JfTU9ERV9DUyogLSB0aGUgYmFjayByZWZlcmVuY2UgaXMgdXNpbmcgY2FzZS1zZW5zaXRpdmUgcGhyYXNlIG1hdGNoaW5nXG4gIC8vIC0gKkJLUl9NT0RFX0NJKiAtIHRoZSBiYWNrIHJlZmVyZW5jZSBpcyB1c2luZyBjYXNlLWluc2Vuc2l0aXZlIHBocmFzZSBtYXRjaGluZ1xuICBCS1JfTU9ERV9VTTogNjAxLFxuICBCS1JfTU9ERV9QTTogNjAyLFxuICBCS1JfTU9ERV9DUzogNjAzLFxuICBCS1JfTU9ERV9DSTogNjA0LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js":
/*!*********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/node-exports.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module serves to export all library objects and object constructors with the `require(\"apg-lib\")` statement.\n// For example, to create a new parser in your program,\n// ````\n// let apglib = require(\"../apg-lib/node-exports\");\n// let my-parser = new apglib.parser();\n// ````\nmodule.exports = {\n  ast: __webpack_require__(/*! ./ast */ \"(ssr)/./node_modules/apg-js/src/apg-lib/ast.js\"),\n  circular: __webpack_require__(/*! ./circular-buffer */ \"(ssr)/./node_modules/apg-js/src/apg-lib/circular-buffer.js\"),\n  ids: __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\"),\n  parser: __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/apg-js/src/apg-lib/parser.js\"),\n  stats: __webpack_require__(/*! ./stats */ \"(ssr)/./node_modules/apg-js/src/apg-lib/stats.js\"),\n  trace: __webpack_require__(/*! ./trace */ \"(ssr)/./node_modules/apg-js/src/apg-lib/trace.js\"),\n  utils: __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\"),\n  emitcss: __webpack_require__(/*! ./emitcss */ \"(ssr)/./node_modules/apg-js/src/apg-lib/emitcss.js\"),\n  style: __webpack_require__(/*! ./style */ \"(ssr)/./node_modules/apg-js/src/apg-lib/style.js\"),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL25vZGUtZXhwb3J0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLDZEQUFPO0FBQ3RCLFlBQVksbUJBQU8sQ0FBQyxxRkFBbUI7QUFDdkMsT0FBTyxtQkFBTyxDQUFDLDZFQUFlO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxtRUFBVTtBQUM1QixTQUFTLG1CQUFPLENBQUMsaUVBQVM7QUFDMUIsU0FBUyxtQkFBTyxDQUFDLGlFQUFTO0FBQzFCLFNBQVMsbUJBQU8sQ0FBQyx5RUFBYTtBQUM5QixXQUFXLG1CQUFPLENBQUMscUVBQVc7QUFDOUIsU0FBUyxtQkFBTyxDQUFDLGlFQUFTO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9ub2RlLWV4cG9ydHMuanM/NmRiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBzZXJ2ZXMgdG8gZXhwb3J0IGFsbCBsaWJyYXJ5IG9iamVjdHMgYW5kIG9iamVjdCBjb25zdHJ1Y3RvcnMgd2l0aCB0aGUgYHJlcXVpcmUoXCJhcGctbGliXCIpYCBzdGF0ZW1lbnQuXG4vLyBGb3IgZXhhbXBsZSwgdG8gY3JlYXRlIGEgbmV3IHBhcnNlciBpbiB5b3VyIHByb2dyYW0sXG4vLyBgYGBgXG4vLyBsZXQgYXBnbGliID0gcmVxdWlyZShcIi4uL2FwZy1saWIvbm9kZS1leHBvcnRzXCIpO1xuLy8gbGV0IG15LXBhcnNlciA9IG5ldyBhcGdsaWIucGFyc2VyKCk7XG4vLyBgYGBgXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXN0OiByZXF1aXJlKCcuL2FzdCcpLFxuICBjaXJjdWxhcjogcmVxdWlyZSgnLi9jaXJjdWxhci1idWZmZXInKSxcbiAgaWRzOiByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyksXG4gIHBhcnNlcjogcmVxdWlyZSgnLi9wYXJzZXInKSxcbiAgc3RhdHM6IHJlcXVpcmUoJy4vc3RhdHMnKSxcbiAgdHJhY2U6IHJlcXVpcmUoJy4vdHJhY2UnKSxcbiAgdXRpbHM6IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyksXG4gIGVtaXRjc3M6IHJlcXVpcmUoJy4vZW1pdGNzcycpLFxuICBzdHlsZTogcmVxdWlyZSgnLi9zdHlsZScpLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/parser.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable new-cap */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This is the primary object of `apg-lib`. Calling its `parse()` member function\n// walks the parse tree of opcodes, matching phrases from the input string as it goes.\n// The working code for all of the operators, `ALT`, `CAT`, etc. is in this module.\nmodule.exports = function parser() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n\n  const thisFileName = 'parser.js: ';\n  const thisThis = this;\n  let opExecute;\n  this.ast = null;\n  this.stats = null;\n  this.trace = null;\n  this.callbacks = [];\n  let opcodes = null;\n  let chars = null;\n  let charsBegin;\n  let charsLength;\n  let charsEnd;\n  let lookAround;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let ruleCallbacks = null;\n  let udtCallbacks = null;\n  let rules = null;\n  let udts = null;\n  let syntaxData = null;\n  let maxMatched = 0;\n  let limitTreeDepth = Infinity;\n  let limitNodeHits = Infinity;\n  // Evaluates any given rule. This can be called from the syntax callback\n  // functions to evaluate any rule in the grammar's rule list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateRule = function evaluateRule(ruleIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateRule(): `;\n    if (ruleIndex >= rules.length) {\n      throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.RNM,\n      index: ruleIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  // Evaluates any given UDT. This can be called from the syntax callback\n  // functions to evaluate any UDT in the grammar's UDT list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateUdt = function (udtIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateUdt(): `;\n    if (udtIndex >= udts.length) {\n      throw new Error(`${functionName}udt index: ${udtIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.UDT,\n      empty: udts[udtIndex].empty,\n      index: udtIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  /* Clears this object of any/all data that has been initialized or added to it. */\n  /* Called by parse() on initialization, allowing this object to be re-used for multiple parsing calls. */\n  const clear = function () {\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    lookAround = [\n      {\n        lookAround: id.LOOKAROUND_NONE,\n        anchor: 0,\n        charsEnd: 0,\n        charsLength: 0,\n      },\n    ];\n    rules = null;\n    udts = null;\n    chars = null;\n    charsBegin = 0;\n    charsLength = 0;\n    charsEnd = 0;\n    ruleCallbacks = null;\n    udtCallbacks = null;\n    syntaxData = null;\n    opcodes = null;\n  };\n  /* object for maintaining a stack of back reference frames */\n  const backRef = function () {\n    const stack = [];\n    const init = function () {\n      const obj = {};\n      rules.forEach((rule) => {\n        if (rule.isBkr) {\n          obj[rule.lower] = null;\n        }\n      });\n      if (udts.length > 0) {\n        udts.forEach((udt) => {\n          if (udt.isBkr) {\n            obj[udt.lower] = null;\n          }\n        });\n      }\n      stack.push(obj);\n    };\n    const copy = function () {\n      const top = stack[stack.length - 1];\n      const obj = {};\n      /* // eslint-disable-next-line no-restricted-syntax */\n      for (const name in top) {\n        obj[name] = top[name];\n      }\n      return obj;\n    };\n    this.push = function push() {\n      stack.push(copy());\n    };\n    this.pop = function pop(lengthArg) {\n      let length = lengthArg;\n      if (!length) {\n        length = stack.length - 1;\n      }\n      if (length < 1 || length > stack.length) {\n        throw new Error(`${thisFileName}backRef.pop(): bad length: ${length}`);\n      }\n      stack.length = length;\n      return stack[stack.length - 1];\n    };\n    this.length = function length() {\n      return stack.length;\n    };\n    this.savePhrase = function savePhrase(name, index, length) {\n      stack[stack.length - 1][name] = {\n        phraseIndex: index,\n        phraseLength: length,\n      };\n    };\n    this.getPhrase = function (name) {\n      return stack[stack.length - 1][name];\n    };\n    /* constructor */\n    init();\n  };\n  // The system data structure that relays system information to and from the rule and UDT callback functions.\n  // - *state* - the state of the parser, ACTIVE, MATCH, EMPTY or NOMATCH (see the `identifiers` object in\n  // [`apg-lib`](https://github.com/ldthomas/apg-js2-lib))\n  // - *phraseLength* - the number of characters matched if the state is MATCHED or EMPTY\n  // - *lookaround* - the top of the stack holds the current look around state,\n  // LOOKAROUND_NONE, LOOKAROUND_AHEAD or LOOKAROUND_BEHIND,\n  // - *uFrame* - the \"universal\" back reference frame.\n  // Holds the last matched phrase for each of the back referenced rules and UDTs.\n  // - *pFrame* - the stack of \"parent\" back reference frames.\n  // Holds the matched phrase from the parent frame of each back referenced rules and UDTs.\n  // - *evaluateRule* - a reference to this object's `evaluateRule()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  // - *evaluateUdt* - a reference to this object's `evaluateUdt()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  const systemData = function systemData() {\n    const thisData = this;\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.ruleIndex = 0;\n    this.udtIndex = 0;\n    this.lookAround = lookAround[lookAround.length - 1];\n    this.uFrame = new backRef();\n    this.pFrame = new backRef();\n    this.evaluateRule = evaluateRule;\n    this.evaluateUdt = evaluateUdt;\n    /* refresh the parser state for the next operation */\n    this.refresh = function refresh() {\n      thisData.state = id.ACTIVE;\n      thisData.phraseLength = 0;\n      thisData.lookAround = lookAround[lookAround.length - 1];\n    };\n  };\n  /* some look around helper functions */\n  const lookAroundValue = function lookAroundValue() {\n    return lookAround[lookAround.length - 1];\n  };\n  /* return true if parser is in look around (ahead or behind) state */\n  const inLookAround = function inLookAround() {\n    return lookAround.length > 1;\n  };\n  /* return true if parser is in look behind state */\n  const inLookBehind = function () {\n    return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;\n  };\n  /* called by parse() to initialize the AST object, if one has been defined */\n  const initializeAst = function () {\n    const functionName = `${thisFileName}initializeAst(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.ast === undefined) {\n        thisThis.ast = null;\n        break;\n      }\n      if (thisThis.ast === null) {\n        break;\n      }\n      if (thisThis.ast.astObject !== 'astObject') {\n        throw new Error(`${functionName}ast object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.ast !== null) {\n      thisThis.ast.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the trace object, if one has been defined */\n  const initializeTrace = function () {\n    const functionName = `${thisFileName}initializeTrace(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.trace === undefined) {\n        thisThis.trace = null;\n        break;\n      }\n      if (thisThis.trace === null) {\n        break;\n      }\n      if (thisThis.trace.traceObject !== 'traceObject') {\n        throw new Error(`${functionName}trace object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.trace !== null) {\n      thisThis.trace.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the statistics object, if one has been defined */\n  const initializeStats = function () {\n    const functionName = `${thisFileName}initializeStats(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.stats === undefined) {\n        thisThis.stats = null;\n        break;\n      }\n      if (thisThis.stats === null) {\n        break;\n      }\n      if (thisThis.stats.statsObject !== 'statsObject') {\n        throw new Error(`${functionName}stats object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.stats !== null) {\n      thisThis.stats.init(rules, udts);\n    }\n  };\n  /* called by parse() to initialize the rules & udts from the grammar object */\n  /* (the grammar object generated previously by apg) */\n  const initializeGrammar = function (grammar) {\n    const functionName = `${thisFileName}initializeGrammar(): `;\n    if (!grammar) {\n      throw new Error(`${functionName}grammar object undefined`);\n    }\n    if (grammar.grammarObject !== 'grammarObject') {\n      throw new Error(`${functionName}bad grammar object`);\n    }\n    rules = grammar.rules;\n    udts = grammar.udts;\n  };\n  /* called by parse() to initialize the start rule */\n  const initializeStartRule = function (startRule) {\n    const functionName = `${thisFileName}initializeStartRule(): `;\n    let start = null;\n    if (typeof startRule === 'number') {\n      if (startRule >= rules.length) {\n        throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);\n      }\n      start = startRule;\n    } else if (typeof startRule === 'string') {\n      const lower = startRule.toLowerCase();\n      for (let i = 0; i < rules.length; i += 1) {\n        if (lower === rules[i].lower) {\n          start = rules[i].index;\n          break;\n        }\n      }\n      if (start === null) {\n        throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n      }\n    } else {\n      throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);\n    }\n    return start;\n  };\n  /* called by parse() to initialize the array of characters codes representing the input string */\n  const initializeInputChars = function initializeInputChars(inputArg, begArg, lenArg) {\n    const functionName = `${thisFileName}initializeInputChars(): `;\n    /* varify and normalize input */\n    let input = inputArg;\n    let beg = begArg;\n    let len = lenArg;\n    if (input === undefined) {\n      throw new Error(`${functionName}input string is undefined`);\n    }\n    if (input === null) {\n      throw new Error(`${functionName}input string is null`);\n    }\n    if (typeof input === 'string') {\n      input = utils.stringToChars(input);\n    } else if (!Array.isArray(input)) {\n      throw new Error(`${functionName}input string is not a string or array`);\n    }\n    if (input.length > 0) {\n      if (typeof input[0] !== 'number') {\n        throw new Error(`${functionName}input string not an array of integers`);\n      }\n    }\n    /* verify and normalize beginning index */\n    if (typeof beg !== 'number') {\n      beg = 0;\n    } else {\n      beg = Math.floor(beg);\n      if (beg < 0 || beg > input.length) {\n        throw new Error(`${functionName}input beginning index out of range: ${beg}`);\n      }\n    }\n    /* verify and normalize input length */\n    if (typeof len !== 'number') {\n      len = input.length - beg;\n    } else {\n      len = Math.floor(len);\n      if (len < 0 || len > input.length - beg) {\n        throw new Error(`${functionName}input length out of range: ${len}`);\n      }\n    }\n    chars = input;\n    charsBegin = beg;\n    charsLength = len;\n    charsEnd = charsBegin + charsLength;\n  };\n  /* called by parse() to initialize the user-written, syntax callback functions, if any */\n  const initializeCallbacks = function () {\n    const functionName = `${thisFileName}initializeCallbacks(): `;\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = null;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = null;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in thisThis.callbacks) {\n      i = list.indexOf(index.toLowerCase());\n      if (i < 0) {\n        throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n      }\n      func = thisThis.callbacks[index];\n      if (!func) {\n        func = null;\n      }\n      if (typeof func === 'function' || func === null) {\n        if (i < rules.length) {\n          ruleCallbacks[i] = func;\n        } else {\n          udtCallbacks[i - rules.length] = func;\n        }\n      } else {\n        throw new Error(\n          `${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`\n        );\n      }\n    }\n    /* make sure all udts have been defined - the parser can't work without them */\n    for (i = 0; i < udts.length; i += 1) {\n      if (udtCallbacks[i] === null) {\n        throw new Error(\n          `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`\n        );\n      }\n    }\n  };\n  // Set the maximum parse tree depth allowed. The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // depth - max allowed parse tree depth. An exception is thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxTreeDepth = function (depth) {\n    if (typeof depth !== 'number') {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n    limitTreeDepth = Math.floor(depth);\n    if (limitTreeDepth <= 0) {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n  };\n  // Set the maximum number of node hits (parser unit steps or opcode function calls) allowed.\n  // The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // hits - maximum number of node hits or parser unit steps allowed.\n  // An exception thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxNodeHits = function (hits) {\n    if (typeof hits !== 'number') {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n    limitNodeHits = Math.floor(hits);\n    if (limitNodeHits <= 0) {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n  };\n  /* the main parser function */\n  const privateParse = function (grammar, startRuleArg, callbackData) {\n    let success;\n    const functionName = `${thisFileName}parse(): `;\n    initializeGrammar(grammar);\n    const startRule = initializeStartRule(startRuleArg);\n    initializeCallbacks();\n    initializeTrace();\n    initializeStats();\n    initializeAst();\n    const sysData = new systemData();\n    if (!(callbackData === undefined || callbackData === null)) {\n      syntaxData = callbackData;\n    }\n    /* create a dummy opcode for the start rule */\n    opcodes = [\n      {\n        type: id.RNM,\n        index: startRule,\n      },\n    ];\n    /* execute the start rule */\n    opExecute(0, charsBegin, sysData);\n    opcodes = null;\n    /* test and return the sysData */\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === charsLength) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      length: charsLength,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits,\n      inputLength: chars.length,\n      subBegin: charsBegin,\n      subEnd: charsEnd,\n      subLength: charsLength,\n    };\n  };\n\n  // This form allows parsing of a sub-string of the full input string.\n  // <ul>\n  // <li>*inputIndex* - index of the first character in the sub-string</li>\n  // <li>*inputLength* - length of the sub-string</li>\n  // </ul>\n  // All other parameters as for the above function `parse()`.\n  this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {\n    clear();\n    initializeInputChars(inputChars, inputIndex, inputLength);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // This is the main function, called to parse an input string.\n  // <ul>\n  // <li>*grammar* - an instantiated grammar object - the output of `apg` for a\n  // specific SABNF grammar</li>\n  // <li>*startRule* - the rule name or rule index to be used as the root of the\n  // parse tree. This is usually the first rule, index = 0, of the grammar\n  // but can be any rule defined in the above grammar object.</li>\n  // <li>*inputChars* - the input string. Can be a string or an array of integer character codes representing the\n  // string.</li>\n  // <li>*callbackData* - user-defined data object to be passed to the user's\n  // callback functions.\n  // This is not used by the parser in any way, merely passed on to the user.\n  // May be `null` or omitted.</li>\n  // </ul>\n  this.parse = function parse(grammar, startRule, inputChars, callbackData) {\n    clear();\n    initializeInputChars(inputChars, 0, inputChars.length);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex, sysData);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    if (op.max === 0) {\n      // this is an empty-string acceptor\n      // deprecated: use the TLS empty string operator, \"\", instead\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex >= charsEnd) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = function (rule, sysData, charsLeft, down) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (down !== true) {\n          throw new Error(\n            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`\n          );\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions, back references and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  // See [`ast.js`](./ast.html) for usage.\n  const opRNM = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back references */\n      astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(op.index, rules[op.index].name);\n      }\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    if (callback === null) {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    } else {\n      /* call user's callback */\n      const charsLeft = charsEnd - phraseIndex;\n      sysData.ruleIndex = rule.index;\n      callback(sysData, chars, phraseIndex, syntaxData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex, sysData);\n        opcodes = savedOpcodes;\n        sysData.ruleIndex = rule.index;\n        callback(sysData, chars, phraseIndex, syntaxData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    }\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (rule.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = function (udt, sysData, charsLeft) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);\n      case id.EMPTY:\n        if (udt.empty === false) {\n          throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n        } else {\n          sysData.phraseLength = 0;\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty === false) {\n            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n          } else {\n            sysData.state = id.EMPTY;\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back reference */\n      astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(astIndex, udt.name);\n      }\n      /* NOTE: push and pop of the back reference frame is normally not necessary */\n      /* only in the case that the UDT calls evaluateRule() or evaluateUdt() */\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    /* call the UDT */\n    const charsLeft = charsEnd - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (udt.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opAND: invalid state ${sysData.state}`);\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < charsEnd) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `ABG` operator.<br>\n  // This is an \"anchor\" for the beginning of the string, similar to the familiar regex `^` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` is 0, NOMATCH otherwise.\n  const opABG = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;\n  };\n  // The `AEN` operator.<br>\n  // This is an \"anchor\" for the end of the string, similar to the familiar regex `$` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` equals the input string length, NOMATCH otherwise.\n  const opAEN = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;\n  };\n  // The `BKR` operator.<br>\n  // The back reference operator.\n  // Matches the last matched phrase of the named rule or UDT against the input string.\n  // For ASCII alphbetical characters the match may be case sensitive (`%s`) or insensitive (`%i`),\n  // depending on the back reference definition.\n  // For `universal` mode (`%u`) matches the last phrase found anywhere in the grammar.\n  // For `parent frame` mode (`%p`) matches the last phrase found in the parent rule only.\n  const opBKR = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The `BKA` operator.<br>\n  // This is the positive `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKA = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opBKA: invalid state ${sysData.state}`);\n    }\n  };\n  // The `BKN` operator.<br>\n  // This is the negative `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is *not* found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKN = function (opIndex, phraseIndex, sysData) {\n    // let op;\n    // op = opcodes[opIndex];\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opBKN: invalid state ${sysData.state}`);\n    }\n  };\n  // The right-to-left `CAT` operator.<br>\n  // Called for `CAT` operators when in look behind mode.\n  // Calls its child nodes from right to left concatenating matched phrases right to left.\n  const opCATBehind = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catMatched;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catMatched = 0;\n    // catPhrase = 0;\n    for (let i = op.children.length - 1; i >= 0; i -= 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      catCharIndex -= sysData.phraseLength;\n      catMatched += sysData.phraseLength;\n      // catPhrase += sysData.phraseLength;\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      }\n    }\n    if (success) {\n      sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catMatched;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `REP` operator.<br>\n  // Called for `REP` operators in look behind mode.\n  // Makes repeated calls to its child node, concatenating matched phrases right to left.\n  const opREPBehind = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex <= 0) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex -= sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `TRG` operator.<br>\n  // Called for `TRG` operators in look behind mode.\n  // Matches a single character at `phraseIndex - 1` to the `min` - `max` range.\n  const opTRGBehind = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (phraseIndex > 0) {\n      const char = chars[phraseIndex - 1];\n      if (op.min <= char && char <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The right-to-left `TBS` operator.<br>\n  // Called for `TBS` operators in look behind mode.\n  // Matches the `TBS` phrase to the left of `phraseIndex`.\n  const opTBSBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[beg + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left `TLS` operator.<br>\n  // Called for `TLS` operators in look behind mode.\n  // Matches the `TLS` phrase to the left of `phraseIndex`.\n  const opTLSBehind = function (opIndex, phraseIndex, sysData) {\n    let char;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (let i = 0; i < len; i += 1) {\n        char = chars[beg + i];\n        if (char >= 65 && char <= 90) {\n          char += 32;\n        }\n        if (char !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left back reference operator.<br>\n  // Matches the back referenced phrase to the left of `phraseIndex`.\n  const opBKRBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    /* NOMATCH default */\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // Generalized execution function.<br>\n  // Having a single, generalized function, allows a single location\n  // for tracing and statistics gathering functions to be called.\n  // Tracing and statistics are handled in separate objects.\n  // However, the parser calls their API to build the object data records.\n  // See [`trace.js`](./trace.html) and [`stats.js`](./stats.html) for their\n  // usage.\n  opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {\n    let ret = true;\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (nodeHits > limitNodeHits) {\n      throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);\n    }\n    treeDepth += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n      if (maxTreeDepth > limitTreeDepth) {\n        throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);\n      }\n    }\n    sysData.refresh();\n    if (thisThis.trace !== null) {\n      /* collect the trace record for down the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    if (inLookBehind()) {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCATBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREPBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRGBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKRBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    } else {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCAT(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREP(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRG(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBS(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLS(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKR(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    }\n    if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {\n      maxMatched = phraseIndex + sysData.phraseLength;\n    }\n    if (thisThis.stats !== null) {\n      /* collect the statistics */\n      thisThis.stats.collect(op, sysData);\n    }\n    if (thisThis.trace !== null) {\n      /* collect the trace record for up the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    treeDepth -= 1;\n    return ret;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNkVBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLHlCQUF5QixhQUFhLGNBQWMsV0FBVztBQUMvRDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDbkU7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLHlCQUF5QixhQUFhLGFBQWEsVUFBVTtBQUM3RDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDbkU7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZUFBZTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9wYXJzZXIuanM/NjQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIGlzIHRoZSBwcmltYXJ5IG9iamVjdCBvZiBgYXBnLWxpYmAuIENhbGxpbmcgaXRzIGBwYXJzZSgpYCBtZW1iZXIgZnVuY3Rpb25cbi8vIHdhbGtzIHRoZSBwYXJzZSB0cmVlIG9mIG9wY29kZXMsIG1hdGNoaW5nIHBocmFzZXMgZnJvbSB0aGUgaW5wdXQgc3RyaW5nIGFzIGl0IGdvZXMuXG4vLyBUaGUgd29ya2luZyBjb2RlIGZvciBhbGwgb2YgdGhlIG9wZXJhdG9ycywgYEFMVGAsIGBDQVRgLCBldGMuIGlzIGluIHRoaXMgbW9kdWxlLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXIoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xuICBjb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyk7XG5cbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3BhcnNlci5qczogJztcbiAgY29uc3QgdGhpc1RoaXMgPSB0aGlzO1xuICBsZXQgb3BFeGVjdXRlO1xuICB0aGlzLmFzdCA9IG51bGw7XG4gIHRoaXMuc3RhdHMgPSBudWxsO1xuICB0aGlzLnRyYWNlID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgbGV0IG9wY29kZXMgPSBudWxsO1xuICBsZXQgY2hhcnMgPSBudWxsO1xuICBsZXQgY2hhcnNCZWdpbjtcbiAgbGV0IGNoYXJzTGVuZ3RoO1xuICBsZXQgY2hhcnNFbmQ7XG4gIGxldCBsb29rQXJvdW5kO1xuICBsZXQgdHJlZURlcHRoID0gMDtcbiAgbGV0IG1heFRyZWVEZXB0aCA9IDA7XG4gIGxldCBub2RlSGl0cyA9IDA7XG4gIGxldCBydWxlQ2FsbGJhY2tzID0gbnVsbDtcbiAgbGV0IHVkdENhbGxiYWNrcyA9IG51bGw7XG4gIGxldCBydWxlcyA9IG51bGw7XG4gIGxldCB1ZHRzID0gbnVsbDtcbiAgbGV0IHN5bnRheERhdGEgPSBudWxsO1xuICBsZXQgbWF4TWF0Y2hlZCA9IDA7XG4gIGxldCBsaW1pdFRyZWVEZXB0aCA9IEluZmluaXR5O1xuICBsZXQgbGltaXROb2RlSGl0cyA9IEluZmluaXR5O1xuICAvLyBFdmFsdWF0ZXMgYW55IGdpdmVuIHJ1bGUuIFRoaXMgY2FuIGJlIGNhbGxlZCBmcm9tIHRoZSBzeW50YXggY2FsbGJhY2tcbiAgLy8gZnVuY3Rpb25zIHRvIGV2YWx1YXRlIGFueSBydWxlIGluIHRoZSBncmFtbWFyJ3MgcnVsZSBsaXN0LiBHcmVhdCBjYXV0aW9uXG4gIC8vIHNob3VsZCBiZSB1c2VkLiBVc2Ugb2YgdGhpcyBmdW5jdGlvbiB3aWxsIGFsdGVyIHRoZSBsYW5ndWFnZSB0aGF0IHRoZVxuICAvLyBwYXJzZXIgYWNjZXB0cy5cbiAgY29uc3QgZXZhbHVhdGVSdWxlID0gZnVuY3Rpb24gZXZhbHVhdGVSdWxlKHJ1bGVJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9ZXZhbHVhdGVSdWxlKCk6IGA7XG4gICAgaWYgKHJ1bGVJbmRleCA+PSBydWxlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9cnVsZSBpbmRleDogJHtydWxlSW5kZXh9IG91dCBvZiByYW5nZWApO1xuICAgIH1cbiAgICBpZiAocGhyYXNlSW5kZXggPj0gY2hhcnNFbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9cGhyYXNlIGluZGV4OiAke3BocmFzZUluZGV4fSBvdXQgb2YgcmFuZ2VgKTtcbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG9wY29kZXM7XG4gICAgb3Bjb2Rlcy5wdXNoKHtcbiAgICAgIHR5cGU6IGlkLlJOTSxcbiAgICAgIGluZGV4OiBydWxlSW5kZXgsXG4gICAgfSk7XG4gICAgb3BFeGVjdXRlKGxlbmd0aCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIG9wY29kZXMucG9wKCk7XG4gIH07XG4gIC8vIEV2YWx1YXRlcyBhbnkgZ2l2ZW4gVURULiBUaGlzIGNhbiBiZSBjYWxsZWQgZnJvbSB0aGUgc3ludGF4IGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBldmFsdWF0ZSBhbnkgVURUIGluIHRoZSBncmFtbWFyJ3MgVURUIGxpc3QuIEdyZWF0IGNhdXRpb25cbiAgLy8gc2hvdWxkIGJlIHVzZWQuIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgYWx0ZXIgdGhlIGxhbmd1YWdlIHRoYXQgdGhlXG4gIC8vIHBhcnNlciBhY2NlcHRzLlxuICBjb25zdCBldmFsdWF0ZVVkdCA9IGZ1bmN0aW9uICh1ZHRJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9ZXZhbHVhdGVVZHQoKTogYDtcbiAgICBpZiAodWR0SW5kZXggPj0gdWR0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9dWR0IGluZGV4OiAke3VkdEluZGV4fSBvdXQgb2YgcmFuZ2VgKTtcbiAgICB9XG4gICAgaWYgKHBocmFzZUluZGV4ID49IGNoYXJzRW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXBocmFzZSBpbmRleDogJHtwaHJhc2VJbmRleH0gb3V0IG9mIHJhbmdlYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBvcGNvZGVzO1xuICAgIG9wY29kZXMucHVzaCh7XG4gICAgICB0eXBlOiBpZC5VRFQsXG4gICAgICBlbXB0eTogdWR0c1t1ZHRJbmRleF0uZW1wdHksXG4gICAgICBpbmRleDogdWR0SW5kZXgsXG4gICAgfSk7XG4gICAgb3BFeGVjdXRlKGxlbmd0aCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIG9wY29kZXMucG9wKCk7XG4gIH07XG4gIC8qIENsZWFycyB0aGlzIG9iamVjdCBvZiBhbnkvYWxsIGRhdGEgdGhhdCBoYXMgYmVlbiBpbml0aWFsaXplZCBvciBhZGRlZCB0byBpdC4gKi9cbiAgLyogQ2FsbGVkIGJ5IHBhcnNlKCkgb24gaW5pdGlhbGl6YXRpb24sIGFsbG93aW5nIHRoaXMgb2JqZWN0IHRvIGJlIHJlLXVzZWQgZm9yIG11bHRpcGxlIHBhcnNpbmcgY2FsbHMuICovXG4gIGNvbnN0IGNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRyZWVEZXB0aCA9IDA7XG4gICAgbWF4VHJlZURlcHRoID0gMDtcbiAgICBub2RlSGl0cyA9IDA7XG4gICAgbWF4TWF0Y2hlZCA9IDA7XG4gICAgbG9va0Fyb3VuZCA9IFtcbiAgICAgIHtcbiAgICAgICAgbG9va0Fyb3VuZDogaWQuTE9PS0FST1VORF9OT05FLFxuICAgICAgICBhbmNob3I6IDAsXG4gICAgICAgIGNoYXJzRW5kOiAwLFxuICAgICAgICBjaGFyc0xlbmd0aDogMCxcbiAgICAgIH0sXG4gICAgXTtcbiAgICBydWxlcyA9IG51bGw7XG4gICAgdWR0cyA9IG51bGw7XG4gICAgY2hhcnMgPSBudWxsO1xuICAgIGNoYXJzQmVnaW4gPSAwO1xuICAgIGNoYXJzTGVuZ3RoID0gMDtcbiAgICBjaGFyc0VuZCA9IDA7XG4gICAgcnVsZUNhbGxiYWNrcyA9IG51bGw7XG4gICAgdWR0Q2FsbGJhY2tzID0gbnVsbDtcbiAgICBzeW50YXhEYXRhID0gbnVsbDtcbiAgICBvcGNvZGVzID0gbnVsbDtcbiAgfTtcbiAgLyogb2JqZWN0IGZvciBtYWludGFpbmluZyBhIHN0YWNrIG9mIGJhY2sgcmVmZXJlbmNlIGZyYW1lcyAqL1xuICBjb25zdCBiYWNrUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgY29uc3QgaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgICBpZiAocnVsZS5pc0Jrcikge1xuICAgICAgICAgIG9ialtydWxlLmxvd2VyXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgICB1ZHRzLmZvckVhY2goKHVkdCkgPT4ge1xuICAgICAgICAgIGlmICh1ZHQuaXNCa3IpIHtcbiAgICAgICAgICAgIG9ialt1ZHQubG93ZXJdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RhY2sucHVzaChvYmopO1xuICAgIH07XG4gICAgY29uc3QgY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAvKiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0b3ApIHtcbiAgICAgICAgb2JqW25hbWVdID0gdG9wW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICBzdGFjay5wdXNoKGNvcHkoKSk7XG4gICAgfTtcbiAgICB0aGlzLnBvcCA9IGZ1bmN0aW9uIHBvcChsZW5ndGhBcmcpIHtcbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhBcmc7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA8IDEgfHwgbGVuZ3RoID4gc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9YmFja1JlZi5wb3AoKTogYmFkIGxlbmd0aDogJHtsZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICBzdGFjay5sZW5ndGggPSBsZW5ndGg7XG4gICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICB0aGlzLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XG4gICAgfTtcbiAgICB0aGlzLnNhdmVQaHJhc2UgPSBmdW5jdGlvbiBzYXZlUGhyYXNlKG5hbWUsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdW25hbWVdID0ge1xuICAgICAgICBwaHJhc2VJbmRleDogaW5kZXgsXG4gICAgICAgIHBocmFzZUxlbmd0aDogbGVuZ3RoLFxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UGhyYXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXVtuYW1lXTtcbiAgICB9O1xuICAgIC8qIGNvbnN0cnVjdG9yICovXG4gICAgaW5pdCgpO1xuICB9O1xuICAvLyBUaGUgc3lzdGVtIGRhdGEgc3RydWN0dXJlIHRoYXQgcmVsYXlzIHN5c3RlbSBpbmZvcm1hdGlvbiB0byBhbmQgZnJvbSB0aGUgcnVsZSBhbmQgVURUIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gLSAqc3RhdGUqIC0gdGhlIHN0YXRlIG9mIHRoZSBwYXJzZXIsIEFDVElWRSwgTUFUQ0gsIEVNUFRZIG9yIE5PTUFUQ0ggKHNlZSB0aGUgYGlkZW50aWZpZXJzYCBvYmplY3QgaW5cbiAgLy8gW2BhcGctbGliYF0oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qczItbGliKSlcbiAgLy8gLSAqcGhyYXNlTGVuZ3RoKiAtIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBtYXRjaGVkIGlmIHRoZSBzdGF0ZSBpcyBNQVRDSEVEIG9yIEVNUFRZXG4gIC8vIC0gKmxvb2thcm91bmQqIC0gdGhlIHRvcCBvZiB0aGUgc3RhY2sgaG9sZHMgdGhlIGN1cnJlbnQgbG9vayBhcm91bmQgc3RhdGUsXG4gIC8vIExPT0tBUk9VTkRfTk9ORSwgTE9PS0FST1VORF9BSEVBRCBvciBMT09LQVJPVU5EX0JFSElORCxcbiAgLy8gLSAqdUZyYW1lKiAtIHRoZSBcInVuaXZlcnNhbFwiIGJhY2sgcmVmZXJlbmNlIGZyYW1lLlxuICAvLyBIb2xkcyB0aGUgbGFzdCBtYXRjaGVkIHBocmFzZSBmb3IgZWFjaCBvZiB0aGUgYmFjayByZWZlcmVuY2VkIHJ1bGVzIGFuZCBVRFRzLlxuICAvLyAtICpwRnJhbWUqIC0gdGhlIHN0YWNrIG9mIFwicGFyZW50XCIgYmFjayByZWZlcmVuY2UgZnJhbWVzLlxuICAvLyBIb2xkcyB0aGUgbWF0Y2hlZCBwaHJhc2UgZnJvbSB0aGUgcGFyZW50IGZyYW1lIG9mIGVhY2ggYmFjayByZWZlcmVuY2VkIHJ1bGVzIGFuZCBVRFRzLlxuICAvLyAtICpldmFsdWF0ZVJ1bGUqIC0gYSByZWZlcmVuY2UgdG8gdGhpcyBvYmplY3QncyBgZXZhbHVhdGVSdWxlKClgIGZ1bmN0aW9uLlxuICAvLyBDYW4gYmUgY2FsbGVkIGZyb20gYSBjYWxsYmFjayBmdW5jdGlvbiAodXNlIHdpdGggZXh0cmVtZSBjYXV0aW9uISlcbiAgLy8gLSAqZXZhbHVhdGVVZHQqIC0gYSByZWZlcmVuY2UgdG8gdGhpcyBvYmplY3QncyBgZXZhbHVhdGVVZHQoKWAgZnVuY3Rpb24uXG4gIC8vIENhbiBiZSBjYWxsZWQgZnJvbSBhIGNhbGxiYWNrIGZ1bmN0aW9uICh1c2Ugd2l0aCBleHRyZW1lIGNhdXRpb24hKVxuICBjb25zdCBzeXN0ZW1EYXRhID0gZnVuY3Rpb24gc3lzdGVtRGF0YSgpIHtcbiAgICBjb25zdCB0aGlzRGF0YSA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZSA9IGlkLkFDVElWRTtcbiAgICB0aGlzLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5ydWxlSW5kZXggPSAwO1xuICAgIHRoaXMudWR0SW5kZXggPSAwO1xuICAgIHRoaXMubG9va0Fyb3VuZCA9IGxvb2tBcm91bmRbbG9va0Fyb3VuZC5sZW5ndGggLSAxXTtcbiAgICB0aGlzLnVGcmFtZSA9IG5ldyBiYWNrUmVmKCk7XG4gICAgdGhpcy5wRnJhbWUgPSBuZXcgYmFja1JlZigpO1xuICAgIHRoaXMuZXZhbHVhdGVSdWxlID0gZXZhbHVhdGVSdWxlO1xuICAgIHRoaXMuZXZhbHVhdGVVZHQgPSBldmFsdWF0ZVVkdDtcbiAgICAvKiByZWZyZXNoIHRoZSBwYXJzZXIgc3RhdGUgZm9yIHRoZSBuZXh0IG9wZXJhdGlvbiAqL1xuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB0aGlzRGF0YS5zdGF0ZSA9IGlkLkFDVElWRTtcbiAgICAgIHRoaXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzRGF0YS5sb29rQXJvdW5kID0gbG9va0Fyb3VuZFtsb29rQXJvdW5kLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gIH07XG4gIC8qIHNvbWUgbG9vayBhcm91bmQgaGVscGVyIGZ1bmN0aW9ucyAqL1xuICBjb25zdCBsb29rQXJvdW5kVmFsdWUgPSBmdW5jdGlvbiBsb29rQXJvdW5kVmFsdWUoKSB7XG4gICAgcmV0dXJuIGxvb2tBcm91bmRbbG9va0Fyb3VuZC5sZW5ndGggLSAxXTtcbiAgfTtcbiAgLyogcmV0dXJuIHRydWUgaWYgcGFyc2VyIGlzIGluIGxvb2sgYXJvdW5kIChhaGVhZCBvciBiZWhpbmQpIHN0YXRlICovXG4gIGNvbnN0IGluTG9va0Fyb3VuZCA9IGZ1bmN0aW9uIGluTG9va0Fyb3VuZCgpIHtcbiAgICByZXR1cm4gbG9va0Fyb3VuZC5sZW5ndGggPiAxO1xuICB9O1xuICAvKiByZXR1cm4gdHJ1ZSBpZiBwYXJzZXIgaXMgaW4gbG9vayBiZWhpbmQgc3RhdGUgKi9cbiAgY29uc3QgaW5Mb29rQmVoaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb29rQXJvdW5kW2xvb2tBcm91bmQubGVuZ3RoIC0gMV0ubG9va0Fyb3VuZCA9PT0gaWQuTE9PS0FST1VORF9CRUhJTkQ7XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIEFTVCBvYmplY3QsIGlmIG9uZSBoYXMgYmVlbiBkZWZpbmVkICovXG4gIGNvbnN0IGluaXRpYWxpemVBc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVBc3QoKTogYDtcbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgaWYgKHRoaXNUaGlzLmFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXNUaGlzLmFzdCA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLmFzdCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzVGhpcy5hc3QuYXN0T2JqZWN0ICE9PSAnYXN0T2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWFzdCBvYmplY3Qgbm90IHJlY29nbml6ZWRgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMuYXN0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzVGhpcy5hc3QuaW5pdChydWxlcywgdWR0cywgY2hhcnMpO1xuICAgIH1cbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhY2Ugb2JqZWN0LCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZCAqL1xuICBjb25zdCBpbml0aWFsaXplVHJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVUcmFjZSgpOiBgO1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAodGhpc1RoaXMudHJhY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzVGhpcy50cmFjZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLnRyYWNlID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLnRyYWNlLnRyYWNlT2JqZWN0ICE9PSAndHJhY2VPYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9dHJhY2Ugb2JqZWN0IG5vdCByZWNvZ25pemVkYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLnRyYWNlICE9PSBudWxsKSB7XG4gICAgICB0aGlzVGhpcy50cmFjZS5pbml0KHJ1bGVzLCB1ZHRzLCBjaGFycyk7XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSBzdGF0aXN0aWNzIG9iamVjdCwgaWYgb25lIGhhcyBiZWVuIGRlZmluZWQgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZVN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplU3RhdHMoKTogYDtcbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgaWYgKHRoaXNUaGlzLnN0YXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1RoaXMuc3RhdHMgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzVGhpcy5zdGF0cyA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzVGhpcy5zdGF0cy5zdGF0c09iamVjdCAhPT0gJ3N0YXRzT2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXN0YXRzIG9iamVjdCBub3QgcmVjb2duaXplZGApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzVGhpcy5zdGF0cyAhPT0gbnVsbCkge1xuICAgICAgdGhpc1RoaXMuc3RhdHMuaW5pdChydWxlcywgdWR0cyk7XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSBydWxlcyAmIHVkdHMgZnJvbSB0aGUgZ3JhbW1hciBvYmplY3QgKi9cbiAgLyogKHRoZSBncmFtbWFyIG9iamVjdCBnZW5lcmF0ZWQgcHJldmlvdXNseSBieSBhcGcpICovXG4gIGNvbnN0IGluaXRpYWxpemVHcmFtbWFyID0gZnVuY3Rpb24gKGdyYW1tYXIpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZUdyYW1tYXIoKTogYDtcbiAgICBpZiAoIWdyYW1tYXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9Z3JhbW1hciBvYmplY3QgdW5kZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmIChncmFtbWFyLmdyYW1tYXJPYmplY3QgIT09ICdncmFtbWFyT2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1iYWQgZ3JhbW1hciBvYmplY3RgKTtcbiAgICB9XG4gICAgcnVsZXMgPSBncmFtbWFyLnJ1bGVzO1xuICAgIHVkdHMgPSBncmFtbWFyLnVkdHM7XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHN0YXJ0IHJ1bGUgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZVN0YXJ0UnVsZSA9IGZ1bmN0aW9uIChzdGFydFJ1bGUpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZVN0YXJ0UnVsZSgpOiBgO1xuICAgIGxldCBzdGFydCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBzdGFydFJ1bGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoc3RhcnRSdWxlID49IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXN0YXJ0IHJ1bGUgaW5kZXggdG9vIGxhcmdlOiBtYXg6ICR7cnVsZXMubGVuZ3RofTogaW5kZXg6ICR7c3RhcnRSdWxlfWApO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydFJ1bGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhcnRSdWxlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbG93ZXIgPSBzdGFydFJ1bGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGxvd2VyID09PSBydWxlc1tpXS5sb3dlcikge1xuICAgICAgICAgIHN0YXJ0ID0gcnVsZXNbaV0uaW5kZXg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXN0YXJ0IHJ1bGUgbmFtZSAnJHtzdGFydFJ1bGV9JyBub3QgcmVjb2duaXplZGApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXR5cGUgb2Ygc3RhcnQgcnVsZSAnJHt0eXBlb2Ygc3RhcnRSdWxlfScgbm90IHJlY29nbml6ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSBhcnJheSBvZiBjaGFyYWN0ZXJzIGNvZGVzIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgc3RyaW5nICovXG4gIGNvbnN0IGluaXRpYWxpemVJbnB1dENoYXJzID0gZnVuY3Rpb24gaW5pdGlhbGl6ZUlucHV0Q2hhcnMoaW5wdXRBcmcsIGJlZ0FyZywgbGVuQXJnKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVJbnB1dENoYXJzKCk6IGA7XG4gICAgLyogdmFyaWZ5IGFuZCBub3JtYWxpemUgaW5wdXQgKi9cbiAgICBsZXQgaW5wdXQgPSBpbnB1dEFyZztcbiAgICBsZXQgYmVnID0gYmVnQXJnO1xuICAgIGxldCBsZW4gPSBsZW5Bcmc7XG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9aW5wdXQgc3RyaW5nIGlzIHVuZGVmaW5lZGApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9aW5wdXQgc3RyaW5nIGlzIG51bGxgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlucHV0ID0gdXRpbHMuc3RyaW5nVG9DaGFycyhpbnB1dCk7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9aW5wdXQgc3RyaW5nIGlzIG5vdCBhIHN0cmluZyBvciBhcnJheWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dFswXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgbm90IGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHZlcmlmeSBhbmQgbm9ybWFsaXplIGJlZ2lubmluZyBpbmRleCAqL1xuICAgIGlmICh0eXBlb2YgYmVnICE9PSAnbnVtYmVyJykge1xuICAgICAgYmVnID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYmVnID0gTWF0aC5mbG9vcihiZWcpO1xuICAgICAgaWYgKGJlZyA8IDAgfHwgYmVnID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9aW5wdXQgYmVnaW5uaW5nIGluZGV4IG91dCBvZiByYW5nZTogJHtiZWd9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHZlcmlmeSBhbmQgbm9ybWFsaXplIGlucHV0IGxlbmd0aCAqL1xuICAgIGlmICh0eXBlb2YgbGVuICE9PSAnbnVtYmVyJykge1xuICAgICAgbGVuID0gaW5wdXQubGVuZ3RoIC0gYmVnO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW4gPSBNYXRoLmZsb29yKGxlbik7XG4gICAgICBpZiAobGVuIDwgMCB8fCBsZW4gPiBpbnB1dC5sZW5ndGggLSBiZWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBsZW5ndGggb3V0IG9mIHJhbmdlOiAke2xlbn1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hhcnMgPSBpbnB1dDtcbiAgICBjaGFyc0JlZ2luID0gYmVnO1xuICAgIGNoYXJzTGVuZ3RoID0gbGVuO1xuICAgIGNoYXJzRW5kID0gY2hhcnNCZWdpbiArIGNoYXJzTGVuZ3RoO1xuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSB1c2VyLXdyaXR0ZW4sIHN5bnRheCBjYWxsYmFjayBmdW5jdGlvbnMsIGlmIGFueSAqL1xuICBjb25zdCBpbml0aWFsaXplQ2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplQ2FsbGJhY2tzKCk6IGA7XG4gICAgbGV0IGk7XG4gICAgcnVsZUNhbGxiYWNrcyA9IFtdO1xuICAgIHVkdENhbGxiYWNrcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgcnVsZUNhbGxiYWNrc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB1ZHRDYWxsYmFja3NbaV0gPSBudWxsO1xuICAgIH1cbiAgICBsZXQgZnVuYztcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsaXN0LnB1c2gocnVsZXNbaV0ubG93ZXIpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHVkdHNbaV0ubG93ZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluZGV4IGluIHRoaXNUaGlzLmNhbGxiYWNrcykge1xuICAgICAgaSA9IGxpc3QuaW5kZXhPZihpbmRleC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXN5bnRheCBjYWxsYmFjayAnJHtpbmRleH0nIG5vdCBhIHJ1bGUgb3IgdWR0IG5hbWVgKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSB0aGlzVGhpcy5jYWxsYmFja3NbaW5kZXhdO1xuICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nIHx8IGZ1bmMgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGkgPCBydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBydWxlQ2FsbGJhY2tzW2ldID0gZnVuYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1ZHRDYWxsYmFja3NbaSAtIHJ1bGVzLmxlbmd0aF0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7ZnVuY3Rpb25OYW1lfXN5bnRheCBjYWxsYmFja1ske2luZGV4fV0gbXVzdCBiZSBmdW5jdGlvbiByZWZlcmVuY2Ugb3IgJ2ZhbHNlJyAoZmFsc2UvbnVsbC91bmRlZmluZWQvZXRjLilgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIG1ha2Ugc3VyZSBhbGwgdWR0cyBoYXZlIGJlZW4gZGVmaW5lZCAtIHRoZSBwYXJzZXIgY2FuJ3Qgd29yayB3aXRob3V0IHRoZW0gKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHVkdENhbGxiYWNrc1tpXSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7ZnVuY3Rpb25OYW1lfWFsbCBVRFQgY2FsbGJhY2tzIG11c3QgYmUgZGVmaW5lZC4gVURUIGNhbGxiYWNrWyR7dWR0c1tpXS5sb3dlcn1dIG5vdCBhIGZ1bmN0aW9uIHJlZmVyZW5jZWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFNldCB0aGUgbWF4aW11bSBwYXJzZSB0cmVlIGRlcHRoIGFsbG93ZWQuIFRoZSBkZWZhdWx0IGlzIGBJbmZpbml0eWAuXG4gIC8vIEEgbGltaXQgaXMgbm90IG5vcm1hbGx5IG5lZWRlZCwgYnV0IGNhbiBiZSB1c2VkIHRvIHByb3RlY3QgYWdhaW5zdCBhblxuICAvLyBleHBvbmVudHVhbCBvciBcImNhdGFzdHJvcGhpY2FsbHkgYmFja3RyYWNraW5nXCIgZ3JhbW1hci5cbiAgLy8gPHVsPlxuICAvLyA8bGk+XG4gIC8vIGRlcHRoIC0gbWF4IGFsbG93ZWQgcGFyc2UgdHJlZSBkZXB0aC4gQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBleGNlZWRlZC5cbiAgLy8gPC9saT5cbiAgLy8gPC91bD5cbiAgdGhpcy5zZXRNYXhUcmVlRGVwdGggPSBmdW5jdGlvbiAoZGVwdGgpIHtcbiAgICBpZiAodHlwZW9mIGRlcHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heCB0cmVlIGRlcHRoIG11c3QgYmUgaW50ZWdlciA+IDA6ICR7ZGVwdGh9YCk7XG4gICAgfVxuICAgIGxpbWl0VHJlZURlcHRoID0gTWF0aC5mbG9vcihkZXB0aCk7XG4gICAgaWYgKGxpbWl0VHJlZURlcHRoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VyOiBtYXggdHJlZSBkZXB0aCBtdXN0IGJlIGludGVnZXIgPiAwOiAke2RlcHRofWApO1xuICAgIH1cbiAgfTtcbiAgLy8gU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBub2RlIGhpdHMgKHBhcnNlciB1bml0IHN0ZXBzIG9yIG9wY29kZSBmdW5jdGlvbiBjYWxscykgYWxsb3dlZC5cbiAgLy8gVGhlIGRlZmF1bHQgaXMgYEluZmluaXR5YC5cbiAgLy8gQSBsaW1pdCBpcyBub3Qgbm9ybWFsbHkgbmVlZGVkLCBidXQgY2FuIGJlIHVzZWQgdG8gcHJvdGVjdCBhZ2FpbnN0IGFuXG4gIC8vIGV4cG9uZW50dWFsIG9yIFwiY2F0YXN0cm9waGljYWxseSBiYWNrdHJhY2tpbmdcIiBncmFtbWFyLlxuICAvLyA8dWw+XG4gIC8vIDxsaT5cbiAgLy8gaGl0cyAtIG1heGltdW0gbnVtYmVyIG9mIG5vZGUgaGl0cyBvciBwYXJzZXIgdW5pdCBzdGVwcyBhbGxvd2VkLlxuICAvLyBBbiBleGNlcHRpb24gdGhyb3duIGlmIGV4Y2VlZGVkLlxuICAvLyA8L2xpPlxuICAvLyA8L3VsPlxuICB0aGlzLnNldE1heE5vZGVIaXRzID0gZnVuY3Rpb24gKGhpdHMpIHtcbiAgICBpZiAodHlwZW9mIGhpdHMgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4IG5vZGUgaGl0cyBtdXN0IGJlIGludGVnZXIgPiAwOiAke2hpdHN9YCk7XG4gICAgfVxuICAgIGxpbWl0Tm9kZUhpdHMgPSBNYXRoLmZsb29yKGhpdHMpO1xuICAgIGlmIChsaW1pdE5vZGVIaXRzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VyOiBtYXggbm9kZSBoaXRzIG11c3QgYmUgaW50ZWdlciA+IDA6ICR7aGl0c31gKTtcbiAgICB9XG4gIH07XG4gIC8qIHRoZSBtYWluIHBhcnNlciBmdW5jdGlvbiAqL1xuICBjb25zdCBwcml2YXRlUGFyc2UgPSBmdW5jdGlvbiAoZ3JhbW1hciwgc3RhcnRSdWxlQXJnLCBjYWxsYmFja0RhdGEpIHtcbiAgICBsZXQgc3VjY2VzcztcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9cGFyc2UoKTogYDtcbiAgICBpbml0aWFsaXplR3JhbW1hcihncmFtbWFyKTtcbiAgICBjb25zdCBzdGFydFJ1bGUgPSBpbml0aWFsaXplU3RhcnRSdWxlKHN0YXJ0UnVsZUFyZyk7XG4gICAgaW5pdGlhbGl6ZUNhbGxiYWNrcygpO1xuICAgIGluaXRpYWxpemVUcmFjZSgpO1xuICAgIGluaXRpYWxpemVTdGF0cygpO1xuICAgIGluaXRpYWxpemVBc3QoKTtcbiAgICBjb25zdCBzeXNEYXRhID0gbmV3IHN5c3RlbURhdGEoKTtcbiAgICBpZiAoIShjYWxsYmFja0RhdGEgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFja0RhdGEgPT09IG51bGwpKSB7XG4gICAgICBzeW50YXhEYXRhID0gY2FsbGJhY2tEYXRhO1xuICAgIH1cbiAgICAvKiBjcmVhdGUgYSBkdW1teSBvcGNvZGUgZm9yIHRoZSBzdGFydCBydWxlICovXG4gICAgb3Bjb2RlcyA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogaWQuUk5NLFxuICAgICAgICBpbmRleDogc3RhcnRSdWxlLFxuICAgICAgfSxcbiAgICBdO1xuICAgIC8qIGV4ZWN1dGUgdGhlIHN0YXJ0IHJ1bGUgKi9cbiAgICBvcEV4ZWN1dGUoMCwgY2hhcnNCZWdpbiwgc3lzRGF0YSk7XG4gICAgb3Bjb2RlcyA9IG51bGw7XG4gICAgLyogdGVzdCBhbmQgcmV0dXJuIHRoZSBzeXNEYXRhICovXG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1maW5hbCBzdGF0ZSBzaG91bGQgbmV2ZXIgYmUgJ0FDVElWRSdgKTtcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoc3lzRGF0YS5waHJhc2VMZW5ndGggPT09IGNoYXJzTGVuZ3RoKSB7XG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgc3RhdGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3MsXG4gICAgICBzdGF0ZTogc3lzRGF0YS5zdGF0ZSxcbiAgICAgIGxlbmd0aDogY2hhcnNMZW5ndGgsXG4gICAgICBtYXRjaGVkOiBzeXNEYXRhLnBocmFzZUxlbmd0aCxcbiAgICAgIG1heE1hdGNoZWQsXG4gICAgICBtYXhUcmVlRGVwdGgsXG4gICAgICBub2RlSGl0cyxcbiAgICAgIGlucHV0TGVuZ3RoOiBjaGFycy5sZW5ndGgsXG4gICAgICBzdWJCZWdpbjogY2hhcnNCZWdpbixcbiAgICAgIHN1YkVuZDogY2hhcnNFbmQsXG4gICAgICBzdWJMZW5ndGg6IGNoYXJzTGVuZ3RoLFxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBmb3JtIGFsbG93cyBwYXJzaW5nIG9mIGEgc3ViLXN0cmluZyBvZiB0aGUgZnVsbCBpbnB1dCBzdHJpbmcuXG4gIC8vIDx1bD5cbiAgLy8gPGxpPippbnB1dEluZGV4KiAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN1Yi1zdHJpbmc8L2xpPlxuICAvLyA8bGk+KmlucHV0TGVuZ3RoKiAtIGxlbmd0aCBvZiB0aGUgc3ViLXN0cmluZzwvbGk+XG4gIC8vIDwvdWw+XG4gIC8vIEFsbCBvdGhlciBwYXJhbWV0ZXJzIGFzIGZvciB0aGUgYWJvdmUgZnVuY3Rpb24gYHBhcnNlKClgLlxuICB0aGlzLnBhcnNlU3Vic3RyaW5nID0gZnVuY3Rpb24gcGFyc2VTdWJzdHJpbmcoZ3JhbW1hciwgc3RhcnRSdWxlLCBpbnB1dENoYXJzLCBpbnB1dEluZGV4LCBpbnB1dExlbmd0aCwgY2FsbGJhY2tEYXRhKSB7XG4gICAgY2xlYXIoKTtcbiAgICBpbml0aWFsaXplSW5wdXRDaGFycyhpbnB1dENoYXJzLCBpbnB1dEluZGV4LCBpbnB1dExlbmd0aCk7XG4gICAgcmV0dXJuIHByaXZhdGVQYXJzZShncmFtbWFyLCBzdGFydFJ1bGUsIGNhbGxiYWNrRGF0YSk7XG4gIH07XG4gIC8vIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24sIGNhbGxlZCB0byBwYXJzZSBhbiBpbnB1dCBzdHJpbmcuXG4gIC8vIDx1bD5cbiAgLy8gPGxpPipncmFtbWFyKiAtIGFuIGluc3RhbnRpYXRlZCBncmFtbWFyIG9iamVjdCAtIHRoZSBvdXRwdXQgb2YgYGFwZ2AgZm9yIGFcbiAgLy8gc3BlY2lmaWMgU0FCTkYgZ3JhbW1hcjwvbGk+XG4gIC8vIDxsaT4qc3RhcnRSdWxlKiAtIHRoZSBydWxlIG5hbWUgb3IgcnVsZSBpbmRleCB0byBiZSB1c2VkIGFzIHRoZSByb290IG9mIHRoZVxuICAvLyBwYXJzZSB0cmVlLiBUaGlzIGlzIHVzdWFsbHkgdGhlIGZpcnN0IHJ1bGUsIGluZGV4ID0gMCwgb2YgdGhlIGdyYW1tYXJcbiAgLy8gYnV0IGNhbiBiZSBhbnkgcnVsZSBkZWZpbmVkIGluIHRoZSBhYm92ZSBncmFtbWFyIG9iamVjdC48L2xpPlxuICAvLyA8bGk+KmlucHV0Q2hhcnMqIC0gdGhlIGlucHV0IHN0cmluZy4gQ2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzIHJlcHJlc2VudGluZyB0aGVcbiAgLy8gc3RyaW5nLjwvbGk+XG4gIC8vIDxsaT4qY2FsbGJhY2tEYXRhKiAtIHVzZXItZGVmaW5lZCBkYXRhIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gdGhlIHVzZXInc1xuICAvLyBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIC8vIFRoaXMgaXMgbm90IHVzZWQgYnkgdGhlIHBhcnNlciBpbiBhbnkgd2F5LCBtZXJlbHkgcGFzc2VkIG9uIHRvIHRoZSB1c2VyLlxuICAvLyBNYXkgYmUgYG51bGxgIG9yIG9taXR0ZWQuPC9saT5cbiAgLy8gPC91bD5cbiAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGdyYW1tYXIsIHN0YXJ0UnVsZSwgaW5wdXRDaGFycywgY2FsbGJhY2tEYXRhKSB7XG4gICAgY2xlYXIoKTtcbiAgICBpbml0aWFsaXplSW5wdXRDaGFycyhpbnB1dENoYXJzLCAwLCBpbnB1dENoYXJzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHByaXZhdGVQYXJzZShncmFtbWFyLCBzdGFydFJ1bGUsIGNhbGxiYWNrRGF0YSk7XG4gIH07XG4gIC8vIFRoZSBgQUxUYCBvcGVyYXRvci48YnI+XG4gIC8vIEV4ZWN1dGVzIGl0cyBjaGlsZCBub2RlcywgZnJvbSBsZWZ0IHRvIHJpZ2h0LCB1bnRpbCBpdCBmaW5kcyBhIG1hdGNoLlxuICAvLyBGYWlscyBpZiAqYWxsKiBvZiBpdHMgY2hpbGQgbm9kZXMgZmFpbC5cbiAgY29uc3Qgb3BBTFQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb3BFeGVjdXRlKG9wLmNoaWxkcmVuW2ldLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSAhPT0gaWQuTk9NQVRDSCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgQ0FUYCBvcGVyYXRvci48YnI+XG4gIC8vIEV4ZWN1dGVzIGFsbCBvZiBpdHMgY2hpbGQgbm9kZXMsIGZyb20gbGVmdCB0byByaWdodCxcbiAgLy8gY29uY2F0ZW5hdGluZyB0aGUgbWF0Y2hlZCBwaHJhc2VzLlxuICAvLyBGYWlscyBpZiAqYW55KiBjaGlsZCBub2RlcyBmYWlsLlxuICBjb25zdCBvcENBVCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBzdWNjZXNzO1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IGNhdENoYXJJbmRleDtcbiAgICBsZXQgY2F0UGhyYXNlO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgY29uc3QgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgc3VjY2VzcyA9IHRydWU7XG4gICAgY2F0Q2hhckluZGV4ID0gcGhyYXNlSW5kZXg7XG4gICAgY2F0UGhyYXNlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvcEV4ZWN1dGUob3AuY2hpbGRyZW5baV0sIGNhdENoYXJJbmRleCwgc3lzRGF0YSk7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2F0Q2hhckluZGV4ICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgICBjYXRQaHJhc2UgKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gY2F0UGhyYXNlID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gY2F0UGhyYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIC8qIHJlc2V0IHRoZSBiYWNrIHJlZmVyZW5jaW5nIGZyYW1lcyBvbiBmYWlsdXJlICovXG4gICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgUkVQYCBvcGVyYXRvci48YnI+XG4gIC8vIFJlcGVhdGVkbHkgZXhlY3V0ZXMgaXRzIHNpbmdsZSBjaGlsZCBub2RlLFxuICAvLyBjb25jYXRlbmF0aW5nIGVhY2ggb2YgdGhlIG1hdGNoZWQgcGhyYXNlcyBmb3VuZC5cbiAgLy8gVGhlIG51bWJlciBvZiByZXBldGl0aW9ucyBleGVjdXRlZCBhbmQgaXRzIGZpbmFsIHN5c0RhdGEgZGVwZW5kc1xuICAvLyBvbiBpdHMgYG1pbmAgJiBgbWF4YCByZXBldGl0aW9uIHZhbHVlcy5cbiAgY29uc3Qgb3BSRVAgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgYXN0TGVuZ3RoO1xuICAgIGxldCByZXBDaGFySW5kZXg7XG4gICAgbGV0IHJlcFBocmFzZTtcbiAgICBsZXQgcmVwQ291bnQ7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGlmIChvcC5tYXggPT09IDApIHtcbiAgICAgIC8vIHRoaXMgaXMgYW4gZW1wdHktc3RyaW5nIGFjY2VwdG9yXG4gICAgICAvLyBkZXByZWNhdGVkOiB1c2UgdGhlIFRMUyBlbXB0eSBzdHJpbmcgb3BlcmF0b3IsIFwiXCIsIGluc3RlYWRcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVwQ2hhckluZGV4ID0gcGhyYXNlSW5kZXg7XG4gICAgcmVwUGhyYXNlID0gMDtcbiAgICByZXBDb3VudCA9IDA7XG4gICAgY29uc3QgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgIGNvbnN0IHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAocmVwQ2hhckluZGV4ID49IGNoYXJzRW5kKSB7XG4gICAgICAgIC8qIGV4aXQgb24gZW5kIG9mIGlucHV0IHN0cmluZyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcmVwQ2hhckluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIC8qIGFsd2F5cyBlbmQgaWYgdGhlIGNoaWxkIG5vZGUgZmFpbHMgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICAgICAgLyogUkVQIGFsd2F5cyBzdWNjZWVkcyB3aGVuIHRoZSBjaGlsZCBub2RlIHJldHVybnMgYW4gZW1wdHkgcGhyYXNlICovXG4gICAgICAgIC8qIHRoaXMgbWF5IG5vdCBzZWVtIG9idmlvdXMsIGJ1dCB0aGF0J3MgdGhlIHdheSBpdCB3b3JrcyBvdXQgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXBDb3VudCArPSAxO1xuICAgICAgcmVwUGhyYXNlICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgcmVwQ2hhckluZGV4ICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgaWYgKHJlcENvdW50ID09PSBvcC5tYXgpIHtcbiAgICAgICAgLyogZW5kIG9uIG1heGVkIG91dCByZXBzICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBldmFsdWF0ZSB0aGUgbWF0Y2ggY291bnQgYWNjb3JkaW5nIHRvIHRoZSBtaW4sIG1heCB2YWx1ZXMgKi9cbiAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSByZXBQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSByZXBQaHJhc2U7XG4gICAgfSBlbHNlIGlmIChyZXBDb3VudCA+PSBvcC5taW4pIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSByZXBQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSByZXBQaHJhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgLyogcmVzZXQgdGhlIGJhY2sgcmVmZXJlbmNpbmcgZnJhbWVzIG9uIGZhaWx1cmUgKi9cbiAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVmFsaWRhdGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uJ3MgcmV0dXJuZWQgc3lzRGF0YSB2YWx1ZXMuXG4gIC8vIEl0J3MgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBnZXQgdGhlbSByaWdodFxuICAvLyBidXQgYFJOTWAgZmFpbHMgaWYgbm90LlxuICBjb25zdCB2YWxpZGF0ZVJubUNhbGxiYWNrUmVzdWx0ID0gZnVuY3Rpb24gKHJ1bGUsIHN5c0RhdGEsIGNoYXJzTGVmdCwgZG93bikge1xuICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA+IGNoYXJzTGVmdCkge1xuICAgICAgbGV0IHN0ciA9IGAke3RoaXNGaWxlTmFtZX1vcFJOTSgke3J1bGUubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiBlcnJvcjogYDtcbiAgICAgIHN0ciArPSBgc3lzRGF0YS5waHJhc2VMZW5ndGg6ICR7c3lzRGF0YS5waHJhc2VMZW5ndGh9YDtcbiAgICAgIHN0ciArPSBgIG11c3QgYmUgPD0gcmVtYWluaW5nIGNoYXJzOiAke2NoYXJzTGVmdH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgfVxuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGlmIChkb3duICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7dGhpc0ZpbGVOYW1lfW9wUk5NKCR7cnVsZS5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gQUNUSVZFIHN0YXRlIG5vdCBhbGxvd2VkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHt0aGlzRmlsZU5hbWV9b3BSTk0oJHtydWxlLm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBVbnJlY29nbml6ZWQgcmV0dXJuIHN0YXRlOiAke3N5c0RhdGEuc3RhdGV9YFxuICAgICAgICApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBSTk1gIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBvcGVyYXRvciB3aWxsIGFjdHMgYXMgYSByb290IG5vZGUgZm9yIGEgcGFyc2UgdHJlZSBicmFuY2ggYmVsb3cgYW5kXG4gIC8vIHJldHVybnMgdGhlIG1hdGNoZWQgcGhyYXNlIHRvIGl0cyBwYXJlbnQuXG4gIC8vIEhvd2V2ZXIsIGl0cyBsYXJnZXIgcmVzcG9uc2liaWxpdHkgaXMgaGFuZGxpbmcgdXNlci1kZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9ucywgYmFjayByZWZlcmVuY2VzIGFuZCBgQVNUYCBub2Rlcy5cbiAgLy8gTm90ZSB0aGF0IHRoZSBgQVNUYCBpcyBhIHNlcGFyYXRlIG9iamVjdCwgYnV0IGBSTk1gIGNhbGxzIGl0cyBmdW5jdGlvbnMgdG8gY3JlYXRlIGl0cyBub2Rlcy5cbiAgLy8gU2VlIFtgYXN0LmpzYF0oLi9hc3QuaHRtbCkgZm9yIHVzYWdlLlxuICBjb25zdCBvcFJOTSA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IGFzdERlZmluZWQ7XG4gICAgbGV0IHNhdmVkT3Bjb2RlcztcbiAgICBsZXQgdWxlbjtcbiAgICBsZXQgcGxlbjtcbiAgICBsZXQgc2F2ZUZyYW1lO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCBydWxlID0gcnVsZXNbb3AuaW5kZXhdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcnVsZUNhbGxiYWNrc1tydWxlLmluZGV4XTtcbiAgICBjb25zdCBub3RMb29rQXJvdW5kID0gIWluTG9va0Fyb3VuZCgpO1xuICAgIC8qIGlnbm9yZSBBU1QgYW5kIGJhY2sgcmVmZXJlbmNlcyBpbiBsb29rYXJvdW5kICovXG4gICAgaWYgKG5vdExvb2tBcm91bmQpIHtcbiAgICAgIC8qIGJlZ2luIEFTVCBhbmQgYmFjayByZWZlcmVuY2VzICovXG4gICAgICBhc3REZWZpbmVkID0gdGhpc1RoaXMuYXN0ICYmIHRoaXNUaGlzLmFzdC5ydWxlRGVmaW5lZChvcC5pbmRleCk7XG4gICAgICBpZiAoYXN0RGVmaW5lZCkge1xuICAgICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5kb3duKG9wLmluZGV4LCBydWxlc1tvcC5pbmRleF0ubmFtZSk7XG4gICAgICB9XG4gICAgICB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgICBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgICBzeXNEYXRhLnVGcmFtZS5wdXNoKCk7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wdXNoKCk7XG4gICAgICBzYXZlRnJhbWUgPSBzeXNEYXRhLnBGcmFtZTtcbiAgICAgIHN5c0RhdGEucEZyYW1lID0gbmV3IGJhY2tSZWYoKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICAvKiBubyBjYWxsYmFjayAtIGp1c3QgZXhlY3V0ZSB0aGUgcnVsZSAqL1xuICAgICAgc2F2ZWRPcGNvZGVzID0gb3Bjb2RlcztcbiAgICAgIG9wY29kZXMgPSBydWxlLm9wY29kZXM7XG4gICAgICBvcEV4ZWN1dGUoMCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgb3Bjb2RlcyA9IHNhdmVkT3Bjb2RlcztcbiAgICB9IGVsc2Uge1xuICAgICAgLyogY2FsbCB1c2VyJ3MgY2FsbGJhY2sgKi9cbiAgICAgIGNvbnN0IGNoYXJzTGVmdCA9IGNoYXJzRW5kIC0gcGhyYXNlSW5kZXg7XG4gICAgICBzeXNEYXRhLnJ1bGVJbmRleCA9IHJ1bGUuaW5kZXg7XG4gICAgICBjYWxsYmFjayhzeXNEYXRhLCBjaGFycywgcGhyYXNlSW5kZXgsIHN5bnRheERhdGEpO1xuICAgICAgdmFsaWRhdGVSbm1DYWxsYmFja1Jlc3VsdChydWxlLCBzeXNEYXRhLCBjaGFyc0xlZnQsIHRydWUpO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLkFDVElWRSkge1xuICAgICAgICBzYXZlZE9wY29kZXMgPSBvcGNvZGVzO1xuICAgICAgICBvcGNvZGVzID0gcnVsZS5vcGNvZGVzO1xuICAgICAgICBvcEV4ZWN1dGUoMCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICBvcGNvZGVzID0gc2F2ZWRPcGNvZGVzO1xuICAgICAgICBzeXNEYXRhLnJ1bGVJbmRleCA9IHJ1bGUuaW5kZXg7XG4gICAgICAgIGNhbGxiYWNrKHN5c0RhdGEsIGNoYXJzLCBwaHJhc2VJbmRleCwgc3ludGF4RGF0YSk7XG4gICAgICAgIHZhbGlkYXRlUm5tQ2FsbGJhY2tSZXN1bHQocnVsZSwgc3lzRGF0YSwgY2hhcnNMZWZ0LCBmYWxzZSk7XG4gICAgICB9IC8qIGltcGxpZWQgZWxzZSBjbGF1c2U6IGp1c3QgYWNjZXB0IHRoZSBjYWxsYmFjayBzeXNEYXRhIC0gUk5NIGFjdGluZyBhcyBVRFQgKi9cbiAgICB9XG4gICAgaWYgKG5vdExvb2tBcm91bmQpIHtcbiAgICAgIC8qIGVuZCBBU1QgKi9cbiAgICAgIGlmIChhc3REZWZpbmVkKSB7XG4gICAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNUaGlzLmFzdC51cChvcC5pbmRleCwgcnVsZS5uYW1lLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBlbmQgYmFjayByZWZlcmVuY2UgKi9cbiAgICAgIHN5c0RhdGEucEZyYW1lID0gc2F2ZUZyYW1lO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICB9IGVsc2UgaWYgKHJ1bGUuaXNCa3IpIHtcbiAgICAgICAgLyogc2F2ZSBwaHJhc2Ugb24gYm90aCB0aGUgcGFyZW50IGFuZCB1bml2ZXJzYWwgZnJhbWVzICovXG4gICAgICAgIC8qIEJLUiBvcGVyYXRvciB3aWxsIGRlY2lkZSB3aGljaCB0byB1c2UgbGF0ZXIgKi9cbiAgICAgICAgc3lzRGF0YS5wRnJhbWUuc2F2ZVBocmFzZShydWxlLmxvd2VyLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgICBzeXNEYXRhLnVGcmFtZS5zYXZlUGhyYXNlKHJ1bGUubG93ZXIsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBWYWxpZGF0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24ncyByZXR1cm5lZCBzeXNEYXRhIHZhbHVlcy5cbiAgLy8gSXQncyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGdldCBpdCByaWdodCBidXQgYFVEVGAgZmFpbHMgaWYgbm90LlxuICBjb25zdCB2YWxpZGF0ZVVkdENhbGxiYWNrUmVzdWx0ID0gZnVuY3Rpb24gKHVkdCwgc3lzRGF0YSwgY2hhcnNMZWZ0KSB7XG4gICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID4gY2hhcnNMZWZ0KSB7XG4gICAgICBsZXQgc3RyID0gYCR7dGhpc0ZpbGVOYW1lfW9wVURUKCR7dWR0Lm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gZXJyb3I6IGA7XG4gICAgICBzdHIgKz0gYHN5c0RhdGEucGhyYXNlTGVuZ3RoOiAke3N5c0RhdGEucGhyYXNlTGVuZ3RofWA7XG4gICAgICBzdHIgKz0gYCBtdXN0IGJlIDw9IHJlbWFpbmluZyBjaGFyczogJHtjaGFyc0xlZnR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW9wVURUKCR7dWR0Lm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBBQ1RJVkUgc3RhdGUgbm90IGFsbG93ZWQuYCk7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBpZiAodWR0LmVtcHR5ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIE1heSBub3QgcmV0dXJuIEVNUFRZLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh1ZHQuZW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW9wVURUKCR7dWR0Lm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBNYXkgbm90IHJldHVybiBFTVBUWS5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIFVucmVjb2duaXplZCByZXR1cm4gc3RhdGU6ICR7c3lzRGF0YS5zdGF0ZX1gXG4gICAgICAgICk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFVEVGAgb3BlcmF0b3IuPGJyPlxuICAvLyBTaW1wbHkgY2FsbHMgdGhlIHVzZXIncyBjYWxsYmFjayBmdW5jdGlvbiwgYnV0IG9wZXJhdGVzIGxpa2UgYFJOTWAgd2l0aCByZWdhcmQgdG8gdGhlIGBBU1RgXG4gIC8vIGFuZCBiYWNrIHJlZmVyZW5jaW5nLlxuICAvLyBUaGVyZSBpcyBzb21lIGFtYmlndWl0eSBoZXJlLiBgVURUYHMgYWN0IGFzIHRlcm1pbmFscyBmb3IgcGhyYXNlIHJlY29nbml0aW9uIGJ1dCBhcyBuYW1lZCBydWxlc1xuICAvLyBmb3IgYEFTVGAgbm9kZXMgYW5kIGJhY2sgcmVmZXJlbmNpbmcuXG4gIC8vIFNlZSBbYGFzdC5qc2BdKC4vYXN0Lmh0bWwpIGZvciB1c2FnZS5cbiAgY29uc3Qgb3BVRFQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgYXN0TGVuZ3RoO1xuICAgIGxldCBhc3RJbmRleDtcbiAgICBsZXQgYXN0RGVmaW5lZDtcbiAgICBsZXQgdWxlbjtcbiAgICBsZXQgcGxlbjtcbiAgICBsZXQgc2F2ZUZyYW1lO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCB1ZHQgPSB1ZHRzW29wLmluZGV4XTtcbiAgICBzeXNEYXRhLlVkdEluZGV4ID0gdWR0LmluZGV4O1xuXG4gICAgY29uc3Qgbm90TG9va0Fyb3VuZCA9ICFpbkxvb2tBcm91bmQoKTtcbiAgICAvKiBpZ25vcmUgQVNUIGFuZCBiYWNrIHJlZmVyZW5jZXMgaW4gbG9va2Fyb3VuZCAqL1xuICAgIGlmIChub3RMb29rQXJvdW5kKSB7XG4gICAgICAvKiBiZWdpbiBBU1QgYW5kIGJhY2sgcmVmZXJlbmNlICovXG4gICAgICBhc3REZWZpbmVkID0gdGhpc1RoaXMuYXN0ICYmIHRoaXNUaGlzLmFzdC51ZHREZWZpbmVkKG9wLmluZGV4KTtcbiAgICAgIGlmIChhc3REZWZpbmVkKSB7XG4gICAgICAgIGFzdEluZGV4ID0gcnVsZXMubGVuZ3RoICsgb3AuaW5kZXg7XG4gICAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICAgICAgdGhpc1RoaXMuYXN0LmRvd24oYXN0SW5kZXgsIHVkdC5uYW1lKTtcbiAgICAgIH1cbiAgICAgIC8qIE5PVEU6IHB1c2ggYW5kIHBvcCBvZiB0aGUgYmFjayByZWZlcmVuY2UgZnJhbWUgaXMgbm9ybWFsbHkgbm90IG5lY2Vzc2FyeSAqL1xuICAgICAgLyogb25seSBpbiB0aGUgY2FzZSB0aGF0IHRoZSBVRFQgY2FsbHMgZXZhbHVhdGVSdWxlKCkgb3IgZXZhbHVhdGVVZHQoKSAqL1xuICAgICAgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgICAgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgICAgc3lzRGF0YS51RnJhbWUucHVzaCgpO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucHVzaCgpO1xuICAgICAgc2F2ZUZyYW1lID0gc3lzRGF0YS5wRnJhbWU7XG4gICAgICBzeXNEYXRhLnBGcmFtZSA9IG5ldyBiYWNrUmVmKCk7XG4gICAgfVxuICAgIC8qIGNhbGwgdGhlIFVEVCAqL1xuICAgIGNvbnN0IGNoYXJzTGVmdCA9IGNoYXJzRW5kIC0gcGhyYXNlSW5kZXg7XG4gICAgdWR0Q2FsbGJhY2tzW29wLmluZGV4XShzeXNEYXRhLCBjaGFycywgcGhyYXNlSW5kZXgsIHN5bnRheERhdGEpO1xuICAgIHZhbGlkYXRlVWR0Q2FsbGJhY2tSZXN1bHQodWR0LCBzeXNEYXRhLCBjaGFyc0xlZnQpO1xuICAgIGlmIChub3RMb29rQXJvdW5kKSB7XG4gICAgICAvKiBlbmQgQVNUICovXG4gICAgICBpZiAoYXN0RGVmaW5lZCkge1xuICAgICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzVGhpcy5hc3QudXAoYXN0SW5kZXgsIHVkdC5uYW1lLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBlbmQgYmFjayByZWZlcmVuY2UgKi9cbiAgICAgIHN5c0RhdGEucEZyYW1lID0gc2F2ZUZyYW1lO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICB9IGVsc2UgaWYgKHVkdC5pc0Jrcikge1xuICAgICAgICAvKiBzYXZlIHBocmFzZSBvbiBib3RoIHRoZSBwYXJlbnQgYW5kIHVuaXZlcnNhbCBmcmFtZXMgKi9cbiAgICAgICAgLyogQktSIG9wZXJhdG9yIHdpbGwgZGVjaWRlIHdoaWNoIHRvIHVzZSBsYXRlciAqL1xuICAgICAgICBzeXNEYXRhLnBGcmFtZS5zYXZlUGhyYXNlKHVkdC5sb3dlciwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgc3lzRGF0YS51RnJhbWUuc2F2ZVBocmFzZSh1ZHQubG93ZXIsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYEFORGAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIHRoZSBwb3NpdGl2ZSBgbG9vayBhaGVhZGAgb3BlcmF0b3IuXG4gIC8vIEV4ZWN1dGVzIGl0cyBzaW5nbGUgY2hpbGQgbm9kZSwgcmV0dXJuaW5nIHRoZSBFTVBUWSBzdGF0ZVxuICAvLyBpZiBpdCBzdWNjZWVkc2FuZCBOT01BVENIIGlmIGl0IGZhaWxzLlxuICAvLyAqQWx3YXlzKiBiYWNrdHJhY2tzIG9uIGFueSBtYXRjaGVkIHBocmFzZSBhbmQgcmV0dXJucyBFTVBUWSBvbiBzdWNjZXNzLlxuICBjb25zdCBvcEFORCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxvb2tBcm91bmQucHVzaCh7XG4gICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX0FIRUFELFxuICAgICAgYW5jaG9yOiBwaHJhc2VJbmRleCxcbiAgICAgIGNoYXJzRW5kLFxuICAgICAgY2hhcnNMZW5ndGgsXG4gICAgfSk7XG4gICAgY2hhcnNFbmQgPSBjaGFycy5sZW5ndGg7XG4gICAgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGggLSBjaGFyc0JlZ2luO1xuICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIGNvbnN0IHBvcCA9IGxvb2tBcm91bmQucG9wKCk7XG4gICAgY2hhcnNFbmQgPSBwb3AuY2hhcnNFbmQ7XG4gICAgY2hhcnNMZW5ndGggPSBwb3AuY2hhcnNMZW5ndGg7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BBTkQ6IGludmFsaWQgc3RhdGUgJHtzeXNEYXRhLnN0YXRlfWApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBOT1RgIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyB0aGUgbmVnYXRpdmUgYGxvb2sgYWhlYWRgIG9wZXJhdG9yLlxuICAvLyBFeGVjdXRlcyBpdHMgc2luZ2xlIGNoaWxkIG5vZGUsIHJldHVybmluZyB0aGUgRU1QVFkgc3RhdGVcbiAgLy8gaWYgaXQgKmZhaWxzKiBhbmQgTk9NQVRDSCBpZiBpdCBzdWNjZWVkcy5cbiAgLy8gKkFsd2F5cyogYmFja3RyYWNrcyBvbiBhbnkgbWF0Y2hlZCBwaHJhc2UgYW5kIHJldHVybnMgRU1QVFlcbiAgLy8gb24gc3VjY2VzcyAoZmFpbHVyZSBvZiBpdHMgY2hpbGQgbm9kZSkuXG4gIGNvbnN0IG9wTk9UID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbG9va0Fyb3VuZC5wdXNoKHtcbiAgICAgIGxvb2tBcm91bmQ6IGlkLkxPT0tBUk9VTkRfQUhFQUQsXG4gICAgICBhbmNob3I6IHBocmFzZUluZGV4LFxuICAgICAgY2hhcnNFbmQsXG4gICAgICBjaGFyc0xlbmd0aCxcbiAgICB9KTtcbiAgICBjaGFyc0VuZCA9IGNoYXJzLmxlbmd0aDtcbiAgICBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aCAtIGNoYXJzQmVnaW47XG4gICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgY29uc3QgcG9wID0gbG9va0Fyb3VuZC5wb3AoKTtcbiAgICBjaGFyc0VuZCA9IHBvcC5jaGFyc0VuZDtcbiAgICBjaGFyc0xlbmd0aCA9IHBvcC5jaGFyc0xlbmd0aDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcE5PVDogaW52YWxpZCBzdGF0ZSAke3N5c0RhdGEuc3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFRSR2Agb3BlcmF0b3IuPGJyPlxuICAvLyBTdWNjZWVkcyBpZiB0aGUgc2luZ2xlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgcGhyYXNlIGlzXG4gIC8vIHdpdGhpbiB0aGUgYG1pbiAtIG1heGAgcmFuZ2UuXG4gIGNvbnN0IG9wVFJHID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGlmIChwaHJhc2VJbmRleCA8IGNoYXJzRW5kKSB7XG4gICAgICBpZiAob3AubWluIDw9IGNoYXJzW3BocmFzZUluZGV4XSAmJiBjaGFyc1twaHJhc2VJbmRleF0gPD0gb3AubWF4KSB7XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBUQlNgIG9wZXJhdG9yLjxicj5cbiAgLy8gTWF0Y2hlcyBpdHMgcHJlLWRlZmluZWQgcGhyYXNlIGFnYWluc3QgdGhlIGlucHV0IHN0cmluZy5cbiAgLy8gQWxsIGNoYXJhY3RlcnMgbXVzdCBtYXRjaCBleGFjdGx5LlxuICAvLyBDYXNlLXNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZ3MgKGAnc3RyaW5nJ2AgJiBgJXNcInN0cmluZ1wiYCkgYXJlIHRyYW5zbGF0ZWQgdG8gYFRCU2BcbiAgLy8gb3BlcmF0b3JzIGJ5IGBhcGdgLlxuICAvLyBQaHJhc2UgbGVuZ3RoIG9mIHplcm8gaXMgbm90IGFsbG93ZWQuXG4gIC8vIEVtcHR5IHBocmFzZXMgY2FuIG9ubHkgYmUgZGVmaW5lZCB3aXRoIGBUTFNgIG9wZXJhdG9ycy5cbiAgY29uc3Qgb3BUQlMgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgbGVuID0gb3Auc3RyaW5nLmxlbmd0aDtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBpZiAocGhyYXNlSW5kZXggKyBsZW4gPD0gY2hhcnNFbmQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoY2hhcnNbcGhyYXNlSW5kZXggKyBpXSAhPT0gb3Auc3RyaW5nW2ldKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9IC8qIGltcGxpZWQgZWxzZSBOT01BVENIICovXG4gIH07XG4gIC8vIFRoZSBgVExTYCBvcGVyYXRvci48YnI+XG4gIC8vIE1hdGNoZXMgaXRzIHByZS1kZWZpbmVkIHBocmFzZSBhZ2FpbnN0IHRoZSBpbnB1dCBzdHJpbmcuXG4gIC8vIEEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBpcyBhdHRlbXB0ZWQgZm9yIEFTQ0lJIGFscGhiZXRpY2FsIGNoYXJhY3RlcnMuXG4gIC8vIGBUTFNgIGlzIHRoZSBvbmx5IG9wZXJhdG9yIHRoYXQgZXhwbGljaXRseSBhbGxvd3MgZW1wdHkgcGhyYXNlcy5cbiAgLy8gYGFwZ2Agd2lsbCBmYWlsIGZvciBlbXB0eSBgVEJTYCwgY2FzZS1zZW5zaXRpdmUgc3RyaW5ncyAoYCcnYCkgb3JcbiAgLy8gemVybyByZXBldGl0aW9ucyAoYDAqMFJ1bGVOYW1lYCBvciBgMFJ1bGVOYW1lYCkuXG4gIGNvbnN0IG9wVExTID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGNvZGU7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGNvbnN0IGxlbiA9IG9wLnN0cmluZy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgLyogRU1QVFkgbWF0Y2ggYWxsb3dlZCBmb3IgVExTICovXG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwaHJhc2VJbmRleCArIGxlbiA8PSBjaGFyc0VuZCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvZGUgPSBjaGFyc1twaHJhc2VJbmRleCArIGldO1xuICAgICAgICBpZiAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB7XG4gICAgICAgICAgY29kZSArPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSAhPT0gb3Auc3RyaW5nW2ldKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9IC8qIGltcGxpZWQgZWxzZSBOT01BVENIICovXG4gIH07XG4gIC8vIFRoZSBgQUJHYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgYW4gXCJhbmNob3JcIiBmb3IgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nLCBzaW1pbGFyIHRvIHRoZSBmYW1pbGlhciByZWdleCBgXmAgYW5jaG9yLlxuICAvLyBBbiBhbmNob3IgbWF0Y2hlcyBhIHBvc2l0aW9uIHJhdGhlciB0aGFuIGEgcGhyYXNlLlxuICAvLyBSZXR1cm5zIEVNUFRZIGlmIGBwaHJhc2VJbmRleGAgaXMgMCwgTk9NQVRDSCBvdGhlcndpc2UuXG4gIGNvbnN0IG9wQUJHID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBwaHJhc2VJbmRleCA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTk9NQVRDSDtcbiAgfTtcbiAgLy8gVGhlIGBBRU5gIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyBhbiBcImFuY2hvclwiIGZvciB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNpbWlsYXIgdG8gdGhlIGZhbWlsaWFyIHJlZ2V4IGAkYCBhbmNob3IuXG4gIC8vIEFuIGFuY2hvciBtYXRjaGVzIGEgcG9zaXRpb24gcmF0aGVyIHRoYW4gYSBwaHJhc2UuXG4gIC8vIFJldHVybnMgRU1QVFkgaWYgYHBocmFzZUluZGV4YCBlcXVhbHMgdGhlIGlucHV0IHN0cmluZyBsZW5ndGgsIE5PTUFUQ0ggb3RoZXJ3aXNlLlxuICBjb25zdCBvcEFFTiA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBzeXNEYXRhLnN0YXRlID0gcGhyYXNlSW5kZXggPT09IGNoYXJzLmxlbmd0aCA/IGlkLkVNUFRZIDogaWQuTk9NQVRDSDtcbiAgfTtcbiAgLy8gVGhlIGBCS1JgIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhlIGJhY2sgcmVmZXJlbmNlIG9wZXJhdG9yLlxuICAvLyBNYXRjaGVzIHRoZSBsYXN0IG1hdGNoZWQgcGhyYXNlIG9mIHRoZSBuYW1lZCBydWxlIG9yIFVEVCBhZ2FpbnN0IHRoZSBpbnB1dCBzdHJpbmcuXG4gIC8vIEZvciBBU0NJSSBhbHBoYmV0aWNhbCBjaGFyYWN0ZXJzIHRoZSBtYXRjaCBtYXkgYmUgY2FzZSBzZW5zaXRpdmUgKGAlc2ApIG9yIGluc2Vuc2l0aXZlIChgJWlgKSxcbiAgLy8gZGVwZW5kaW5nIG9uIHRoZSBiYWNrIHJlZmVyZW5jZSBkZWZpbml0aW9uLlxuICAvLyBGb3IgYHVuaXZlcnNhbGAgbW9kZSAoYCV1YCkgbWF0Y2hlcyB0aGUgbGFzdCBwaHJhc2UgZm91bmQgYW55d2hlcmUgaW4gdGhlIGdyYW1tYXIuXG4gIC8vIEZvciBgcGFyZW50IGZyYW1lYCBtb2RlIChgJXBgKSBtYXRjaGVzIHRoZSBsYXN0IHBocmFzZSBmb3VuZCBpbiB0aGUgcGFyZW50IHJ1bGUgb25seS5cbiAgY29uc3Qgb3BCS1IgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgY29kZTtcbiAgICBsZXQgbG1jb2RlO1xuICAgIGxldCBsb3dlcjtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgaWYgKG9wLmluZGV4IDwgcnVsZXMubGVuZ3RoKSB7XG4gICAgICBsb3dlciA9IHJ1bGVzW29wLmluZGV4XS5sb3dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbG93ZXIgPSB1ZHRzW29wLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5sb3dlcjtcbiAgICB9XG4gICAgY29uc3QgZnJhbWUgPSBvcC5ia3JNb2RlID09PSBpZC5CS1JfTU9ERV9QTSA/IHN5c0RhdGEucEZyYW1lLmdldFBocmFzZShsb3dlcikgOiBzeXNEYXRhLnVGcmFtZS5nZXRQaHJhc2UobG93ZXIpO1xuICAgIGNvbnN0IGluc2Vuc2l0aXZlID0gb3AuYmtyQ2FzZSA9PT0gaWQuQktSX01PREVfQ0k7XG4gICAgaWYgKGZyYW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxtSW5kZXggPSBmcmFtZS5waHJhc2VJbmRleDtcbiAgICBjb25zdCBsZW4gPSBmcmFtZS5waHJhc2VMZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGhyYXNlSW5kZXggKyBsZW4gPD0gY2hhcnNFbmQpIHtcbiAgICAgIGlmIChpbnNlbnNpdGl2ZSkge1xuICAgICAgICAvKiBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvZGUgPSBjaGFyc1twaHJhc2VJbmRleCArIGldO1xuICAgICAgICAgIGxtY29kZSA9IGNoYXJzW2xtSW5kZXggKyBpXTtcbiAgICAgICAgICBpZiAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB7XG4gICAgICAgICAgICBjb2RlICs9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG1jb2RlID49IDY1ICYmIGxtY29kZSA8PSA5MCkge1xuICAgICAgICAgICAgbG1jb2RlICs9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZSAhPT0gbG1jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBjYXNlLXNlbnNpdGl2ZSBtYXRjaCAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBjb2RlID0gY2hhcnNbcGhyYXNlSW5kZXggKyBpXTtcbiAgICAgICAgICBsbWNvZGUgPSBjaGFyc1tsbUluZGV4ICsgaV07XG4gICAgICAgICAgaWYgKGNvZGUgIT09IGxtY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYEJLQWAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIHRoZSBwb3NpdGl2ZSBgbG9vayBiZWhpbmRgIG9wZXJhdG9yLlxuICAvLyBJdCdzIGNoaWxkIG5vZGUgaXMgcGFyc2VkIHJpZ2h0LXRvLWxlZnQuXG4gIC8vIFJldHVybnMgdGhlIEVNUFRZIHN0YXRlIGlmIGEgbWF0Y2ggaXMgZm91bmQsIE5PTUFUQ0ggb3RoZXJ3aXNlLlxuICAvLyBMaWtlIHRoZSBsb29rIGFoZWFkIG9wZXJhdG9ycywgaXQgYWx3YXlzIGJhY2t0cmFja3MgdG8gYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BCS0EgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsb29rQXJvdW5kLnB1c2goe1xuICAgICAgbG9va0Fyb3VuZDogaWQuTE9PS0FST1VORF9CRUhJTkQsXG4gICAgICBhbmNob3I6IHBocmFzZUluZGV4LFxuICAgIH0pO1xuICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIGxvb2tBcm91bmQucG9wKCk7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BCS0E6IGludmFsaWQgc3RhdGUgJHtzeXNEYXRhLnN0YXRlfWApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBCS05gIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyB0aGUgbmVnYXRpdmUgYGxvb2sgYmVoaW5kYCBvcGVyYXRvci5cbiAgLy8gSXQncyBjaGlsZCBub2RlIGlzIHBhcnNlZCByaWdodC10by1sZWZ0LlxuICAvLyBSZXR1cm5zIHRoZSBFTVBUWSBzdGF0ZSBpZiBhIG1hdGNoIGlzICpub3QqIGZvdW5kLCBOT01BVENIIG90aGVyd2lzZS5cbiAgLy8gTGlrZSB0aGUgbG9vayBhaGVhZCBvcGVyYXRvcnMsIGl0IGFsd2F5cyBiYWNrdHJhY2tzIHRvIGBwaHJhc2VJbmRleGAuXG4gIGNvbnN0IG9wQktOID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgLy8gbGV0IG9wO1xuICAgIC8vIG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBsb29rQXJvdW5kLnB1c2goe1xuICAgICAgbG9va0Fyb3VuZDogaWQuTE9PS0FST1VORF9CRUhJTkQsXG4gICAgICBhbmNob3I6IHBocmFzZUluZGV4LFxuICAgIH0pO1xuICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIGxvb2tBcm91bmQucG9wKCk7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BCS046IGludmFsaWQgc3RhdGUgJHtzeXNEYXRhLnN0YXRlfWApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYENBVGAgb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBDQVRgIG9wZXJhdG9ycyB3aGVuIGluIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIENhbGxzIGl0cyBjaGlsZCBub2RlcyBmcm9tIHJpZ2h0IHRvIGxlZnQgY29uY2F0ZW5hdGluZyBtYXRjaGVkIHBocmFzZXMgcmlnaHQgdG8gbGVmdC5cbiAgY29uc3Qgb3BDQVRCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgc3VjY2VzcztcbiAgICBsZXQgYXN0TGVuZ3RoO1xuICAgIGxldCBjYXRDaGFySW5kZXg7XG4gICAgbGV0IGNhdE1hdGNoZWQ7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICBjb25zdCBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgIH1cbiAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICBjYXRDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICBjYXRNYXRjaGVkID0gMDtcbiAgICAvLyBjYXRQaHJhc2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSBvcC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgb3BFeGVjdXRlKG9wLmNoaWxkcmVuW2ldLCBjYXRDaGFySW5kZXgsIHN5c0RhdGEpO1xuICAgICAgY2F0Q2hhckluZGV4IC09IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgY2F0TWF0Y2hlZCArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIC8vIGNhdFBocmFzZSArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gY2F0TWF0Y2hlZCA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGNhdE1hdGNoZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucG9wKHBsZW4pO1xuICAgICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBgUkVQYCBvcGVyYXRvci48YnI+XG4gIC8vIENhbGxlZCBmb3IgYFJFUGAgb3BlcmF0b3JzIGluIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIE1ha2VzIHJlcGVhdGVkIGNhbGxzIHRvIGl0cyBjaGlsZCBub2RlLCBjb25jYXRlbmF0aW5nIG1hdGNoZWQgcGhyYXNlcyByaWdodCB0byBsZWZ0LlxuICBjb25zdCBvcFJFUEJlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IHJlcENoYXJJbmRleDtcbiAgICBsZXQgcmVwUGhyYXNlO1xuICAgIGxldCByZXBDb3VudDtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgcmVwQ2hhckluZGV4ID0gcGhyYXNlSW5kZXg7XG4gICAgcmVwUGhyYXNlID0gMDtcbiAgICByZXBDb3VudCA9IDA7XG4gICAgY29uc3QgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgIGNvbnN0IHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAocmVwQ2hhckluZGV4IDw9IDApIHtcbiAgICAgICAgLyogZXhpdCBvbiBlbmQgb2YgaW5wdXQgc3RyaW5nICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCByZXBDaGFySW5kZXgsIHN5c0RhdGEpO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgLyogYWx3YXlzIGVuZCBpZiB0aGUgY2hpbGQgbm9kZSBmYWlscyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgICAvKiBSRVAgYWx3YXlzIHN1Y2NlZWRzIHdoZW4gdGhlIGNoaWxkIG5vZGUgcmV0dXJucyBhbiBlbXB0eSBwaHJhc2UgKi9cbiAgICAgICAgLyogdGhpcyBtYXkgbm90IHNlZW0gb2J2aW91cywgYnV0IHRoYXQncyB0aGUgd2F5IGl0IHdvcmtzIG91dCAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlcENvdW50ICs9IDE7XG4gICAgICByZXBQaHJhc2UgKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICByZXBDaGFySW5kZXggLT0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICBpZiAocmVwQ291bnQgPT09IG9wLm1heCkge1xuICAgICAgICAvKiBlbmQgb24gbWF4ZWQgb3V0IHJlcHMgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGV2YWx1YXRlIHRoZSBtYXRjaCBjb3VudCBhY2NvcmRpbmcgdG8gdGhlIG1pbiwgbWF4IHZhbHVlcyAqL1xuICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IHJlcFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IHJlcFBocmFzZTtcbiAgICB9IGVsc2UgaWYgKHJlcENvdW50ID49IG9wLm1pbikge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IHJlcFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IHJlcFBocmFzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGBUUkdgIG9wZXJhdG9yLjxicj5cbiAgLy8gQ2FsbGVkIGZvciBgVFJHYCBvcGVyYXRvcnMgaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gTWF0Y2hlcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYXQgYHBocmFzZUluZGV4IC0gMWAgdG8gdGhlIGBtaW5gIC0gYG1heGAgcmFuZ2UuXG4gIGNvbnN0IG9wVFJHQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBpZiAocGhyYXNlSW5kZXggPiAwKSB7XG4gICAgICBjb25zdCBjaGFyID0gY2hhcnNbcGhyYXNlSW5kZXggLSAxXTtcbiAgICAgIGlmIChvcC5taW4gPD0gY2hhciAmJiBjaGFyIDw9IG9wLm1heCkge1xuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGBUQlNgIG9wZXJhdG9yLjxicj5cbiAgLy8gQ2FsbGVkIGZvciBgVEJTYCBvcGVyYXRvcnMgaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gTWF0Y2hlcyB0aGUgYFRCU2AgcGhyYXNlIHRvIHRoZSBsZWZ0IG9mIGBwaHJhc2VJbmRleGAuXG4gIGNvbnN0IG9wVEJTQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGNvbnN0IGxlbiA9IG9wLnN0cmluZy5sZW5ndGg7XG4gICAgY29uc3QgYmVnID0gcGhyYXNlSW5kZXggLSBsZW47XG4gICAgaWYgKGJlZyA+PSAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGNoYXJzW2JlZyArIGldICE9PSBvcC5zdHJpbmdbaV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYFRMU2Agb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBUTFNgIG9wZXJhdG9ycyBpbiBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBNYXRjaGVzIHRoZSBgVExTYCBwaHJhc2UgdG8gdGhlIGxlZnQgb2YgYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BUTFNCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgY2hhcjtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgY29uc3QgbGVuID0gb3Auc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAvKiBFTVBUWSBtYXRjaCBhbGxvd2VkIGZvciBUTFMgKi9cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmVnID0gcGhyYXNlSW5kZXggLSBsZW47XG4gICAgaWYgKGJlZyA+PSAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNoYXIgPSBjaGFyc1tiZWcgKyBpXTtcbiAgICAgICAgaWYgKGNoYXIgPj0gNjUgJiYgY2hhciA8PSA5MCkge1xuICAgICAgICAgIGNoYXIgKz0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgIT09IG9wLnN0cmluZ1tpXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBiYWNrIHJlZmVyZW5jZSBvcGVyYXRvci48YnI+XG4gIC8vIE1hdGNoZXMgdGhlIGJhY2sgcmVmZXJlbmNlZCBwaHJhc2UgdG8gdGhlIGxlZnQgb2YgYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BCS1JCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgY29kZTtcbiAgICBsZXQgbG1jb2RlO1xuICAgIGxldCBsb3dlcjtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgLyogTk9NQVRDSCBkZWZhdWx0ICovXG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIGlmIChvcC5pbmRleCA8IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgbG93ZXIgPSBydWxlc1tvcC5pbmRleF0ubG93ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvd2VyID0gdWR0c1tvcC5pbmRleCAtIHJ1bGVzLmxlbmd0aF0ubG93ZXI7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lID0gb3AuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfUE0gPyBzeXNEYXRhLnBGcmFtZS5nZXRQaHJhc2UobG93ZXIpIDogc3lzRGF0YS51RnJhbWUuZ2V0UGhyYXNlKGxvd2VyKTtcbiAgICBjb25zdCBpbnNlbnNpdGl2ZSA9IG9wLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NJO1xuICAgIGlmIChmcmFtZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsbUluZGV4ID0gZnJhbWUucGhyYXNlSW5kZXg7XG4gICAgY29uc3QgbGVuID0gZnJhbWUucGhyYXNlTGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmVnID0gcGhyYXNlSW5kZXggLSBsZW47XG4gICAgaWYgKGJlZyA+PSAwKSB7XG4gICAgICBpZiAoaW5zZW5zaXRpdmUpIHtcbiAgICAgICAgLyogY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBjb2RlID0gY2hhcnNbYmVnICsgaV07XG4gICAgICAgICAgbG1jb2RlID0gY2hhcnNbbG1JbmRleCArIGldO1xuICAgICAgICAgIGlmIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgIGNvZGUgKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsbWNvZGUgPj0gNjUgJiYgbG1jb2RlIDw9IDkwKSB7XG4gICAgICAgICAgICBsbWNvZGUgKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlICE9PSBsbWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGNhc2Utc2Vuc2l0aXZlIG1hdGNoICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvZGUgPSBjaGFyc1tiZWcgKyBpXTtcbiAgICAgICAgICBsbWNvZGUgPSBjaGFyc1tsbUluZGV4ICsgaV07XG4gICAgICAgICAgaWYgKGNvZGUgIT09IGxtY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuICAvLyBHZW5lcmFsaXplZCBleGVjdXRpb24gZnVuY3Rpb24uPGJyPlxuICAvLyBIYXZpbmcgYSBzaW5nbGUsIGdlbmVyYWxpemVkIGZ1bmN0aW9uLCBhbGxvd3MgYSBzaW5nbGUgbG9jYXRpb25cbiAgLy8gZm9yIHRyYWNpbmcgYW5kIHN0YXRpc3RpY3MgZ2F0aGVyaW5nIGZ1bmN0aW9ucyB0byBiZSBjYWxsZWQuXG4gIC8vIFRyYWNpbmcgYW5kIHN0YXRpc3RpY3MgYXJlIGhhbmRsZWQgaW4gc2VwYXJhdGUgb2JqZWN0cy5cbiAgLy8gSG93ZXZlciwgdGhlIHBhcnNlciBjYWxscyB0aGVpciBBUEkgdG8gYnVpbGQgdGhlIG9iamVjdCBkYXRhIHJlY29yZHMuXG4gIC8vIFNlZSBbYHRyYWNlLmpzYF0oLi90cmFjZS5odG1sKSBhbmQgW2BzdGF0cy5qc2BdKC4vc3RhdHMuaHRtbCkgZm9yIHRoZWlyXG4gIC8vIHVzYWdlLlxuICBvcEV4ZWN1dGUgPSBmdW5jdGlvbiBvcEV4ZWN1dGVGdW5jKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IHJldCA9IHRydWU7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIG5vZGVIaXRzICs9IDE7XG4gICAgaWYgKG5vZGVIaXRzID4gbGltaXROb2RlSGl0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heGltdW0gbnVtYmVyIG9mIG5vZGUgaGl0cyBleGNlZWRlZDogJHtsaW1pdE5vZGVIaXRzfWApO1xuICAgIH1cbiAgICB0cmVlRGVwdGggKz0gMTtcbiAgICBpZiAodHJlZURlcHRoID4gbWF4VHJlZURlcHRoKSB7XG4gICAgICBtYXhUcmVlRGVwdGggPSB0cmVlRGVwdGg7XG4gICAgICBpZiAobWF4VHJlZURlcHRoID4gbGltaXRUcmVlRGVwdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heGltdW0gcGFyc2UgdHJlZSBkZXB0aCBleGNlZWRlZDogJHtsaW1pdFRyZWVEZXB0aH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3lzRGF0YS5yZWZyZXNoKCk7XG4gICAgaWYgKHRoaXNUaGlzLnRyYWNlICE9PSBudWxsKSB7XG4gICAgICAvKiBjb2xsZWN0IHRoZSB0cmFjZSByZWNvcmQgZm9yIGRvd24gdGhlIHBhcnNlIHRyZWUgKi9cbiAgICAgIGNvbnN0IGxrID0gbG9va0Fyb3VuZFZhbHVlKCk7XG4gICAgICB0aGlzVGhpcy50cmFjZS5kb3duKG9wLCBzeXNEYXRhLnN0YXRlLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgsIGxrLmFuY2hvciwgbGsubG9va0Fyb3VuZCk7XG4gICAgfVxuICAgIGlmIChpbkxvb2tCZWhpbmQoKSkge1xuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgIG9wQUxUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5DQVQ6XG4gICAgICAgICAgb3BDQVRCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICBvcFJFUEJlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuUk5NOlxuICAgICAgICAgIG9wUk5NKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgb3BVRFQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFORDpcbiAgICAgICAgICBvcEFORChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgICAgIG9wTk9UKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgb3BUUkdCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICBvcFRCU0JlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgIG9wVExTQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgb3BCS1JCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLQTpcbiAgICAgICAgICBvcEJLQShvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktOOlxuICAgICAgICAgIG9wQktOKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BQkc6XG4gICAgICAgICAgb3BBQkcob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICBvcEFFTihvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlIGlkLkFMVDpcbiAgICAgICAgICBvcEFMVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgICAgIG9wQ0FUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5SRVA6XG4gICAgICAgICAgb3BSRVAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICBvcFJOTShvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICAgIG9wVURUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BTkQ6XG4gICAgICAgICAgb3BBTkQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLk5PVDpcbiAgICAgICAgICBvcE5PVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVFJHOlxuICAgICAgICAgIG9wVFJHKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICAgICAgb3BUQlMob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRMUzpcbiAgICAgICAgICBvcFRMUyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgIG9wQktSKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS0E6XG4gICAgICAgICAgb3BCS0Eob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgICBvcEJLTihvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQUJHOlxuICAgICAgICAgIG9wQUJHKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgICAgb3BBRU4ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluTG9va0Fyb3VuZCgpICYmIHBocmFzZUluZGV4ICsgc3lzRGF0YS5waHJhc2VMZW5ndGggPiBtYXhNYXRjaGVkKSB7XG4gICAgICBtYXhNYXRjaGVkID0gcGhyYXNlSW5kZXggKyBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLnN0YXRzICE9PSBudWxsKSB7XG4gICAgICAvKiBjb2xsZWN0IHRoZSBzdGF0aXN0aWNzICovXG4gICAgICB0aGlzVGhpcy5zdGF0cy5jb2xsZWN0KG9wLCBzeXNEYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLnRyYWNlICE9PSBudWxsKSB7XG4gICAgICAvKiBjb2xsZWN0IHRoZSB0cmFjZSByZWNvcmQgZm9yIHVwIHRoZSBwYXJzZSB0cmVlICovXG4gICAgICBjb25zdCBsayA9IGxvb2tBcm91bmRWYWx1ZSgpO1xuICAgICAgdGhpc1RoaXMudHJhY2UudXAob3AsIHN5c0RhdGEuc3RhdGUsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCwgbGsuYW5jaG9yLCBsay5sb29rQXJvdW5kKTtcbiAgICB9XG4gICAgdHJlZURlcHRoIC09IDE7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/stats.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/stats.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is the constructor for the statistics gathering object.\n// The statistics are nothing more than keeping a count of the\n// number of times each node in the parse tree is traversed.\n//\n// Counts are collected for each of the individual types of operators.\n// Additionally, counts are collected for each of the individually named\n// `RNM` and `UDT` operators.\nmodule.exports = function statsFunc() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n  const style = __webpack_require__(/*! ./style */ \"(ssr)/./node_modules/apg-js/src/apg-lib/style.js\");\n\n  const thisFileName = 'stats.js: ';\n  let rules = [];\n  let udts = [];\n  const stats = [];\n  let totals;\n  const ruleStats = [];\n  const udtStats = [];\n  this.statsObject = 'statsObject';\n  const nameId = 'stats';\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators alphabetically by name. */\n  const sortAlpha = function sortAlpha(lhs, rhs) {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by hit count. */\n  const sortHits = function sortHits(lhs, rhs) {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by index */\n  /* (in the order in which they appear in the SABNF grammar). */\n  const sortIndex = function sortIndex(lhs, rhs) {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function EmptyStat() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = function clear() {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    stats[id.BKR] = new EmptyStat();\n    stats[id.BKA] = new EmptyStat();\n    stats[id.BKN] = new EmptyStat();\n    stats[id.ABG] = new EmptyStat();\n    stats[id.AEN] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index,\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index,\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = function incStat(stat, state) {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n    }\n  };\n  /* helper for toHtml() */\n  const displayRow = function displayRow(name, stat) {\n    let html = '';\n    html += '<tr>';\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${name}</td>`;\n    html += `<td class=\"${style.CLASS_EMPTY}\">${stat.empty}</td>`;\n    html += `<td class=\"${style.CLASS_MATCH}\">${stat.match}</td>`;\n    html += `<td class=\"${style.CLASS_NOMATCH}\">${stat.nomatch}</td>`;\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${stat.total}</td>`;\n    html += '</tr>\\n';\n    return html;\n  };\n  const displayOpsOnly = function displayOpsOnly() {\n    let html = '';\n    html += displayRow('ALT', stats[id.ALT]);\n    html += displayRow('CAT', stats[id.CAT]);\n    html += displayRow('REP', stats[id.REP]);\n    html += displayRow('RNM', stats[id.RNM]);\n    html += displayRow('TRG', stats[id.TRG]);\n    html += displayRow('TBS', stats[id.TBS]);\n    html += displayRow('TLS', stats[id.TLS]);\n    html += displayRow('UDT', stats[id.UDT]);\n    html += displayRow('AND', stats[id.AND]);\n    html += displayRow('NOT', stats[id.NOT]);\n    html += displayRow('BKR', stats[id.BKR]);\n    html += displayRow('BKA', stats[id.BKA]);\n    html += displayRow('BKN', stats[id.BKN]);\n    html += displayRow('ABG', stats[id.ABG]);\n    html += displayRow('AEN', stats[id.AEN]);\n    html += displayRow('totals', totals);\n    return html;\n  };\n  /* helper for toHtml() */\n  const displayRules = function displayRules() {\n    let html = '';\n    html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n    html += '<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\\n';\n    for (let i = 0; i < rules.length; i += 1) {\n      if (ruleStats[i].total > 0) {\n        html += '<tr>';\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].name}</td>`;\n        html += `<td class=\"${style.CLASS_EMPTY}\">${ruleStats[i].empty}</td>`;\n        html += `<td class=\"${style.CLASS_MATCH}\">${ruleStats[i].match}</td>`;\n        html += `<td class=\"${style.CLASS_NOMATCH}\">${ruleStats[i].nomatch}</td>`;\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].total}</td>`;\n        html += '</tr>\\n';\n      }\n    }\n    if (udts.length > 0) {\n      html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n      html += '<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\\n';\n      for (let i = 0; i < udts.length; i += 1) {\n        if (udtStats[i].total > 0) {\n          html += '<tr>';\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].name}</td>`;\n          html += `<td class=\"${style.CLASS_EMPTY}\">${udtStats[i].empty}</td>`;\n          html += `<td class=\"${style.CLASS_MATCH}\">${udtStats[i].match}</td>`;\n          html += `<td class=\"${style.CLASS_NOMATCH}\">${udtStats[i].nomatch}</td>`;\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].total}</td>`;\n          html += '</tr>\\n';\n        }\n      }\n    }\n    return html;\n  };\n  /* called only by the parser to validate a stats object */\n  this.validate = function validate(name) {\n    let ret = false;\n    if (typeof name === 'string' && nameId === name) {\n      ret = true;\n    }\n    return ret;\n  };\n  /* no verification of input - only called by parser() */\n  this.init = function init(inputRules, inputUdts) {\n    rules = inputRules;\n    udts = inputUdts;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = function collect(op, result) {\n    incStat(totals, result.state, result.phraseLength);\n    incStat(stats[op.type], result.state, result.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], result.state, result.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], result.state, result.phraseLength);\n    }\n  };\n  // Display the statistics as an HTML table.\n  // - *type*\n  //   - \"ops\" - (default) display only the total hit counts for all operator types.\n  //   - \"index\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators ordered by index.\n  //   - \"hits\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by hit count.\n  //   - \"alpha\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by name alphabetically.\n  // - *caption* - optional caption for the table\n  this.toHtml = function toHtml(type, caption) {\n    let html = '';\n    html += `<table class=\"${style.CLASS_STATS}\">\\n`;\n    if (typeof caption === 'string') {\n      html += `<caption>${caption}</caption>\\n`;\n    }\n    html += `<tr><th class=\"${style.CLASS_ACTIVE}\">ops</th>\\n`;\n    html += `<th class=\"${style.CLASS_EMPTY}\">EMPTY</th>\\n`;\n    html += `<th class=\"${style.CLASS_MATCH}\">MATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_NOMATCH}\">NOMATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_ACTIVE}\">totals</th></tr>\\n`;\n    const test = true;\n    while (test) {\n      if (type === undefined) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === null) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'ops') {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'index') {\n        ruleStats.sort(sortIndex);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'hits') {\n        ruleStats.sort(sortHits);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'alpha') {\n        ruleStats.sort(sortAlpha);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortAlpha);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      break;\n    }\n    html += '</table>\\n';\n    return html;\n  };\n  // Display the stats table in a complete HTML5 page.\n  this.toHtmlPage = function toHtmlPage(type, caption, title) {\n    return utils.htmlToPage(this.toHtml(type, caption), title);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0YXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw2RUFBZTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsNENBQTRDLE1BQU07QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQixJQUFJLEtBQUs7QUFDdEQsMEJBQTBCLGtCQUFrQixJQUFJLFdBQVc7QUFDM0QsMEJBQTBCLGtCQUFrQixJQUFJLFdBQVc7QUFDM0QsMEJBQTBCLG9CQUFvQixJQUFJLGFBQWE7QUFDL0QsMEJBQTBCLG1CQUFtQixJQUFJLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CLElBQUksa0JBQWtCO0FBQ3ZFLDhCQUE4QixrQkFBa0IsSUFBSSxtQkFBbUI7QUFDdkUsOEJBQThCLGtCQUFrQixJQUFJLG1CQUFtQjtBQUN2RSw4QkFBOEIsb0JBQW9CLElBQUkscUJBQXFCO0FBQzNFLDhCQUE4QixtQkFBbUIsSUFBSSxtQkFBbUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQixJQUFJLGlCQUFpQjtBQUN4RSxnQ0FBZ0Msa0JBQWtCLElBQUksa0JBQWtCO0FBQ3hFLGdDQUFnQyxrQkFBa0IsSUFBSSxrQkFBa0I7QUFDeEUsZ0NBQWdDLG9CQUFvQixJQUFJLG9CQUFvQjtBQUM1RSxnQ0FBZ0MsbUJBQW1CLElBQUksa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pELDBCQUEwQixrQkFBa0I7QUFDNUMsMEJBQTBCLGtCQUFrQjtBQUM1QywwQkFBMEIsb0JBQW9CO0FBQzlDLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9zdGF0cy5qcz82OTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGlzIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHN0YXRpc3RpY3MgZ2F0aGVyaW5nIG9iamVjdC5cbi8vIFRoZSBzdGF0aXN0aWNzIGFyZSBub3RoaW5nIG1vcmUgdGhhbiBrZWVwaW5nIGEgY291bnQgb2YgdGhlXG4vLyBudW1iZXIgb2YgdGltZXMgZWFjaCBub2RlIGluIHRoZSBwYXJzZSB0cmVlIGlzIHRyYXZlcnNlZC5cbi8vXG4vLyBDb3VudHMgYXJlIGNvbGxlY3RlZCBmb3IgZWFjaCBvZiB0aGUgaW5kaXZpZHVhbCB0eXBlcyBvZiBvcGVyYXRvcnMuXG4vLyBBZGRpdGlvbmFsbHksIGNvdW50cyBhcmUgY29sbGVjdGVkIGZvciBlYWNoIG9mIHRoZSBpbmRpdmlkdWFsbHkgbmFtZWRcbi8vIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0YXRzRnVuYygpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcbiAgY29uc3Qgc3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG5cbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3N0YXRzLmpzOiAnO1xuICBsZXQgcnVsZXMgPSBbXTtcbiAgbGV0IHVkdHMgPSBbXTtcbiAgY29uc3Qgc3RhdHMgPSBbXTtcbiAgbGV0IHRvdGFscztcbiAgY29uc3QgcnVsZVN0YXRzID0gW107XG4gIGNvbnN0IHVkdFN0YXRzID0gW107XG4gIHRoaXMuc3RhdHNPYmplY3QgPSAnc3RhdHNPYmplY3QnO1xuICBjb25zdCBuYW1lSWQgPSAnc3RhdHMnO1xuICAvKiBgQXJyYXkuc29ydCgpYCBjYWxsYmFjayBmdW5jdGlvbiBmb3Igc29ydGluZyBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzIGFscGhhYmV0aWNhbGx5IGJ5IG5hbWUuICovXG4gIGNvbnN0IHNvcnRBbHBoYSA9IGZ1bmN0aW9uIHNvcnRBbHBoYShsaHMsIHJocykge1xuICAgIGlmIChsaHMubG93ZXIgPCByaHMubG93ZXIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGxocy5sb3dlciA+IHJocy5sb3dlcikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICAvKiBgQXJyYXkuc29ydCgpYCBjYWxsYmFjayBmdW5jdGlvbiBmb3Igc29ydGluZyBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzIGJ5IGhpdCBjb3VudC4gKi9cbiAgY29uc3Qgc29ydEhpdHMgPSBmdW5jdGlvbiBzb3J0SGl0cyhsaHMsIHJocykge1xuICAgIGlmIChsaHMudG90YWwgPCByaHMudG90YWwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAobGhzLnRvdGFsID4gcmhzLnRvdGFsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiBzb3J0QWxwaGEobGhzLCByaHMpO1xuICB9O1xuICAvKiBgQXJyYXkuc29ydCgpYCBjYWxsYmFjayBmdW5jdGlvbiBmb3Igc29ydGluZyBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzIGJ5IGluZGV4ICovXG4gIC8qIChpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcHBlYXIgaW4gdGhlIFNBQk5GIGdyYW1tYXIpLiAqL1xuICBjb25zdCBzb3J0SW5kZXggPSBmdW5jdGlvbiBzb3J0SW5kZXgobGhzLCByaHMpIHtcbiAgICBpZiAobGhzLmluZGV4IDwgcmhzLmluZGV4KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChsaHMuaW5kZXggPiByaHMuaW5kZXgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgY29uc3QgRW1wdHlTdGF0ID0gZnVuY3Rpb24gRW1wdHlTdGF0KCkge1xuICAgIHRoaXMuZW1wdHkgPSAwO1xuICAgIHRoaXMubWF0Y2ggPSAwO1xuICAgIHRoaXMubm9tYXRjaCA9IDA7XG4gICAgdGhpcy50b3RhbCA9IDA7XG4gIH07XG4gIC8qIFplcm8gb3V0IGFsbCBzdGF0cyAqL1xuICBjb25zdCBjbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHN0YXRzLmxlbmd0aCA9IDA7XG4gICAgdG90YWxzID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkFMVF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQ0FUXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5SRVBdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlJOTV0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuVFJHXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5UQlNdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlRMU10gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuVURUXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5BTkRdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLk5PVF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQktSXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5CS0FdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkJLTl0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQUJHXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5BRU5dID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHJ1bGVTdGF0cy5sZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHJ1bGVTdGF0cy5wdXNoKHtcbiAgICAgICAgZW1wdHk6IDAsXG4gICAgICAgIG1hdGNoOiAwLFxuICAgICAgICBub21hdGNoOiAwLFxuICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgbmFtZTogcnVsZXNbaV0ubmFtZSxcbiAgICAgICAgbG93ZXI6IHJ1bGVzW2ldLmxvd2VyLFxuICAgICAgICBpbmRleDogcnVsZXNbaV0uaW5kZXgsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgdWR0U3RhdHMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB1ZHRTdGF0cy5wdXNoKHtcbiAgICAgICAgICBlbXB0eTogMCxcbiAgICAgICAgICBtYXRjaDogMCxcbiAgICAgICAgICBub21hdGNoOiAwLFxuICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgIG5hbWU6IHVkdHNbaV0ubmFtZSxcbiAgICAgICAgICBsb3dlcjogdWR0c1tpXS5sb3dlcixcbiAgICAgICAgICBpbmRleDogdWR0c1tpXS5pbmRleCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBpbmNyZW1lbnQgdGhlIGRlc2lnbmF0ZWQgb3BlcmF0b3IgaGl0IGNvdW50IGJ5IG9uZSAqL1xuICBjb25zdCBpbmNTdGF0ID0gZnVuY3Rpb24gaW5jU3RhdChzdGF0LCBzdGF0ZSkge1xuICAgIHN0YXQudG90YWwgKz0gMTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBzdGF0LmVtcHR5ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3RhdC5tYXRjaCArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3RhdC5ub21hdGNoICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jb2xsZWN0KCk6IGluY1N0YXQoKTogdW5yZWNvZ25pemVkIHN0YXRlOiAke3N0YXRlfWApO1xuICAgIH1cbiAgfTtcbiAgLyogaGVscGVyIGZvciB0b0h0bWwoKSAqL1xuICBjb25zdCBkaXNwbGF5Um93ID0gZnVuY3Rpb24gZGlzcGxheVJvdyhuYW1lLCBzdGF0KSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9ICc8dHI+JztcbiAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4ke25hbWV9PC90ZD5gO1xuICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+JHtzdGF0LmVtcHR5fTwvdGQ+YDtcbiAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPiR7c3RhdC5tYXRjaH08L3RkPmA7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiR7c3RhdC5ub21hdGNofTwvdGQ+YDtcbiAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4ke3N0YXQudG90YWx9PC90ZD5gO1xuICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgY29uc3QgZGlzcGxheU9wc09ubHkgPSBmdW5jdGlvbiBkaXNwbGF5T3BzT25seSgpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQUxUJywgc3RhdHNbaWQuQUxUXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdDQVQnLCBzdGF0c1tpZC5DQVRdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1JFUCcsIHN0YXRzW2lkLlJFUF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnUk5NJywgc3RhdHNbaWQuUk5NXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdUUkcnLCBzdGF0c1tpZC5UUkddKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1RCUycsIHN0YXRzW2lkLlRCU10pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnVExTJywgc3RhdHNbaWQuVExTXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdVRFQnLCBzdGF0c1tpZC5VRFRdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0FORCcsIHN0YXRzW2lkLkFORF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnTk9UJywgc3RhdHNbaWQuTk9UXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdCS1InLCBzdGF0c1tpZC5CS1JdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0JLQScsIHN0YXRzW2lkLkJLQV0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQktOJywgc3RhdHNbaWQuQktOXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdBQkcnLCBzdGF0c1tpZC5BQkddKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0FFTicsIHN0YXRzW2lkLkFFTl0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygndG90YWxzJywgdG90YWxzKTtcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogaGVscGVyIGZvciB0b0h0bWwoKSAqL1xuICBjb25zdCBkaXNwbGF5UnVsZXMgPSBmdW5jdGlvbiBkaXNwbGF5UnVsZXMoKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9ICc8dHI+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PC90cj5cXG4nO1xuICAgIGh0bWwgKz0gJzx0cj48dGg+cnVsZXM8L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjwvdHI+XFxuJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAocnVsZVN0YXRzW2ldLnRvdGFsID4gMCkge1xuICAgICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtydWxlU3RhdHNbaV0ubmFtZX08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+JHtydWxlU3RhdHNbaV0uZW1wdHl9PC90ZD5gO1xuICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPiR7cnVsZVN0YXRzW2ldLm1hdGNofTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiR7cnVsZVN0YXRzW2ldLm5vbWF0Y2h9PC90ZD5gO1xuICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4ke3J1bGVTdGF0c1tpXS50b3RhbH08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgaHRtbCArPSAnPHRyPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjwvdHI+XFxuJztcbiAgICAgIGh0bWwgKz0gJzx0cj48dGg+dWR0czwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PC90cj5cXG4nO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICh1ZHRTdGF0c1tpXS50b3RhbCA+IDApIHtcbiAgICAgICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4ke3VkdFN0YXRzW2ldLm5hbWV9PC90ZD5gO1xuICAgICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+JHt1ZHRTdGF0c1tpXS5lbXB0eX08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4ke3VkdFN0YXRzW2ldLm1hdGNofTwvdGQ+YDtcbiAgICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+JHt1ZHRTdGF0c1tpXS5ub21hdGNofTwvdGQ+YDtcbiAgICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4ke3VkdFN0YXRzW2ldLnRvdGFsfTwvdGQ+YDtcbiAgICAgICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGNhbGxlZCBvbmx5IGJ5IHRoZSBwYXJzZXIgdG8gdmFsaWRhdGUgYSBzdGF0cyBvYmplY3QgKi9cbiAgdGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKG5hbWUpIHtcbiAgICBsZXQgcmV0ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBuYW1lSWQgPT09IG5hbWUpIHtcbiAgICAgIHJldCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIC8qIG5vIHZlcmlmaWNhdGlvbiBvZiBpbnB1dCAtIG9ubHkgY2FsbGVkIGJ5IHBhcnNlcigpICovXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIGluaXQoaW5wdXRSdWxlcywgaW5wdXRVZHRzKSB7XG4gICAgcnVsZXMgPSBpbnB1dFJ1bGVzO1xuICAgIHVkdHMgPSBpbnB1dFVkdHM7XG4gICAgY2xlYXIoKTtcbiAgfTtcbiAgLyogVGhpcyBmdW5jdGlvbiBpcyB0aGUgbWFpbiBpbnRlcmFjdGlvbiB3aXRoIHRoZSBwYXJzZXIuICovXG4gIC8qIFRoZSBwYXJzZXIgY2FsbHMgaXQgYWZ0ZXIgZWFjaCBub2RlIGhhcyBiZWVuIHRyYXZlcnNlZC4gKi9cbiAgdGhpcy5jb2xsZWN0ID0gZnVuY3Rpb24gY29sbGVjdChvcCwgcmVzdWx0KSB7XG4gICAgaW5jU3RhdCh0b3RhbHMsIHJlc3VsdC5zdGF0ZSwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgaW5jU3RhdChzdGF0c1tvcC50eXBlXSwgcmVzdWx0LnN0YXRlLCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICBpZiAob3AudHlwZSA9PT0gaWQuUk5NKSB7XG4gICAgICBpbmNTdGF0KHJ1bGVTdGF0c1tvcC5pbmRleF0sIHJlc3VsdC5zdGF0ZSwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChvcC50eXBlID09PSBpZC5VRFQpIHtcbiAgICAgIGluY1N0YXQodWR0U3RhdHNbb3AuaW5kZXhdLCByZXN1bHQuc3RhdGUsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgIH1cbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgc3RhdGlzdGljcyBhcyBhbiBIVE1MIHRhYmxlLlxuICAvLyAtICp0eXBlKlxuICAvLyAgIC0gXCJvcHNcIiAtIChkZWZhdWx0KSBkaXNwbGF5IG9ubHkgdGhlIHRvdGFsIGhpdCBjb3VudHMgZm9yIGFsbCBvcGVyYXRvciB0eXBlcy5cbiAgLy8gICAtIFwiaW5kZXhcIiAtIGFkZGl0aW9uYWxseSwgZGlzcGxheSB0aGUgaGl0IGNvdW50cyBmb3IgdGhlIGluZGl2aWR1YWwgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBvcmRlcmVkIGJ5IGluZGV4LlxuICAvLyAgIC0gXCJoaXRzXCIgLSBhZGRpdGlvbmFsbHksIGRpc3BsYXkgdGhlIGhpdCBjb3VudHMgZm9yIHRoZSBpbmRpdmlkdWFsIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMgYnkgaGl0IGNvdW50LlxuICAvLyAgIC0gXCJhbHBoYVwiIC0gYWRkaXRpb25hbGx5LCBkaXNwbGF5IHRoZSBoaXQgY291bnRzIGZvciB0aGUgaW5kaXZpZHVhbCBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzIGJ5IG5hbWUgYWxwaGFiZXRpY2FsbHkuXG4gIC8vIC0gKmNhcHRpb24qIC0gb3B0aW9uYWwgY2FwdGlvbiBmb3IgdGhlIHRhYmxlXG4gIHRoaXMudG9IdG1sID0gZnVuY3Rpb24gdG9IdG1sKHR5cGUsIGNhcHRpb24pIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGh0bWwgKz0gYDx0YWJsZSBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfU1RBVFN9XCI+XFxuYDtcbiAgICBpZiAodHlwZW9mIGNhcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBodG1sICs9IGA8Y2FwdGlvbj4ke2NhcHRpb259PC9jYXB0aW9uPlxcbmA7XG4gICAgfVxuICAgIGh0bWwgKz0gYDx0cj48dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj5vcHM8L3RoPlxcbmA7XG4gICAgaHRtbCArPSBgPHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj5FTVBUWTwvdGg+XFxuYDtcbiAgICBodG1sICs9IGA8dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPk1BVENIPC90aD5cXG5gO1xuICAgIGh0bWwgKz0gYDx0aCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5OT01BVENIPC90aD5cXG5gO1xuICAgIGh0bWwgKz0gYDx0aCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPnRvdGFsczwvdGg+PC90cj5cXG5gO1xuICAgIGNvbnN0IHRlc3QgPSB0cnVlO1xuICAgIHdoaWxlICh0ZXN0KSB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheU9wc09ubHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdvcHMnKSB7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheU9wc09ubHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2luZGV4Jykge1xuICAgICAgICBydWxlU3RhdHMuc29ydChzb3J0SW5kZXgpO1xuICAgICAgICBpZiAodWR0U3RhdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVkdFN0YXRzLnNvcnQoc29ydEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheVJ1bGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdoaXRzJykge1xuICAgICAgICBydWxlU3RhdHMuc29ydChzb3J0SGl0cyk7XG4gICAgICAgIGlmICh1ZHRTdGF0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdWR0U3RhdHMuc29ydChzb3J0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheU9wc09ubHkoKTtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5UnVsZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2FscGhhJykge1xuICAgICAgICBydWxlU3RhdHMuc29ydChzb3J0QWxwaGEpO1xuICAgICAgICBpZiAodWR0U3RhdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVkdFN0YXRzLnNvcnQoc29ydEFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheVJ1bGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGh0bWwgKz0gJzwvdGFibGU+XFxuJztcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgc3RhdHMgdGFibGUgaW4gYSBjb21wbGV0ZSBIVE1MNSBwYWdlLlxuICB0aGlzLnRvSHRtbFBhZ2UgPSBmdW5jdGlvbiB0b0h0bWxQYWdlKHR5cGUsIGNhcHRpb24sIHRpdGxlKSB7XG4gICAgcmV0dXJuIHV0aWxzLmh0bWxUb1BhZ2UodGhpcy50b0h0bWwodHlwZSwgY2FwdGlvbiksIHRpdGxlKTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/style.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/style.js ***!
  \**************************************************/
/***/ ((module) => {

eval("module.exports = {\n\n  // Generated by apglib/style.js \n  CLASS_MONOSPACE: 'apg-mono',\n  CLASS_ACTIVE: 'apg-active',\n  CLASS_EMPTY: 'apg-empty',\n  CLASS_MATCH: 'apg-match',\n  CLASS_NOMATCH: 'apg-nomatch',\n  CLASS_LOOKAHEAD: 'apg-lh-match',\n  CLASS_LOOKBEHIND: 'apg-lb-match',\n  CLASS_REMAINDER: 'apg-remainder',\n  CLASS_CTRLCHAR: 'apg-ctrl-char',\n  CLASS_LINEEND: 'apg-line-end',\n  CLASS_ERROR: 'apg-error',\n  CLASS_PHRASE: 'apg-phrase',\n  CLASS_EMPTYPHRASE: 'apg-empty-phrase',\n  CLASS_STATE: 'apg-state',\n  CLASS_STATS: 'apg-stats',\n  CLASS_TRACE: 'apg-trace',\n  CLASS_GRAMMAR: 'apg-grammar',\n  CLASS_RULES: 'apg-rules',\n  CLASS_RULESLINK: 'apg-rules-link',\n  CLASS_ATTRIBUTES: 'apg-attrs',\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0eWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9zdHlsZS5qcz9jYjhlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8vIEdlbmVyYXRlZCBieSBhcGdsaWIvc3R5bGUuanMgXG4gIENMQVNTX01PTk9TUEFDRTogJ2FwZy1tb25vJyxcbiAgQ0xBU1NfQUNUSVZFOiAnYXBnLWFjdGl2ZScsXG4gIENMQVNTX0VNUFRZOiAnYXBnLWVtcHR5JyxcbiAgQ0xBU1NfTUFUQ0g6ICdhcGctbWF0Y2gnLFxuICBDTEFTU19OT01BVENIOiAnYXBnLW5vbWF0Y2gnLFxuICBDTEFTU19MT09LQUhFQUQ6ICdhcGctbGgtbWF0Y2gnLFxuICBDTEFTU19MT09LQkVISU5EOiAnYXBnLWxiLW1hdGNoJyxcbiAgQ0xBU1NfUkVNQUlOREVSOiAnYXBnLXJlbWFpbmRlcicsXG4gIENMQVNTX0NUUkxDSEFSOiAnYXBnLWN0cmwtY2hhcicsXG4gIENMQVNTX0xJTkVFTkQ6ICdhcGctbGluZS1lbmQnLFxuICBDTEFTU19FUlJPUjogJ2FwZy1lcnJvcicsXG4gIENMQVNTX1BIUkFTRTogJ2FwZy1waHJhc2UnLFxuICBDTEFTU19FTVBUWVBIUkFTRTogJ2FwZy1lbXB0eS1waHJhc2UnLFxuICBDTEFTU19TVEFURTogJ2FwZy1zdGF0ZScsXG4gIENMQVNTX1NUQVRTOiAnYXBnLXN0YXRzJyxcbiAgQ0xBU1NfVFJBQ0U6ICdhcGctdHJhY2UnLFxuICBDTEFTU19HUkFNTUFSOiAnYXBnLWdyYW1tYXInLFxuICBDTEFTU19SVUxFUzogJ2FwZy1ydWxlcycsXG4gIENMQVNTX1JVTEVTTElOSzogJ2FwZy1ydWxlcy1saW5rJyxcbiAgQ0xBU1NfQVRUUklCVVRFUzogJ2FwZy1hdHRycycsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/trace.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/trace.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module provides a means of tracing the parser through the parse tree as it goes.\n// It is the primary debugging facility for debugging both the SABNF grammar syntax\n// and the input strings that are supposed to be valid grammar sentences.\n// It is also a very informative and educational tool for understanding\n// how a parser actually operates for a given language.\n//\n// Tracing is the process of generating and saving a record of information for each passage\n// of the parser through a parse tree node. And since it traverses each node twice, once down the tree\n// and once coming back up, there are two records for each node.\n// This, obviously, has the potential of generating lots of records.\n// And since these records are normally displayed on a web page\n// it is important to have a means to limit the actual number of records generated to\n// probably no more that a few thousand. This is almost always enough to find any errors.\n// The problem is to get the *right* few thousand records.\n// Therefore, this module has a number of ways of limiting and/or filtering, the number and type of records.\n// Considerable effort has been made to make this filtering of the trace output as simple\n// and intuitive as possible.\n//\n// However, the ability to filter the trace records, or for that matter even understand what they are\n// and the information they contain, does require a minimum amount of understanding of the APG parsing\n// method. The parse tree nodes are all represented by APG operators. They break down into two natural groups.\n// - The `RNM` operators and `UDT` operators are named phrases.\n// These are names chosen by the writer of the SABNF grammar to represent special phrases of interest.\n// - All others collect, concatenate and otherwise manipulate various intermediate phrases along the way.\n//\n// There are separate means of filtering which of these operators in each of these two groups get traced.\n// Let `trace` be an instantiated `trace.js` object.\n// Prior to parsing the string, filtering the rules and UDTs can be defined as follows:\n// ```\n// trace.filter.rules[\"rulename\"] = true;\n//     /* trace rule name \"rulename\" */\n// trace.filter.rules[\"udtname\"]  = true;\n//     /* trace UDT name \"udtname\" */\n// trace.filter.rules[\"<ALL>\"]    = true;\n//     /* trace all rules and UDTs (the default) */\n// trace.filter.rules[\"<NONE>\"]   = true;\n//     /* trace no rules or UDTS */\n// ```\n// If any rule or UDT name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of rule names, a filter statement is required for each rule/UDT name desired.\n//\n// Filtering of the other operators follows a similar procedure.\n// ```\n// trace.filter.operators[\"TRG\"] = true;\n//     /* trace the terminal range, TRG, operators */\n// trace.filter.operators[\"CAT\"]  = true;\n//     /* trace the concatenations, CAT, operators */\n// trace.filter.operators[\"<ALL>\"]    = true;\n//     /* trace all operators */\n// trace.filter.operators[\"<NONE>\"]   = true;\n//     /* trace no operators (the default) */\n// ```\n// If any operator name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of operator names, a filter statement is required for each name desired.\n//\n// There is, additionally, a means for limiting the total number of filtered or saved trace records.\n// See the function, `setMaxRecords(max)` below. This will result in only the last `max` records being saved.\n//\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js-examples) for examples of using `trace.js`.)\nmodule.exports = function exportTrace() {\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n  const style = __webpack_require__(/*! ./style */ \"(ssr)/./node_modules/apg-js/src/apg-lib/style.js\");\n  const circular = new (__webpack_require__(/*! ./circular-buffer */ \"(ssr)/./node_modules/apg-js/src/apg-lib/circular-buffer.js\"))();\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n\n  const thisFileName = 'trace.js: ';\n  const that = this;\n  const MODE_HEX = 16;\n  const MODE_DEC = 10;\n  const MODE_ASCII = 8;\n  const MODE_UNICODE = 32;\n  const MAX_PHRASE = 80;\n  const MAX_TLS = 5;\n  const records = [];\n  let maxRecords = 5000;\n  let lastRecord = -1;\n  let filteredRecords = 0;\n  let treeDepth = 0;\n  const recordStack = [];\n  let chars = null;\n  let rules = null;\n  let udts = null;\n  const operatorFilter = [];\n  const ruleFilter = [];\n  /* special trace table phrases */\n  const PHRASE_END = `<span class=\"${style.CLASS_LINEEND}\">&bull;</span>`;\n  const PHRASE_CONTINUE = `<span class=\"${style.CLASS_LINEEND}\">&hellip;</span>`;\n  const PHRASE_EMPTY = `<span class=\"${style.CLASS_EMPTY}\">&#120634;</span>`;\n  /* filter the non-RNM & non-UDT operators */\n  const initOperatorFilter = function () {\n    const setOperators = function (set) {\n      operatorFilter[id.ALT] = set;\n      operatorFilter[id.CAT] = set;\n      operatorFilter[id.REP] = set;\n      operatorFilter[id.TLS] = set;\n      operatorFilter[id.TBS] = set;\n      operatorFilter[id.TRG] = set;\n      operatorFilter[id.AND] = set;\n      operatorFilter[id.NOT] = set;\n      operatorFilter[id.BKR] = set;\n      operatorFilter[id.BKA] = set;\n      operatorFilter[id.BKN] = set;\n      operatorFilter[id.ABG] = set;\n      operatorFilter[id.AEN] = set;\n    };\n    let items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.operators) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: no operators specified: default: do not trace any operators */\n      setOperators(false);\n      return;\n    }\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      if (upper === '<ALL>') {\n        /* case 2: <all> operators specified: trace all operators ignore all other operator commands */\n        setOperators(true);\n        return;\n      }\n      if (upper === '<NONE>') {\n        /* case 3: <none> operators specified: trace NO operators ignore all other operator commands */\n        setOperators(false);\n        return;\n      }\n    }\n    setOperators(false);\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      /* case 4: one or more individual operators specified: trace 'true' operators only */\n      if (upper === 'ALT') {\n        operatorFilter[id.ALT] = that.filter.operators[name] === true;\n      } else if (upper === 'CAT') {\n        operatorFilter[id.CAT] = that.filter.operators[name] === true;\n      } else if (upper === 'REP') {\n        operatorFilter[id.REP] = that.filter.operators[name] === true;\n      } else if (upper === 'AND') {\n        operatorFilter[id.AND] = that.filter.operators[name] === true;\n      } else if (upper === 'NOT') {\n        operatorFilter[id.NOT] = that.filter.operators[name] === true;\n      } else if (upper === 'TLS') {\n        operatorFilter[id.TLS] = that.filter.operators[name] === true;\n      } else if (upper === 'TBS') {\n        operatorFilter[id.TBS] = that.filter.operators[name] === true;\n      } else if (upper === 'TRG') {\n        operatorFilter[id.TRG] = that.filter.operators[name] === true;\n      } else if (upper === 'BKR') {\n        operatorFilter[id.BKR] = that.filter.operators[name] === true;\n      } else if (upper === 'BKA') {\n        operatorFilter[id.BKA] = that.filter.operators[name] === true;\n      } else if (upper === 'BKN') {\n        operatorFilter[id.BKN] = that.filter.operators[name] === true;\n      } else if (upper === 'ABG') {\n        operatorFilter[id.ABG] = that.filter.operators[name] === true;\n      } else if (upper === 'AEN') {\n        operatorFilter[id.AEN] = that.filter.operators[name] === true;\n      } else {\n        throw new Error(\n          `${thisFileName}initOpratorFilter: '${name}' not a valid operator name.` +\n            ` Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`\n        );\n      }\n    }\n  };\n  /* filter the rule and `UDT` named operators */\n  const initRuleFilter = function () {\n    const setRules = function (set) {\n      operatorFilter[id.RNM] = set;\n      operatorFilter[id.UDT] = set;\n      const count = rules.length + udts.length;\n      ruleFilter.length = 0;\n      for (let i = 0; i < count; i += 1) {\n        ruleFilter.push(set);\n      }\n    };\n    let items;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    ruleFilter.length = 0;\n    items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.rules) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: default to all rules & udts */\n      setRules(true);\n      return;\n    }\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      if (lower === '<all>') {\n        /* case 2: trace all rules ignore all other rule commands */\n        setRules(true);\n        return;\n      }\n      if (lower === '<none>') {\n        /* case 3: trace no rules */\n        setRules(false);\n        return;\n      }\n    }\n    /* case 4: trace only individually specified rules */\n    setRules(false);\n    operatorFilter[id.RNM] = true;\n    operatorFilter[id.UDT] = true;\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);\n      }\n      ruleFilter[i] = that.filter.rules[name] === true;\n    }\n  };\n  /* used by other APG components to verify that they have a valid trace object */\n  this.traceObject = 'traceObject';\n  this.filter = {\n    operators: [],\n    rules: [],\n  };\n  // Set the maximum number of records to keep (default = 5000).\n  // Each record number larger than `maxRecords`\n  // will result in deleting the previously oldest record.\n  // - `max`: maximum number of records to retain (default = 5000)\n  // - `last`: last record number to retain, (default = -1 for (unknown) actual last record)\n  this.setMaxRecords = function (max, last) {\n    lastRecord = -1;\n    if (typeof max === 'number' && max > 0) {\n      maxRecords = Math.ceil(max);\n    } else {\n      maxRecords = 0;\n      return;\n    }\n    if (typeof last === 'number') {\n      lastRecord = Math.floor(last);\n      if (lastRecord < 0) {\n        lastRecord = -1;\n      }\n    }\n  };\n  // Returns `maxRecords` to the caller.\n  this.getMaxRecords = function () {\n    return maxRecords;\n  };\n  // Returns `lastRecord` to the caller.\n  this.getLastRecord = function () {\n    return lastRecord;\n  };\n  /* Called only by the `parser.js` object. No verification of input. */\n  this.init = function (rulesIn, udtsIn, charsIn) {\n    records.length = 0;\n    recordStack.length = 0;\n    filteredRecords = 0;\n    treeDepth = 0;\n    chars = charsIn;\n    rules = rulesIn;\n    udts = udtsIn;\n    initOperatorFilter();\n    initRuleFilter();\n    circular.init(maxRecords);\n  };\n  /* returns true if this records passes through the designated filter, false if the record is to be skipped */\n  const filterOps = function (op) {\n    let ret = false;\n    if (op.type === id.RNM) {\n      if (operatorFilter[op.type] && ruleFilter[op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else if (op.type === id.UDT) {\n      if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else {\n      ret = operatorFilter[op.type];\n    }\n    return ret;\n  };\n  const filterRecords = function (record) {\n    if (lastRecord === -1) {\n      return true;\n    }\n    if (record <= lastRecord) {\n      return true;\n    }\n    return false;\n  };\n  /* Collect the \"down\" record. */\n  this.down = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      recordStack.push(filteredRecords);\n      records[circular.increment()] = {\n        dirUp: false,\n        depth: treeDepth,\n        thisLine: filteredRecords,\n        thatLine: undefined,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n      treeDepth += 1;\n    }\n  };\n  /* Collect the \"up\" record. */\n  this.up = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      const thisLine = filteredRecords;\n      const thatLine = recordStack.pop();\n      const thatRecord = circular.getListIndex(thatLine);\n      if (thatRecord !== -1) {\n        records[thatRecord].thatLine = thisLine;\n      }\n      treeDepth -= 1;\n      records[circular.increment()] = {\n        dirUp: true,\n        depth: treeDepth,\n        thisLine,\n        thatLine,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n    }\n  };\n  /* convert the trace records to a tree of nodes */\n  const toTreeObj = function () {\n    /* private helper functions */\n    function nodeOpcode(node, opcode) {\n      let name;\n      let casetype;\n      let modetype;\n      if (opcode) {\n        node.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };\n        node.opData = undefined;\n        switch (opcode.type) {\n          case id.RNM:\n            node.opData = rules[opcode.index].name;\n            break;\n          case id.UDT:\n            node.opData = udts[opcode.index].name;\n            break;\n          case id.BKR:\n            if (opcode.index < rules.length) {\n              name = rules[opcode.index].name;\n            } else {\n              name = udts[opcode.index - rules.length].name;\n            }\n            casetype = opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n            modetype = opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n            node.opData = `\\\\\\\\${casetype}${modetype}${name}`;\n            break;\n          case id.TLS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TBS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TRG:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          case id.REP:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          default:\n            throw new Error('unrecognized opcode');\n        }\n      } else {\n        node.op = { id: undefined, name: undefined };\n        node.opData = undefined;\n      }\n    }\n    function nodePhrase(state, index, length) {\n      if (state === id.MATCH) {\n        return {\n          index,\n          length,\n        };\n      }\n      if (state === id.NOMATCH) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      if (state === id.EMPTY) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      return null;\n    }\n    let nodeId = -1;\n    function nodeDown(parent, record, depth) {\n      const node = {\n        // eslint-disable-next-line no-plusplus\n        id: nodeId++,\n        branch: -1,\n        parent,\n        up: false,\n        down: false,\n        depth,\n        children: [],\n      };\n      if (record) {\n        node.down = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = null;\n        nodeOpcode(node, record.opcode);\n      } else {\n        node.state = { id: undefined, name: undefined };\n        node.phrase = nodePhrase();\n        nodeOpcode(node, undefined);\n      }\n      return node;\n    }\n    function nodeUp(node, record) {\n      if (record) {\n        node.up = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = nodePhrase(record.state, record.phraseIndex, record.phraseLength);\n        if (!node.down) {\n          nodeOpcode(node, record.opcode);\n        }\n      }\n    }\n    /* walk the final tree: label branches and count leaf nodes */\n    let leafNodes = 0;\n    let depth = -1;\n    let branchCount = 1;\n    function walk(node) {\n      depth += 1;\n      node.branch = branchCount;\n      if (depth > treeDepth) {\n        treeDepth = depth;\n      }\n      if (node.children.length === 0) {\n        leafNodes += 1;\n      } else {\n        for (let i = 0; i < node.children.length; i += 1) {\n          if (i > 0) {\n            branchCount += 1;\n          }\n          node.children[i].leftMost = false;\n          node.children[i].rightMost = false;\n          if (node.leftMost) {\n            node.children[i].leftMost = i === 0;\n          }\n          if (node.rightMost) {\n            node.children[i].rightMost = i === node.children.length - 1;\n          }\n          walk(node.children[i]);\n        }\n      }\n      depth -= 1;\n    }\n    function display(node, offset) {\n      let name;\n      const obj = {};\n      obj.id = node.id;\n      obj.branch = node.branch;\n      obj.leftMost = node.leftMost;\n      obj.rightMost = node.rightMost;\n      name = node.state.name ? node.state.name : 'ACTIVE';\n      obj.state = { id: node.state.id, name };\n      name = node.op.name ? node.op.name : '?';\n      obj.op = { id: node.op.id, name };\n      if (typeof node.opData === 'string') {\n        obj.opData = node.opData;\n      } else if (Array.isArray(node.opData)) {\n        obj.opData = [];\n        for (let i = 0; i < node.opData.length; i += 1) {\n          obj.opData[i] = node.opData[i];\n        }\n      } else {\n        obj.opData = undefined;\n      }\n      if (node.phrase) {\n        obj.phrase = { index: node.phrase.index, length: node.phrase.length };\n      } else {\n        obj.phrase = null;\n      }\n      obj.depth = node.depth;\n      obj.children = [];\n      for (let i = 0; i < node.children.length; i += 1) {\n        const c = i !== node.children.length - 1;\n        obj.children[i] = display(node.children[i], offset, c);\n      }\n      return obj;\n    }\n\n    /* construct the tree beginning here */\n    const branch = [];\n    let root;\n    let node;\n    let parent;\n    let record;\n    let firstRecord = true;\n    /* push a dummy node so the root node will have a non-null parent */\n    const dummy = nodeDown(null, null, -1);\n    branch.push(dummy);\n    node = dummy;\n    circular.forEach((lineIndex) => {\n      record = records[lineIndex];\n      if (firstRecord) {\n        firstRecord = false;\n        if (record.depth > 0) {\n          /* push some dummy nodes to fill in for missing records */\n          const num = record.dirUp ? record.depth + 1 : record.depth;\n          for (let i = 0; i < num; i += 1) {\n            parent = node;\n            node = nodeDown(node, null, i);\n            branch.push(node);\n            parent.children.push(node);\n          }\n        }\n      }\n      if (record.dirUp) {\n        /* handle the next record up */\n        node = branch.pop();\n        nodeUp(node, record);\n        node = branch[branch.length - 1];\n      } else {\n        /* handle the next record down */\n        parent = node;\n        node = nodeDown(node, record, record.depth);\n        branch.push(node);\n        parent.children.push(node);\n      }\n    });\n\n    /* if not at root, walk it up to root */\n    while (branch.length > 1) {\n      node = branch.pop();\n      nodeUp(node, null);\n    }\n    /* maybe redundant or paranoid tests: these should never happen */\n    if (dummy.children.length === 0) {\n      throw new Error('trace.toTree(): parse tree has no nodes');\n    }\n    if (branch.length === 0) {\n      throw new Error('trace.toTree(): integrity check: dummy root node disappeared?');\n    }\n\n    /* if no record for start rule: find the pseudo root node (first dummy node above a real node) */\n    root = dummy.children[0];\n    let prev = root;\n    while (root && !root.down && !root.up) {\n      prev = root;\n      root = root.children[0];\n    }\n    root = prev;\n\n    /* walk the tree of nodes: label brances and count leaves */\n    root.leftMost = true;\n    root.rightMost = true;\n    walk(root);\n    root.branch = 0;\n\n    /* generate the exported object */\n    const obj = {};\n    obj.string = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      obj.string[i] = chars[i];\n    }\n    /* generate the exported rule names */\n    obj.rules = [];\n    for (let i = 0; i < rules.length; i += 1) {\n      obj.rules[i] = rules[i].name;\n    }\n    /* generate the exported UDT names */\n    obj.udts = [];\n    for (let i = 0; i < udts.length; i += 1) {\n      obj.udts[i] = udts[i].name;\n    }\n    /* generate the ids */\n    obj.id = {};\n    obj.id.ALT = { id: id.ALT, name: 'ALT' };\n    obj.id.CAT = { id: id.CAT, name: 'CAT' };\n    obj.id.REP = { id: id.REP, name: 'REP' };\n    obj.id.RNM = { id: id.RNM, name: 'RNM' };\n    obj.id.TLS = { id: id.TLS, name: 'TLS' };\n    obj.id.TBS = { id: id.TBS, name: 'TBS' };\n    obj.id.TRG = { id: id.TRG, name: 'TRG' };\n    obj.id.UDT = { id: id.UDT, name: 'UDT' };\n    obj.id.AND = { id: id.AND, name: 'AND' };\n    obj.id.NOT = { id: id.NOT, name: 'NOT' };\n    obj.id.BKR = { id: id.BKR, name: 'BKR' };\n    obj.id.BKA = { id: id.BKA, name: 'BKA' };\n    obj.id.BKN = { id: id.BKN, name: 'BKN' };\n    obj.id.ABG = { id: id.ABG, name: 'ABG' };\n    obj.id.AEN = { id: id.AEN, name: 'AEN' };\n    obj.id.ACTIVE = { id: id.ACTIVE, name: 'ACTIVE' };\n    obj.id.MATCH = { id: id.MATCH, name: 'MATCH' };\n    obj.id.EMPTY = { id: id.EMPTY, name: 'EMPTY' };\n    obj.id.NOMATCH = { id: id.NOMATCH, name: 'NOMATCH' };\n    /* generate the max tree depth */\n    obj.treeDepth = treeDepth;\n    /* generate the number of leaf nodes (branches) */\n    obj.leafNodes = leafNodes;\n    /* generate the types of the left- and right-most branches */\n    let branchesIncomplete;\n    if (root.down) {\n      if (root.up) {\n        branchesIncomplete = 'none';\n      } else {\n        branchesIncomplete = 'right';\n      }\n    } else if (root.up) {\n      branchesIncomplete = 'left';\n    } else {\n      branchesIncomplete = 'both';\n    }\n    obj.branchesIncomplete = branchesIncomplete;\n    obj.tree = display(root, root.depth, false);\n    return obj;\n  };\n  // Returns the trace records as JSON parse tree object.\n  // - stringify: if `true`, the object is 'stringified' before returning, otherwise, the object itself is returned.\n  this.toTree = function (stringify) {\n    const obj = toTreeObj();\n    if (stringify) {\n      return JSON.stringify(obj);\n    }\n    return obj;\n  };\n  // Translate the trace records to HTML format and create a complete HTML page for browser display.\n  this.toHtmlPage = function (mode, caption, title) {\n    return utils.htmlToPage(this.toHtml(mode, caption), title);\n  };\n\n  /* From here on down, these are just helper functions for `toHtml()`. */\n  const htmlHeader = function (mode, caption) {\n    /* open the page */\n    /* write the HTML5 header with table style */\n    /* open the <table> tag */\n    let modeName;\n    switch (mode) {\n      case MODE_HEX:\n        modeName = 'hexadecimal';\n        break;\n      case MODE_DEC:\n        modeName = 'decimal';\n        break;\n      case MODE_ASCII:\n        modeName = 'ASCII';\n        break;\n      case MODE_UNICODE:\n        modeName = 'UNICODE';\n        break;\n      default:\n        throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);\n    }\n    let header = '';\n    header += `<p>display mode: ${modeName}</p>\\n`;\n    header += `<table class=\"${style.CLASS_TRACE}\">\\n`;\n    if (typeof caption === 'string') {\n      header += `<caption>${caption}</caption>`;\n    }\n    return header;\n  };\n  const htmlFooter = function () {\n    let footer = '';\n    /* close the </table> tag */\n    footer += '</table>\\n';\n    /* display a table legend */\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">legend:<br>\\n`;\n    footer += '(a)&nbsp;-&nbsp;line number<br>\\n';\n    footer += '(b)&nbsp;-&nbsp;matching line number<br>\\n';\n    footer += '(c)&nbsp;-&nbsp;phrase offset<br>\\n';\n    footer += '(d)&nbsp;-&nbsp;phrase length<br>\\n';\n    footer += '(e)&nbsp;-&nbsp;tree depth<br>\\n';\n    footer += '(f)&nbsp;-&nbsp;operator state<br>\\n';\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_ACTIVE}\">&darr;</span>&nbsp;&nbsp;phrase opened<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">&uarr;M</span> phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span> empty phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span> phrase not matched<br>\\n`;\n    footer +=\n      'operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\\n';\n    footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">matched characters</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKAHEAD}\">matched characters in look ahead mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKBEHIND}\">matched characters in look behind mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_REMAINDER}\">remainder characters(not yet examined by parser)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_CTRLCHAR}\">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>\\n`;\n    footer += '</p>\\n';\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">\\n`;\n    footer += '<sup>&dagger;</sup>original ABNF operators:<br>\\n';\n    footer += 'ALT - alternation<br>\\n';\n    footer += 'CAT - concatenation<br>\\n';\n    footer += 'REP - repetition<br>\\n';\n    footer += 'RNM - rule name<br>\\n';\n    footer += 'TRG - terminal range<br>\\n';\n    footer += 'TLS - terminal literal string (case insensitive)<br>\\n';\n    footer += 'TBS - terminal binary string (case sensitive)<br>\\n';\n    footer += '<br>\\n';\n    footer += '<sup>&Dagger;</sup>super set SABNF operators:<br>\\n';\n    footer += 'UDT - user-defined terminal<br>\\n';\n    footer += 'AND - positive look ahead<br>\\n';\n    footer += 'NOT - negative look ahead<br>\\n';\n    footer += 'BKA - positive look behind<br>\\n';\n    footer += 'BKN - negative look behind<br>\\n';\n    footer += 'BKR - back reference<br>\\n';\n    footer += 'ABG - anchor - begin of input string<br>\\n';\n    footer += 'AEN - anchor - end of input string<br>\\n';\n    footer += '</p>\\n';\n    return footer;\n  };\n  this.indent = function (depth) {\n    let html = '';\n    for (let i = 0; i < depth; i += 1) {\n      html += '.';\n    }\n    return html;\n  };\n  /* format the TRG operator */\n  const displayTrg = function (mode, op) {\n    let html = '';\n    if (op.type === id.TRG) {\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        html += hex;\n        hex = op.max.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += `&ndash;${hex}`;\n      } else {\n        html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      }\n    }\n    return html;\n  };\n  /* format the REP operator */\n  const displayRep = function (mode, op) {\n    let html = '';\n    if (op.type === id.REP) {\n      if (mode === MODE_HEX) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html = `x${hex}`;\n        if (op.max < Infinity) {\n          hex = op.max.toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n        } else {\n          hex = 'inf';\n        }\n        html += `&ndash;${hex}`;\n      } else if (op.max < Infinity) {\n        html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      } else {\n        html = `${op.min.toString(10)}&ndash;inf`;\n      }\n    }\n    return html;\n  };\n  /* format the TBS operator */\n  const displayTbs = function (mode, op) {\n    let html = '';\n    if (op.type === id.TBS) {\n      const len = Math.min(op.string.length, MAX_TLS * 2);\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        for (let i = 0; i < len; i += 1) {\n          let hex;\n          if (i > 0) {\n            html += '.';\n          }\n          hex = op.string[i].toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n          html += hex;\n        }\n      } else {\n        html = '%d';\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          html += op.string[i].toString(10);\n        }\n      }\n      if (len < op.string.length) {\n        html += PHRASE_CONTINUE;\n      }\n    }\n    return html;\n  };\n  /* format the TLS operator */\n  const displayTls = function (mode, op) {\n    let html = '';\n    if (op.type === id.TLS) {\n      const len = Math.min(op.string.length, MAX_TLS);\n      if (mode === MODE_HEX || mode === MODE_DEC) {\n        let charu;\n        let charl;\n        let base;\n        if (mode === MODE_HEX) {\n          html = '%x';\n          base = 16;\n        } else {\n          html = '%d';\n          base = 10;\n        }\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          charl = op.string[i];\n          if (charl >= 97 && charl <= 122) {\n            charu = charl - 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else if (charl >= 65 && charl <= 90) {\n            charu = charl;\n            charl += 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else {\n            html += charl.toString(base).toUpperCase();\n          }\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n      } else {\n        html = '\"';\n        for (let i = 0; i < len; i += 1) {\n          html += utils.asciiChars[op.string[i]];\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n        html += '\"';\n      }\n    }\n    return html;\n  };\n  const subPhrase = function (mode, charsArg, index, length, prev) {\n    if (length === 0) {\n      return '';\n    }\n    let phrase = '';\n    const comma = prev ? ',' : '';\n    switch (mode) {\n      case MODE_HEX:\n        phrase = comma + utils.charsToHex(charsArg, index, length);\n        break;\n      case MODE_DEC:\n        if (prev) {\n          return `,${utils.charsToDec(charsArg, index, length)}`;\n        }\n        phrase = comma + utils.charsToDec(charsArg, index, length);\n        break;\n      case MODE_UNICODE:\n        phrase = utils.charsToUnicode(charsArg, index, length);\n        break;\n      case MODE_ASCII:\n      default:\n        phrase = utils.charsToAsciiHtml(charsArg, index, length);\n        break;\n    }\n    return phrase;\n  };\n  /* display phrases matched in look-behind mode */\n  const displayBehind = function (mode, charsArg, state, index, length, anchor) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanBehind = `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.MATCH:\n      case id.ACTIVE:\n        beg1 = index - length;\n        len1 = anchor - beg1;\n        beg2 = anchor;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanBehind;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  const displayForward = function (mode, charsArg, state, index, length, spanAhead) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.ACTIVE:\n        beg1 = index;\n        len1 = 0;\n        beg2 = index;\n        len2 = charsArg.length - beg2;\n        break;\n      case id.MATCH:\n        beg1 = index;\n        len1 = length;\n        beg2 = index + len1;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanAhead;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  /* display phrases matched in look-ahead mode */\n  const displayAhead = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* display phrases matched in normal parsing mode */\n  const displayNone = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_MATCH}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* Returns the filtered records, formatted as an HTML table. */\n  const htmlTable = function (mode) {\n    if (rules === null) {\n      return '';\n    }\n    let html = '';\n    let thisLine;\n    let thatLine;\n    let lookAhead;\n    let lookBehind;\n    let lookAround;\n    let anchor;\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    circular.forEach((lineIndex) => {\n      const line = records[lineIndex];\n      thisLine = line.thisLine;\n      thatLine = line.thatLine !== undefined ? line.thatLine : '--';\n      lookAhead = false;\n      lookBehind = false;\n      lookAround = false;\n      if (line.lookAround === id.LOOKAROUND_AHEAD) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      if (line.lookAround === id.LOOKAROUND_BEHIND) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      html += '<tr>';\n      html += `<td>${thisLine}</td><td>${thatLine}</td>`;\n      html += `<td>${line.phraseIndex}</td>`;\n      html += `<td>${line.phraseLength}</td>`;\n      html += `<td>${line.depth}</td>`;\n      html += '<td>';\n      switch (line.state) {\n        case id.ACTIVE:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">&darr;&nbsp;</span>`;\n          break;\n        case id.MATCH:\n          html += `<span class=\"${style.CLASS_MATCH}\">&uarr;M</span>`;\n          break;\n        case id.NOMATCH:\n          html += `<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span>`;\n          break;\n        case id.EMPTY:\n          html += `<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span>`;\n          break;\n        default:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">--</span>`;\n          break;\n      }\n      html += '</td>';\n      html += '<td>';\n      html += that.indent(line.depth);\n      if (lookAhead) {\n        html += `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n      } else if (lookBehind) {\n        html += `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n      }\n      html += utils.opcodeToString(line.opcode.type);\n      if (line.opcode.type === id.RNM) {\n        html += `(${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.BKR) {\n        const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n        const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n        html += `(\\\\${casetype}${modetype}${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.UDT) {\n        html += `(${udts[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.TRG) {\n        html += `(${displayTrg(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TBS) {\n        html += `(${displayTbs(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TLS) {\n        html += `(${displayTls(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.REP) {\n        html += `(${displayRep(mode, line.opcode)}) `;\n      }\n      if (lookAround) {\n        html += '</span>';\n      }\n      html += '</td>';\n      html += '<td>';\n      if (lookBehind) {\n        html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);\n      } else if (lookAhead) {\n        html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      } else {\n        html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      }\n      html += '</td></tr>\\n';\n    });\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    html += '</table>\\n';\n    return html;\n  };\n  // Translate the trace records to HTML format.\n  // - *modearg* - can be `\"ascii\"`, `\"decimal\"`, `\"hexadecimal\"` or `\"unicode\"`.\n  // Determines the format of the string character code display.\n  // - *caption* - optional caption for the HTML table.\n  this.toHtml = function (modearg, caption) {\n    /* writes the trace records as a table in a complete html page */\n    let mode = MODE_ASCII;\n    if (typeof modearg === 'string' && modearg.length >= 3) {\n      const modein = modearg.toLowerCase().slice(0, 3);\n      if (modein === 'hex') {\n        mode = MODE_HEX;\n      } else if (modein === 'dec') {\n        mode = MODE_DEC;\n      } else if (modein === 'uni') {\n        mode = MODE_UNICODE;\n      }\n    }\n    let html = '';\n    html += htmlHeader(mode, caption);\n    html += htmlTable(mode);\n    html += htmlFooter();\n    return html;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3RyYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLHFGQUFtQjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsNkVBQWU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CLFFBQVE7QUFDakUsMENBQTBDLG9CQUFvQixVQUFVO0FBQ3hFLHVDQUF1QyxrQkFBa0IsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLGFBQWEsYUFBYSxzQkFBc0IsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsbUJBQW1CLEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsaUNBQWlDLEtBQUs7QUFDOUU7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRCx3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sT0FBTyxlQUFlLG1CQUFtQixRQUFRLGFBQWEsTUFBTTtBQUMzRyxxQkFBcUIsTUFBTSxNQUFNLE1BQU0sT0FBTyxlQUFlLGtCQUFrQixRQUFRO0FBQ3ZGLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxPQUFPLGVBQWUsa0JBQWtCLFFBQVE7QUFDdkYscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE9BQU8sZUFBZSxvQkFBb0IsUUFBUTtBQUN6RjtBQUNBLHFCQUFxQixPQUFPLDhDQUE4QywyREFBMkQ7QUFDckksMkJBQTJCLE1BQU0sTUFBTSxPQUFPLFFBQVEsWUFBWTtBQUNsRSxxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE9BQU8sZUFBZSxrQkFBa0I7QUFDN0cscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxPQUFPLGVBQWUsc0JBQXNCO0FBQ2pILHFCQUFxQixNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sT0FBTyxlQUFlLHVCQUF1QjtBQUNsSCxxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE9BQU8sZUFBZSxzQkFBc0I7QUFDakgscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxPQUFPLGVBQWUscUJBQXFCO0FBQ2hILHFCQUFxQixNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sT0FBTyxFQUFFLGNBQWM7QUFDNUYscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxPQUFPLEVBQUUsWUFBWTtBQUMxRixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE9BQU8sRUFBRSxpQkFBaUI7QUFDL0Y7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBLHdCQUF3QixFQUFFLElBQUk7QUFDOUIsUUFBUTtBQUNSLG9CQUFvQixvQkFBb0IsT0FBTyxFQUFFLG9CQUFvQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsSUFBSTtBQUM5QixRQUFRO0FBQ1Isa0JBQWtCLG9CQUFvQixPQUFPLEVBQUUsb0JBQW9CO0FBQ25FLFFBQVE7QUFDUixrQkFBa0Isb0JBQW9CLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3BFLFlBQVk7QUFDWjtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQixHQUFHLHFCQUFxQjtBQUNwRSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTLFdBQVcsU0FBUztBQUNsRCxxQkFBcUIsaUJBQWlCO0FBQ3RDLHFCQUFxQixrQkFBa0I7QUFDdkMscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQixRQUFRLE1BQU07QUFDbkU7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0IsUUFBUTtBQUM1RDtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQixRQUFRO0FBQzlEO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCLFFBQVE7QUFDNUQ7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RCxRQUFRO0FBQ1IsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVMsRUFBRSxTQUFTLEVBQUUsOEJBQThCO0FBQzFFO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0Ly4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi90cmFjZS5qcz81MTFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIG1lYW5zIG9mIHRyYWNpbmcgdGhlIHBhcnNlciB0aHJvdWdoIHRoZSBwYXJzZSB0cmVlIGFzIGl0IGdvZXMuXG4vLyBJdCBpcyB0aGUgcHJpbWFyeSBkZWJ1Z2dpbmcgZmFjaWxpdHkgZm9yIGRlYnVnZ2luZyBib3RoIHRoZSBTQUJORiBncmFtbWFyIHN5bnRheFxuLy8gYW5kIHRoZSBpbnB1dCBzdHJpbmdzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIGJlIHZhbGlkIGdyYW1tYXIgc2VudGVuY2VzLlxuLy8gSXQgaXMgYWxzbyBhIHZlcnkgaW5mb3JtYXRpdmUgYW5kIGVkdWNhdGlvbmFsIHRvb2wgZm9yIHVuZGVyc3RhbmRpbmdcbi8vIGhvdyBhIHBhcnNlciBhY3R1YWxseSBvcGVyYXRlcyBmb3IgYSBnaXZlbiBsYW5ndWFnZS5cbi8vXG4vLyBUcmFjaW5nIGlzIHRoZSBwcm9jZXNzIG9mIGdlbmVyYXRpbmcgYW5kIHNhdmluZyBhIHJlY29yZCBvZiBpbmZvcm1hdGlvbiBmb3IgZWFjaCBwYXNzYWdlXG4vLyBvZiB0aGUgcGFyc2VyIHRocm91Z2ggYSBwYXJzZSB0cmVlIG5vZGUuIEFuZCBzaW5jZSBpdCB0cmF2ZXJzZXMgZWFjaCBub2RlIHR3aWNlLCBvbmNlIGRvd24gdGhlIHRyZWVcbi8vIGFuZCBvbmNlIGNvbWluZyBiYWNrIHVwLCB0aGVyZSBhcmUgdHdvIHJlY29yZHMgZm9yIGVhY2ggbm9kZS5cbi8vIFRoaXMsIG9idmlvdXNseSwgaGFzIHRoZSBwb3RlbnRpYWwgb2YgZ2VuZXJhdGluZyBsb3RzIG9mIHJlY29yZHMuXG4vLyBBbmQgc2luY2UgdGhlc2UgcmVjb3JkcyBhcmUgbm9ybWFsbHkgZGlzcGxheWVkIG9uIGEgd2ViIHBhZ2Vcbi8vIGl0IGlzIGltcG9ydGFudCB0byBoYXZlIGEgbWVhbnMgdG8gbGltaXQgdGhlIGFjdHVhbCBudW1iZXIgb2YgcmVjb3JkcyBnZW5lcmF0ZWQgdG9cbi8vIHByb2JhYmx5IG5vIG1vcmUgdGhhdCBhIGZldyB0aG91c2FuZC4gVGhpcyBpcyBhbG1vc3QgYWx3YXlzIGVub3VnaCB0byBmaW5kIGFueSBlcnJvcnMuXG4vLyBUaGUgcHJvYmxlbSBpcyB0byBnZXQgdGhlICpyaWdodCogZmV3IHRob3VzYW5kIHJlY29yZHMuXG4vLyBUaGVyZWZvcmUsIHRoaXMgbW9kdWxlIGhhcyBhIG51bWJlciBvZiB3YXlzIG9mIGxpbWl0aW5nIGFuZC9vciBmaWx0ZXJpbmcsIHRoZSBudW1iZXIgYW5kIHR5cGUgb2YgcmVjb3Jkcy5cbi8vIENvbnNpZGVyYWJsZSBlZmZvcnQgaGFzIGJlZW4gbWFkZSB0byBtYWtlIHRoaXMgZmlsdGVyaW5nIG9mIHRoZSB0cmFjZSBvdXRwdXQgYXMgc2ltcGxlXG4vLyBhbmQgaW50dWl0aXZlIGFzIHBvc3NpYmxlLlxuLy9cbi8vIEhvd2V2ZXIsIHRoZSBhYmlsaXR5IHRvIGZpbHRlciB0aGUgdHJhY2UgcmVjb3Jkcywgb3IgZm9yIHRoYXQgbWF0dGVyIGV2ZW4gdW5kZXJzdGFuZCB3aGF0IHRoZXkgYXJlXG4vLyBhbmQgdGhlIGluZm9ybWF0aW9uIHRoZXkgY29udGFpbiwgZG9lcyByZXF1aXJlIGEgbWluaW11bSBhbW91bnQgb2YgdW5kZXJzdGFuZGluZyBvZiB0aGUgQVBHIHBhcnNpbmdcbi8vIG1ldGhvZC4gVGhlIHBhcnNlIHRyZWUgbm9kZXMgYXJlIGFsbCByZXByZXNlbnRlZCBieSBBUEcgb3BlcmF0b3JzLiBUaGV5IGJyZWFrIGRvd24gaW50byB0d28gbmF0dXJhbCBncm91cHMuXG4vLyAtIFRoZSBgUk5NYCBvcGVyYXRvcnMgYW5kIGBVRFRgIG9wZXJhdG9ycyBhcmUgbmFtZWQgcGhyYXNlcy5cbi8vIFRoZXNlIGFyZSBuYW1lcyBjaG9zZW4gYnkgdGhlIHdyaXRlciBvZiB0aGUgU0FCTkYgZ3JhbW1hciB0byByZXByZXNlbnQgc3BlY2lhbCBwaHJhc2VzIG9mIGludGVyZXN0LlxuLy8gLSBBbGwgb3RoZXJzIGNvbGxlY3QsIGNvbmNhdGVuYXRlIGFuZCBvdGhlcndpc2UgbWFuaXB1bGF0ZSB2YXJpb3VzIGludGVybWVkaWF0ZSBwaHJhc2VzIGFsb25nIHRoZSB3YXkuXG4vL1xuLy8gVGhlcmUgYXJlIHNlcGFyYXRlIG1lYW5zIG9mIGZpbHRlcmluZyB3aGljaCBvZiB0aGVzZSBvcGVyYXRvcnMgaW4gZWFjaCBvZiB0aGVzZSB0d28gZ3JvdXBzIGdldCB0cmFjZWQuXG4vLyBMZXQgYHRyYWNlYCBiZSBhbiBpbnN0YW50aWF0ZWQgYHRyYWNlLmpzYCBvYmplY3QuXG4vLyBQcmlvciB0byBwYXJzaW5nIHRoZSBzdHJpbmcsIGZpbHRlcmluZyB0aGUgcnVsZXMgYW5kIFVEVHMgY2FuIGJlIGRlZmluZWQgYXMgZm9sbG93czpcbi8vIGBgYFxuLy8gdHJhY2UuZmlsdGVyLnJ1bGVzW1wicnVsZW5hbWVcIl0gPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIHJ1bGUgbmFtZSBcInJ1bGVuYW1lXCIgKi9cbi8vIHRyYWNlLmZpbHRlci5ydWxlc1tcInVkdG5hbWVcIl0gID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBVRFQgbmFtZSBcInVkdG5hbWVcIiAqL1xuLy8gdHJhY2UuZmlsdGVyLnJ1bGVzW1wiPEFMTD5cIl0gICAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIGFsbCBydWxlcyBhbmQgVURUcyAodGhlIGRlZmF1bHQpICovXG4vLyB0cmFjZS5maWx0ZXIucnVsZXNbXCI8Tk9ORT5cIl0gICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2Ugbm8gcnVsZXMgb3IgVURUUyAqL1xuLy8gYGBgXG4vLyBJZiBhbnkgcnVsZSBvciBVRFQgbmFtZSBvdGhlciB0aGFuIFwiJmx0O0FMTD5cIiBvciBcIiZsdDtOT05FPlwiIGlzIHNwZWNpZmllZCwgYWxsIG90aGVyIG5hbWVzIGFyZSB0dXJuZWQgb2ZmLlxuLy8gVGhlcmVmb3JlLCB0byBiZSBzZWxlY3RpdmUgb2YgcnVsZSBuYW1lcywgYSBmaWx0ZXIgc3RhdGVtZW50IGlzIHJlcXVpcmVkIGZvciBlYWNoIHJ1bGUvVURUIG5hbWUgZGVzaXJlZC5cbi8vXG4vLyBGaWx0ZXJpbmcgb2YgdGhlIG90aGVyIG9wZXJhdG9ycyBmb2xsb3dzIGEgc2ltaWxhciBwcm9jZWR1cmUuXG4vLyBgYGBcbi8vIHRyYWNlLmZpbHRlci5vcGVyYXRvcnNbXCJUUkdcIl0gPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIHRoZSB0ZXJtaW5hbCByYW5nZSwgVFJHLCBvcGVyYXRvcnMgKi9cbi8vIHRyYWNlLmZpbHRlci5vcGVyYXRvcnNbXCJDQVRcIl0gID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSB0aGUgY29uY2F0ZW5hdGlvbnMsIENBVCwgb3BlcmF0b3JzICovXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiPEFMTD5cIl0gICAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIGFsbCBvcGVyYXRvcnMgKi9cbi8vIHRyYWNlLmZpbHRlci5vcGVyYXRvcnNbXCI8Tk9ORT5cIl0gICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2Ugbm8gb3BlcmF0b3JzICh0aGUgZGVmYXVsdCkgKi9cbi8vIGBgYFxuLy8gSWYgYW55IG9wZXJhdG9yIG5hbWUgb3RoZXIgdGhhbiBcIiZsdDtBTEw+XCIgb3IgXCImbHQ7Tk9ORT5cIiBpcyBzcGVjaWZpZWQsIGFsbCBvdGhlciBuYW1lcyBhcmUgdHVybmVkIG9mZi5cbi8vIFRoZXJlZm9yZSwgdG8gYmUgc2VsZWN0aXZlIG9mIG9wZXJhdG9yIG5hbWVzLCBhIGZpbHRlciBzdGF0ZW1lbnQgaXMgcmVxdWlyZWQgZm9yIGVhY2ggbmFtZSBkZXNpcmVkLlxuLy9cbi8vIFRoZXJlIGlzLCBhZGRpdGlvbmFsbHksIGEgbWVhbnMgZm9yIGxpbWl0aW5nIHRoZSB0b3RhbCBudW1iZXIgb2YgZmlsdGVyZWQgb3Igc2F2ZWQgdHJhY2UgcmVjb3Jkcy5cbi8vIFNlZSB0aGUgZnVuY3Rpb24sIGBzZXRNYXhSZWNvcmRzKG1heClgIGJlbG93LiBUaGlzIHdpbGwgcmVzdWx0IGluIG9ubHkgdGhlIGxhc3QgYG1heGAgcmVjb3JkcyBiZWluZyBzYXZlZC5cbi8vXG4vLyAoU2VlIFtgYXBnLWV4YW1wbGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qcy1leGFtcGxlcykgZm9yIGV4YW1wbGVzIG9mIHVzaW5nIGB0cmFjZS5qc2AuKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHBvcnRUcmFjZSgpIHtcbiAgY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxpdGllcycpO1xuICBjb25zdCBzdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGUnKTtcbiAgY29uc3QgY2lyY3VsYXIgPSBuZXcgKHJlcXVpcmUoJy4vY2lyY3VsYXItYnVmZmVyJykpKCk7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xuXG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICd0cmFjZS5qczogJztcbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIGNvbnN0IE1PREVfSEVYID0gMTY7XG4gIGNvbnN0IE1PREVfREVDID0gMTA7XG4gIGNvbnN0IE1PREVfQVNDSUkgPSA4O1xuICBjb25zdCBNT0RFX1VOSUNPREUgPSAzMjtcbiAgY29uc3QgTUFYX1BIUkFTRSA9IDgwO1xuICBjb25zdCBNQVhfVExTID0gNTtcbiAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICBsZXQgbWF4UmVjb3JkcyA9IDUwMDA7XG4gIGxldCBsYXN0UmVjb3JkID0gLTE7XG4gIGxldCBmaWx0ZXJlZFJlY29yZHMgPSAwO1xuICBsZXQgdHJlZURlcHRoID0gMDtcbiAgY29uc3QgcmVjb3JkU3RhY2sgPSBbXTtcbiAgbGV0IGNoYXJzID0gbnVsbDtcbiAgbGV0IHJ1bGVzID0gbnVsbDtcbiAgbGV0IHVkdHMgPSBudWxsO1xuICBjb25zdCBvcGVyYXRvckZpbHRlciA9IFtdO1xuICBjb25zdCBydWxlRmlsdGVyID0gW107XG4gIC8qIHNwZWNpYWwgdHJhY2UgdGFibGUgcGhyYXNlcyAqL1xuICBjb25zdCBQSFJBU0VfRU5EID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MSU5FRU5EfVwiPiZidWxsOzwvc3Bhbj5gO1xuICBjb25zdCBQSFJBU0VfQ09OVElOVUUgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xJTkVFTkR9XCI+JmhlbGxpcDs8L3NwYW4+YDtcbiAgY29uc3QgUEhSQVNFX0VNUFRZID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj4mIzEyMDYzNDs8L3NwYW4+YDtcbiAgLyogZmlsdGVyIHRoZSBub24tUk5NICYgbm9uLVVEVCBvcGVyYXRvcnMgKi9cbiAgY29uc3QgaW5pdE9wZXJhdG9yRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHNldE9wZXJhdG9ycyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFMVF0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5DQVRdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuUkVQXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRMU10gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5UQlNdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVFJHXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFORF0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5OT1RdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktSXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLQV0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5CS05dID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQUJHXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFFTl0gPSBzZXQ7XG4gICAgfTtcbiAgICBsZXQgaXRlbXMgPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGF0LmZpbHRlci5vcGVyYXRvcnMpIHtcbiAgICAgIGl0ZW1zICs9IDE7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gMCkge1xuICAgICAgLyogY2FzZSAxOiBubyBvcGVyYXRvcnMgc3BlY2lmaWVkOiBkZWZhdWx0OiBkbyBub3QgdHJhY2UgYW55IG9wZXJhdG9ycyAqL1xuICAgICAgc2V0T3BlcmF0b3JzKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoYXQuZmlsdGVyLm9wZXJhdG9ycykge1xuICAgICAgY29uc3QgdXBwZXIgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAodXBwZXIgPT09ICc8QUxMPicpIHtcbiAgICAgICAgLyogY2FzZSAyOiA8YWxsPiBvcGVyYXRvcnMgc3BlY2lmaWVkOiB0cmFjZSBhbGwgb3BlcmF0b3JzIGlnbm9yZSBhbGwgb3RoZXIgb3BlcmF0b3IgY29tbWFuZHMgKi9cbiAgICAgICAgc2V0T3BlcmF0b3JzKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgPT09ICc8Tk9ORT4nKSB7XG4gICAgICAgIC8qIGNhc2UgMzogPG5vbmU+IG9wZXJhdG9ycyBzcGVjaWZpZWQ6IHRyYWNlIE5PIG9wZXJhdG9ycyBpZ25vcmUgYWxsIG90aGVyIG9wZXJhdG9yIGNvbW1hbmRzICovXG4gICAgICAgIHNldE9wZXJhdG9ycyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0T3BlcmF0b3JzKGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIub3BlcmF0b3JzKSB7XG4gICAgICBjb25zdCB1cHBlciA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgIC8qIGNhc2UgNDogb25lIG9yIG1vcmUgaW5kaXZpZHVhbCBvcGVyYXRvcnMgc3BlY2lmaWVkOiB0cmFjZSAndHJ1ZScgb3BlcmF0b3JzIG9ubHkgKi9cbiAgICAgIGlmICh1cHBlciA9PT0gJ0FMVCcpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQUxUXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdDQVQnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkNBVF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnUkVQJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5SRVBdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0FORCcpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQU5EXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdOT1QnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLk5PVF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnVExTJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5UTFNdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ1RCUycpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVEJTXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdUUkcnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRSR10gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQktSJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5CS1JdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0JLQScpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktBXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdCS04nKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLTl0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQUJHJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5BQkddID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0FFTicpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQUVOXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHt0aGlzRmlsZU5hbWV9aW5pdE9wcmF0b3JGaWx0ZXI6ICcke25hbWV9JyBub3QgYSB2YWxpZCBvcGVyYXRvciBuYW1lLmAgK1xuICAgICAgICAgICAgYCBNdXN0IGJlIDxhbGw+LCA8bm9uZT4sIGFsdCwgY2F0LCByZXAsIHRscywgdGJzLCB0cmcsIGFuZCwgbm90LCBia3IsIGJrYSBvciBia25gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBmaWx0ZXIgdGhlIHJ1bGUgYW5kIGBVRFRgIG5hbWVkIG9wZXJhdG9ycyAqL1xuICBjb25zdCBpbml0UnVsZUZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZXRSdWxlcyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlJOTV0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5VRFRdID0gc2V0O1xuICAgICAgY29uc3QgY291bnQgPSBydWxlcy5sZW5ndGggKyB1ZHRzLmxlbmd0aDtcbiAgICAgIHJ1bGVGaWx0ZXIubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgICBydWxlRmlsdGVyLnB1c2goc2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBpdGVtcztcbiAgICBsZXQgaTtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsaXN0LnB1c2gocnVsZXNbaV0ubG93ZXIpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHVkdHNbaV0ubG93ZXIpO1xuICAgIH1cbiAgICBydWxlRmlsdGVyLmxlbmd0aCA9IDA7XG4gICAgaXRlbXMgPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGF0LmZpbHRlci5ydWxlcykge1xuICAgICAgaXRlbXMgKz0gMTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zID09PSAwKSB7XG4gICAgICAvKiBjYXNlIDE6IGRlZmF1bHQgdG8gYWxsIHJ1bGVzICYgdWR0cyAqL1xuICAgICAgc2V0UnVsZXModHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGF0LmZpbHRlci5ydWxlcykge1xuICAgICAgY29uc3QgbG93ZXIgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXIgPT09ICc8YWxsPicpIHtcbiAgICAgICAgLyogY2FzZSAyOiB0cmFjZSBhbGwgcnVsZXMgaWdub3JlIGFsbCBvdGhlciBydWxlIGNvbW1hbmRzICovXG4gICAgICAgIHNldFJ1bGVzKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09ICc8bm9uZT4nKSB7XG4gICAgICAgIC8qIGNhc2UgMzogdHJhY2Ugbm8gcnVsZXMgKi9cbiAgICAgICAgc2V0UnVsZXMoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGNhc2UgNDogdHJhY2Ugb25seSBpbmRpdmlkdWFsbHkgc3BlY2lmaWVkIHJ1bGVzICovXG4gICAgc2V0UnVsZXMoZmFsc2UpO1xuICAgIG9wZXJhdG9yRmlsdGVyW2lkLlJOTV0gPSB0cnVlO1xuICAgIG9wZXJhdG9yRmlsdGVyW2lkLlVEVF0gPSB0cnVlO1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGF0LmZpbHRlci5ydWxlcykge1xuICAgICAgY29uc3QgbG93ZXIgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpID0gbGlzdC5pbmRleE9mKGxvd2VyKTtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWluaXRSdWxlRmlsdGVyOiAnJHtuYW1lfScgbm90IGEgdmFsaWQgcnVsZSBvciB1ZHQgbmFtZWApO1xuICAgICAgfVxuICAgICAgcnVsZUZpbHRlcltpXSA9IHRoYXQuZmlsdGVyLnJ1bGVzW25hbWVdID09PSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgLyogdXNlZCBieSBvdGhlciBBUEcgY29tcG9uZW50cyB0byB2ZXJpZnkgdGhhdCB0aGV5IGhhdmUgYSB2YWxpZCB0cmFjZSBvYmplY3QgKi9cbiAgdGhpcy50cmFjZU9iamVjdCA9ICd0cmFjZU9iamVjdCc7XG4gIHRoaXMuZmlsdGVyID0ge1xuICAgIG9wZXJhdG9yczogW10sXG4gICAgcnVsZXM6IFtdLFxuICB9O1xuICAvLyBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdG8ga2VlcCAoZGVmYXVsdCA9IDUwMDApLlxuICAvLyBFYWNoIHJlY29yZCBudW1iZXIgbGFyZ2VyIHRoYW4gYG1heFJlY29yZHNgXG4gIC8vIHdpbGwgcmVzdWx0IGluIGRlbGV0aW5nIHRoZSBwcmV2aW91c2x5IG9sZGVzdCByZWNvcmQuXG4gIC8vIC0gYG1heGA6IG1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdG8gcmV0YWluIChkZWZhdWx0ID0gNTAwMClcbiAgLy8gLSBgbGFzdGA6IGxhc3QgcmVjb3JkIG51bWJlciB0byByZXRhaW4sIChkZWZhdWx0ID0gLTEgZm9yICh1bmtub3duKSBhY3R1YWwgbGFzdCByZWNvcmQpXG4gIHRoaXMuc2V0TWF4UmVjb3JkcyA9IGZ1bmN0aW9uIChtYXgsIGxhc3QpIHtcbiAgICBsYXN0UmVjb3JkID0gLTE7XG4gICAgaWYgKHR5cGVvZiBtYXggPT09ICdudW1iZXInICYmIG1heCA+IDApIHtcbiAgICAgIG1heFJlY29yZHMgPSBNYXRoLmNlaWwobWF4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4UmVjb3JkcyA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxhc3RSZWNvcmQgPSBNYXRoLmZsb29yKGxhc3QpO1xuICAgICAgaWYgKGxhc3RSZWNvcmQgPCAwKSB7XG4gICAgICAgIGxhc3RSZWNvcmQgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFJldHVybnMgYG1heFJlY29yZHNgIHRvIHRoZSBjYWxsZXIuXG4gIHRoaXMuZ2V0TWF4UmVjb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWF4UmVjb3JkcztcbiAgfTtcbiAgLy8gUmV0dXJucyBgbGFzdFJlY29yZGAgdG8gdGhlIGNhbGxlci5cbiAgdGhpcy5nZXRMYXN0UmVjb3JkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsYXN0UmVjb3JkO1xuICB9O1xuICAvKiBDYWxsZWQgb25seSBieSB0aGUgYHBhcnNlci5qc2Agb2JqZWN0LiBObyB2ZXJpZmljYXRpb24gb2YgaW5wdXQuICovXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChydWxlc0luLCB1ZHRzSW4sIGNoYXJzSW4pIHtcbiAgICByZWNvcmRzLmxlbmd0aCA9IDA7XG4gICAgcmVjb3JkU3RhY2subGVuZ3RoID0gMDtcbiAgICBmaWx0ZXJlZFJlY29yZHMgPSAwO1xuICAgIHRyZWVEZXB0aCA9IDA7XG4gICAgY2hhcnMgPSBjaGFyc0luO1xuICAgIHJ1bGVzID0gcnVsZXNJbjtcbiAgICB1ZHRzID0gdWR0c0luO1xuICAgIGluaXRPcGVyYXRvckZpbHRlcigpO1xuICAgIGluaXRSdWxlRmlsdGVyKCk7XG4gICAgY2lyY3VsYXIuaW5pdChtYXhSZWNvcmRzKTtcbiAgfTtcbiAgLyogcmV0dXJucyB0cnVlIGlmIHRoaXMgcmVjb3JkcyBwYXNzZXMgdGhyb3VnaCB0aGUgZGVzaWduYXRlZCBmaWx0ZXIsIGZhbHNlIGlmIHRoZSByZWNvcmQgaXMgdG8gYmUgc2tpcHBlZCAqL1xuICBjb25zdCBmaWx0ZXJPcHMgPSBmdW5jdGlvbiAob3ApIHtcbiAgICBsZXQgcmV0ID0gZmFsc2U7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgaWYgKG9wZXJhdG9yRmlsdGVyW29wLnR5cGVdICYmIHJ1bGVGaWx0ZXJbb3AuaW5kZXhdKSB7XG4gICAgICAgIHJldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IGlkLlVEVCkge1xuICAgICAgaWYgKG9wZXJhdG9yRmlsdGVyW29wLnR5cGVdICYmIHJ1bGVGaWx0ZXJbcnVsZXMubGVuZ3RoICsgb3AuaW5kZXhdKSB7XG4gICAgICAgIHJldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ID0gb3BlcmF0b3JGaWx0ZXJbb3AudHlwZV07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIGNvbnN0IGZpbHRlclJlY29yZHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgaWYgKGxhc3RSZWNvcmQgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlY29yZCA8PSBsYXN0UmVjb3JkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKiBDb2xsZWN0IHRoZSBcImRvd25cIiByZWNvcmQuICovXG4gIHRoaXMuZG93biA9IGZ1bmN0aW9uIChvcCwgc3RhdGUsIG9mZnNldCwgbGVuZ3RoLCBhbmNob3IsIGxvb2tBcm91bmQpIHtcbiAgICBpZiAoZmlsdGVyUmVjb3JkcyhmaWx0ZXJlZFJlY29yZHMpICYmIGZpbHRlck9wcyhvcCkpIHtcbiAgICAgIHJlY29yZFN0YWNrLnB1c2goZmlsdGVyZWRSZWNvcmRzKTtcbiAgICAgIHJlY29yZHNbY2lyY3VsYXIuaW5jcmVtZW50KCldID0ge1xuICAgICAgICBkaXJVcDogZmFsc2UsXG4gICAgICAgIGRlcHRoOiB0cmVlRGVwdGgsXG4gICAgICAgIHRoaXNMaW5lOiBmaWx0ZXJlZFJlY29yZHMsXG4gICAgICAgIHRoYXRMaW5lOiB1bmRlZmluZWQsXG4gICAgICAgIG9wY29kZTogb3AsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwaHJhc2VJbmRleDogb2Zmc2V0LFxuICAgICAgICBwaHJhc2VMZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgbG9va0FuY2hvcjogYW5jaG9yLFxuICAgICAgICBsb29rQXJvdW5kLFxuICAgICAgfTtcbiAgICAgIGZpbHRlcmVkUmVjb3JkcyArPSAxO1xuICAgICAgdHJlZURlcHRoICs9IDE7XG4gICAgfVxuICB9O1xuICAvKiBDb2xsZWN0IHRoZSBcInVwXCIgcmVjb3JkLiAqL1xuICB0aGlzLnVwID0gZnVuY3Rpb24gKG9wLCBzdGF0ZSwgb2Zmc2V0LCBsZW5ndGgsIGFuY2hvciwgbG9va0Fyb3VuZCkge1xuICAgIGlmIChmaWx0ZXJSZWNvcmRzKGZpbHRlcmVkUmVjb3JkcykgJiYgZmlsdGVyT3BzKG9wKSkge1xuICAgICAgY29uc3QgdGhpc0xpbmUgPSBmaWx0ZXJlZFJlY29yZHM7XG4gICAgICBjb25zdCB0aGF0TGluZSA9IHJlY29yZFN0YWNrLnBvcCgpO1xuICAgICAgY29uc3QgdGhhdFJlY29yZCA9IGNpcmN1bGFyLmdldExpc3RJbmRleCh0aGF0TGluZSk7XG4gICAgICBpZiAodGhhdFJlY29yZCAhPT0gLTEpIHtcbiAgICAgICAgcmVjb3Jkc1t0aGF0UmVjb3JkXS50aGF0TGluZSA9IHRoaXNMaW5lO1xuICAgICAgfVxuICAgICAgdHJlZURlcHRoIC09IDE7XG4gICAgICByZWNvcmRzW2NpcmN1bGFyLmluY3JlbWVudCgpXSA9IHtcbiAgICAgICAgZGlyVXA6IHRydWUsXG4gICAgICAgIGRlcHRoOiB0cmVlRGVwdGgsXG4gICAgICAgIHRoaXNMaW5lLFxuICAgICAgICB0aGF0TGluZSxcbiAgICAgICAgb3Bjb2RlOiBvcCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHBocmFzZUluZGV4OiBvZmZzZXQsXG4gICAgICAgIHBocmFzZUxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBsb29rQW5jaG9yOiBhbmNob3IsXG4gICAgICAgIGxvb2tBcm91bmQsXG4gICAgICB9O1xuICAgICAgZmlsdGVyZWRSZWNvcmRzICs9IDE7XG4gICAgfVxuICB9O1xuICAvKiBjb252ZXJ0IHRoZSB0cmFjZSByZWNvcmRzIHRvIGEgdHJlZSBvZiBub2RlcyAqL1xuICBjb25zdCB0b1RyZWVPYmogPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogcHJpdmF0ZSBoZWxwZXIgZnVuY3Rpb25zICovXG4gICAgZnVuY3Rpb24gbm9kZU9wY29kZShub2RlLCBvcGNvZGUpIHtcbiAgICAgIGxldCBuYW1lO1xuICAgICAgbGV0IGNhc2V0eXBlO1xuICAgICAgbGV0IG1vZGV0eXBlO1xuICAgICAgaWYgKG9wY29kZSkge1xuICAgICAgICBub2RlLm9wID0geyBpZDogb3Bjb2RlLnR5cGUsIG5hbWU6IHV0aWxzLm9wY29kZVRvU3RyaW5nKG9wY29kZS50eXBlKSB9O1xuICAgICAgICBub2RlLm9wRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3dpdGNoIChvcGNvZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgaWQuUk5NOlxuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSBydWxlc1tvcGNvZGUuaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gdWR0c1tvcGNvZGUuaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLUjpcbiAgICAgICAgICAgIGlmIChvcGNvZGUuaW5kZXggPCBydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHJ1bGVzW29wY29kZS5pbmRleF0ubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWUgPSB1ZHRzW29wY29kZS5pbmRleCAtIHJ1bGVzLmxlbmd0aF0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2V0eXBlID0gb3Bjb2RlLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NJID8gJyVpJyA6ICclcyc7XG4gICAgICAgICAgICBtb2RldHlwZSA9IG9wY29kZS5ia3JNb2RlID09PSBpZC5CS1JfTU9ERV9VTSA/ICcldScgOiAnJXAnO1xuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSBgXFxcXFxcXFwke2Nhc2V0eXBlfSR7bW9kZXR5cGV9JHtuYW1lfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRMUzpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wY29kZS5zdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgbm9kZS5vcERhdGEucHVzaChvcGNvZGUuc3RyaW5nW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVEJTOlxuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3Bjb2RlLnN0cmluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBub2RlLm9wRGF0YS5wdXNoKG9wY29kZS5zdHJpbmdbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IFtvcGNvZGUubWluLCBvcGNvZGUubWF4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSBbb3Bjb2RlLm1pbiwgb3Bjb2RlLm1heF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUub3AgPSB7IGlkOiB1bmRlZmluZWQsIG5hbWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICBub2RlLm9wRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbm9kZVBocmFzZShzdGF0ZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgaWYgKHN0YXRlID09PSBpZC5NQVRDSCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5vZGVJZCA9IC0xO1xuICAgIGZ1bmN0aW9uIG5vZGVEb3duKHBhcmVudCwgcmVjb3JkLCBkZXB0aCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBsdXNwbHVzXG4gICAgICAgIGlkOiBub2RlSWQrKyxcbiAgICAgICAgYnJhbmNoOiAtMSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICB1cDogZmFsc2UsXG4gICAgICAgIGRvd246IGZhbHNlLFxuICAgICAgICBkZXB0aCxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgfTtcbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbm9kZS5kb3duID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5zdGF0ZSA9IHsgaWQ6IHJlY29yZC5zdGF0ZSwgbmFtZTogdXRpbHMuc3RhdGVUb1N0cmluZyhyZWNvcmQuc3RhdGUpIH07XG4gICAgICAgIG5vZGUucGhyYXNlID0gbnVsbDtcbiAgICAgICAgbm9kZU9wY29kZShub2RlLCByZWNvcmQub3Bjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc3RhdGUgPSB7IGlkOiB1bmRlZmluZWQsIG5hbWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICBub2RlLnBocmFzZSA9IG5vZGVQaHJhc2UoKTtcbiAgICAgICAgbm9kZU9wY29kZShub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVVcChub2RlLCByZWNvcmQpIHtcbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbm9kZS51cCA9IHRydWU7XG4gICAgICAgIG5vZGUuc3RhdGUgPSB7IGlkOiByZWNvcmQuc3RhdGUsIG5hbWU6IHV0aWxzLnN0YXRlVG9TdHJpbmcocmVjb3JkLnN0YXRlKSB9O1xuICAgICAgICBub2RlLnBocmFzZSA9IG5vZGVQaHJhc2UocmVjb3JkLnN0YXRlLCByZWNvcmQucGhyYXNlSW5kZXgsIHJlY29yZC5waHJhc2VMZW5ndGgpO1xuICAgICAgICBpZiAoIW5vZGUuZG93bikge1xuICAgICAgICAgIG5vZGVPcGNvZGUobm9kZSwgcmVjb3JkLm9wY29kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogd2FsayB0aGUgZmluYWwgdHJlZTogbGFiZWwgYnJhbmNoZXMgYW5kIGNvdW50IGxlYWYgbm9kZXMgKi9cbiAgICBsZXQgbGVhZk5vZGVzID0gMDtcbiAgICBsZXQgZGVwdGggPSAtMTtcbiAgICBsZXQgYnJhbmNoQ291bnQgPSAxO1xuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICAgICAgZGVwdGggKz0gMTtcbiAgICAgIG5vZGUuYnJhbmNoID0gYnJhbmNoQ291bnQ7XG4gICAgICBpZiAoZGVwdGggPiB0cmVlRGVwdGgpIHtcbiAgICAgICAgdHJlZURlcHRoID0gZGVwdGg7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbGVhZk5vZGVzICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGJyYW5jaENvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuY2hpbGRyZW5baV0ubGVmdE1vc3QgPSBmYWxzZTtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLnJpZ2h0TW9zdCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChub2RlLmxlZnRNb3N0KSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmxlZnRNb3N0ID0gaSA9PT0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUucmlnaHRNb3N0KSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLnJpZ2h0TW9zdCA9IGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2Fsayhub2RlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVwdGggLT0gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGxheShub2RlLCBvZmZzZXQpIHtcbiAgICAgIGxldCBuYW1lO1xuICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICBvYmouaWQgPSBub2RlLmlkO1xuICAgICAgb2JqLmJyYW5jaCA9IG5vZGUuYnJhbmNoO1xuICAgICAgb2JqLmxlZnRNb3N0ID0gbm9kZS5sZWZ0TW9zdDtcbiAgICAgIG9iai5yaWdodE1vc3QgPSBub2RlLnJpZ2h0TW9zdDtcbiAgICAgIG5hbWUgPSBub2RlLnN0YXRlLm5hbWUgPyBub2RlLnN0YXRlLm5hbWUgOiAnQUNUSVZFJztcbiAgICAgIG9iai5zdGF0ZSA9IHsgaWQ6IG5vZGUuc3RhdGUuaWQsIG5hbWUgfTtcbiAgICAgIG5hbWUgPSBub2RlLm9wLm5hbWUgPyBub2RlLm9wLm5hbWUgOiAnPyc7XG4gICAgICBvYmoub3AgPSB7IGlkOiBub2RlLm9wLmlkLCBuYW1lIH07XG4gICAgICBpZiAodHlwZW9mIG5vZGUub3BEYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBvYmoub3BEYXRhID0gbm9kZS5vcERhdGE7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5vcERhdGEpKSB7XG4gICAgICAgIG9iai5vcERhdGEgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm9wRGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIG9iai5vcERhdGFbaV0gPSBub2RlLm9wRGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLm9wRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnBocmFzZSkge1xuICAgICAgICBvYmoucGhyYXNlID0geyBpbmRleDogbm9kZS5waHJhc2UuaW5kZXgsIGxlbmd0aDogbm9kZS5waHJhc2UubGVuZ3RoIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmoucGhyYXNlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG9iai5kZXB0aCA9IG5vZGUuZGVwdGg7XG4gICAgICBvYmouY2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjID0gaSAhPT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBvYmouY2hpbGRyZW5baV0gPSBkaXNwbGF5KG5vZGUuY2hpbGRyZW5baV0sIG9mZnNldCwgYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIC8qIGNvbnN0cnVjdCB0aGUgdHJlZSBiZWdpbm5pbmcgaGVyZSAqL1xuICAgIGNvbnN0IGJyYW5jaCA9IFtdO1xuICAgIGxldCByb290O1xuICAgIGxldCBub2RlO1xuICAgIGxldCBwYXJlbnQ7XG4gICAgbGV0IHJlY29yZDtcbiAgICBsZXQgZmlyc3RSZWNvcmQgPSB0cnVlO1xuICAgIC8qIHB1c2ggYSBkdW1teSBub2RlIHNvIHRoZSByb290IG5vZGUgd2lsbCBoYXZlIGEgbm9uLW51bGwgcGFyZW50ICovXG4gICAgY29uc3QgZHVtbXkgPSBub2RlRG93bihudWxsLCBudWxsLCAtMSk7XG4gICAgYnJhbmNoLnB1c2goZHVtbXkpO1xuICAgIG5vZGUgPSBkdW1teTtcbiAgICBjaXJjdWxhci5mb3JFYWNoKChsaW5lSW5kZXgpID0+IHtcbiAgICAgIHJlY29yZCA9IHJlY29yZHNbbGluZUluZGV4XTtcbiAgICAgIGlmIChmaXJzdFJlY29yZCkge1xuICAgICAgICBmaXJzdFJlY29yZCA9IGZhbHNlO1xuICAgICAgICBpZiAocmVjb3JkLmRlcHRoID4gMCkge1xuICAgICAgICAgIC8qIHB1c2ggc29tZSBkdW1teSBub2RlcyB0byBmaWxsIGluIGZvciBtaXNzaW5nIHJlY29yZHMgKi9cbiAgICAgICAgICBjb25zdCBudW0gPSByZWNvcmQuZGlyVXAgPyByZWNvcmQuZGVwdGggKyAxIDogcmVjb3JkLmRlcHRoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZURvd24obm9kZSwgbnVsbCwgaSk7XG4gICAgICAgICAgICBicmFuY2gucHVzaChub2RlKTtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlY29yZC5kaXJVcCkge1xuICAgICAgICAvKiBoYW5kbGUgdGhlIG5leHQgcmVjb3JkIHVwICovXG4gICAgICAgIG5vZGUgPSBicmFuY2gucG9wKCk7XG4gICAgICAgIG5vZGVVcChub2RlLCByZWNvcmQpO1xuICAgICAgICBub2RlID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGhhbmRsZSB0aGUgbmV4dCByZWNvcmQgZG93biAqL1xuICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZURvd24obm9kZSwgcmVjb3JkLCByZWNvcmQuZGVwdGgpO1xuICAgICAgICBicmFuY2gucHVzaChub2RlKTtcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiBpZiBub3QgYXQgcm9vdCwgd2FsayBpdCB1cCB0byByb290ICovXG4gICAgd2hpbGUgKGJyYW5jaC5sZW5ndGggPiAxKSB7XG4gICAgICBub2RlID0gYnJhbmNoLnBvcCgpO1xuICAgICAgbm9kZVVwKG5vZGUsIG51bGwpO1xuICAgIH1cbiAgICAvKiBtYXliZSByZWR1bmRhbnQgb3IgcGFyYW5vaWQgdGVzdHM6IHRoZXNlIHNob3VsZCBuZXZlciBoYXBwZW4gKi9cbiAgICBpZiAoZHVtbXkuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYWNlLnRvVHJlZSgpOiBwYXJzZSB0cmVlIGhhcyBubyBub2RlcycpO1xuICAgIH1cbiAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjZS50b1RyZWUoKTogaW50ZWdyaXR5IGNoZWNrOiBkdW1teSByb290IG5vZGUgZGlzYXBwZWFyZWQ/Jyk7XG4gICAgfVxuXG4gICAgLyogaWYgbm8gcmVjb3JkIGZvciBzdGFydCBydWxlOiBmaW5kIHRoZSBwc2V1ZG8gcm9vdCBub2RlIChmaXJzdCBkdW1teSBub2RlIGFib3ZlIGEgcmVhbCBub2RlKSAqL1xuICAgIHJvb3QgPSBkdW1teS5jaGlsZHJlblswXTtcbiAgICBsZXQgcHJldiA9IHJvb3Q7XG4gICAgd2hpbGUgKHJvb3QgJiYgIXJvb3QuZG93biAmJiAhcm9vdC51cCkge1xuICAgICAgcHJldiA9IHJvb3Q7XG4gICAgICByb290ID0gcm9vdC5jaGlsZHJlblswXTtcbiAgICB9XG4gICAgcm9vdCA9IHByZXY7XG5cbiAgICAvKiB3YWxrIHRoZSB0cmVlIG9mIG5vZGVzOiBsYWJlbCBicmFuY2VzIGFuZCBjb3VudCBsZWF2ZXMgKi9cbiAgICByb290LmxlZnRNb3N0ID0gdHJ1ZTtcbiAgICByb290LnJpZ2h0TW9zdCA9IHRydWU7XG4gICAgd2Fsayhyb290KTtcbiAgICByb290LmJyYW5jaCA9IDA7XG5cbiAgICAvKiBnZW5lcmF0ZSB0aGUgZXhwb3J0ZWQgb2JqZWN0ICovXG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgb2JqLnN0cmluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9iai5zdHJpbmdbaV0gPSBjaGFyc1tpXTtcbiAgICB9XG4gICAgLyogZ2VuZXJhdGUgdGhlIGV4cG9ydGVkIHJ1bGUgbmFtZXMgKi9cbiAgICBvYmoucnVsZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvYmoucnVsZXNbaV0gPSBydWxlc1tpXS5uYW1lO1xuICAgIH1cbiAgICAvKiBnZW5lcmF0ZSB0aGUgZXhwb3J0ZWQgVURUIG5hbWVzICovXG4gICAgb2JqLnVkdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9iai51ZHRzW2ldID0gdWR0c1tpXS5uYW1lO1xuICAgIH1cbiAgICAvKiBnZW5lcmF0ZSB0aGUgaWRzICovXG4gICAgb2JqLmlkID0ge307XG4gICAgb2JqLmlkLkFMVCA9IHsgaWQ6IGlkLkFMVCwgbmFtZTogJ0FMVCcgfTtcbiAgICBvYmouaWQuQ0FUID0geyBpZDogaWQuQ0FULCBuYW1lOiAnQ0FUJyB9O1xuICAgIG9iai5pZC5SRVAgPSB7IGlkOiBpZC5SRVAsIG5hbWU6ICdSRVAnIH07XG4gICAgb2JqLmlkLlJOTSA9IHsgaWQ6IGlkLlJOTSwgbmFtZTogJ1JOTScgfTtcbiAgICBvYmouaWQuVExTID0geyBpZDogaWQuVExTLCBuYW1lOiAnVExTJyB9O1xuICAgIG9iai5pZC5UQlMgPSB7IGlkOiBpZC5UQlMsIG5hbWU6ICdUQlMnIH07XG4gICAgb2JqLmlkLlRSRyA9IHsgaWQ6IGlkLlRSRywgbmFtZTogJ1RSRycgfTtcbiAgICBvYmouaWQuVURUID0geyBpZDogaWQuVURULCBuYW1lOiAnVURUJyB9O1xuICAgIG9iai5pZC5BTkQgPSB7IGlkOiBpZC5BTkQsIG5hbWU6ICdBTkQnIH07XG4gICAgb2JqLmlkLk5PVCA9IHsgaWQ6IGlkLk5PVCwgbmFtZTogJ05PVCcgfTtcbiAgICBvYmouaWQuQktSID0geyBpZDogaWQuQktSLCBuYW1lOiAnQktSJyB9O1xuICAgIG9iai5pZC5CS0EgPSB7IGlkOiBpZC5CS0EsIG5hbWU6ICdCS0EnIH07XG4gICAgb2JqLmlkLkJLTiA9IHsgaWQ6IGlkLkJLTiwgbmFtZTogJ0JLTicgfTtcbiAgICBvYmouaWQuQUJHID0geyBpZDogaWQuQUJHLCBuYW1lOiAnQUJHJyB9O1xuICAgIG9iai5pZC5BRU4gPSB7IGlkOiBpZC5BRU4sIG5hbWU6ICdBRU4nIH07XG4gICAgb2JqLmlkLkFDVElWRSA9IHsgaWQ6IGlkLkFDVElWRSwgbmFtZTogJ0FDVElWRScgfTtcbiAgICBvYmouaWQuTUFUQ0ggPSB7IGlkOiBpZC5NQVRDSCwgbmFtZTogJ01BVENIJyB9O1xuICAgIG9iai5pZC5FTVBUWSA9IHsgaWQ6IGlkLkVNUFRZLCBuYW1lOiAnRU1QVFknIH07XG4gICAgb2JqLmlkLk5PTUFUQ0ggPSB7IGlkOiBpZC5OT01BVENILCBuYW1lOiAnTk9NQVRDSCcgfTtcbiAgICAvKiBnZW5lcmF0ZSB0aGUgbWF4IHRyZWUgZGVwdGggKi9cbiAgICBvYmoudHJlZURlcHRoID0gdHJlZURlcHRoO1xuICAgIC8qIGdlbmVyYXRlIHRoZSBudW1iZXIgb2YgbGVhZiBub2RlcyAoYnJhbmNoZXMpICovXG4gICAgb2JqLmxlYWZOb2RlcyA9IGxlYWZOb2RlcztcbiAgICAvKiBnZW5lcmF0ZSB0aGUgdHlwZXMgb2YgdGhlIGxlZnQtIGFuZCByaWdodC1tb3N0IGJyYW5jaGVzICovXG4gICAgbGV0IGJyYW5jaGVzSW5jb21wbGV0ZTtcbiAgICBpZiAocm9vdC5kb3duKSB7XG4gICAgICBpZiAocm9vdC51cCkge1xuICAgICAgICBicmFuY2hlc0luY29tcGxldGUgPSAnbm9uZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmFuY2hlc0luY29tcGxldGUgPSAncmlnaHQnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocm9vdC51cCkge1xuICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ2xlZnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmFuY2hlc0luY29tcGxldGUgPSAnYm90aCc7XG4gICAgfVxuICAgIG9iai5icmFuY2hlc0luY29tcGxldGUgPSBicmFuY2hlc0luY29tcGxldGU7XG4gICAgb2JqLnRyZWUgPSBkaXNwbGF5KHJvb3QsIHJvb3QuZGVwdGgsIGZhbHNlKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuICAvLyBSZXR1cm5zIHRoZSB0cmFjZSByZWNvcmRzIGFzIEpTT04gcGFyc2UgdHJlZSBvYmplY3QuXG4gIC8vIC0gc3RyaW5naWZ5OiBpZiBgdHJ1ZWAsIHRoZSBvYmplY3QgaXMgJ3N0cmluZ2lmaWVkJyBiZWZvcmUgcmV0dXJuaW5nLCBvdGhlcndpc2UsIHRoZSBvYmplY3QgaXRzZWxmIGlzIHJldHVybmVkLlxuICB0aGlzLnRvVHJlZSA9IGZ1bmN0aW9uIChzdHJpbmdpZnkpIHtcbiAgICBjb25zdCBvYmogPSB0b1RyZWVPYmooKTtcbiAgICBpZiAoc3RyaW5naWZ5KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbiAgLy8gVHJhbnNsYXRlIHRoZSB0cmFjZSByZWNvcmRzIHRvIEhUTUwgZm9ybWF0IGFuZCBjcmVhdGUgYSBjb21wbGV0ZSBIVE1MIHBhZ2UgZm9yIGJyb3dzZXIgZGlzcGxheS5cbiAgdGhpcy50b0h0bWxQYWdlID0gZnVuY3Rpb24gKG1vZGUsIGNhcHRpb24sIHRpdGxlKSB7XG4gICAgcmV0dXJuIHV0aWxzLmh0bWxUb1BhZ2UodGhpcy50b0h0bWwobW9kZSwgY2FwdGlvbiksIHRpdGxlKTtcbiAgfTtcblxuICAvKiBGcm9tIGhlcmUgb24gZG93biwgdGhlc2UgYXJlIGp1c3QgaGVscGVyIGZ1bmN0aW9ucyBmb3IgYHRvSHRtbCgpYC4gKi9cbiAgY29uc3QgaHRtbEhlYWRlciA9IGZ1bmN0aW9uIChtb2RlLCBjYXB0aW9uKSB7XG4gICAgLyogb3BlbiB0aGUgcGFnZSAqL1xuICAgIC8qIHdyaXRlIHRoZSBIVE1MNSBoZWFkZXIgd2l0aCB0YWJsZSBzdHlsZSAqL1xuICAgIC8qIG9wZW4gdGhlIDx0YWJsZT4gdGFnICovXG4gICAgbGV0IG1vZGVOYW1lO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBNT0RFX0hFWDpcbiAgICAgICAgbW9kZU5hbWUgPSAnaGV4YWRlY2ltYWwnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9ERV9ERUM6XG4gICAgICAgIG1vZGVOYW1lID0gJ2RlY2ltYWwnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9ERV9BU0NJSTpcbiAgICAgICAgbW9kZU5hbWUgPSAnQVNDSUknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9ERV9VTklDT0RFOlxuICAgICAgICBtb2RlTmFtZSA9ICdVTklDT0RFJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWh0bWxIZWFkZXI6IHVucmVjb2duaXplZCBtb2RlOiAke21vZGV9YCk7XG4gICAgfVxuICAgIGxldCBoZWFkZXIgPSAnJztcbiAgICBoZWFkZXIgKz0gYDxwPmRpc3BsYXkgbW9kZTogJHttb2RlTmFtZX08L3A+XFxuYDtcbiAgICBoZWFkZXIgKz0gYDx0YWJsZSBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfVFJBQ0V9XCI+XFxuYDtcbiAgICBpZiAodHlwZW9mIGNhcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBoZWFkZXIgKz0gYDxjYXB0aW9uPiR7Y2FwdGlvbn08L2NhcHRpb24+YDtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcjtcbiAgfTtcbiAgY29uc3QgaHRtbEZvb3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgZm9vdGVyID0gJyc7XG4gICAgLyogY2xvc2UgdGhlIDwvdGFibGU+IHRhZyAqL1xuICAgIGZvb3RlciArPSAnPC90YWJsZT5cXG4nO1xuICAgIC8qIGRpc3BsYXkgYSB0YWJsZSBsZWdlbmQgKi9cbiAgICBmb290ZXIgKz0gYDxwIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NT05PU1BBQ0V9XCI+bGVnZW5kOjxicj5cXG5gO1xuICAgIGZvb3RlciArPSAnKGEpJm5ic3A7LSZuYnNwO2xpbmUgbnVtYmVyPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoYikmbmJzcDstJm5ic3A7bWF0Y2hpbmcgbGluZSBudW1iZXI8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJyhjKSZuYnNwOy0mbmJzcDtwaHJhc2Ugb2Zmc2V0PGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoZCkmbmJzcDstJm5ic3A7cGhyYXNlIGxlbmd0aDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGUpJm5ic3A7LSZuYnNwO3RyZWUgZGVwdGg8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJyhmKSZuYnNwOy0mbmJzcDtvcGVyYXRvciBzdGF0ZTxicj5cXG4nO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JmRhcnI7PC9zcGFuPiZuYnNwOyZuYnNwO3BocmFzZSBvcGVuZWQ8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+JnVhcnI7TTwvc3Bhbj4gcGhyYXNlIG1hdGNoZWQ8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+JnVhcnI7RTwvc3Bhbj4gZW1wdHkgcGhyYXNlIG1hdGNoZWQ8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4mdWFycjtOPC9zcGFuPiBwaHJhc2Ugbm90IG1hdGNoZWQ8YnI+XFxuYDtcbiAgICBmb290ZXIgKz1cbiAgICAgICdvcGVyYXRvciZuYnNwOy0mbmJzcDtBTFQsIENBVCwgUkVQLCBSTk0sIFRSRywgVExTLCBUQlM8c3VwPiZkYWdnZXI7PC9zdXA+LCBVRFQsIEFORCwgTk9ULCBCS0EsIEJLTiwgQktSLCBBQkcsIEFFTjxzdXA+JkRhZ2dlcjs8L3N1cD48YnI+XFxuJztcbiAgICBmb290ZXIgKz0gYHBocmFzZSZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDt1cCB0byAke01BWF9QSFJBU0V9IGNoYXJhY3RlcnMgb2YgdGhlIHBocmFzZSBiZWluZyBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPm1hdGNoZWQgY2hhcmFjdGVyczwvc3Bhbj48YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0FIRUFEfVwiPm1hdGNoZWQgY2hhcmFjdGVycyBpbiBsb29rIGFoZWFkIG1vZGU8L3NwYW4+PGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xPT0tCRUhJTkR9XCI+bWF0Y2hlZCBjaGFyYWN0ZXJzIGluIGxvb2sgYmVoaW5kIG1vZGU8L3NwYW4+PGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX1JFTUFJTkRFUn1cIj5yZW1haW5kZXIgY2hhcmFjdGVycyhub3QgeWV0IGV4YW1pbmVkIGJ5IHBhcnNlcik8L3NwYW4+PGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0NUUkxDSEFSfVwiPmNvbnRyb2wgY2hhcmFjdGVycywgVEFCLCBMRiwgQ1IsIGV0Yy4gKEFTQ0lJIG1vZGUgb25seSk8L3NwYW4+PGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7JHtQSFJBU0VfRU1QVFl9IGVtcHR5IHN0cmluZzxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOyR7UEhSQVNFX0VORH0gZW5kIG9mIGlucHV0IHN0cmluZzxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOyR7UEhSQVNFX0NPTlRJTlVFfSBpbnB1dCBzdHJpbmcgZGlzcGxheSB0cnVuY2F0ZWQ8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gJzwvcD5cXG4nO1xuICAgIGZvb3RlciArPSBgPHAgY2xhc3M9XCIke3N0eWxlLkNMQVNTX01PTk9TUEFDRX1cIj5cXG5gO1xuICAgIGZvb3RlciArPSAnPHN1cD4mZGFnZ2VyOzwvc3VwPm9yaWdpbmFsIEFCTkYgb3BlcmF0b3JzOjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQUxUIC0gYWx0ZXJuYXRpb248YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0NBVCAtIGNvbmNhdGVuYXRpb248YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1JFUCAtIHJlcGV0aXRpb248YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1JOTSAtIHJ1bGUgbmFtZTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnVFJHIC0gdGVybWluYWwgcmFuZ2U8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1RMUyAtIHRlcm1pbmFsIGxpdGVyYWwgc3RyaW5nIChjYXNlIGluc2Vuc2l0aXZlKTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnVEJTIC0gdGVybWluYWwgYmluYXJ5IHN0cmluZyAoY2FzZSBzZW5zaXRpdmUpPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICc8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJzxzdXA+JkRhZ2dlcjs8L3N1cD5zdXBlciBzZXQgU0FCTkYgb3BlcmF0b3JzOjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnVURUIC0gdXNlci1kZWZpbmVkIHRlcm1pbmFsPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdBTkQgLSBwb3NpdGl2ZSBsb29rIGFoZWFkPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdOT1QgLSBuZWdhdGl2ZSBsb29rIGFoZWFkPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdCS0EgLSBwb3NpdGl2ZSBsb29rIGJlaGluZDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQktOIC0gbmVnYXRpdmUgbG9vayBiZWhpbmQ8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0JLUiAtIGJhY2sgcmVmZXJlbmNlPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdBQkcgLSBhbmNob3IgLSBiZWdpbiBvZiBpbnB1dCBzdHJpbmc8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0FFTiAtIGFuY2hvciAtIGVuZCBvZiBpbnB1dCBzdHJpbmc8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJzwvcD5cXG4nO1xuICAgIHJldHVybiBmb290ZXI7XG4gIH07XG4gIHRoaXMuaW5kZW50ID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpICs9IDEpIHtcbiAgICAgIGh0bWwgKz0gJy4nO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogZm9ybWF0IHRoZSBUUkcgb3BlcmF0b3IgKi9cbiAgY29uc3QgZGlzcGxheVRyZyA9IGZ1bmN0aW9uIChtb2RlLCBvcCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlRSRykge1xuICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYIHx8IG1vZGUgPT09IE1PREVfVU5JQ09ERSkge1xuICAgICAgICBsZXQgaGV4ID0gb3AubWluLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBtb2RlID09PSBNT0RFX0hFWCA/ICcleCcgOiAnVSsnO1xuICAgICAgICBodG1sICs9IGhleDtcbiAgICAgICAgaGV4ID0gb3AubWF4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBgJm5kYXNoOyR7aGV4fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sID0gYCVkJHtvcC5taW4udG9TdHJpbmcoMTApfSZuZGFzaDske29wLm1heC50b1N0cmluZygxMCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGZvcm1hdCB0aGUgUkVQIG9wZXJhdG9yICovXG4gIGNvbnN0IGRpc3BsYXlSZXAgPSBmdW5jdGlvbiAobW9kZSwgb3ApIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5SRVApIHtcbiAgICAgIGlmIChtb2RlID09PSBNT0RFX0hFWCkge1xuICAgICAgICBsZXQgaGV4ID0gb3AubWluLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCA9IGB4JHtoZXh9YDtcbiAgICAgICAgaWYgKG9wLm1heCA8IEluZmluaXR5KSB7XG4gICAgICAgICAgaGV4ID0gb3AubWF4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZXggPSAnaW5mJztcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IGAmbmRhc2g7JHtoZXh9YDtcbiAgICAgIH0gZWxzZSBpZiAob3AubWF4IDwgSW5maW5pdHkpIHtcbiAgICAgICAgaHRtbCA9IGAke29wLm1pbi50b1N0cmluZygxMCl9Jm5kYXNoOyR7b3AubWF4LnRvU3RyaW5nKDEwKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9IGAke29wLm1pbi50b1N0cmluZygxMCl9Jm5kYXNoO2luZmA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBmb3JtYXQgdGhlIFRCUyBvcGVyYXRvciAqL1xuICBjb25zdCBkaXNwbGF5VGJzID0gZnVuY3Rpb24gKG1vZGUsIG9wKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBpZiAob3AudHlwZSA9PT0gaWQuVEJTKSB7XG4gICAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihvcC5zdHJpbmcubGVuZ3RoLCBNQVhfVExTICogMik7XG4gICAgICBpZiAobW9kZSA9PT0gTU9ERV9IRVggfHwgbW9kZSA9PT0gTU9ERV9VTklDT0RFKSB7XG4gICAgICAgIGh0bWwgKz0gbW9kZSA9PT0gTU9ERV9IRVggPyAnJXgnIDogJ1UrJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGxldCBoZXg7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICcuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaGV4ID0gb3Auc3RyaW5nW2ldLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sICs9IGhleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9ICclZCc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJy4nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sICs9IG9wLnN0cmluZ1tpXS50b1N0cmluZygxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZW4gPCBvcC5zdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGh0bWwgKz0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogZm9ybWF0IHRoZSBUTFMgb3BlcmF0b3IgKi9cbiAgY29uc3QgZGlzcGxheVRscyA9IGZ1bmN0aW9uIChtb2RlLCBvcCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlRMUykge1xuICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4ob3Auc3RyaW5nLmxlbmd0aCwgTUFYX1RMUyk7XG4gICAgICBpZiAobW9kZSA9PT0gTU9ERV9IRVggfHwgbW9kZSA9PT0gTU9ERV9ERUMpIHtcbiAgICAgICAgbGV0IGNoYXJ1O1xuICAgICAgICBsZXQgY2hhcmw7XG4gICAgICAgIGxldCBiYXNlO1xuICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9IRVgpIHtcbiAgICAgICAgICBodG1sID0gJyV4JztcbiAgICAgICAgICBiYXNlID0gMTY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaHRtbCA9ICclZCc7XG4gICAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJy4nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFybCA9IG9wLnN0cmluZ1tpXTtcbiAgICAgICAgICBpZiAoY2hhcmwgPj0gOTcgJiYgY2hhcmwgPD0gMTIyKSB7XG4gICAgICAgICAgICBjaGFydSA9IGNoYXJsIC0gMzI7XG4gICAgICAgICAgICBodG1sICs9IGAke2NoYXJ1LnRvU3RyaW5nKGJhc2UpfS8ke2NoYXJsLnRvU3RyaW5nKGJhc2UpfWAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJsID49IDY1ICYmIGNoYXJsIDw9IDkwKSB7XG4gICAgICAgICAgICBjaGFydSA9IGNoYXJsO1xuICAgICAgICAgICAgY2hhcmwgKz0gMzI7XG4gICAgICAgICAgICBodG1sICs9IGAke2NoYXJ1LnRvU3RyaW5nKGJhc2UpfS8ke2NoYXJsLnRvU3RyaW5nKGJhc2UpfWAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbCArPSBjaGFybC50b1N0cmluZyhiYXNlKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuIDwgb3Auc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGh0bWwgKz0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sID0gJ1wiJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGh0bWwgKz0gdXRpbHMuYXNjaWlDaGFyc1tvcC5zdHJpbmdbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPCBvcC5zdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgaHRtbCArPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSAnXCInO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgY29uc3Qgc3ViUGhyYXNlID0gZnVuY3Rpb24gKG1vZGUsIGNoYXJzQXJnLCBpbmRleCwgbGVuZ3RoLCBwcmV2KSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBsZXQgcGhyYXNlID0gJyc7XG4gICAgY29uc3QgY29tbWEgPSBwcmV2ID8gJywnIDogJyc7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIE1PREVfSEVYOlxuICAgICAgICBwaHJhc2UgPSBjb21tYSArIHV0aWxzLmNoYXJzVG9IZXgoY2hhcnNBcmcsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9ERV9ERUM6XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgcmV0dXJuIGAsJHt1dGlscy5jaGFyc1RvRGVjKGNoYXJzQXJnLCBpbmRleCwgbGVuZ3RoKX1gO1xuICAgICAgICB9XG4gICAgICAgIHBocmFzZSA9IGNvbW1hICsgdXRpbHMuY2hhcnNUb0RlYyhjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNT0RFX1VOSUNPREU6XG4gICAgICAgIHBocmFzZSA9IHV0aWxzLmNoYXJzVG9Vbmljb2RlKGNoYXJzQXJnLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfQVNDSUk6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwaHJhc2UgPSB1dGlscy5jaGFyc1RvQXNjaWlIdG1sKGNoYXJzQXJnLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwaHJhc2U7XG4gIH07XG4gIC8qIGRpc3BsYXkgcGhyYXNlcyBtYXRjaGVkIGluIGxvb2stYmVoaW5kIG1vZGUgKi9cbiAgY29uc3QgZGlzcGxheUJlaGluZCA9IGZ1bmN0aW9uIChtb2RlLCBjaGFyc0FyZywgc3RhdGUsIGluZGV4LCBsZW5ndGgsIGFuY2hvcikge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgbGV0IGJlZzE7XG4gICAgbGV0IGxlbjE7XG4gICAgbGV0IGJlZzI7XG4gICAgbGV0IGxlbjI7XG4gICAgbGV0IGxhc3RjaGFyID0gUEhSQVNFX0VORDtcbiAgICBjb25zdCBzcGFuQmVoaW5kID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQkVISU5EfVwiPmA7XG4gICAgY29uc3Qgc3BhblJlbWFpbmRlciA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfUkVNQUlOREVSfVwiPmA7XG4gICAgY29uc3Qgc3BhbmVuZCA9ICc8L3NwYW4+JztcbiAgICBsZXQgcHJldiA9IGZhbHNlO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGh0bWwgKz0gUEhSQVNFX0VNUFRZO1xuICAgICAgLyogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJlZzEgPSBpbmRleCAtIGxlbmd0aDtcbiAgICAgICAgbGVuMSA9IGFuY2hvciAtIGJlZzE7XG4gICAgICAgIGJlZzIgPSBhbmNob3I7XG4gICAgICAgIGxlbjIgPSBjaGFyc0FyZy5sZW5ndGggLSBiZWcyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHN0YXRlJyk7XG4gICAgfVxuICAgIGxhc3RjaGFyID0gUEhSQVNFX0VORDtcbiAgICBpZiAobGVuMSA+IE1BWF9QSFJBU0UpIHtcbiAgICAgIGxlbjEgPSBNQVhfUEhSQVNFO1xuICAgICAgbGFzdGNoYXIgPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICBsZW4yID0gMDtcbiAgICB9IGVsc2UgaWYgKGxlbjEgKyBsZW4yID4gTUFYX1BIUkFTRSkge1xuICAgICAgbGFzdGNoYXIgPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICBsZW4yID0gTUFYX1BIUkFTRSAtIGxlbjE7XG4gICAgfVxuICAgIGlmIChsZW4xID4gMCkge1xuICAgICAgaHRtbCArPSBzcGFuQmVoaW5kO1xuICAgICAgaHRtbCArPSBzdWJQaHJhc2UobW9kZSwgY2hhcnNBcmcsIGJlZzEsIGxlbjEsIHByZXYpO1xuICAgICAgaHRtbCArPSBzcGFuZW5kO1xuICAgICAgcHJldiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChsZW4yID4gMCkge1xuICAgICAgaHRtbCArPSBzcGFuUmVtYWluZGVyO1xuICAgICAgaHRtbCArPSBzdWJQaHJhc2UobW9kZSwgY2hhcnNBcmcsIGJlZzIsIGxlbjIsIHByZXYpO1xuICAgICAgaHRtbCArPSBzcGFuZW5kO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbCArIGxhc3RjaGFyO1xuICB9O1xuICBjb25zdCBkaXNwbGF5Rm9yd2FyZCA9IGZ1bmN0aW9uIChtb2RlLCBjaGFyc0FyZywgc3RhdGUsIGluZGV4LCBsZW5ndGgsIHNwYW5BaGVhZCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgbGV0IGJlZzE7XG4gICAgbGV0IGxlbjE7XG4gICAgbGV0IGJlZzI7XG4gICAgbGV0IGxlbjI7XG4gICAgbGV0IGxhc3RjaGFyID0gUEhSQVNFX0VORDtcbiAgICBjb25zdCBzcGFuUmVtYWluZGVyID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19SRU1BSU5ERVJ9XCI+YDtcbiAgICBjb25zdCBzcGFuZW5kID0gJzwvc3Bhbj4nO1xuICAgIGxldCBwcmV2ID0gZmFsc2U7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgaHRtbCArPSBQSFJBU0VfRU1QVFk7XG4gICAgICAvKiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2ggKi9cbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBiZWcxID0gaW5kZXg7XG4gICAgICAgIGxlbjEgPSAwO1xuICAgICAgICBiZWcyID0gaW5kZXg7XG4gICAgICAgIGxlbjIgPSBjaGFyc0FyZy5sZW5ndGggLSBiZWcyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGJlZzEgPSBpbmRleDtcbiAgICAgICAgbGVuMSA9IGxlbmd0aDtcbiAgICAgICAgYmVnMiA9IGluZGV4ICsgbGVuMTtcbiAgICAgICAgbGVuMiA9IGNoYXJzQXJnLmxlbmd0aCAtIGJlZzI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgc3RhdGUnKTtcbiAgICB9XG4gICAgbGFzdGNoYXIgPSBQSFJBU0VfRU5EO1xuICAgIGlmIChsZW4xID4gTUFYX1BIUkFTRSkge1xuICAgICAgbGVuMSA9IE1BWF9QSFJBU0U7XG4gICAgICBsYXN0Y2hhciA9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgIGxlbjIgPSAwO1xuICAgIH0gZWxzZSBpZiAobGVuMSArIGxlbjIgPiBNQVhfUEhSQVNFKSB7XG4gICAgICBsYXN0Y2hhciA9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgIGxlbjIgPSBNQVhfUEhSQVNFIC0gbGVuMTtcbiAgICB9XG4gICAgaWYgKGxlbjEgPiAwKSB7XG4gICAgICBodG1sICs9IHNwYW5BaGVhZDtcbiAgICAgIGh0bWwgKz0gc3ViUGhyYXNlKG1vZGUsIGNoYXJzQXJnLCBiZWcxLCBsZW4xLCBwcmV2KTtcbiAgICAgIGh0bWwgKz0gc3BhbmVuZDtcbiAgICAgIHByZXYgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVuMiA+IDApIHtcbiAgICAgIGh0bWwgKz0gc3BhblJlbWFpbmRlcjtcbiAgICAgIGh0bWwgKz0gc3ViUGhyYXNlKG1vZGUsIGNoYXJzQXJnLCBiZWcyLCBsZW4yLCBwcmV2KTtcbiAgICAgIGh0bWwgKz0gc3BhbmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWwgKyBsYXN0Y2hhcjtcbiAgfTtcbiAgLyogZGlzcGxheSBwaHJhc2VzIG1hdGNoZWQgaW4gbG9vay1haGVhZCBtb2RlICovXG4gIGNvbnN0IGRpc3BsYXlBaGVhZCA9IGZ1bmN0aW9uIChtb2RlLCBjaGFyc0FyZywgc3RhdGUsIGluZGV4LCBsZW5ndGgpIHtcbiAgICBjb25zdCBzcGFuQWhlYWQgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xPT0tBSEVBRH1cIj5gO1xuICAgIHJldHVybiBkaXNwbGF5Rm9yd2FyZChtb2RlLCBjaGFyc0FyZywgc3RhdGUsIGluZGV4LCBsZW5ndGgsIHNwYW5BaGVhZCk7XG4gIH07XG4gIC8qIGRpc3BsYXkgcGhyYXNlcyBtYXRjaGVkIGluIG5vcm1hbCBwYXJzaW5nIG1vZGUgKi9cbiAgY29uc3QgZGlzcGxheU5vbmUgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgY29uc3Qgc3BhbkFoZWFkID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5gO1xuICAgIHJldHVybiBkaXNwbGF5Rm9yd2FyZChtb2RlLCBjaGFyc0FyZywgc3RhdGUsIGluZGV4LCBsZW5ndGgsIHNwYW5BaGVhZCk7XG4gIH07XG4gIC8qIFJldHVybnMgdGhlIGZpbHRlcmVkIHJlY29yZHMsIGZvcm1hdHRlZCBhcyBhbiBIVE1MIHRhYmxlLiAqL1xuICBjb25zdCBodG1sVGFibGUgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIGlmIChydWxlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCB0aGlzTGluZTtcbiAgICBsZXQgdGhhdExpbmU7XG4gICAgbGV0IGxvb2tBaGVhZDtcbiAgICBsZXQgbG9va0JlaGluZDtcbiAgICBsZXQgbG9va0Fyb3VuZDtcbiAgICBsZXQgYW5jaG9yO1xuICAgIGh0bWwgKz0gJzx0cj48dGg+KGEpPC90aD48dGg+KGIpPC90aD48dGg+KGMpPC90aD48dGg+KGQpPC90aD48dGg+KGUpPC90aD48dGg+KGYpPC90aD4nO1xuICAgIGh0bWwgKz0gJzx0aD5vcGVyYXRvcjwvdGg+PHRoPnBocmFzZTwvdGg+PC90cj5cXG4nO1xuICAgIGNpcmN1bGFyLmZvckVhY2goKGxpbmVJbmRleCkgPT4ge1xuICAgICAgY29uc3QgbGluZSA9IHJlY29yZHNbbGluZUluZGV4XTtcbiAgICAgIHRoaXNMaW5lID0gbGluZS50aGlzTGluZTtcbiAgICAgIHRoYXRMaW5lID0gbGluZS50aGF0TGluZSAhPT0gdW5kZWZpbmVkID8gbGluZS50aGF0TGluZSA6ICctLSc7XG4gICAgICBsb29rQWhlYWQgPSBmYWxzZTtcbiAgICAgIGxvb2tCZWhpbmQgPSBmYWxzZTtcbiAgICAgIGxvb2tBcm91bmQgPSBmYWxzZTtcbiAgICAgIGlmIChsaW5lLmxvb2tBcm91bmQgPT09IGlkLkxPT0tBUk9VTkRfQUhFQUQpIHtcbiAgICAgICAgbG9va0FoZWFkID0gdHJ1ZTtcbiAgICAgICAgbG9va0Fyb3VuZCA9IHRydWU7XG4gICAgICAgIGFuY2hvciA9IGxpbmUubG9va0FuY2hvcjtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5BTkQgfHwgbGluZS5vcGNvZGUudHlwZSA9PT0gaWQuTk9UKSB7XG4gICAgICAgIGxvb2tBaGVhZCA9IHRydWU7XG4gICAgICAgIGxvb2tBcm91bmQgPSB0cnVlO1xuICAgICAgICBhbmNob3IgPSBsaW5lLnBocmFzZUluZGV4O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUubG9va0Fyb3VuZCA9PT0gaWQuTE9PS0FST1VORF9CRUhJTkQpIHtcbiAgICAgICAgbG9va0JlaGluZCA9IHRydWU7XG4gICAgICAgIGxvb2tBcm91bmQgPSB0cnVlO1xuICAgICAgICBhbmNob3IgPSBsaW5lLmxvb2tBbmNob3I7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuQktBIHx8IGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLkJLTikge1xuICAgICAgICBsb29rQmVoaW5kID0gdHJ1ZTtcbiAgICAgICAgbG9va0Fyb3VuZCA9IHRydWU7XG4gICAgICAgIGFuY2hvciA9IGxpbmUucGhyYXNlSW5kZXg7XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgIGh0bWwgKz0gYDx0ZD4ke3RoaXNMaW5lfTwvdGQ+PHRkPiR7dGhhdExpbmV9PC90ZD5gO1xuICAgICAgaHRtbCArPSBgPHRkPiR7bGluZS5waHJhc2VJbmRleH08L3RkPmA7XG4gICAgICBodG1sICs9IGA8dGQ+JHtsaW5lLnBocmFzZUxlbmd0aH08L3RkPmA7XG4gICAgICBodG1sICs9IGA8dGQ+JHtsaW5lLmRlcHRofTwvdGQ+YDtcbiAgICAgIGh0bWwgKz0gJzx0ZD4nO1xuICAgICAgc3dpdGNoIChsaW5lLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JmRhcnI7Jm5ic3A7PC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPiZ1YXJyO008L3NwYW4+YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiZ1YXJyO048L3NwYW4+YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+JnVhcnI7RTwvc3Bhbj5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+LS08L3NwYW4+YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGh0bWwgKz0gJzwvdGQ+JztcbiAgICAgIGh0bWwgKz0gJzx0ZD4nO1xuICAgICAgaHRtbCArPSB0aGF0LmluZGVudChsaW5lLmRlcHRoKTtcbiAgICAgIGlmIChsb29rQWhlYWQpIHtcbiAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xPT0tBSEVBRH1cIj5gO1xuICAgICAgfSBlbHNlIGlmIChsb29rQmVoaW5kKSB7XG4gICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQkVISU5EfVwiPmA7XG4gICAgICB9XG4gICAgICBodG1sICs9IHV0aWxzLm9wY29kZVRvU3RyaW5nKGxpbmUub3Bjb2RlLnR5cGUpO1xuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgICBodG1sICs9IGAoJHtydWxlc1tsaW5lLm9wY29kZS5pbmRleF0ubmFtZX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuQktSKSB7XG4gICAgICAgIGNvbnN0IGNhc2V0eXBlID0gbGluZS5vcGNvZGUuYmtyQ2FzZSA9PT0gaWQuQktSX01PREVfQ0kgPyAnJWknIDogJyVzJztcbiAgICAgICAgY29uc3QgbW9kZXR5cGUgPSBsaW5lLm9wY29kZS5ia3JNb2RlID09PSBpZC5CS1JfTU9ERV9VTSA/ICcldScgOiAnJXAnO1xuICAgICAgICBodG1sICs9IGAoXFxcXCR7Y2FzZXR5cGV9JHttb2RldHlwZX0ke3J1bGVzW2xpbmUub3Bjb2RlLmluZGV4XS5uYW1lfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5VRFQpIHtcbiAgICAgICAgaHRtbCArPSBgKCR7dWR0c1tsaW5lLm9wY29kZS5pbmRleF0ubmFtZX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuVFJHKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke2Rpc3BsYXlUcmcobW9kZSwgbGluZS5vcGNvZGUpfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5UQlMpIHtcbiAgICAgICAgaHRtbCArPSBgKCR7ZGlzcGxheVRicyhtb2RlLCBsaW5lLm9wY29kZSl9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlRMUykge1xuICAgICAgICBodG1sICs9IGAoJHtkaXNwbGF5VGxzKG1vZGUsIGxpbmUub3Bjb2RlKX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuUkVQKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke2Rpc3BsYXlSZXAobW9kZSwgbGluZS5vcGNvZGUpfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsb29rQXJvdW5kKSB7XG4gICAgICAgIGh0bWwgKz0gJzwvc3Bhbj4nO1xuICAgICAgfVxuICAgICAgaHRtbCArPSAnPC90ZD4nO1xuICAgICAgaHRtbCArPSAnPHRkPic7XG4gICAgICBpZiAobG9va0JlaGluZCkge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlCZWhpbmQobW9kZSwgY2hhcnMsIGxpbmUuc3RhdGUsIGxpbmUucGhyYXNlSW5kZXgsIGxpbmUucGhyYXNlTGVuZ3RoLCBhbmNob3IpO1xuICAgICAgfSBlbHNlIGlmIChsb29rQWhlYWQpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5QWhlYWQobW9kZSwgY2hhcnMsIGxpbmUuc3RhdGUsIGxpbmUucGhyYXNlSW5kZXgsIGxpbmUucGhyYXNlTGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheU5vbmUobW9kZSwgY2hhcnMsIGxpbmUuc3RhdGUsIGxpbmUucGhyYXNlSW5kZXgsIGxpbmUucGhyYXNlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGh0bWwgKz0gJzwvdGQ+PC90cj5cXG4nO1xuICAgIH0pO1xuICAgIGh0bWwgKz0gJzx0cj48dGg+KGEpPC90aD48dGg+KGIpPC90aD48dGg+KGMpPC90aD48dGg+KGQpPC90aD48dGg+KGUpPC90aD48dGg+KGYpPC90aD4nO1xuICAgIGh0bWwgKz0gJzx0aD5vcGVyYXRvcjwvdGg+PHRoPnBocmFzZTwvdGg+PC90cj5cXG4nO1xuICAgIGh0bWwgKz0gJzwvdGFibGU+XFxuJztcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLy8gVHJhbnNsYXRlIHRoZSB0cmFjZSByZWNvcmRzIHRvIEhUTUwgZm9ybWF0LlxuICAvLyAtICptb2RlYXJnKiAtIGNhbiBiZSBgXCJhc2NpaVwiYCwgYFwiZGVjaW1hbFwiYCwgYFwiaGV4YWRlY2ltYWxcImAgb3IgYFwidW5pY29kZVwiYC5cbiAgLy8gRGV0ZXJtaW5lcyB0aGUgZm9ybWF0IG9mIHRoZSBzdHJpbmcgY2hhcmFjdGVyIGNvZGUgZGlzcGxheS5cbiAgLy8gLSAqY2FwdGlvbiogLSBvcHRpb25hbCBjYXB0aW9uIGZvciB0aGUgSFRNTCB0YWJsZS5cbiAgdGhpcy50b0h0bWwgPSBmdW5jdGlvbiAobW9kZWFyZywgY2FwdGlvbikge1xuICAgIC8qIHdyaXRlcyB0aGUgdHJhY2UgcmVjb3JkcyBhcyBhIHRhYmxlIGluIGEgY29tcGxldGUgaHRtbCBwYWdlICovXG4gICAgbGV0IG1vZGUgPSBNT0RFX0FTQ0lJO1xuICAgIGlmICh0eXBlb2YgbW9kZWFyZyA9PT0gJ3N0cmluZycgJiYgbW9kZWFyZy5sZW5ndGggPj0gMykge1xuICAgICAgY29uc3QgbW9kZWluID0gbW9kZWFyZy50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDMpO1xuICAgICAgaWYgKG1vZGVpbiA9PT0gJ2hleCcpIHtcbiAgICAgICAgbW9kZSA9IE1PREVfSEVYO1xuICAgICAgfSBlbHNlIGlmIChtb2RlaW4gPT09ICdkZWMnKSB7XG4gICAgICAgIG1vZGUgPSBNT0RFX0RFQztcbiAgICAgIH0gZWxzZSBpZiAobW9kZWluID09PSAndW5pJykge1xuICAgICAgICBtb2RlID0gTU9ERV9VTklDT0RFO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGh0bWwgKz0gaHRtbEhlYWRlcihtb2RlLCBjYXB0aW9uKTtcbiAgICBodG1sICs9IGh0bWxUYWJsZShtb2RlKTtcbiAgICBodG1sICs9IGh0bWxGb290ZXIoKTtcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/trace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js":
/*!******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/utilities.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exports a variety of utility functions that support\n// [`apg`](https://github.com/ldthomas/apg-js2), [`apg-lib`](https://github.com/ldthomas/apg-js2-lib)\n// and the generated parser applications.\n\nconst style = __webpack_require__(/*! ./style */ \"(ssr)/./node_modules/apg-js/src/apg-lib/style.js\");\nconst converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"(ssr)/./node_modules/apg-js/src/apg-conv-api/converter.js\");\nconst emitCss = __webpack_require__(/*! ./emitcss */ \"(ssr)/./node_modules/apg-js/src/apg-lib/emitcss.js\");\nconst id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n\nconst thisFileName = 'utilities.js: ';\n\n/* translate (implied) phrase beginning character and length to actual first and last character indexes */\n/* used by multiple phrase handling functions */\nconst getBounds = function (length, begArg, len) {\n  let end;\n  let beg = begArg;\n  const TRUE = true;\n  while (TRUE) {\n    if (length <= 0) {\n      beg = 0;\n      end = 0;\n      break;\n    }\n    if (typeof beg !== 'number') {\n      beg = 0;\n      end = length;\n      break;\n    }\n    if (beg >= length) {\n      beg = length;\n      end = length;\n      break;\n    }\n    if (typeof len !== 'number') {\n      end = length;\n      break;\n    }\n    end = beg + len;\n    if (end > length) {\n      end = length;\n      break;\n    }\n    break;\n  }\n  return {\n    beg,\n    end,\n  };\n};\n// Generates a complete, minimal HTML5 page, inserting the user's HTML text on the page.\n// - *html* - the page text in HTML format\n// - *title* - the HTML page `<title>` - defaults to `htmlToPage`.\nexports.htmlToPage = function (html, titleArg) {\n  let title;\n  if (typeof html !== 'string') {\n    throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);\n  }\n  if (typeof titleArg !== 'string') {\n    title = 'htmlToPage';\n  } else {\n    title = titleArg;\n  }\n  let page = '';\n  page += '<!DOCTYPE html>\\n';\n  page += '<html lang=\"en\">\\n';\n  page += '<head>\\n';\n  page += '<meta charset=\"utf-8\">\\n';\n  page += `<title>${title}</title>\\n`;\n  page += '<style>\\n';\n  page += emitCss();\n  page += '</style>\\n';\n  page += '</head>\\n<body>\\n';\n  page += `<p>${new Date()}</p>\\n`;\n  page += html;\n  page += '</body>\\n</html>\\n';\n  return page;\n};\n// Formats the returned object from `parser.parse()`\n// into an HTML table.\n// ```\n// return {\n//   success : sysData.success,\n//   state : sysData.state,\n//   length : charsLength,\n//   matched : sysData.phraseLength,\n//   maxMatched : maxMatched,\n//   maxTreeDepth : maxTreeDepth,\n//   nodeHits : nodeHits,\n//   inputLength : chars.length,\n//   subBegin : charsBegin,\n//   subEnd : charsEnd,\n//   subLength : charsLength\n// };\n// ```\nexports.parserResultToHtml = function (result, caption) {\n  let cap = null;\n  if (typeof caption === 'string' && caption !== '') {\n    cap = caption;\n  }\n  let success;\n  let state;\n  if (result.success === true) {\n    success = `<span class=\"${style.CLASS_MATCH}\">true</span>`;\n  } else {\n    success = `<span class=\"${style.CLASS_NOMATCH}\">false</span>`;\n  }\n  if (result.state === id.EMPTY) {\n    state = `<span class=\"${style.CLASS_EMPTY}\">EMPTY</span>`;\n  } else if (result.state === id.MATCH) {\n    state = `<span class=\"${style.CLASS_MATCH}\">MATCH</span>`;\n  } else if (result.state === id.NOMATCH) {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span>`;\n  } else {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">unrecognized</span>`;\n  }\n  let html = '';\n  html += `<table class=\"${style.CLASS_STATE}\">\\n`;\n  if (cap) {\n    html += `<caption>${cap}</caption>\\n`;\n  }\n  html += '<tr><th>state item</th><th>value</th><th>description</th></tr>\\n';\n  html += `<tr><td>parser success</td><td>${success}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_MATCH}\">true</span> if the parse succeeded,\\n`;\n  html += ` <span class=\"${style.CLASS_NOMATCH}\">false</span> otherwise`;\n  html += '<br><i>NOTE: for success, entire string must be matched</i></td></tr>\\n';\n  html += `<tr><td>parser state</td><td>${state}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_EMPTY}\">EMPTY</span>, `;\n  html += `<span class=\"${style.CLASS_MATCH}\">MATCH</span> or \\n`;\n  html += `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span></td></tr>\\n`;\n  html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>\\n`;\n  html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>\\n`;\n  html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>\\n`;\n  html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>\\n`;\n  html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>\\n`;\n  html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>\\n`;\n  html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>\\n`;\n  html += '</table>\\n';\n  return html;\n};\n// Translates a sub-array of integer character codes into a string.\n// Very useful in callback functions to translate the matched phrases into strings.\nexports.charsToString = function (chars, phraseIndex, phraseLength) {\n  let beg;\n  let end;\n  if (typeof phraseIndex === 'number') {\n    if (phraseIndex >= chars.length) {\n      return '';\n    }\n    beg = phraseIndex < 0 ? 0 : phraseIndex;\n  } else {\n    beg = 0;\n  }\n  if (typeof phraseLength === 'number') {\n    if (phraseLength <= 0) {\n      return '';\n    }\n    end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;\n  } else {\n    end = chars.length;\n  }\n  if (beg < end) {\n    return converter.encode('UTF16LE', chars.slice(beg, end)).toString('utf16le');\n  }\n  return '';\n};\n// Translates a string into an array of integer character codes.\nexports.stringToChars = function (string) {\n  return converter.decode('STRING', string);\n};\n// Translates an opcode identifier into a human-readable string.\nexports.opcodeToString = function (type) {\n  let ret = 'unknown';\n  switch (type) {\n    case id.ALT:\n      ret = 'ALT';\n      break;\n    case id.CAT:\n      ret = 'CAT';\n      break;\n    case id.RNM:\n      ret = 'RNM';\n      break;\n    case id.UDT:\n      ret = 'UDT';\n      break;\n    case id.AND:\n      ret = 'AND';\n      break;\n    case id.NOT:\n      ret = 'NOT';\n      break;\n    case id.REP:\n      ret = 'REP';\n      break;\n    case id.TRG:\n      ret = 'TRG';\n      break;\n    case id.TBS:\n      ret = 'TBS';\n      break;\n    case id.TLS:\n      ret = 'TLS';\n      break;\n    case id.BKR:\n      ret = 'BKR';\n      break;\n    case id.BKA:\n      ret = 'BKA';\n      break;\n    case id.BKN:\n      ret = 'BKN';\n      break;\n    case id.ABG:\n      ret = 'ABG';\n      break;\n    case id.AEN:\n      ret = 'AEN';\n      break;\n    default:\n      throw new Error('unrecognized opcode');\n  }\n  return ret;\n};\n// Translates an state identifier into a human-readable string.\nexports.stateToString = function (state) {\n  let ret = 'unknown';\n  switch (state) {\n    case id.ACTIVE:\n      ret = 'ACTIVE';\n      break;\n    case id.MATCH:\n      ret = 'MATCH';\n      break;\n    case id.EMPTY:\n      ret = 'EMPTY';\n      break;\n    case id.NOMATCH:\n      ret = 'NOMATCH';\n      break;\n    default:\n      throw new Error('unrecognized state');\n  }\n  return ret;\n};\n// Array which translates all 128, 7-bit ASCII character codes to their respective HTML format.\nexports.asciiChars = [\n  'NUL',\n  'SOH',\n  'STX',\n  'ETX',\n  'EOT',\n  'ENQ',\n  'ACK',\n  'BEL',\n  'BS',\n  'TAB',\n  'LF',\n  'VT',\n  'FF',\n  'CR',\n  'SO',\n  'SI',\n  'DLE',\n  'DC1',\n  'DC2',\n  'DC3',\n  'DC4',\n  'NAK',\n  'SYN',\n  'ETB',\n  'CAN',\n  'EM',\n  'SUB',\n  'ESC',\n  'FS',\n  'GS',\n  'RS',\n  'US',\n  '&nbsp;',\n  '!',\n  '&#34;',\n  '#',\n  '$',\n  '%',\n  '&#38;',\n  '&#39;',\n  '(',\n  ')',\n  '*',\n  '+',\n  ',',\n  '-',\n  '.',\n  '/',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  ':',\n  ';',\n  '&#60;',\n  '=',\n  '&#62;',\n  '?',\n  '@',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n  '[',\n  '&#92;',\n  ']',\n  '^',\n  '_',\n  '`',\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  '{',\n  '|',\n  '}',\n  '~',\n  'DEL',\n];\n// Translates a single character to hexadecimal with leading zeros for 2, 4, or 8 digit display.\nexports.charToHex = function (char) {\n  let ch = char.toString(16).toUpperCase();\n  switch (ch.length) {\n    case 1:\n    case 3:\n    case 7:\n      ch = `0${ch}`;\n      break;\n    case 2:\n    case 6:\n      ch = `00${ch}`;\n      break;\n    case 4:\n      break;\n    case 5:\n      ch = `000${ch}`;\n      break;\n    default:\n      throw new Error('unrecognized option');\n  }\n  return ch;\n};\n// Translates a sub-array of character codes to decimal display format.\nexports.charsToDec = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += chars[bounds.beg];\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,${chars[i]}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to hexadecimal display format.\nexports.charsToHex = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\x${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\x${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\nexports.charsToHtmlEntities = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      ret += `&#x${chars[i].toString(16)};`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to Unicode display format.\nfunction isUnicode(char) {\n  if (char >= 0xd800 && char <= 0xdfff) {\n    return false;\n  }\n  if (char > 0x10ffff) {\n    return false;\n  }\n  return true;\n}\nexports.charsToUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      if (isUnicode(chars[i])) {\n        ret += `&#${chars[i]};`;\n      } else {\n        ret += ` U+${exports.charToHex(chars[i])}`;\n      }\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to JavaScript Unicode display format (`\\uXXXX`).\nexports.charsToJsUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\u${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\u${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to printing ASCII character display format.\nexports.charsToAscii = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      ret += String.fromCharCode(char);\n    } else {\n      ret += `\\\\x${exports.charToHex(char)}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to HTML display format.\nexports.charsToAsciiHtml = function (chars, beg, len) {\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);\n  }\n  let html = '';\n  let char;\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    char = chars[i];\n    if (char < 32 || char === 127) {\n      /* control characters */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">${exports.asciiChars[char]}</span>`;\n    } else if (char > 127) {\n      /* non-ASCII */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">U+${exports.charToHex(char)}</span>`;\n    } else {\n      /* printing ASCII, 32 <= char <= 126 */\n      html += exports.asciiChars[char];\n    }\n  }\n  return html;\n};\n// Translates a JavaScript string to HTML display format.\nexports.stringToAsciiHtml = function (str) {\n  const chars = converter.decode('STRING', str);\n  return this.charsToAsciiHtml(chars);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3V0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxpRUFBUztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMscUVBQVc7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLDZFQUFlOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQsSUFBSTtBQUNKLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUMsSUFBSTtBQUNKLDRCQUE0QixrQkFBa0I7QUFDOUMsSUFBSTtBQUNKLDRCQUE0QixvQkFBb0I7QUFDaEQsSUFBSTtBQUNKLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSx3QkFBd0IsSUFBSTtBQUM1QjtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQsOEJBQThCLGtCQUFrQjtBQUNoRCwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQsOEJBQThCLGtCQUFrQjtBQUNoRCwwQkFBMEIsa0JBQWtCO0FBQzVDLDBCQUEwQixvQkFBb0I7QUFDOUMsMkNBQTJDLGNBQWM7QUFDekQsNENBQTRDLGVBQWU7QUFDM0QseUNBQXlDLGtCQUFrQjtBQUMzRCw0Q0FBNEMsb0JBQW9CO0FBQ2hFLHVDQUF1QyxnQkFBZ0I7QUFDdkQsMENBQTBDLG1CQUFtQjtBQUM3RCw4Q0FBOEMsZ0JBQWdCO0FBQzlELDRDQUE0QyxjQUFjO0FBQzFELCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRCxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUNBQXFDO0FBQ3RELGlDQUFpQyxnQkFBZ0I7QUFDakQsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QyxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixRQUFRO0FBQ1IscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQsaUNBQWlDLGdCQUFnQjtBQUNqRCxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQixJQUFJLHlCQUF5QjtBQUNoRixNQUFNO0FBQ047QUFDQSw4QkFBOEIscUJBQXFCLE1BQU0sd0JBQXdCO0FBQ2pGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3V0aWxpdGllcy5qcz9kZmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGV4cG9ydHMgYSB2YXJpZXR5IG9mIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgc3VwcG9ydFxuLy8gW2BhcGdgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMiksIFtgYXBnLWxpYmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMyLWxpYilcbi8vIGFuZCB0aGUgZ2VuZXJhdGVkIHBhcnNlciBhcHBsaWNhdGlvbnMuXG5cbmNvbnN0IHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuY29uc3QgY29udmVydGVyID0gcmVxdWlyZSgnLi4vYXBnLWNvbnYtYXBpL2NvbnZlcnRlcicpO1xuY29uc3QgZW1pdENzcyA9IHJlcXVpcmUoJy4vZW1pdGNzcycpO1xuY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG5cbmNvbnN0IHRoaXNGaWxlTmFtZSA9ICd1dGlsaXRpZXMuanM6ICc7XG5cbi8qIHRyYW5zbGF0ZSAoaW1wbGllZCkgcGhyYXNlIGJlZ2lubmluZyBjaGFyYWN0ZXIgYW5kIGxlbmd0aCB0byBhY3R1YWwgZmlyc3QgYW5kIGxhc3QgY2hhcmFjdGVyIGluZGV4ZXMgKi9cbi8qIHVzZWQgYnkgbXVsdGlwbGUgcGhyYXNlIGhhbmRsaW5nIGZ1bmN0aW9ucyAqL1xuY29uc3QgZ2V0Qm91bmRzID0gZnVuY3Rpb24gKGxlbmd0aCwgYmVnQXJnLCBsZW4pIHtcbiAgbGV0IGVuZDtcbiAgbGV0IGJlZyA9IGJlZ0FyZztcbiAgY29uc3QgVFJVRSA9IHRydWU7XG4gIHdoaWxlIChUUlVFKSB7XG4gICAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgICBiZWcgPSAwO1xuICAgICAgZW5kID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJlZyAhPT0gJ251bWJlcicpIHtcbiAgICAgIGJlZyA9IDA7XG4gICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGJlZyA+PSBsZW5ndGgpIHtcbiAgICAgIGJlZyA9IGxlbmd0aDtcbiAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbmQgPSBiZWcgKyBsZW47XG4gICAgaWYgKGVuZCA+IGxlbmd0aCkge1xuICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmVnLFxuICAgIGVuZCxcbiAgfTtcbn07XG4vLyBHZW5lcmF0ZXMgYSBjb21wbGV0ZSwgbWluaW1hbCBIVE1MNSBwYWdlLCBpbnNlcnRpbmcgdGhlIHVzZXIncyBIVE1MIHRleHQgb24gdGhlIHBhZ2UuXG4vLyAtICpodG1sKiAtIHRoZSBwYWdlIHRleHQgaW4gSFRNTCBmb3JtYXRcbi8vIC0gKnRpdGxlKiAtIHRoZSBIVE1MIHBhZ2UgYDx0aXRsZT5gIC0gZGVmYXVsdHMgdG8gYGh0bWxUb1BhZ2VgLlxuZXhwb3J0cy5odG1sVG9QYWdlID0gZnVuY3Rpb24gKGh0bWwsIHRpdGxlQXJnKSB7XG4gIGxldCB0aXRsZTtcbiAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aHRtbFRvUGFnZTogaW5wdXQgSFRNTCBpcyBub3QgYSBzdHJpbmdgKTtcbiAgfVxuICBpZiAodHlwZW9mIHRpdGxlQXJnICE9PSAnc3RyaW5nJykge1xuICAgIHRpdGxlID0gJ2h0bWxUb1BhZ2UnO1xuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gdGl0bGVBcmc7XG4gIH1cbiAgbGV0IHBhZ2UgPSAnJztcbiAgcGFnZSArPSAnPCFET0NUWVBFIGh0bWw+XFxuJztcbiAgcGFnZSArPSAnPGh0bWwgbGFuZz1cImVuXCI+XFxuJztcbiAgcGFnZSArPSAnPGhlYWQ+XFxuJztcbiAgcGFnZSArPSAnPG1ldGEgY2hhcnNldD1cInV0Zi04XCI+XFxuJztcbiAgcGFnZSArPSBgPHRpdGxlPiR7dGl0bGV9PC90aXRsZT5cXG5gO1xuICBwYWdlICs9ICc8c3R5bGU+XFxuJztcbiAgcGFnZSArPSBlbWl0Q3NzKCk7XG4gIHBhZ2UgKz0gJzwvc3R5bGU+XFxuJztcbiAgcGFnZSArPSAnPC9oZWFkPlxcbjxib2R5Plxcbic7XG4gIHBhZ2UgKz0gYDxwPiR7bmV3IERhdGUoKX08L3A+XFxuYDtcbiAgcGFnZSArPSBodG1sO1xuICBwYWdlICs9ICc8L2JvZHk+XFxuPC9odG1sPlxcbic7XG4gIHJldHVybiBwYWdlO1xufTtcbi8vIEZvcm1hdHMgdGhlIHJldHVybmVkIG9iamVjdCBmcm9tIGBwYXJzZXIucGFyc2UoKWBcbi8vIGludG8gYW4gSFRNTCB0YWJsZS5cbi8vIGBgYFxuLy8gcmV0dXJuIHtcbi8vICAgc3VjY2VzcyA6IHN5c0RhdGEuc3VjY2Vzcyxcbi8vICAgc3RhdGUgOiBzeXNEYXRhLnN0YXRlLFxuLy8gICBsZW5ndGggOiBjaGFyc0xlbmd0aCxcbi8vICAgbWF0Y2hlZCA6IHN5c0RhdGEucGhyYXNlTGVuZ3RoLFxuLy8gICBtYXhNYXRjaGVkIDogbWF4TWF0Y2hlZCxcbi8vICAgbWF4VHJlZURlcHRoIDogbWF4VHJlZURlcHRoLFxuLy8gICBub2RlSGl0cyA6IG5vZGVIaXRzLFxuLy8gICBpbnB1dExlbmd0aCA6IGNoYXJzLmxlbmd0aCxcbi8vICAgc3ViQmVnaW4gOiBjaGFyc0JlZ2luLFxuLy8gICBzdWJFbmQgOiBjaGFyc0VuZCxcbi8vICAgc3ViTGVuZ3RoIDogY2hhcnNMZW5ndGhcbi8vIH07XG4vLyBgYGBcbmV4cG9ydHMucGFyc2VyUmVzdWx0VG9IdG1sID0gZnVuY3Rpb24gKHJlc3VsdCwgY2FwdGlvbikge1xuICBsZXQgY2FwID0gbnVsbDtcbiAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSAnc3RyaW5nJyAmJiBjYXB0aW9uICE9PSAnJykge1xuICAgIGNhcCA9IGNhcHRpb247XG4gIH1cbiAgbGV0IHN1Y2Nlc3M7XG4gIGxldCBzdGF0ZTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzID09PSB0cnVlKSB7XG4gICAgc3VjY2VzcyA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+dHJ1ZTwvc3Bhbj5gO1xuICB9IGVsc2Uge1xuICAgIHN1Y2Nlc3MgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+ZmFsc2U8L3NwYW4+YDtcbiAgfVxuICBpZiAocmVzdWx0LnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgIHN0YXRlID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj5FTVBUWTwvc3Bhbj5gO1xuICB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gaWQuTUFUQ0gpIHtcbiAgICBzdGF0ZSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+TUFUQ0g8L3NwYW4+YDtcbiAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICBzdGF0ZSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5OT01BVENIPC9zcGFuPmA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+dW5yZWNvZ25pemVkPC9zcGFuPmA7XG4gIH1cbiAgbGV0IGh0bWwgPSAnJztcbiAgaHRtbCArPSBgPHRhYmxlIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19TVEFURX1cIj5cXG5gO1xuICBpZiAoY2FwKSB7XG4gICAgaHRtbCArPSBgPGNhcHRpb24+JHtjYXB9PC9jYXB0aW9uPlxcbmA7XG4gIH1cbiAgaHRtbCArPSAnPHRyPjx0aD5zdGF0ZSBpdGVtPC90aD48dGg+dmFsdWU8L3RoPjx0aD5kZXNjcmlwdGlvbjwvdGg+PC90cj5cXG4nO1xuICBodG1sICs9IGA8dHI+PHRkPnBhcnNlciBzdWNjZXNzPC90ZD48dGQ+JHtzdWNjZXNzfTwvdGQ+XFxuYDtcbiAgaHRtbCArPSBgPHRkPjxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj50cnVlPC9zcGFuPiBpZiB0aGUgcGFyc2Ugc3VjY2VlZGVkLFxcbmA7XG4gIGh0bWwgKz0gYCA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5mYWxzZTwvc3Bhbj4gb3RoZXJ3aXNlYDtcbiAgaHRtbCArPSAnPGJyPjxpPk5PVEU6IGZvciBzdWNjZXNzLCBlbnRpcmUgc3RyaW5nIG11c3QgYmUgbWF0Y2hlZDwvaT48L3RkPjwvdHI+XFxuJztcbiAgaHRtbCArPSBgPHRyPjx0ZD5wYXJzZXIgc3RhdGU8L3RkPjx0ZD4ke3N0YXRlfTwvdGQ+XFxuYDtcbiAgaHRtbCArPSBgPHRkPjxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj5FTVBUWTwvc3Bhbj4sIGA7XG4gIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5NQVRDSDwvc3Bhbj4gb3IgXFxuYDtcbiAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+Tk9NQVRDSDwvc3Bhbj48L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5zdHJpbmcgbGVuZ3RoPC90ZD48dGQ+JHtyZXN1bHQubGVuZ3RofTwvdGQ+PHRkPmxlbmd0aCBvZiB0aGUgaW5wdXQgKHN1YilzdHJpbmc8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5tYXRjaGVkIGxlbmd0aDwvdGQ+PHRkPiR7cmVzdWx0Lm1hdGNoZWR9PC90ZD48dGQ+bnVtYmVyIG9mIGlucHV0IHN0cmluZyBjaGFyYWN0ZXJzIG1hdGNoZWQ8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5tYXggbWF0Y2hlZDwvdGQ+PHRkPiR7cmVzdWx0Lm1heE1hdGNoZWR9PC90ZD48dGQ+bWF4aW11bSBudW1iZXIgb2YgaW5wdXQgc3RyaW5nIGNoYXJhY3RlcnMgbWF0Y2hlZDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPm1heCB0cmVlIGRlcHRoPC90ZD48dGQ+JHtyZXN1bHQubWF4VHJlZURlcHRofTwvdGQ+PHRkPm1heGltdW0gZGVwdGggb2YgdGhlIHBhcnNlIHRyZWUgcmVhY2hlZDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPm5vZGUgaGl0czwvdGQ+PHRkPiR7cmVzdWx0Lm5vZGVIaXRzfTwvdGQ+PHRkPm51bWJlciBvZiBwYXJzZSB0cmVlIG5vZGUgaGl0cyAob3Bjb2RlIGZ1bmN0aW9uIGNhbGxzKTwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPmlucHV0IGxlbmd0aDwvdGQ+PHRkPiR7cmVzdWx0LmlucHV0TGVuZ3RofTwvdGQ+PHRkPmxlbmd0aCBvZiBmdWxsIGlucHV0IHN0cmluZzwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPnN1Yi1zdHJpbmcgYmVnaW48L3RkPjx0ZD4ke3Jlc3VsdC5zdWJCZWdpbn08L3RkPjx0ZD5zdWItc3RyaW5nIGZpcnN0IGNoYXJhY3RlciBpbmRleDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPnN1Yi1zdHJpbmcgZW5kPC90ZD48dGQ+JHtyZXN1bHQuc3ViRW5kfTwvdGQ+PHRkPnN1Yi1zdHJpbmcgZW5kLW9mLXN0cmluZyBpbmRleDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPnN1Yi1zdHJpbmcgbGVuZ3RoPC90ZD48dGQ+JHtyZXN1bHQuc3ViTGVuZ3RofTwvdGQ+PHRkPnN1Yi1zdHJpbmcgbGVuZ3RoPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gJzwvdGFibGU+XFxuJztcbiAgcmV0dXJuIGh0bWw7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBpbnRlZ2VyIGNoYXJhY3RlciBjb2RlcyBpbnRvIGEgc3RyaW5nLlxuLy8gVmVyeSB1c2VmdWwgaW4gY2FsbGJhY2sgZnVuY3Rpb25zIHRvIHRyYW5zbGF0ZSB0aGUgbWF0Y2hlZCBwaHJhc2VzIGludG8gc3RyaW5ncy5cbmV4cG9ydHMuY2hhcnNUb1N0cmluZyA9IGZ1bmN0aW9uIChjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aCkge1xuICBsZXQgYmVnO1xuICBsZXQgZW5kO1xuICBpZiAodHlwZW9mIHBocmFzZUluZGV4ID09PSAnbnVtYmVyJykge1xuICAgIGlmIChwaHJhc2VJbmRleCA+PSBjaGFycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgYmVnID0gcGhyYXNlSW5kZXggPCAwID8gMCA6IHBocmFzZUluZGV4O1xuICB9IGVsc2Uge1xuICAgIGJlZyA9IDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBwaHJhc2VMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHBocmFzZUxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGVuZCA9IHBocmFzZUxlbmd0aCA+IGNoYXJzLmxlbmd0aCAtIGJlZyA/IGNoYXJzLmxlbmd0aCA6IGJlZyArIHBocmFzZUxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBlbmQgPSBjaGFycy5sZW5ndGg7XG4gIH1cbiAgaWYgKGJlZyA8IGVuZCkge1xuICAgIHJldHVybiBjb252ZXJ0ZXIuZW5jb2RlKCdVVEYxNkxFJywgY2hhcnMuc2xpY2UoYmVnLCBlbmQpKS50b1N0cmluZygndXRmMTZsZScpO1xuICB9XG4gIHJldHVybiAnJztcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMuXG5leHBvcnRzLnN0cmluZ1RvQ2hhcnMgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBjb252ZXJ0ZXIuZGVjb2RlKCdTVFJJTkcnLCBzdHJpbmcpO1xufTtcbi8vIFRyYW5zbGF0ZXMgYW4gb3Bjb2RlIGlkZW50aWZpZXIgaW50byBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbmV4cG9ydHMub3Bjb2RlVG9TdHJpbmcgPSBmdW5jdGlvbiAodHlwZSkge1xuICBsZXQgcmV0ID0gJ3Vua25vd24nO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGlkLkFMVDpcbiAgICAgIHJldCA9ICdBTFQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5DQVQ6XG4gICAgICByZXQgPSAnQ0FUJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuUk5NOlxuICAgICAgcmV0ID0gJ1JOTSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlVEVDpcbiAgICAgIHJldCA9ICdVRFQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5BTkQ6XG4gICAgICByZXQgPSAnQU5EJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuTk9UOlxuICAgICAgcmV0ID0gJ05PVCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlJFUDpcbiAgICAgIHJldCA9ICdSRVAnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5UUkc6XG4gICAgICByZXQgPSAnVFJHJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuVEJTOlxuICAgICAgcmV0ID0gJ1RCUyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlRMUzpcbiAgICAgIHJldCA9ICdUTFMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5CS1I6XG4gICAgICByZXQgPSAnQktSJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQktBOlxuICAgICAgcmV0ID0gJ0JLQSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkJLTjpcbiAgICAgIHJldCA9ICdCS04nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5BQkc6XG4gICAgICByZXQgPSAnQUJHJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQUVOOlxuICAgICAgcmV0ID0gJ0FFTic7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGFuIHN0YXRlIGlkZW50aWZpZXIgaW50byBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbmV4cG9ydHMuc3RhdGVUb1N0cmluZyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBsZXQgcmV0ID0gJ3Vua25vd24nO1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICByZXQgPSAnQUNUSVZFJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICByZXQgPSAnTUFUQ0gnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgIHJldCA9ICdFTVBUWSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICByZXQgPSAnTk9NQVRDSCc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgc3RhdGUnKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIEFycmF5IHdoaWNoIHRyYW5zbGF0ZXMgYWxsIDEyOCwgNy1iaXQgQVNDSUkgY2hhcmFjdGVyIGNvZGVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgSFRNTCBmb3JtYXQuXG5leHBvcnRzLmFzY2lpQ2hhcnMgPSBbXG4gICdOVUwnLFxuICAnU09IJyxcbiAgJ1NUWCcsXG4gICdFVFgnLFxuICAnRU9UJyxcbiAgJ0VOUScsXG4gICdBQ0snLFxuICAnQkVMJyxcbiAgJ0JTJyxcbiAgJ1RBQicsXG4gICdMRicsXG4gICdWVCcsXG4gICdGRicsXG4gICdDUicsXG4gICdTTycsXG4gICdTSScsXG4gICdETEUnLFxuICAnREMxJyxcbiAgJ0RDMicsXG4gICdEQzMnLFxuICAnREM0JyxcbiAgJ05BSycsXG4gICdTWU4nLFxuICAnRVRCJyxcbiAgJ0NBTicsXG4gICdFTScsXG4gICdTVUInLFxuICAnRVNDJyxcbiAgJ0ZTJyxcbiAgJ0dTJyxcbiAgJ1JTJyxcbiAgJ1VTJyxcbiAgJyZuYnNwOycsXG4gICchJyxcbiAgJyYjMzQ7JyxcbiAgJyMnLFxuICAnJCcsXG4gICclJyxcbiAgJyYjMzg7JyxcbiAgJyYjMzk7JyxcbiAgJygnLFxuICAnKScsXG4gICcqJyxcbiAgJysnLFxuICAnLCcsXG4gICctJyxcbiAgJy4nLFxuICAnLycsXG4gICcwJyxcbiAgJzEnLFxuICAnMicsXG4gICczJyxcbiAgJzQnLFxuICAnNScsXG4gICc2JyxcbiAgJzcnLFxuICAnOCcsXG4gICc5JyxcbiAgJzonLFxuICAnOycsXG4gICcmIzYwOycsXG4gICc9JyxcbiAgJyYjNjI7JyxcbiAgJz8nLFxuICAnQCcsXG4gICdBJyxcbiAgJ0InLFxuICAnQycsXG4gICdEJyxcbiAgJ0UnLFxuICAnRicsXG4gICdHJyxcbiAgJ0gnLFxuICAnSScsXG4gICdKJyxcbiAgJ0snLFxuICAnTCcsXG4gICdNJyxcbiAgJ04nLFxuICAnTycsXG4gICdQJyxcbiAgJ1EnLFxuICAnUicsXG4gICdTJyxcbiAgJ1QnLFxuICAnVScsXG4gICdWJyxcbiAgJ1cnLFxuICAnWCcsXG4gICdZJyxcbiAgJ1onLFxuICAnWycsXG4gICcmIzkyOycsXG4gICddJyxcbiAgJ14nLFxuICAnXycsXG4gICdgJyxcbiAgJ2EnLFxuICAnYicsXG4gICdjJyxcbiAgJ2QnLFxuICAnZScsXG4gICdmJyxcbiAgJ2cnLFxuICAnaCcsXG4gICdpJyxcbiAgJ2onLFxuICAnaycsXG4gICdsJyxcbiAgJ20nLFxuICAnbicsXG4gICdvJyxcbiAgJ3AnLFxuICAncScsXG4gICdyJyxcbiAgJ3MnLFxuICAndCcsXG4gICd1JyxcbiAgJ3YnLFxuICAndycsXG4gICd4JyxcbiAgJ3knLFxuICAneicsXG4gICd7JyxcbiAgJ3wnLFxuICAnfScsXG4gICd+JyxcbiAgJ0RFTCcsXG5dO1xuLy8gVHJhbnNsYXRlcyBhIHNpbmdsZSBjaGFyYWN0ZXIgdG8gaGV4YWRlY2ltYWwgd2l0aCBsZWFkaW5nIHplcm9zIGZvciAyLCA0LCBvciA4IGRpZ2l0IGRpc3BsYXkuXG5leHBvcnRzLmNoYXJUb0hleCA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gIGxldCBjaCA9IGNoYXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIHN3aXRjaCAoY2gubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMzpcbiAgICBjYXNlIDc6XG4gICAgICBjaCA9IGAwJHtjaH1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgIGNhc2UgNjpcbiAgICAgIGNoID0gYDAwJHtjaH1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgY2ggPSBgMDAwJHtjaH1gO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIG9wdGlvbicpO1xuICB9XG4gIHJldHVybiBjaDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBkZWNpbWFsIGRpc3BsYXkgZm9ybWF0LlxuZXhwb3J0cy5jaGFyc1RvRGVjID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9EZWM6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGlmIChib3VuZHMuZW5kID4gYm91bmRzLmJlZykge1xuICAgIHJldCArPSBjaGFyc1tib3VuZHMuYmVnXTtcbiAgICBmb3IgKGxldCBpID0gYm91bmRzLmJlZyArIDE7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICAgIHJldCArPSBgLCR7Y2hhcnNbaV19YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBoZXhhZGVjaW1hbCBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuY2hhcnNUb0hleCA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvSGV4OiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICByZXQgKz0gYFxcXFx4JHtleHBvcnRzLmNoYXJUb0hleChjaGFyc1tib3VuZHMuYmVnXSl9YDtcbiAgICBmb3IgKGxldCBpID0gYm91bmRzLmJlZyArIDE7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICAgIHJldCArPSBgLFxcXFx4JHtleHBvcnRzLmNoYXJUb0hleChjaGFyc1tpXSl9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5leHBvcnRzLmNoYXJzVG9IdG1sRW50aXRpZXMgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0hleDogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgaWYgKGJvdW5kcy5lbmQgPiBib3VuZHMuYmVnKSB7XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWc7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICAgIHJldCArPSBgJiN4JHtjaGFyc1tpXS50b1N0cmluZygxNil9O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gVW5pY29kZSBkaXNwbGF5IGZvcm1hdC5cbmZ1bmN0aW9uIGlzVW5pY29kZShjaGFyKSB7XG4gIGlmIChjaGFyID49IDB4ZDgwMCAmJiBjaGFyIDw9IDB4ZGZmZikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY2hhciA+IDB4MTBmZmZmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5jaGFyc1RvVW5pY29kZSA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvVW5pY29kZTogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgaWYgKGJvdW5kcy5lbmQgPiBib3VuZHMuYmVnKSB7XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWc7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICAgIGlmIChpc1VuaWNvZGUoY2hhcnNbaV0pKSB7XG4gICAgICAgIHJldCArPSBgJiMke2NoYXJzW2ldfTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ICs9IGAgVSske2V4cG9ydHMuY2hhclRvSGV4KGNoYXJzW2ldKX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIEphdmFTY3JpcHQgVW5pY29kZSBkaXNwbGF5IGZvcm1hdCAoYFxcdVhYWFhgKS5cbmV4cG9ydHMuY2hhcnNUb0pzVW5pY29kZSA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvSnNVbmljb2RlOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICByZXQgKz0gYFxcXFx1JHtleHBvcnRzLmNoYXJUb0hleChjaGFyc1tib3VuZHMuYmVnXSl9YDtcbiAgICBmb3IgKGxldCBpID0gYm91bmRzLmJlZyArIDE7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICAgIHJldCArPSBgLFxcXFx1JHtleHBvcnRzLmNoYXJUb0hleChjaGFyc1tpXSl9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBwcmludGluZyBBU0NJSSBjaGFyYWN0ZXIgZGlzcGxheSBmb3JtYXQuXG5leHBvcnRzLmNoYXJzVG9Bc2NpaSA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvQXNjaWk6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGZvciAobGV0IGkgPSBib3VuZHMuYmVnOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgIGlmIChjaGFyID49IDMyICYmIGNoYXIgPD0gMTI2KSB7XG4gICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IGBcXFxceCR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcil9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBIVE1MIGRpc3BsYXkgZm9ybWF0LlxuZXhwb3J0cy5jaGFyc1RvQXNjaWlIdG1sID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvQXNjaWlIdG1sOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgbGV0IGh0bWwgPSAnJztcbiAgbGV0IGNoYXI7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWc7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICBjaGFyID0gY2hhcnNbaV07XG4gICAgaWYgKGNoYXIgPCAzMiB8fCBjaGFyID09PSAxMjcpIHtcbiAgICAgIC8qIGNvbnRyb2wgY2hhcmFjdGVycyAqL1xuICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0NUUkxDSEFSfVwiPiR7ZXhwb3J0cy5hc2NpaUNoYXJzW2NoYXJdfTwvc3Bhbj5gO1xuICAgIH0gZWxzZSBpZiAoY2hhciA+IDEyNykge1xuICAgICAgLyogbm9uLUFTQ0lJICovXG4gICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQ1RSTENIQVJ9XCI+VSske2V4cG9ydHMuY2hhclRvSGV4KGNoYXIpfTwvc3Bhbj5gO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBwcmludGluZyBBU0NJSSwgMzIgPD0gY2hhciA8PSAxMjYgKi9cbiAgICAgIGh0bWwgKz0gZXhwb3J0cy5hc2NpaUNoYXJzW2NoYXJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaHRtbDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgSmF2YVNjcmlwdCBzdHJpbmcgdG8gSFRNTCBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuc3RyaW5nVG9Bc2NpaUh0bWwgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGNvbnN0IGNoYXJzID0gY29udmVydGVyLmRlY29kZSgnU1RSSU5HJywgc3RyKTtcbiAgcmV0dXJuIHRoaXMuY2hhcnNUb0FzY2lpSHRtbChjaGFycyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\n");

/***/ })

};
;