"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micro-ftch";
exports.ids = ["vendor-chunks/micro-ftch"];
exports.modules = {

/***/ "(ssr)/./node_modules/micro-ftch/index.js":
/*!******************************************!*\
  !*** ./node_modules/micro-ftch/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0,\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256) {\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode) {\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === 'text' || type === 'json') {\n        try {\n            let text = new TextDecoder('utf8', { fatal: true }).decode(b);\n            if (type === 'text')\n                return text;\n            try {\n                return JSON.parse(text);\n            }\n            catch (err) {\n                if (type === 'json')\n                    throw err;\n                return text;\n            }\n        }\n        catch (err) {\n            if (type === 'text' || type === 'json')\n                throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const http = __webpack_require__(/*! http */ \"http\");\n    const https = __webpack_require__(/*! https */ \"https\");\n    const zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    const { promisify } = __webpack_require__(/*! util */ \"util\");\n    const { resolve: urlResolve } = __webpack_require__(/*! url */ \"url\");\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || 'GET',\n        headers: { 'Accept-Encoding': 'gzip, deflate, br' },\n    };\n    const compactFP = (s) => s.replace(/:| /g, '').toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024,\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort(),\n        ].join();\n        opts.agent =\n            agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === 'json')\n        opts.headers['Content-Type'] = 'application/json';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = { ...opts.headers, ...options.headers };\n    if (options.sslAllowSelfSigned)\n        opts.rejectUnauthorized = false;\n    const handleRes = async (res) => {\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n            if (options._redirectCount == 10)\n                throw new Error('Request failed. Too much redirects.');\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers['location']), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)\n            buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers['content-encoding'];\n        if (encoding === 'br')\n            bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === 'gzip' || encoding === 'deflate')\n            bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full)\n            return { headers: res.headers, status, body };\n        return body;\n    };\n    return new Promise((resolve, reject) => {\n        const handleError = async (err) => {\n            if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n                try {\n                    await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });\n                }\n                catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res) => {\n            res.on('error', handleError);\n            (async () => {\n                try {\n                    resolve(await handleRes(res));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on('error', handleError);\n        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));\n        const mfetchSecureConnect = (socket) => {\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');\n            if (!fp256 && socket.isSessionReused())\n                return;\n            if (pinned.includes(fp256))\n                return;\n            req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on('socket', (socket) => {\n                const hasListeners = socket\n                    .listeners('secureConnect')\n                    .map((i) => (i.name || '').replace('bound ', ''))\n                    .includes('mfetchSecureConnect');\n                if (hasListeners)\n                    return;\n                socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive)\n            req.setNoDelay(true);\n        if (opts.body)\n            req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map((i) => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method',\n    'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer',\n    'Transfer-Encoding', 'Upgrade', 'Via'].map((i) => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const headers = new Headers();\n    if (options.type === 'json')\n        headers.set('Content-Type', 'application/json');\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set('Authorization', `Basic ${auth}`);\n        parsed.username = '';\n        parsed.password = '';\n    }\n    url = '' + parsed;\n    for (let k in options.headers) {\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || (options.cors && !FORBIDDEN_HEADERS.has(name)))\n            headers.set(k, options.headers[k]);\n    }\n    let opts = { headers, redirect: options.redirect ? 'follow' : 'manual' };\n    if (!options.referrer)\n        opts.referrerPolicy = 'no-referrer';\n    if (options.cors)\n        opts.mode = 'cors';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode)\n        throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full)\n        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };\n    return body;\n}\nconst IS_NODE = !!(typeof process == 'object' &&\n    process.versions &&\n    process.versions.node &&\n    process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports[\"default\"] = fetchUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm8tZnRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyx3QkFBd0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLG9CQUFPO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNO0FBQy9CLFlBQVksWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDeEMsWUFBWSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLGdCQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUVBQWlFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixpQkFBaUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxPQUFPLFlBQVksT0FBTztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDaEUsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC8uL25vZGVfbW9kdWxlcy9taWNyby1mdGNoL2luZGV4LmpzP2ZiOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmFsaWRTdGF0dXNDb2RlRXJyb3IgPSBleHBvcnRzLkludmFsaWRDZXJ0RXJyb3IgPSB2b2lkIDA7XG5jb25zdCBERUZBVUxUX09QVCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHJlZGlyZWN0OiB0cnVlLFxuICAgIGV4cGVjdFN0YXR1c0NvZGU6IDIwMCxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICBmdWxsOiBmYWxzZSxcbiAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgY29yczogZmFsc2UsXG4gICAgcmVmZXJyZXI6IGZhbHNlLFxuICAgIHNzbEFsbG93U2VsZlNpZ25lZDogZmFsc2UsXG4gICAgX3JlZGlyZWN0Q291bnQ6IDAsXG59KTtcbmNsYXNzIEludmFsaWRDZXJ0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnLCBmaW5nZXJwcmludDI1Nikge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmZpbmdlcnByaW50MjU2ID0gZmluZ2VycHJpbnQyNTY7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2VydEVycm9yID0gSW52YWxpZENlcnRFcnJvcjtcbmNsYXNzIEludmFsaWRTdGF0dXNDb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZSkge1xuICAgICAgICBzdXBlcihgUmVxdWVzdCBGYWlsZWQuIFN0YXR1cyBDb2RlOiAke3N0YXR1c0NvZGV9YCk7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU3RhdHVzQ29kZUVycm9yID0gSW52YWxpZFN0YXR1c0NvZGVFcnJvcjtcbmZ1bmN0aW9uIGRldGVjdFR5cGUoYiwgdHlwZSkge1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAndGV4dCcgfHwgdHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcsIHsgZmF0YWw6IHRydWUgfSkuZGVjb2RlKGIpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0JylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdqc29uJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcgfHwgdHlwZSA9PT0gJ2pzb24nKVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbmxldCBhZ2VudHMgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTm9kZSh1cmwsIF9vcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfT1BULCAuLi5fb3B0aW9ucyB9O1xuICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG4gICAgY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuICAgIGNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG4gICAgY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHVybFJlc29sdmUgfSA9IHJlcXVpcmUoJ3VybCcpO1xuICAgIGNvbnN0IGlzU2VjdXJlID0gISEvXmh0dHBzLy50ZXN0KHVybCk7XG4gICAgbGV0IG9wdHMgPSB7XG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlLCBicicgfSxcbiAgICB9O1xuICAgIGNvbnN0IGNvbXBhY3RGUCA9IChzKSA9PiBzLnJlcGxhY2UoLzp8IC9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29uc3QgYWdlbnRPcHQgPSB7XG4gICAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgICBrZWVwQWxpdmVNc2VjczogMzAgKiAxMDAwLFxuICAgICAgICAgICAgbWF4RnJlZVNvY2tldHM6IDEwMjQsXG4gICAgICAgICAgICBtYXhDYWNoZWRTZXNzaW9uczogMTAyNCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWdlbnRLZXkgPSBbXG4gICAgICAgICAgICBpc1NlY3VyZSxcbiAgICAgICAgICAgIGlzU2VjdXJlICYmIG9wdGlvbnMuc3NsUGlubmVkQ2VydGlmaWNhdGVzPy5tYXAoKGkpID0+IGNvbXBhY3RGUChpKSkuc29ydCgpLFxuICAgICAgICBdLmpvaW4oKTtcbiAgICAgICAgb3B0cy5hZ2VudCA9XG4gICAgICAgICAgICBhZ2VudHNbYWdlbnRLZXldIHx8IChhZ2VudHNbYWdlbnRLZXldID0gbmV3IChpc1NlY3VyZSA/IGh0dHBzIDogaHR0cCkuQWdlbnQoYWdlbnRPcHQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2pzb24nKVxuICAgICAgICBvcHRzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm1ldGhvZClcbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBvcHRzLmJvZHkgPSBvcHRpb25zLnR5cGUgPT09ICdqc29uJyA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSkgOiBvcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIG9wdHMuaGVhZGVycyA9IHsgLi4ub3B0cy5oZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICBpZiAob3B0aW9ucy5zc2xBbGxvd1NlbGZTaWduZWQpXG4gICAgICAgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gZmFsc2U7XG4gICAgY29uc3QgaGFuZGxlUmVzID0gYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSByZXMuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVkaXJlY3QgJiYgMzAwIDw9IHN0YXR1cyAmJiBzdGF0dXMgPCA0MDAgJiYgcmVzLmhlYWRlcnNbJ2xvY2F0aW9uJ10pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLl9yZWRpcmVjdENvdW50ID09IDEwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCBmYWlsZWQuIFRvbyBtdWNoIHJlZGlyZWN0cy4nKTtcbiAgICAgICAgICAgIG9wdGlvbnMuX3JlZGlyZWN0Q291bnQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmZXRjaE5vZGUodXJsUmVzb2x2ZSh1cmwsIHJlcy5oZWFkZXJzWydsb2NhdGlvbiddKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwZWN0U3RhdHVzQ29kZSAmJiBzdGF0dXMgIT09IG9wdGlvbnMuZXhwZWN0U3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgcmVzLnJlc3VtZSgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0dXNDb2RlRXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVmID0gW107XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzKVxuICAgICAgICAgICAgYnVmLnB1c2goY2h1bmspO1xuICAgICAgICBsZXQgYnl0ZXMgPSBCdWZmZXIuY29uY2F0KGJ1Zik7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYnInKVxuICAgICAgICAgICAgYnl0ZXMgPSBhd2FpdCBwcm9taXNpZnkoemxpYi5icm90bGlEZWNvbXByZXNzKShieXRlcyk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2d6aXAnIHx8IGVuY29kaW5nID09PSAnZGVmbGF0ZScpXG4gICAgICAgICAgICBieXRlcyA9IGF3YWl0IHByb21pc2lmeSh6bGliLnVuemlwKShieXRlcyk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBkZXRlY3RUeXBlKGJ5dGVzLCBvcHRpb25zLnR5cGUpO1xuICAgICAgICBpZiAob3B0aW9ucy5mdWxsKVxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogcmVzLmhlYWRlcnMsIHN0YXR1cywgYm9keSB9O1xuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ0RFUFRIX1pFUk9fU0VMRl9TSUdORURfQ0VSVCcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaE5vZGUodXJsLCB7IC4uLm9wdGlvbnMsIHNzbEFsbG93U2VsZlNpZ25lZDogdHJ1ZSwgc3NsUGlubmVkQ2VydGlmaWNhdGVzOiBbXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS5maW5nZXJwcmludDI1Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gbmV3IEludmFsaWRDZXJ0RXJyb3IoYFNlbGYtc2lnbmVkIFNTTCBjZXJ0aWZpY2F0ZTogJHtlLmZpbmdlcnByaW50MjU2fWAsIGUuZmluZ2VycHJpbnQyNTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcSA9IChpc1NlY3VyZSA/IGh0dHBzIDogaHR0cCkucmVxdWVzdCh1cmwsIG9wdHMsIChyZXMpID0+IHtcbiAgICAgICAgICAgIHJlcy5vbignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXdhaXQgaGFuZGxlUmVzKHJlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgY29uc3QgcGlubmVkID0gb3B0aW9ucy5zc2xQaW5uZWRDZXJ0aWZpY2F0ZXM/Lm1hcCgoaSkgPT4gY29tcGFjdEZQKGkpKTtcbiAgICAgICAgY29uc3QgbWZldGNoU2VjdXJlQ29ubmVjdCA9IChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZwMjU2ID0gY29tcGFjdEZQKHNvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUoKT8uZmluZ2VycHJpbnQyNTYgfHwgJycpO1xuICAgICAgICAgICAgaWYgKCFmcDI1NiAmJiBzb2NrZXQuaXNTZXNzaW9uUmV1c2VkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHBpbm5lZC5pbmNsdWRlcyhmcDI1NikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVxLmVtaXQoJ2Vycm9yJywgbmV3IEludmFsaWRDZXJ0RXJyb3IoYEludmFsaWQgU1NMIGNlcnRpZmljYXRlOiAke2ZwMjU2fSBFeHBlY3RlZDogJHtwaW5uZWR9YCwgZnAyNTYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXEuYWJvcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3NsUGlubmVkQ2VydGlmaWNhdGVzKSB7XG4gICAgICAgICAgICByZXEub24oJ3NvY2tldCcsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNMaXN0ZW5lcnMgPSBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgLmxpc3RlbmVycygnc2VjdXJlQ29ubmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGkpID0+IChpLm5hbWUgfHwgJycpLnJlcGxhY2UoJ2JvdW5kICcsICcnKSlcbiAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKCdtZmV0Y2hTZWN1cmVDb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0xpc3RlbmVycylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbignc2VjdXJlQ29ubmVjdCcsIG1mZXRjaFNlY3VyZUNvbm5lY3QuYmluZChudWxsLCBzb2NrZXQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSlcbiAgICAgICAgICAgIHJlcS5zZXROb0RlbGF5KHRydWUpO1xuICAgICAgICBpZiAob3B0cy5ib2R5KVxuICAgICAgICAgICAgcmVxLndyaXRlKG9wdHMuYm9keSk7XG4gICAgICAgIHJlcS5lbmQoKTtcbiAgICB9KTtcbn1cbmNvbnN0IFNBRkVfSEVBREVSUyA9IG5ldyBTZXQoWydBY2NlcHQnLCAnQWNjZXB0LUxhbmd1YWdlJywgJ0NvbnRlbnQtTGFuZ3VhZ2UnLCAnQ29udGVudC1UeXBlJ10ubWFwKChpKSA9PiBpLnRvTG93ZXJDYXNlKCkpKTtcbmNvbnN0IEZPUkJJRERFTl9IRUFERVJTID0gbmV3IFNldChbJ0FjY2VwdC1DaGFyc2V0JywgJ0FjY2VwdC1FbmNvZGluZycsICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnMnLCAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2QnLFxuICAgICdDb25uZWN0aW9uJywgJ0NvbnRlbnQtTGVuZ3RoJywgJ0Nvb2tpZScsICdDb29raWUyJywgJ0RhdGUnLCAnRE5UJywgJ0V4cGVjdCcsICdIb3N0JywgJ0tlZXAtQWxpdmUnLCAnT3JpZ2luJywgJ1JlZmVyZXInLCAnVEUnLCAnVHJhaWxlcicsXG4gICAgJ1RyYW5zZmVyLUVuY29kaW5nJywgJ1VwZ3JhZGUnLCAnVmlhJ10ubWFwKChpKSA9PiBpLnRvTG93ZXJDYXNlKCkpKTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoQnJvd3Nlcih1cmwsIF9vcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfT1BULCAuLi5fb3B0aW9ucyB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdqc29uJylcbiAgICAgICAgaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgbGV0IHBhcnNlZCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAocGFyc2VkLnVzZXJuYW1lKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBidG9hKGAke3BhcnNlZC51c2VybmFtZX06JHtwYXJzZWQucGFzc3dvcmR9YCk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJhc2ljICR7YXV0aH1gKTtcbiAgICAgICAgcGFyc2VkLnVzZXJuYW1lID0gJyc7XG4gICAgICAgIHBhcnNlZC5wYXNzd29yZCA9ICcnO1xuICAgIH1cbiAgICB1cmwgPSAnJyArIHBhcnNlZDtcbiAgICBmb3IgKGxldCBrIGluIG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBjb25zdCBuYW1lID0gay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoU0FGRV9IRUFERVJTLmhhcyhuYW1lKSB8fCAob3B0aW9ucy5jb3JzICYmICFGT1JCSURERU5fSEVBREVSUy5oYXMobmFtZSkpKVxuICAgICAgICAgICAgaGVhZGVycy5zZXQoaywgb3B0aW9ucy5oZWFkZXJzW2tdKTtcbiAgICB9XG4gICAgbGV0IG9wdHMgPSB7IGhlYWRlcnMsIHJlZGlyZWN0OiBvcHRpb25zLnJlZGlyZWN0ID8gJ2ZvbGxvdycgOiAnbWFudWFsJyB9O1xuICAgIGlmICghb3B0aW9ucy5yZWZlcnJlcilcbiAgICAgICAgb3B0cy5yZWZlcnJlclBvbGljeSA9ICduby1yZWZlcnJlcic7XG4gICAgaWYgKG9wdGlvbnMuY29ycylcbiAgICAgICAgb3B0cy5tb2RlID0gJ2NvcnMnO1xuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm1ldGhvZClcbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBvcHRzLmJvZHkgPSBvcHRpb25zLnR5cGUgPT09ICdqc29uJyA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSkgOiBvcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0cyk7XG4gICAgaWYgKG9wdGlvbnMuZXhwZWN0U3RhdHVzQ29kZSAmJiByZXMuc3RhdHVzICE9PSBvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdHVzQ29kZUVycm9yKHJlcy5zdGF0dXMpO1xuICAgIGNvbnN0IGJvZHkgPSBkZXRlY3RUeXBlKG5ldyBVaW50OEFycmF5KGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpKSwgb3B0aW9ucy50eXBlKTtcbiAgICBpZiAob3B0aW9ucy5mdWxsKVxuICAgICAgICByZXR1cm4geyBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVzLmhlYWRlcnMuZW50cmllcygpKSwgc3RhdHVzOiByZXMuc3RhdHVzLCBib2R5IH07XG4gICAgcmV0dXJuIGJvZHk7XG59XG5jb25zdCBJU19OT0RFID0gISEodHlwZW9mIHByb2Nlc3MgPT0gJ29iamVjdCcgJiZcbiAgICBwcm9jZXNzLnZlcnNpb25zICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucy52OCk7XG5mdW5jdGlvbiBmZXRjaFVybCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmbiA9IElTX05PREUgPyBmZXRjaE5vZGUgOiBmZXRjaEJyb3dzZXI7XG4gICAgcmV0dXJuIGZuKHVybCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBmZXRjaFVybDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micro-ftch/index.js\n");

/***/ })

};
;